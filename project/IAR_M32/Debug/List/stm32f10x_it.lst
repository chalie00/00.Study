###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     08/Jul/2022  12:01:43 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\Libraries\STM32F1 #
#                    0x_StdPeriph_Driver\src\stm32f10x_it.c                   #
#    Command line =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\Libraries\STM32F1 #
#                    0x_StdPeriph_Driver\src\stm32f10x_it.c -D                #
#                    USE_STDPERIPH_DRIVER -D STM32F10x_HD -D USE_FULL_ASSERT  #
#                    -lcN C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_ #
#                    M32\Debug\List\ -lb C:\Users\TTT\Desktop\zz.STDFW\00.Stu #
#                    dy\project\IAR_M32\Debug\List\ -o                        #
#                    C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_M32\D #
#                    ebug\Obj\ --no_cse --no_unroll --no_inline               #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\I #
#                    AR_M32\..\..\inc\ -I C:\Users\TTT\Desktop\zz.STDFW\00.St #
#                    udy\project\IAR_M32\..\..\Libraries\CMSIS\CM3\DeviceSupp #
#                    ort\ST\STM32F10x\ -I C:\Users\TTT\Desktop\zz.STDFW\00.St #
#                    udy\project\IAR_M32\..\..\Libraries\STM32F10x_StdPeriph_ #
#                    Driver\inc\ -I "C:\Program Files (x86)\IAR               #
#                    Systems\Embedded Workbench 6.0\arm\inc\c\" -On -I        #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_M32\D #
#                    ebug\List\stm32f10x_it.lst                               #
#    Object file  =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_M32\D #
#                    ebug\Obj\stm32f10x_it.o                                  #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\TTT\Desktop\zz.STDFW\00.Study\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_it.c
      1          /*=================================================================================
      2          Project Name 		:	TPV HD Type (HD IP THERMOGRAPHY PTZ CAMERA)
      3          Author			:	phs@tbtsys.com
      4          ==================================================================================*/ 
      5          
      6          /*******************************************************************************
      7          * INCLUDE
      8          *******************************************************************************/
      9          #include "stm32f10x_it.h"
     10          #include "I2c.h"
     11          #include "Extern.h"
     12          #include "Device.h"
     13          #include "Define.h"
     14          #include "Common.h"
     15          
     16          
     17          /* External Varible */
     18          extern int red_status;
     19          extern int green_status;
     20          extern int yellow_status;
     21          
     22          
     23          
     24          /*******************************************************************************
     25          * Function Name  : assert_failed
     26          * Description    : Reports the name of the source file and the source line number
     27            *   where the assert_param error has occurred.
     28          * Input          : - file: pointer to the source file name
     29          *                  - line: assert_param error line source number
     30          * Output         : None
     31          * Return         : None
     32          *******************************************************************************/
     33          void assert_failed(uint8_t* file, uint32_t line)
     34          { 
     35          	/* User can add his own implementation to report the file name and line number,
     36          	ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
     37          	//printf("Wrong parameters value: file %s on line %d\r\n", file, line);
     38          
     39          	/* Infinite loop */
     40          	while (1)
     41          	{}
     42          }
     43          
     44          /******************************************************************************/
     45          /*            Cortex-M3 Processor Exceptions Handlers                         */
     46          /******************************************************************************/
     47          
     48          /**
     49            * @brief  This function handles NMI exception.
     50            * @param  None
     51            * @retval None
     52            */
     53          void NMI_Handler(void)
     54          {
     55          }
     56          
     57          /**
     58            * @brief  This function handles Hard Fault exception.
     59            * @param  None
     60            * @retval None
     61            */
     62          void HardFault_Handler(void)
     63          {
     64              /* Go to infinite loop when Hard Fault exception occurs */
     65              while (1)
     66              {
     67              }
     68          }
     69          
     70          /**
     71            * @brief  This function handles Memory Manage exception.
     72            * @param  None
     73            * @retval None
     74            */
     75          void MemManage_Handler(void)
     76          {
     77              /* Go to infinite loop when Memory Manage exception occurs */
     78              while (1)
     79              {
     80              }
     81          }
     82          
     83          /**
     84            * @brief  This function handles Bus Fault exception.
     85            * @param  None
     86            * @retval None
     87            */
     88          void BusFault_Handler(void)
     89          {
     90              /* Go to infinite loop when Bus Fault exception occurs */
     91              while (1)
     92              {
     93              }
     94          }
     95          
     96          /**
     97            * @brief  This function handles Usage Fault exception.
     98            * @param  None
     99            * @retval None
    100            */
    101          void UsageFault_Handler(void)
    102          {
    103              /* Go to infinite loop when Usage Fault exception occurs */
    104              while (1)
    105              {
    106              }
    107          }
    108          
    109          /**
    110            * @brief  This function handles SVCall exception.
    111            * @param  None
    112            * @retval None
    113            */
    114          void SVC_Handler(void)
    115          {
    116          }
    117          
    118          /**
    119            * @brief  This function handles Debug Monitor exception.
    120            * @param  None
    121            * @retval None
    122            */
    123          void DebugMon_Handler(void)
    124          {
    125          }
    126          
    127          /**
    128            * @brief  This function handles PendSV_Handler exception.
    129            * @param  None
    130            * @retval None
    131            */
    132          void PendSV_Handler(void)
    133          {
    134          }
    135          
    136          /**
    137            * @brief  This function handles SysTick Handler.
    138            * @param  None
    139            * @retval None
    140            */
    141          void SysTick_Handler(void)
    142          {
    143              TimingDelay_Decrement();
    144              Delay_Decrement();
    145              i2cDelay_Decrement();
    146          }
    147          
    148          /******************************************************************************/
    149          /*            STM32F10x Peripherals Interrupt Handlers                        */
    150          /*  Add here the Interrupt Handler for the used peripheral(s) (PPP), for the  */
    151          /*  available peripheral interrupt handler's name please refer to the startup */
    152          /*  file (startup_stm32f10x_xx.s).                                            */
    153          /******************************************************************************/
    154          
    155          /*******************************************************************************
    156          * Function Name  : WWDG_IRQHandler
    157          * Description    : This function handles WWDG interrupt request.
    158          * Input          : None
    159          * Output         : None
    160          * Return         : None
    161          *******************************************************************************/
    162          void WWDG_IRQHandler(void)
    163          {
    164          }
    165          
    166          /*******************************************************************************
    167          * Function Name  : PVD_IRQHandler
    168          * Description    : This function handles PVD interrupt request.
    169          * Input          : None
    170          * Output         : None
    171          * Return         : None
    172          *******************************************************************************/
    173          void PVD_IRQHandler(void)
    174          {
    175          }
    176          
    177          /*******************************************************************************
    178          * Function Name  : TAMPER_IRQHandler
    179          * Description    : This function handles Tamper interrupt request. 
    180          * Input          : None
    181          * Output         : None
    182          * Return         : None
    183          *******************************************************************************/
    184          void TAMPER_IRQHandler(void)
    185          {
    186          }
    187          
    188          /*******************************************************************************
    189          * Function Name  : RTC_IRQHandler
    190          * Description    : This function handles RTC global interrupt request.
    191          * Input          : None
    192          * Output         : None
    193          * Return         : None
    194          *******************************************************************************/
    195          void RTC_IRQHandler(void)
    196          {
    197          }
    198          
    199          /*******************************************************************************
    200          * Function Name  : FLASH_IRQHandler
    201          * Description    : This function handles Flash interrupt request.
    202          * Input          : None
    203          * Output         : None
    204          * Return         : None
    205          *******************************************************************************/
    206          void FLASH_IRQHandler(void)
    207          {
    208          }
    209          
    210          /*******************************************************************************
    211          * Function Name  : RCC_IRQHandler
    212          * Description    : This function handles RCC interrupt request. 
    213          * Input          : None
    214          * Output         : None
    215          * Return         : None
    216          *******************************************************************************/
    217          void RCC_IRQHandler(void)
    218          {
    219          }
    220          
    221          /*******************************************************************************
    222          * Function Name  : EXTI0_IRQHandler
    223          * Description    : This function handles External interrupt Line 0 request.
    224          * Input          : None
    225          * Output         : None
    226          * Return         : None
    227          *******************************************************************************/
    228          
    229          //static bool toggle_data_key1 = FALSE;
    230          /*
    231          void EXTI0_IRQHandler(void)
    232          {
    233              if(EXTI_GetITStatus(GPIO_EXTI_Line_KEY1) != RESET) {
    234                  printf("Left-WKUP Button Press\n");
    235          
    236          #if 0
    237            
    238                  if (pInformation->Current_Feature & 0x20) //Remote wake-up enabled
    239                  {
    240                    Resume(RESUME_INTERNAL);
    241                  }
    242          #endif
    243          
    244                  if(TRUE == g_TestProcessState)
    245                  {
    246                      Send_Buffer[0] = 0x05;
    247          
    248                      if(toggle_data_key1)
    249                      {
    250                          toggle_data_key1 = FALSE;
    251                          Send_Buffer[1] = 0x01;
    252                      }
    253                      else
    254                      {
    255                          toggle_data_key1 = TRUE;
    256                          Send_Buffer[1] = 0x00;
    257                      }
    258          
    259                      UserToPMABufferCopy(Send_Buffer, ENDP1_TXADDR, 2);
    260                      SetEPTxCount(ENDP1, 2);
    261                      SetEPTxValid(ENDP1);
    262                  }
    263          
    264                  EXTI_ClearITPendingBit(GPIO_EXTI_Line_KEY1);
    265              }
    266          }
    267          */
    268          /*******************************************************************************
    269          * Function Name  : EXTI1_IRQHandler
    270          * Description    : This function handles External interrupt Line 1 request.
    271          * Input          : None
    272          * Output         : None
    273          * Return         : None
    274          *******************************************************************************/
    275          /*
    276          static bool toggle_data_key2 = FALSE;
    277          
    278          void EXTI1_IRQHandler(void)
    279          {
    280              if(EXTI_GetITStatus(GPIO_EXTI_Line_KEY2) != RESET) {
    281                  printf("Right-USER Button Press\n");
    282          
    283                  if(TRUE == g_TestProcessState)
    284                  {
    285                      Send_Buffer[0] = 0x06;
    286          
    287                      if(toggle_data_key2)
    288                      {
    289                          toggle_data_key2 = FALSE;
    290                          Send_Buffer[1] = 0x01;
    291                      }
    292                      else
    293                      {
    294                          toggle_data_key2 = TRUE;
    295                          Send_Buffer[1] = 0x00;
    296                      }
    297          
    298                      UserToPMABufferCopy(Send_Buffer, ENDP1_TXADDR, 2);
    299                      SetEPTxCount(ENDP1, 2);
    300                      SetEPTxValid(ENDP1);
    301                  }
    302          
    303                  EXTI_ClearITPendingBit(GPIO_EXTI_Line_KEY2);
    304              }
    305          }
    306          */
    307          /*******************************************************************************
    308          * Function Name  : EXTI2_IRQHandler
    309          * Description    : This function handles External interrupt Line 2 request.
    310          * Input          : None
    311          * Output         : None
    312          * Return         : None
    313          *******************************************************************************/
    314          /*
    315          void EXTI2_IRQHandler(void)
    316          {
    317          }
    318          */
    319          /*******************************************************************************
    320          * Function Name  : EXTI3_IRQHandler
    321          * Description    : This function handles External interrupt Line 3 request.
    322          * Input          : None
    323          * Output         : None
    324          * Return         : None
    325          *******************************************************************************/
    326          /*
    327          void EXTI3_IRQHandler(void)
    328          {
    329          }
    330          */
    331          /*******************************************************************************
    332          * Function Name  : EXTI4_IRQHandler
    333          * Description    : This function handles External interrupt Line 4 request.
    334          * Input          : None
    335          * Output         : None
    336          * Return         : None
    337          *******************************************************************************/
    338          /*
    339          void EXTI4_IRQHandler(void)
    340          {
    341          }
    342          */
    343          /*******************************************************************************
    344          * Function Name  : DMA1_Channel1_IRQHandler
    345          * Description    : This function handles DMA1 Channel 1 interrupt request.
    346          * Input          : None
    347          * Output         : None
    348          * Return         : None
    349          *******************************************************************************/
    350          /*
    351          void DMA1_Channel1_IRQHandler(void)
    352          {
    353              Send_Buffer[0] = 0x07;
    354          
    355              if((ADC_ConvertedValueX >>4) - (ADC_ConvertedValueX_1 >>4) > 4)
    356              {
    357                  Send_Buffer[1] = (uint8_t)(ADC_ConvertedValueX >>4);
    358                  UserToPMABufferCopy(Send_Buffer, ENDP1_TXADDR, 2);
    359                  SetEPTxCount(ENDP1, 2);
    360                  SetEPTxValid(ENDP1);
    361                  ADC_ConvertedValueX_1 = ADC_ConvertedValueX;
    362              }
    363          
    364              DMA_ClearFlag(DMA1_FLAG_TC1);
    365          }
    366          */
    367          /*******************************************************************************
    368          * Function Name  : DMA1_Channel2_IRQHandler
    369          * Description    : This function handles DMA1 Channel 2 interrupt request.
    370          * Input          : None
    371          * Output         : None
    372          * Return         : None
    373          *******************************************************************************/
    374          void DMA1_Channel2_IRQHandler(void)
    375          {
    376          }
    377          
    378          /*******************************************************************************
    379          * Function Name  : DMA1_Channel3_IRQHandler
    380          * Description    : This function handles DMA1 Channel 3 interrupt request.
    381          * Input          : None
    382          * Output         : None
    383          * Return         : None
    384          *******************************************************************************/
    385          void DMA1_Channel3_IRQHandler(void)
    386          {
    387          }
    388          
    389          /*******************************************************************************
    390          * Function Name  : DMA1_Channel4_IRQHandler
    391          * Description    : This function handles DMA1 Channel 4 interrupt request.
    392          * Input          : None
    393          * Output         : None
    394          * Return         : None
    395          *******************************************************************************/
    396          void DMA1_Channel4_IRQHandler(void)
    397          {
    398          }
    399          
    400          /*******************************************************************************
    401          * Function Name  : DMA1_Channel5_IRQHandler
    402          * Description    : This function handles DMA1 Channel 5 interrupt request.
    403          * Input          : None
    404          * Output         : None
    405          * Return         : None
    406          *******************************************************************************/
    407          void DMA1_Channel5_IRQHandler(void)
    408          {
    409          }
    410          
    411          /*******************************************************************************
    412          * Function Name  : DMA1_Channel6_IRQHandler
    413          * Description    : This function handles DMA1 Channel 6 interrupt request.
    414          * Input          : None
    415          * Output         : None
    416          * Return         : None
    417          *******************************************************************************/
    418          void DMA1_Channel6_IRQHandler(void)
    419          {
    420          }
    421          
    422          /*******************************************************************************
    423          * Function Name  : DMA1_Channel7_IRQHandler
    424          * Description    : This function handles DMA1 Channel 7 interrupt request.
    425          * Input          : None
    426          * Output         : None
    427          * Return         : None
    428          *******************************************************************************/
    429          void DMA1_Channel7_IRQHandler(void)
    430          {
    431          }
    432          
    433          /*******************************************************************************
    434          * Function Name  : ADC1_2_IRQHandler
    435          * Description    : This function handles ADC1 and ADC2 global interrupts requests.
    436          * Input          : None
    437          * Output         : None
    438          * Return         : None
    439          *******************************************************************************/
    440          void ADC1_2_IRQHandler(void)
    441          {
    442          }
    443          
    444          /*******************************************************************************
    445          * Function Name  : USB_HP_CAN_TX_IRQHandler
    446          * Description    : This function handles USB High Priority or CAN TX interrupts 
    447          *                  requests.
    448          * Input          : None
    449          * Output         : None
    450          * Return         : None
    451          *******************************************************************************/
    452          void USB_HP_CAN1_TX_IRQHandler(void)
    453          {
    454          }
    455          
    456          /*******************************************************************************
    457          * Function Name  : USB_LP_CAN_RX0_IRQHandler
    458          * Description    : This function handles USB Low Priority or CAN RX0 interrupts 
    459          *                  requests.
    460          * Input          : None
    461          * Output         : None
    462          * Return         : None
    463          *******************************************************************************/
    464          /*
    465          void USB_LP_CAN1_RX0_IRQHandler(void)
    466          {
    467              USB_Istr();
    468          }
    469          */
    470          /*******************************************************************************
    471          * Function Name  : CAN_RX1_IRQHandler
    472          * Description    : This function handles CAN RX1 interrupt request.
    473          * Input          : None
    474          * Output         : None
    475          * Return         : None
    476          *******************************************************************************/
    477          void CAN1_RX1_IRQHandler(void)
    478          {
    479          }
    480          
    481          /*******************************************************************************
    482          * Function Name  : CAN_SCE_IRQHandler
    483          * Description    : This function handles CAN SCE interrupt request.
    484          * Input          : None
    485          * Output         : None
    486          * Return         : None
    487          *******************************************************************************/
    488          void CAN1_SCE_IRQHandler(void)
    489          {
    490          }
    491          
    492          /*******************************************************************************
    493          * Function Name  : EXTI9_5_IRQHandler
    494          * Description    : This function handles External lines 9 to 5 interrupt request.
    495          * Input          : None
    496          * Output         : None
    497          * Return         : None
    498          *******************************************************************************/
    499          /*
    500          void EXTI9_5_IRQHandler(void)
    501          {
    502          #ifdef  BOARD_DEF_MANGO_Z1
    503              if(EXTI_GetITStatus(GPIO_EXTI_Line_RF_GPIO0) != RESET)
    504              {
    505                  basicRfRxFrmDoneIsr();
    506                  EXTI_ClearITPendingBit(GPIO_EXTI_Line_RF_GPIO0);
    507              }
    508          #endif
    509          }
    510          */
    511          /*******************************************************************************
    512          * Function Name  : TIM1_BRK_IRQHandler
    513          * Description    : This function handles TIM1 Break interrupt request.
    514          * Input          : None
    515          * Output         : None
    516          * Return         : None
    517          *******************************************************************************/
    518          void TIM1_BRK_IRQHandler(void)
    519          {
    520          }
    521          
    522          /*******************************************************************************
    523          * Function Name  : TIM1_UP_IRQHandler
    524          * Description    : This function handles TIM1 overflow and update interrupt 
    525          *                  request.
    526          * Input          : None
    527          * Output         : None
    528          * Return         : None
    529          *******************************************************************************/
    530          void TIM1_UP_IRQHandler(void)
    531          {
    532          }
    533          
    534          /*******************************************************************************
    535          * Function Name  : TIM1_TRG_COM_IRQHandler
    536          * Description    : This function handles TIM1 Trigger and commutation interrupts 
    537          *                  requests.
    538          * Input          : None
    539          * Output         : None
    540          * Return         : None
    541          *******************************************************************************/
    542          void TIM1_TRG_COM_IRQHandler(void)
    543          {
    544          }
    545          
    546          /*******************************************************************************
    547          * Function Name  : TIM1_CC_IRQHandler
    548          * Description    : This function handles TIM1 capture compare interrupt request.
    549          * Input          : None
    550          * Output         : None
    551          * Return         : None
    552          *******************************************************************************/
    553          void TIM1_CC_IRQHandler(void)
    554          {
    555          }
    556          
    557          /*******************************************************************************
    558          * Function Name  : TIM2_IRQHandler
    559          * Description    : This function handles TIM2 global interrupt request.
    560          * Input          : None
    561          * Output         : None
    562          * Return         : None
    563          * Timer		: 10ms
    564          *******************************************************************************/
    565          u8 g_Tx_Buf = 0x00;
    566          
    567          void TIM2_IRQHandler(void)
    568          {
    569          	if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)
    570          	{
    571          		TIM_ClearITPendingBit(TIM2, TIM_IT_Update);	
    572          
    573          		// =======================================
    574          		// LED Control : 1s
    575          		// =======================================
    576          		stLED_SET.LED_COUNT++;
    577          		if(stLED_SET.LED_COUNT >= 100)
    578          		{
    579          			stLED_SET.LED_COUNT = 0;
    580          			stLED_SET.LED_FLAG ^= 0xFF;
    581          
    582          			//if(stLED_SET.LED_FLAG) LED1_ON;
    583          			//else LED1_OFF;
    584          		}
    585          
    586          		if(stINFO.BOOT_FLAG == 0x01)
    587          		{
    588          			stINFO.BOOT_CHECK_LIMIT_ms++;
    589          
    590          			if(stINFO.BOOT_CHECK_LIMIT_ms >= 1000)
    591          			{
    592          				stINFO.BOOT_CHECK_LIMIT_ms = 0;
    593          				stINFO.BOOT_FLAG = 0x00;
    594          			}
    595          		}
    596          
    597          		// ================================================================
    598          		// Wiper Sensor Check
    599          		// ================================================================
    600          
    601          		switch(stDIP.MODE2)
    602          		{
    603          			case 0x00:
    604          
    605          				stWIPER2.SENSOR_1 = WIPER_SENSOR_1;
    606          				stWIPER2.SENSOR_2 = WIPER_SENSOR_2;
    607          				
    608          				break;
    609          
    610          			case 0x01:
    611          
    612          				stWIPER2.SENSOR_1 = WIPER_SENSOR_1;
    613          				
    614          				if(stWIPER1.SENSOR_TEMP != stWIPER2.SENSOR_1) 
    615          				{
    616          
    617          					if((stWIPER2.SENSOR_1 == WIPER_SENS1_ON) && (stWIPER1.SENSOR_TEMP == WIPER_SENS1_OFF))
    618          					{
    619          						if((stWIPER1.ACTIVE_COUNT > 0) && (stWIPER1.ACTIVE_COUNT < 0x0F)) 
    620          						{
    621          							stWIPER1.ACTIVE_COUNT--;
    622          						}
    623          						
    624          						if(stWIPER1.ACTIVE_COUNT == 0) 
    625          						{
    626          							Run_Wiper(WIPER_OFF, DIRECTION_CW);				// Wiper Off
    627          						}
    628          						else
    629          						{
    630          							if((stWIPER1.DWELL_FLAG == 0x00) && (stWIPER1.DWELL_TIME != 0))
    631          							{
    632          								Run_Wiper(WIPER_OFF, DIRECTION_CW);				// Wiper off
    633          								stWIPER1.DWELL_FLAG = 0x01;
    634          							}
    635          						}
    636          					}
    637          
    638          					stWIPER1.SENSOR_TEMP = WIPER_SENSOR_1;
    639          					
    640          				}
    641          				stWIPER2.SENSOR_2 = WIPER_SENSOR_2;
    642          
    643          
    644          				break;
    645          
    646          			default:
    647          				break;
    648          		}
    649          
    650          		// =======================================
    651          		// Wiper1 Dwell Timer
    652          		// =======================================
    653          		if(stWIPER1.DWELL_FLAG == 0x01)
    654          		{
    655          			stWIPER1.DWELL_TIME_10ms++;
    656          			if(stWIPER1.DWELL_TIME_10ms > 100)
    657          			{
    658          				stWIPER1.DWELL_TIME_10ms = 0;
    659          				stWIPER1.DWELL_TIME_1s++;
    660          
    661          				if(stWIPER1.DWELL_TIME <= stWIPER1.DWELL_TIME_1s)
    662          				{
    663          					stWIPER1.DWELL_FLAG = 0x00;
    664          					if(stWIPER1.ACTIVE_COUNT != 0)
    665          					{
    666          						Run_Wiper(WIPER_ON, DIRECTION_CW);				// Wiper On
    667          					}
    668          
    669          					stWIPER1.DWELL_TIME_1s = 0;
    670          				}
    671          			}
    672          		}
    673          		
    674          		// ================================================================
    675          		// Wiper2 Dwell Timer
    676          		// ================================================================
    677          		if(stWIPER2.DWELL_TIMER_FLAG)
    678          		{
    679          			stWIPER2.DWELL_TIMER_ms++;
    680          
    681          			if(stWIPER2.DWELL_TIMER_ms >= 100)	// 1s
    682          			{
    683          				stWIPER2.DWELL_TIMER_s++;
    684          				stWIPER2.DWELL_TIMER_ms = 0x00;
    685          		
    686          				if(stWIPER2.DWELL_TIMER_s >= stWIPER2.DWELL_TIME_DATA)
    687          				{
    688          					stWIPER2.DWELL_END_FLAG = 0x01;
    689          					stWIPER2.DWELL_TIMER_s = 0x00;
    690          					stWIPER2.DWELL_TIMER_FLAG = 0x00;
    691          				}
    692          			}
    693          		}
    694          
    695          		if((stWIPER2.COUNT == 0x00) && (stWIPER2.DWELL_TIMER_FLAG != 0x00))
    696          		{
    697          			stWIPER2.DWELL_TIMER_FLAG = 0x00;
    698          			stWIPER2.DWELL_TIMER_ms = 0;
    699          			stWIPER2.DWELL_TIMER_s = 0;
    700          		}
    701          
    702          		// ================================================================
    703          		// LRF Booting Check Time
    704          		// ================================================================
    705          		if(stLRF.INIT_FLAG == 0x01)
    706          		{
    707          			stLRF.INIT_TIME++;
    708          
    709          			if(stLRF.INIT_TIME >= LRF_BOOTING_TIME)
    710          			{
    711          				stLRF.INIT_ACTIVE = 0x01;
    712          
    713          				stLRF.INIT_TIME = 0x00;
    714          				stLRF.INIT_FLAG = 0x00;
    715          			}
    716          		}
    717          
    718          		if(stLRF.CONTINUOUS_FLAG == 0x01)
    719          		{
    720          			stLRF.CONTINUOUS_TIME++;
    721          
    722          			if(stLRF.CONTINUOUS_TIME > stLRF.CONTINUOUS_TIME_MAX)
    723          			{
    724          				stLRF.CONTINUOUS_ACTIVE = 0x01;
    725          				
    726          				stLRF.CONTINUOUS_TIME = 0;
    727          			}
    728          		}
    729          
    730          		// ================================================================
    731          		// BYPASS Tx Check (전송 후 500ms 후 Clear)
    732          		// ================================================================
    733          		if(stBYPASS.TX_FLAG == 0x01)
    734          		{
    735          			stBYPASS.TX_TIMER++;
    736          
    737          			if(stBYPASS.TX_TIMER >= 50)
    738          			{
    739          				stBYPASS.TX_TIMER = 0;
    740          				stBYPASS.TX_FLAG = 0x00;
    741          			}
    742          		}
    743          
    744          		// ================================================================
    745          		// WIPER CONTINUOUS TIMER
    746          		// ================================================================
    747          		if(stWIPER2.CONTINUOUS_FLAG == 0x00)
    748          		{
    749          			if((stWIPER2.CONTINUOUS_ms != 0) || (stWIPER2.CONTINUOUS_s != 0) || (stWIPER2.CONTINUOUS_m != 0) || (stWIPER2.CONTINUOUS_h != 0))
    750          			{
    751          				stWIPER2.CONTINUOUS_ms = 0;
    752          				stWIPER2.CONTINUOUS_s = 0;
    753          				stWIPER2.CONTINUOUS_m = 0;
    754          				stWIPER2.CONTINUOUS_h = 0;
    755          			}
    756          		}
    757          			
    758          		if(stWIPER2.CONTINUOUS_FLAG == 0x01)
    759          		{
    760          			stWIPER2.CONTINUOUS_ms++;
    761          			
    762          			if(stWIPER2.CONTINUOUS_ms >= 100)
    763          			{
    764          				stWIPER2.CONTINUOUS_ms = 0;
    765          				stWIPER2.CONTINUOUS_s++;
    766          				
    767          				if(stWIPER2.CONTINUOUS_s >= 60)
    768          				{
    769          					stWIPER2.CONTINUOUS_s = 0;
    770          					stWIPER2.CONTINUOUS_m++;
    771          
    772          					if(stWIPER2.CONTINUOUS_m >= 60)
    773          					{
    774          						stWIPER2.CONTINUOUS_m = 0;
    775          						stWIPER2.CONTINUOUS_h++;
    776          
    777          						if(stWIPER2.CONTINUOUS_h >= stWIPER2.CONTINUOUS_TIME)
    778          						{
    779          							stWIPER2.CONTINUOUS_h = 0;
    780          							stWIPER2.CONTINUOUS_FLAG = 0x00;
    781          							stWIPER2.CONTINUOUS_STOP_FLAG = 0x01;
    782          						}
    783          					}
    784          				}
    785          			}
    786          		}
    787          
    788          		// ================================================================
    789          		// TEST TIMER
    790          		// ================================================================
    791          /*
    792          		if(stUSART2.TX_CNT < stUSART2.TX_MAX)
    793          		{
    794          			g_Tx_Buf = stUSART2.TX_BUF[stUSART2.TX_CNT];
    795          			stUSART2.TX_CNT++;				
    796          
    797          			USART_SendData(USART2, g_Tx_Buf);
    798          		}
    799          		else
    800          		{
    801          			stUSART2.TX_CNT = 0x00;
    802          			stUSART2.TX_MAX = 0x00;
    803          		
    804          			//USART_SendData(USART2, Tx_Buf);
    805          		}
    806          */
    807          
    808          	}	
    809          }
    810          
    811          /*******************************************************************************
    812          * Function Name  : TIM3_IRQHandler
    813          * Description    : This function handles TIM3 global interrupt request.
    814          * Input          : None
    815          * Output         : None
    816          * Return         : None
    817          * Timer		: 1ms
    818          *******************************************************************************/
    819          void TIM3_IRQHandler(void)
    820          {
    821          	if (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET)
    822          	{
    823          
    824          				TIM_ClearITPendingBit(TIM4, TIM_IT_Update);
    825          				LED_Off_Green();
    826          				LED_On_Green();
    827          				
    828          
    829          		
    830          //			TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
    831          //	
    832          //			// ================================================================
    833          //			// Sony-Zoom & Light-Zoom Sync
    834          //			// ================================================================
    835          //			//Zoom_Data_Sync();
    836          //	
    837          //			// ================================================================
    838          //			// TEMPERATURE (DC-103JU)
    839          //			// ================================================================
    840          //			Temperature_Data_Check();
    841          //			Temperature_Boot_Mode();
    842          //	
    843          //			// =======================================
    844          //			// Temperature Control
    845          //			// =======================================
    846          //			if(stTEMP.STARTING_MODE == 0x00)
    847          //			{
    848          //				Fan_Heater_Control(BOOT_MODE);
    849          //			}
    850          //			else
    851          //			{
    852          //				Fan_Heater_Control(NORMAL_MODE);
    853          //			}
    854          //			
    855          //			// ================================================================
    856          //			// CDS CHECK
    857          //			// ================================================================
    858          //			//CDS_Data_Check();
    859          //			//Auto_Day_And_Night_Control();
    860          	}	
    861          }
    862          
    863          /*******************************************************************************
    864          * Function Name  : SYSTEM_Data_Reordering
    865          *******************************************************************************/
    866          void SYSTEM_Data_Reordering(void)
    867          {
    868          	u8 i = 0x00, j = 0x00, u_buf = 0x00, u_length = 0x00, u_max = 0x00;
    869          	
    870          	if((stSYS.RX_PARITY == 0x00) && (stSYS.RX_REORDERING == 0x01))
    871          	{
    872          		if(stSYS.RX_INDEX == 0x00)
    873          		{
    874          			u_buf = stSYS.RX_BUF[0][1];
    875          		
    876          			switch(u_buf)
    877          			{
    878          				case TILT_FIRST_BYTE:
    879          				case IP_SONY_FIRST_BYTE:
    880          				case IP_TSM_FIRST_BYTE:
    881          				case IP_DRS_FIRST_BYTE:
    882          				case IP_PTZ_FIRST_BYTE:
    883          				case IP_DATA_FIRST_BYTE:
    884          				case IP_OPTION_FIRST_BYTE:
    885          
    886          					u_length = stSYS.RX_BUF[i][3];		// Length Byte Check
    887          
    888          					u_max = u_length + 6;
    889          					
    890          					for(j=0; j<u_max; j++)
    891          					{
    892          						stSYS.RX_BUF[0][j] = 0x00;
    893          					}
    894          
    895          					stSYS.RX_REORDERING = 0x00;
    896          					
    897          					break;
    898          
    899          				default:
    900          					break;
    901          			}			
    902          		}
    903          		else
    904          		{
    905          			for(i=1; i<SYS_RX_BUF_CNT; i++)
    906          			{
    907          				if(stSYS.RX_BUF[i][0] != 0x00)
    908          				{
    909          					u_buf = stSYS.RX_BUF[i][1];	// Command Byte Check
    910          					
    911          					switch(u_buf)
    912          					{
    913          						case TILT_FIRST_BYTE:
    914          						case IP_SONY_FIRST_BYTE:
    915          						case IP_TSM_FIRST_BYTE:
    916          						case IP_DRS_FIRST_BYTE:
    917          						case IP_PTZ_FIRST_BYTE:
    918          						case IP_DATA_FIRST_BYTE:
    919          						case IP_OPTION_FIRST_BYTE:
    920          
    921          							u_length = stSYS.RX_BUF[i][3];		// Length Byte Check
    922          
    923          							u_max = u_length + 6;
    924          							
    925          							for(j=0; j<u_max; j++)
    926          							{
    927          								stSYS.RX_BUF[i-1][j] = stSYS.RX_BUF[i][j];
    928          								if(stSYS.RX_INDEX > 0) stSYS.RX_BUF[stSYS.RX_INDEX - 1][j] = 0x00;
    929          							}
    930          
    931          							stSYS.RX_REORDERING = 0x00;
    932          							
    933          							break;
    934          
    935          						default:
    936          							break;
    937          
    938          					}
    939          				}
    940          			}
    941          		}
    942          		
    943          		stSYS.RX_COMPLETE = 0x00;
    944          		if(stSYS.RX_INDEX > 0) stSYS.RX_INDEX--;
    945          		
    946          	}
    947          }
    948          
    949          /*******************************************************************************
    950          * Function Name  : SYSTEM_Data_Handling
    951          *******************************************************************************/
    952          void SYSTEM_Data_Handling(void)
    953          {
    954          	if((stSYS.RX_BUF[0][0] != 0x00) && (stSYS.RX_COMPLETE == 0x00) && (stSYS.RX_PARITY == 0x00) && (stSYS.RX_REORDERING == 0x00))
    955          	{
    956          		stSYS.RX_PARITY = 0x01;
    957          	}
    958          }
    959          
    960          /*******************************************************************************
    961          * Function Name  : SYSTEM_Data_Handling
    962          *******************************************************************************/
    963          void SYSTEM_Data_Buffer(void)
    964          {
    965          	u8 i = 0x00, u_buf = 0x00, u_length = 0x00, u_max = 0x00;
    966          
    967          	if(stUSART1.RX_PARITY == 0x01)
    968          	{
    969          		u_buf = stUSART1.RX_BUF[0];
    970          
    971          		switch(u_buf)
    972          		{
    973          /*
    974          			case TILT_FIRST_BYTE:
    975          
    976          				u_length = stUSART1.RX_BUF[2];
    977          
    978          				u_max = u_length + 5;
    979          
    980          				stCOOR.RX_BUF[stCOOR.RX_INDEX][0] = stCOOR.RX_INDEX + 1;
    981          
    982          				for(i=0; i<u_max; i++)
    983          				{
    984          					stCOOR.RX_BUF[stCOOR.RX_INDEX][i+1] =  stUSART1.RX_BUF[i];
    985          					stUSART1.RX_BUF[i] = 0x00;
    986          				}
    987          
    988          				stCOOR.RX_INDEX++;
    989          				
    990          				break;
    991          */				
    992          			case TILT_FIRST_BYTE:
    993          			case IP_SONY_FIRST_BYTE:
    994          			case IP_TSM_FIRST_BYTE:
    995          			case IP_DRS_FIRST_BYTE:
    996          			case IP_PTZ_FIRST_BYTE:
    997          			case IP_DATA_FIRST_BYTE:
    998          			case IP_OPTION_FIRST_BYTE:
    999          
   1000          				u_length = stUSART1.RX_BUF[2];
   1001          
   1002          				u_max = u_length + 5;
   1003          
   1004          				stSYS.RX_BUF[stSYS.RX_INDEX][0] = stSYS.RX_INDEX + 1;
   1005          
   1006          				for(i=0; i<u_max; i++)
   1007          				{
   1008          					stSYS.RX_BUF[stSYS.RX_INDEX][i+1] =  stUSART1.RX_BUF[i];
   1009          					stUSART1.RX_BUF[i] = 0x00;
   1010          				}
   1011          
   1012          				stSYS.RX_INDEX++;
   1013          
   1014          				break;
   1015          
   1016          			default:
   1017          				break;
   1018          		}
   1019          
   1020          		stUSART1.RX_PARITY = 0x00;
   1021          
   1022          	}
   1023          }
   1024          
   1025          /*******************************************************************************
   1026          * Function Name  : SYSTEM_Data_Parser
   1027          *******************************************************************************/
   1028          void SYSTEM_Data_Parser(u8 u_port)
   1029          {
   1030          	switch(u_port)
   1031          	{
   1032          		case USART1_INDEX:
   1033          
   1034          			// =======================================
   1035          			// System Data Reordering
   1036          			// =======================================
   1037          			SYSTEM_Data_Reordering();
   1038          
   1039          			// =======================================
   1040          			// System Data Handling
   1041          			// =======================================
   1042          			SYSTEM_Data_Handling();
   1043          
   1044          			// =======================================
   1045          			// Rx Buffer Check & Data Trans
   1046          			// =======================================
   1047          			SYSTEM_Data_Buffer();
   1048          
   1049          			break;
   1050          
   1051          		default:
   1052          			break;
   1053          	}
   1054          }
   1055          
   1056          /****************************************************************************************************
   1057          * Function Name  : Boot_Status_Data_Trans
   1058          * Data Architecture :
   1059          BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]		BYTE5[LENGTH+4]
   1060          0xCA		0xAC		LENGTH		ADDR		COMM		DATA...		CS
   1061          0xCA		0xAC		0x04		0x01		0xD1		DATA...		CS
   1062          
   1063          DATA : 0x00: Nondata, 0x01: ACTIVE Status, 0x02 : Boot Ready Status
   1064          *****************************************************************************************************/
   1065          void Boot_Status_Data_Trans(void)
   1066          {
   1067          	u8 u_Cmd = TILT_BOOT_STATUS, u_Leng = 0x04, u_ID = MDIN_LAYER_CENTER_MSG;
   1068          
   1069          	switch(stSYS.BOOT_STATUS)
   1070          	{
   1071          		// TILT B/D 가 POWER OFF 인 경우
   1072          		case STOP:
   1073          			break;
   1074          
   1075          		// TILT B/D 가 MODULE 을 정상 경우
   1076          		case ACTIVE:
   1077          
   1078          			stUSART1.TX_BUF[0] = TILT_FIRST_BYTE;
   1079          			stUSART1.TX_BUF[1] = TILT_SECOND_BYTE;
   1080          			stUSART1.TX_BUF[2] = u_Leng;
   1081          			stUSART1.TX_BUF[3] = u_ID;
   1082          			stUSART1.TX_BUF[4] = u_Cmd;
   1083          			stUSART1.TX_BUF[5] = ACTIVE;
   1084          			stUSART1.TX_BUF[6] = 0x00;
   1085          			
   1086          			stUSART1.TX_BUF[7] = 0x00;		
   1087          			stUSART1.TX_BUF[7] = stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5] + stUSART1.TX_BUF[6];
   1088          
   1089          			stUSART1.TX_BUF[8] = 0xCF;
   1090          			
   1091          			stUSART1.TX_CNT = 0;
   1092          			stUSART1.TX_MAX = u_Leng + 5;
   1093          
   1094          			USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   1095          
   1096          			stSYS.BOOT_STATUS = STOP;
   1097          			
   1098          			break;
   1099          
   1100          		// TILT B/D 가 MODULE 을 정상 부팅 못하였을 경우 (MAIN으로 부터 체크 송신을 받았으나 MODULE 미인식, 데이터 비정상)
   1101          		case READY:
   1102          
   1103          			stUSART1.TX_BUF[0] = TILT_FIRST_BYTE;
   1104          			stUSART1.TX_BUF[1] = TILT_SECOND_BYTE;
   1105          			stUSART1.TX_BUF[2] = u_Leng;
   1106          			stUSART1.TX_BUF[3] = u_ID;
   1107          			stUSART1.TX_BUF[4] = u_Cmd;
   1108          			stUSART1.TX_BUF[5] = READY;
   1109          			stUSART1.TX_BUF[6] = 0x00;
   1110          			
   1111          			stUSART1.TX_BUF[7] = 0x00;		
   1112          			stUSART1.TX_BUF[7] = stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5] + stUSART1.TX_BUF[6];
   1113          
   1114          			stUSART1.TX_BUF[8] = 0xCF;
   1115          
   1116          			stUSART1.TX_CNT = 0;
   1117          			stUSART1.TX_MAX = u_Leng + 5;
   1118          
   1119          			USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   1120          
   1121          			stSYS.BOOT_STATUS = STOP;
   1122          		
   1123          			break;
   1124          
   1125          		default:
   1126          			break;
   1127          	}
   1128          }
   1129          
   1130          /*******************************************************************************
   1131          * Function Name  : TIM4_IRQHandler
   1132          * Description    : This function handles TIM4 global interrupt request.
   1133          * Input          : None
   1134          * Output         : None
   1135          * Return         : None
   1136          * Timer		: 1ms
   1137          *******************************************************************************/
   1138          void TIM4_IRQHandler(void)
   1139          {
   1140          	if (TIM_GetITStatus(TIM4, TIM_IT_Update) != RESET)
   1141          	{
   1142          		
   1143          		TIM_ClearITPendingBit(TIM4, TIM_IT_Update);
   1144          		LED_On_Red();
   1145          		LED_Off_Red();
   1146          		
   1147          
   1148          
   1149          
   1150          //			if(stSYS.START == ACTIVE)
   1151          //			{
   1152          //				SYSTEM_Data_Parser(USART1_INDEX);
   1153          //			}
   1154          //			else
   1155          //			{
   1156          //				Boot_Status_Data_Trans();
   1157          //			}
   1158          	}
   1159          
   1160          }//End Of The TIM4_IRQ_Handler
   1161          
   1162          
   1163          
   1164          void EXTI0_IRQHandler(void) {
   1165          	if(EXTI_GetITStatus(EXTI_Line0) != RESET)
   1166          	{
   1167          		EXTI_ClearITPendingBit(EXTI_Line0);
   1168          		if (red_status) {
   1169          			LED_Off_Red();
   1170          	    	Delay_1ms(1000);
   1171          		} else {
   1172          			LED_On_Red();
   1173          			Delay_1ms(1000);
   1174          		}
   1175          	}
   1176          }
   1177          
   1178          
   1179          
   1180          
   1181          
   1182          /*******************************************************************************
   1183          * Function Name  : I2C1_EV_IRQHandler
   1184          * Description    : This function handles I2C1 Event interrupt request.
   1185          * Input          : None
   1186          * Output         : None
   1187          * Return         : None
   1188          *******************************************************************************/
   1189          void I2C1_EV_IRQHandler(void)
   1190          {
   1191          }
   1192          
   1193          /*******************************************************************************
   1194          * Function Name  : I2C1_ER_IRQHandler
   1195          * Description    : This function handles I2C1 Error interrupt request.
   1196          * Input          : None
   1197          * Output         : None
   1198          
   1199          * Return         : None
   1200          *******************************************************************************/
   1201          void I2C1_ER_IRQHandler(void)
   1202          {
   1203          }
   1204          
   1205          /*******************************************************************************
   1206          * Function Name  : I2C2_EV_IRQHandler
   1207          * Description    : This function handles I2C2 Event interrupt request.
   1208          * Input          : None
   1209          * Output         : None
   1210          * Return         : None
   1211          *******************************************************************************/
   1212          void I2C2_EV_IRQHandler(void)
   1213          {
   1214          }
   1215          
   1216          /*******************************************************************************
   1217          * Function Name  : I2C2_ER_IRQHandler
   1218          * Description    : This function handles I2C2 Error interrupt request.
   1219          * Input          : None
   1220          * Output         : None
   1221          * Return         : None
   1222          *******************************************************************************/
   1223          void I2C2_ER_IRQHandler(void)
   1224          {
   1225          }
   1226          
   1227          /*******************************************************************************
   1228          * Function Name  : SPI1_IRQHandler
   1229          * Description    : This function handles SPI1 global interrupt request.
   1230          * Input          : None
   1231          * Output         : None
   1232          * Return         : None
   1233          *******************************************************************************/
   1234          void SPI1_IRQHandler(void)
   1235          {
   1236          }
   1237          
   1238          /*******************************************************************************
   1239          * Function Name  : SPI2_IRQHandler
   1240          * Description    : This function handles SPI2 global interrupt request.
   1241          * Input          : None
   1242          * Output         : None
   1243          * Return         : None
   1244          *******************************************************************************/
   1245          void SPI2_IRQHandler(void)
   1246          {
   1247          }
   1248          
   1249          /*******************************************************************************
   1250          * Function Name  : USART1_IRQHandler
   1251          * Description    : This function handles USART1 global interrupt request.
   1252          * Input          : None
   1253          * Output         : None
   1254          * Return         : None
   1255          *******************************************************************************/
   1256          /*******************************************************************************
   1257          * Function Name  : USART2_IRQHandler
   1258          * Description    : This function handles USART2 global interrupt request.
   1259          * Input          : None
   1260          * Output         : None
   1261          * Return         : None
   1262          *******************************************************************************/
   1263          /*******************************************************************************
   1264          * Function Name  : USART3_IRQHandler
   1265          * Description    : This function handles USART3 global interrupt request.
   1266          * Input          : None
   1267          * Output         : None
   1268          * Return         : None
   1269          *******************************************************************************/
   1270          /*******************************************************************************
   1271          * Function Name  : EXTI15_10_IRQHandler
   1272          * Description    : This function handles External lines 15 to 10 interrupt request.
   1273          * Input          : None
   1274          * Output         : None
   1275          * Return         : None
   1276          *******************************************************************************/
   1277          void EXTI15_10_IRQHandler(void)
   1278          {
   1279          }
   1280          
   1281          /*******************************************************************************
   1282          * Function Name  : RTCAlarm_IRQHandler
   1283          * Description    : This function handles RTC Alarm interrupt request.
   1284          * Input          : None
   1285          * Output         : None
   1286          * Return         : None
   1287          *******************************************************************************/
   1288          void RTCAlarm_IRQHandler(void)
   1289          {
   1290          }
   1291          
   1292          /*******************************************************************************
   1293          * Function Name  : USBWakeUp_IRQHandler
   1294          * Description    : This function handles USB WakeUp interrupt request.
   1295          * Input          : None
   1296          * Output         : None
   1297          * Return         : None
   1298          *******************************************************************************/
   1299          /*
   1300          void USBWakeUp_IRQHandler(void)
   1301          {
   1302          #if 1
   1303              EXTI_ClearITPendingBit(EXTI_Line18);
   1304          #endif
   1305          }
   1306          */
   1307          
   1308          
   1309          /*******************************************************************************
   1310          * Function Name  : Rx_Second_Comm_Check
   1311          *******************************************************************************/
   1312          void Rx_Main_Second_Comm_Check(u8 u_buf, u8 u_andbyte)
   1313          {
   1314          	if(u_buf == u_andbyte)
   1315          	{
   1316          		stUSART1.RX_BUF[1] =  u_buf;
   1317          		stUSART1.RX_BUF_INDEX++;
   1318          		stUSART1.RX_BUF_LENGTH = 0x01;
   1319          	}
   1320          	else
   1321          	{
   1322          		stUSART1.RX_BUF_INDEX = 0x00;					// Index Clear
   1323          		stUSART1.RX_BUF[0] = 0x00;						// Buffer Clear
   1324          		stUSART1.RX_ENABLE = 0x00;						// Command Check Byte Clear
   1325          	}	
   1326          }
   1327          
   1328          /*******************************************************************************
   1329          * Function Name  : Boot_Status_Check_Parser
   1330          *******************************************************************************/
   1331          void Boot_Status_Check_Parser(void)
   1332          {
   1333          	if((stUSART1.RX_BUF[0] == TILT_FIRST_BYTE) && (stUSART1.RX_BUF[4] == TILT_BOOT_STATUS))
   1334          	{
   1335          		if(stSYS.START == STOP)
   1336          		{
   1337          			stSYS.BOOT_STATUS = READY;
   1338          		}
   1339          		/*
   1340          		else
   1341          		{
   1342          			stSYS.BOOT_STATUS = ACTIVE;
   1343          		}
   1344          		*/
   1345          	}
   1346          }
   1347          
   1348          /*******************************************************************************
   1349          * Function Name  : Rx_Main_Comm_Handling
   1350          *******************************************************************************/
   1351          void Rx_Main_Comm_Handling(u8 u_sync, u8 u_buf)	// u_port : Uart Port, u_sync : Sync Byte Check (0 : First Byte, 1 : Second Byte)
   1352          {
   1353          	// 첫번째 바이트 체크 (Sync Byte Check)
   1354          	if(u_sync == Rx_SYNC_BYTE)	
   1355          	{
   1356          		stUSART1.RX_BUF_INDEX = 0x00;	// Index Init
   1357          		stUSART1.RX_BUF[stUSART1.RX_BUF_INDEX] = u_buf;
   1358          		stUSART1.RX_BUF_INDEX++;
   1359          		
   1360          		#if(ERROR_CHECK_BUF)
   1361          		stERROR.RX_BUF[stERROR.RX_CNT++] = u_buf;
   1362          		if(stERROR.RX_CNT >= ERROR_DATA_MAX) stERROR.RX_CNT = 0;
   1363          		#endif
   1364          	}
   1365          
   1366          	// 두번째 바이트 체크 (Sync & Byte Check)
   1367          	if(u_sync == Rx_SYNC_AND_BYTE)
   1368          	{
   1369          		#if(ERROR_CHECK_BUF)	
   1370          		stERROR.RX_BUF[stERROR.RX_CNT++] = u_buf;
   1371          		if(stERROR.RX_CNT >= ERROR_DATA_MAX) stERROR.RX_CNT = 0;
   1372          		#endif		
   1373          		
   1374          		// 두번째 명령어 체크 (Sync & Byte Check)
   1375          		if(stUSART1.RX_BUF_INDEX == 0x01)
   1376          		{
   1377          			switch(stUSART1.RX_ENABLE)
   1378          			{
   1379          				case TILT_SECOND_BYTE:
   1380          					Rx_Main_Second_Comm_Check(u_buf, TILT_SECOND_BYTE);
   1381          					break;
   1382          
   1383          				case IP_SONY_SECOND_BYTE:
   1384          					Rx_Main_Second_Comm_Check(u_buf, IP_SONY_SECOND_BYTE);
   1385          					break;
   1386          					
   1387          				case IP_TSM_SECOND_BYTE:
   1388          					Rx_Main_Second_Comm_Check(u_buf, IP_TSM_SECOND_BYTE);
   1389          					break;
   1390          
   1391          				default:
   1392          					break;
   1393          			}
   1394          		}	
   1395          	}
   1396          
   1397          	// 세번째 바이트 체크 (Data Length)
   1398          	if(u_sync == Rx_LENGTH_BYTE)
   1399          	{
   1400          		#if(ERROR_CHECK_BUF)	
   1401          		stERROR.RX_BUF[stERROR.RX_CNT++] = u_buf;
   1402          		if(stERROR.RX_CNT >= ERROR_DATA_MAX) stERROR.RX_CNT = 0;
   1403          		#endif
   1404          		
   1405          		if(stUSART1.RX_ENABLE == IP_PELCO_CHK_BYTE)
   1406          		{
   1407          			// PELCO-D Command 예외처리
   1408          			if(stUSART1.RX_BUF_INDEX == 0x02)
   1409          			{
   1410          				stUSART1.RX_BUF_LENGTH = 0x02;
   1411          				stUSART1.RX_BUF_MAX = stUSART1.RX_BUF_LENGTH + 5;
   1412          				
   1413          				stUSART1.RX_BUF[2] =  u_buf;
   1414          				
   1415          				stUSART1.RX_BUF_INDEX++;
   1416          			}					
   1417          		}
   1418          		else
   1419          		{
   1420          			// 세번째 데이터 길이 체크 (Sync & Byte Check)
   1421          			if(stUSART1.RX_BUF_INDEX == 0x02)
   1422          			{
   1423          				stUSART1.RX_BUF_LENGTH = u_buf;
   1424          				stUSART1.RX_BUF_MAX = stUSART1.RX_BUF_LENGTH + 5;
   1425          				
   1426          				stUSART1.RX_BUF[2] =  u_buf;
   1427          				
   1428          				stUSART1.RX_BUF_INDEX++;
   1429          			}
   1430          		}
   1431          	}	
   1432          
   1433          	// 데이터 누적
   1434          	if(u_sync == Rx_DATA_BYTE)
   1435          	{
   1436          		#if(ERROR_CHECK_BUF)
   1437          		stERROR.RX_BUF[stERROR.RX_CNT++] = u_buf;
   1438          		if(stERROR.RX_CNT >= ERROR_DATA_MAX) stERROR.RX_CNT = 0;
   1439          		#endif		
   1440          		
   1441          		stUSART1.RX_BUF[stUSART1.RX_BUF_INDEX] = u_buf;
   1442          
   1443          		stUSART1.RX_BUF_INDEX++;	
   1444          		
   1445          		if(stUSART1.RX_BUF_INDEX == stUSART1.RX_BUF_MAX)
   1446          		{
   1447          			// PELCO-D Command 예외처리
   1448          			if(stUSART1.RX_ENABLE == IP_PELCO_CHK_BYTE)
   1449          			{
   1450          				Rx_Pelco_Data_Check();
   1451          			}
   1452          			else
   1453          			{
   1454          				if((stUSART1.RX_BUF[stUSART1.RX_BUF_INDEX - 1]&0x0F) == 0x0F)		// End Byte Check
   1455          				{
   1456          					if(stSYS.START == ACTIVE)
   1457          					{
   1458          						stUSART1.RX_PARITY = 0x01;	// 정상 데이터 수신 (0x00: Nondata(수신대기), 0x01: 정상데이터, 0xFF, 비정상 데이터, 0xFE = Boot Check)
   1459          						stUSART1.RX_PARITY_CNT++;
   1460          						
   1461          						// DEBUG 데이터 체크 ======================================================/
   1462          						//stERROR.PARITY_CNT_CHECK++;
   1463          						//if(stERROR.PARITY_CNT_CHECK == 0x01) stERROR.TIMER_CHECK_FLAG = 0x01;
   1464          						//if(stERROR.PARITY_CNT_CHECK == 0x02) stERROR.TIMER_CHECK_FLAG = 0x00;
   1465          						// DEBUG 데이터 체크 ===================================================END/
   1466          						
   1467          						//if(stUSART1.RX_PRIORITY == 0x00) stUSART1.RX_PRIORITY = 0x01;
   1468          					}
   1469          					else
   1470          					{
   1471          						Boot_Status_Check_Parser();
   1472          					}
   1473          
   1474          					stUSART1.RX_BUF_INDEX = 0x00;	// Index Init
   1475          					//stUSART1.RX_BUF[stUSART1.RX_BUF_INDEX] = stUSART1.RX_PRIORITY++;
   1476          				}
   1477          				else
   1478          				{
   1479          					stUSART1.RX_PARITY = 0xFF;	// 비정상 데이터 수신 (0x00: Nondata(수신대기), 0x01: 정상데이터, 0xFF, 비정상 데이터, 0xFE = Boot Check)
   1480          					stUSART1.RX_ERROR_CNT++;
   1481          				}
   1482          			}
   1483          			
   1484          			stUSART1.RX_BUF_INDEX = 0x00;
   1485          			stUSART1.RX_BUF_LENGTH = 0x00;
   1486          			
   1487          			stUSART1.RX_ENABLE = 0x00;
   1488          		}
   1489          	}		
   1490          }
   1491          
   1492          /*******************************************************************************
   1493          * Function Name  : Main_Protocol_Data_Pasher
   1494          * Description    : This function handles USART1 interrupt request.
   1495          * Input           : Main - PA10 USART1_RX
   1496          * Output         : Main - PA9 USART1_TX
   1497          *******************************************************************************/
   1498          void Main_Protocol_Data_Pasher(u8 u_buf)
   1499          {
   1500          	u8 u_Index_Chk = 0;
   1501          
   1502          	if(stUSART1.RX_ENABLE == 0x00)
   1503          	{
   1504          		// 첫번째 바이트 체크 (Sync Byte Check)
   1505          		switch(u_buf)
   1506          		{
   1507          			case TILT_FIRST_BYTE:
   1508          				Rx_Main_Comm_Handling(Rx_SYNC_BYTE, TILT_FIRST_BYTE);
   1509          				stUSART1.RX_ENABLE = TILT_SECOND_BYTE;
   1510          				break;
   1511          
   1512          			case IP_SONY_FIRST_BYTE:
   1513          				Rx_Main_Comm_Handling(Rx_SYNC_BYTE, IP_SONY_FIRST_BYTE);
   1514          				stUSART1.RX_ENABLE = IP_SONY_SECOND_BYTE;
   1515          				break;
   1516          
   1517          			case IP_TSM_FIRST_BYTE:
   1518          				Rx_Main_Comm_Handling(Rx_SYNC_BYTE, IP_TSM_FIRST_BYTE);
   1519          				stUSART1.RX_ENABLE = IP_TSM_SECOND_BYTE;
   1520          				break;
   1521          
   1522          			default:
   1523          				break;
   1524          		}
   1525          	}
   1526          	else
   1527          	{
   1528          		if(stUSART1.RX_BUF_LENGTH == 0x00) u_Index_Chk = Rx_SYNC_AND_BYTE;
   1529          		else 
   1530          		{
   1531          			if(stUSART1.RX_BUF_INDEX >= 0x03)
   1532          			{
   1533          				u_Index_Chk = Rx_DATA_BYTE;
   1534          			}
   1535          			else
   1536          			{
   1537          				if(stUSART1.RX_STATUS == 0x00)
   1538          				{
   1539          					u_Index_Chk = Rx_LENGTH_BYTE;
   1540          				}
   1541          			}
   1542          		}
   1543          
   1544          		// 두번째, 세번째 바이트 체크 (Rx_SYNC_AND_BYTE : Sync & Byte Check, Rx_LENGTH_BYTE : Length Check)
   1545          		Rx_Main_Comm_Handling(u_Index_Chk, u_buf);
   1546          	}
   1547          }
   1548          
   1549          /*******************************************************************************
   1550          * Function Name  : Sony_Data_Pasher
   1551          * Description    : This function handles USART1 interrupt request.
   1552          * Input           : Main - PA10 USART1_RX
   1553          * Output         : Main - PA9 USART1_TX
   1554          *******************************************************************************/
   1555          void Sony_Data_Pasher(u8 u_buf)
   1556          {
   1557          	if(stBYPASS.RX_STATUS)
   1558          	{
   1559          		stBYPASS.RX_BUF[stBYPASS.RX_CNT++] = u_buf;
   1560          
   1561          		if(u_buf == 0xFF)
   1562          		{
   1563          			stBYPASS.RX_STATUS = 0x00;
   1564          			stBYPASS.RX_CNT = 0x00;
   1565          			stBYPASS.RX_PARITY = 0x01;			
   1566          		}
   1567          	}
   1568          	else
   1569          	{
   1570          		if(u_buf == SONY_FIRST_BYTE)
   1571          		{
   1572          			stBYPASS.RX_STATUS = 0x01;
   1573          			stBYPASS.RX_BUF[0] = u_buf;
   1574          			stBYPASS.RX_CNT++;
   1575          			
   1576          		}
   1577          	}
   1578          }
   1579          
   1580          /*******************************************************************************
   1581          * Function Name  : USART1_IRQHandler
   1582          * Description    : This function handles USART1 interrupt request.
   1583          * Input           : Main - PA10 USART1_RX
   1584          * Output         : Main - PA9 USART1_TX
   1585          *******************************************************************************/
   1586          void USART1_IRQHandler(void)
   1587          {
   1588          	u8 Rx_Buf = 0x00;
   1589          	
   1590            	// =======================================
   1591            	// USART1 TX Process : TILT -> MAIN Board
   1592            	// =======================================
   1593          	if (USART_GetITStatus(USART1, USART_IT_TC) != RESET)
   1594          	{
   1595          		if (stUSART1.TX_CNT < stUSART1.TX_MAX) 
   1596          		{
   1597          			USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   1598          		}
   1599          		else 
   1600          		{
   1601          			stUSART1.TX_MAX = 0;
   1602          			stUSART1.TX_CNT = 0;
   1603          		}
   1604          		
   1605          		USART_ClearITPendingBit(USART1, USART_IT_TC);
   1606          	}
   1607          
   1608            	// =======================================
   1609            	// USART1 RX Process : TILT <- MAIN Board
   1610            	// =======================================
   1611          	if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
   1612          	{
   1613          		Rx_Buf = USART_ReceiveData(USART1);
   1614          
   1615          		Main_Protocol_Data_Pasher(Rx_Buf);
   1616          		
   1617          		//Sony_Data_Pasher(Rx_Buf);
   1618          
   1619          		//if(stUSART_ERROR.RX_CNT == UART4_RX_BUF_MAX) stUSART_ERROR.RX_CNT = 0;
   1620          
   1621          		//stUSART_ERROR.RX_BUF[stUSART_ERROR.RX_CNT++] = Rx_Buf;
   1622          	}
   1623          }
   1624          
   1625          /*******************************************************************************
   1626          * Function Name  : LRF_Data_Clear
   1627          *******************************************************************************/
   1628          void LRF_Data_Clear(void)
   1629          {
   1630          	u8 i;
   1631          	
   1632          	for(i=0; i<LRF_RX_BUF_MAX; i++)
   1633          	{
   1634          		stLRF.RX_BUF[i] = 0x00;
   1635          	}
   1636          }
   1637          
   1638          /*******************************************************************************
   1639          * Function Name  : LRF_Trans_Data
   1640          *******************************************************************************/
   1641          void LRF_Trans_Data(void)
   1642          {
   1643          	u8 i;
   1644          
   1645          	if(stBYPASS.TX_FLAG == 0x00)
   1646          	{
   1647          		for(i=0; i<LRF_RX_BUF_MAX; i++)
   1648          		{
   1649          			stUSART1.TX_BUF[i] = stLRF.RX_BUF[i];
   1650          		}
   1651          
   1652          		stUSART1.TX_CNT = 0;
   1653          		stUSART1.TX_MAX = 21;
   1654          		
   1655          		USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   1656          	}
   1657          	
   1658          }
   1659          
   1660          /************************************************************************************
   1661          * Function Name  : LRF_Data_Pasher
   1662          * Description    : This function handles USART2 interrupt request.
   1663          * Input           : LRF - PA10 USART2_RX
   1664          * Output         : LRF - PA9 USART2_TX
   1665          -------------------------------------------------------------------------------------
   1666          * LRF 출력데이터 예제
   1667          [00]	[01]	[02]	[03]	[04]	[05]	[06]	[07]	[08]	[09]	[10]	[11]	[12]	[13]	[14]	[15]	[16]	[17]	[18]	[19]	[20]
   1668          44	4D	20	31	20	30	30	30	38	2E	36	20	20	39	39	39	20	33	31	0D	0A
   1669          D	M		1		0	0	0	8	.	6			9	9	9		3	1		
   1670          *************************************************************************************/
   1671          void LRF_Data_Pasher(u8 u_Data)
   1672          {
   1673          	// LRF <-> TILT
   1674          	switch(stDIP.MODE2)
   1675          	{
   1676          		case LRF_MODE:
   1677          
   1678          			// Data Compare Check
   1679          			if(stLRF.RX_CNT == 0x14)
   1680          			{
   1681          				if((stLRF.RX_BUF[0] == LRF_BYTE_1) && (stLRF.RX_BUF[1] == LRF_BYTE_2) && (stLRF.RX_BUF[19] == LRF_BYTE_END))
   1682          				{
   1683          					LRF_Trans_Data();
   1684          				}
   1685          
   1686          				LRF_Data_Clear();
   1687          				stLRF.RX_CNT = 0;
   1688          				stLRF.RX_END_FLAG = 0x01;
   1689          			}
   1690          
   1691          			// Data Save
   1692          			if(stLRF.RX_CNT >= 0x02)
   1693          			{
   1694          				stLRF.RX_BUF[stLRF.RX_CNT] = u_Data;
   1695          				stLRF.RX_CNT++;
   1696          			}
   1697          
   1698          			if(stLRF.RX_END_FLAG == 0x00)
   1699          			{
   1700          				// Second Data Check
   1701          				if((u_Data == LRF_BYTE_2) && (stLRF.RX_CNT == 1))
   1702          				{
   1703          					stLRF.RX_BUF[1] = LRF_BYTE_2;
   1704          					stLRF.RX_CNT++;
   1705          				}			
   1706          
   1707          				// First Data Check
   1708          				if((u_Data == LRF_BYTE_1) && (stLRF.RX_CNT == 0))
   1709          				{
   1710          					stLRF.RX_BUF[0] = LRF_BYTE_1;
   1711          					stLRF.RX_CNT++;
   1712          				}
   1713          			}
   1714          			else
   1715          			{
   1716          				stLRF.RX_END_FLAG = 0x00;
   1717          			}
   1718          
   1719          			if(stLRF.RX_CNT >= LRF_RX_BUF_MAX) 
   1720          			{
   1721          				stLRF.RX_CNT = 0;
   1722          				LRF_Data_Clear();
   1723          			}
   1724          			
   1725          			break;
   1726          	}
   1727          }
   1728          
   1729          /*******************************************************************************
   1730          * Function Name  : USART2_IRQHandler
   1731          * Description    : This function handles USART2 interrupt request.
   1732          * Input           : MDIN - PA3 USART2_RX
   1733          * Output         : MDIN - PA2 USART2_TX
   1734          *******************************************************************************/
   1735          void USART2_IRQHandler(void)
   1736          {
   1737          	u8 Rx_Buf = 0x00, Tx_Buf = 0x00;	
   1738          
   1739          	// =======================================
   1740          	// USART2 TX Process 
   1741          	// =======================================
   1742          	if (USART_GetITStatus(USART2, USART_IT_TC) != RESET)
   1743          	{
   1744          
   1745          		if(stUSART2.TX_CNT < stUSART2.TX_MAX)
   1746          		{
   1747          			Tx_Buf = stUSART2.TX_BUF[stUSART2.TX_CNT];
   1748          			stUSART2.TX_CNT++;				
   1749          
   1750          			USART_SendData(USART2, Tx_Buf);
   1751          		}
   1752          		else
   1753          		{
   1754          			stUSART2.TX_CNT = 0x00;
   1755          			stUSART2.TX_MAX = 0x00;
   1756          		}
   1757          
   1758          		USART_ClearITPendingBit(USART2, USART_IT_TC);
   1759          
   1760          	}
   1761          
   1762          	// =======================================
   1763          	// USART2 RX Process
   1764          	// =======================================
   1765          	if (USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)
   1766          	{
   1767          		Rx_Buf = USART_ReceiveData(USART2);
   1768          	}     
   1769          }
   1770          
   1771          /*******************************************************************************
   1772          * Function Name  : USART3_IRQHandler
   1773          * Description    : This function handles USART1 interrupt request.
   1774          * Input           : Camera - PB11 USART3_RX
   1775          * Output         : Camera - PB10 USART3_TX
   1776          *******************************************************************************/
   1777          void USART3_IRQHandler(void)
   1778          {
   1779          	u8 Rx_Buf = 0x00, Tx_Buf = 0x00;	
   1780          
   1781            	// =======================================
   1782            	// USART3 TX Process 
   1783            	// =======================================
   1784          	if (USART_GetITStatus(USART3, USART_IT_TC) != RESET)
   1785          	{ 
   1786          		USART_SendData(USART3, Tx_Buf);
   1787          		
   1788          		USART_ClearITPendingBit(USART3, USART_IT_TC);
   1789          	}
   1790          	
   1791            	// =======================================
   1792            	// USART3 RX Process
   1793            	// =======================================
   1794          	if (USART_GetITStatus(USART3, USART_IT_RXNE) != RESET)
   1795          	{
   1796          		Rx_Buf = USART_ReceiveData(USART3);
   1797          	}
   1798          
   1799          }
   1800          
   1801          /*******************************************************************************
   1802          * Function Name  : SONY_Data_Clear
   1803          *******************************************************************************/
   1804          void SONY_Data_Clear(void)
   1805          {
   1806          	u8 i;
   1807          	
   1808          	for(i=0; i<SONY_RX_BUF_MAX; i++)
   1809          	{
   1810          		stSONY.RX_BUF[i] = 0x00;
   1811          	}
   1812          }
   1813          
   1814          /*******************************************************************************
   1815          * Function Name  : TSM_Data_Pasher
   1816          *******************************************************************************/
   1817          void TSM_Data_Pasher(u8 u_Buf)
   1818          {
   1819          	u8 i = 0;
   1820          	u8 u_Data_P1 = 0x00, u_Data_P2 = 0x00;
   1821          	u16 u16_Convert_Data = 0x0000;
   1822          	u8 u_Convert_Data  = 0x00;	
   1823          
   1824          	if(stUART4.RX_ENABLE == 0x01)
   1825          	{
   1826          		stUART4.RX_BUF[stUART4.RX_CNT++] = u_Buf;
   1827          
   1828          		if(stUART4.RX_BUF_MAX == 0x00)
   1829          		{
   1830          			switch(stUART4.RX_BUF[1])
   1831          			{
   1832          				case TSM_CALL_ALL_TEMPERATURE:
   1833          					stUART4.RX_BUF_MAX = 0x23;
   1834          					break;
   1835          
   1836          				case TSM_CALL_FIRMWARE_VERSION:
   1837          					stUART4.RX_BUF_MAX = 0x08;
   1838          					break;
   1839          
   1840          				case TCM_COOLER_RUNTIME_INQ:
   1841          					if(stINFO.THERMAL_MODEL == TCM_640)
   1842          					{
   1843          						stUART4.RX_BUF_MAX = 0x07;
   1844          					}
   1845          					break;
   1846          
   1847          				default:
   1848          					stUART4.RX_BUF_MAX = 0x06;
   1849          					break;
   1850          			}
   1851          		}
   1852          
   1853          		// Rx Data Check & Initialization
   1854          		if((stUART4.RX_CNT == stUART4.RX_BUF_MAX) && (u_Buf == 0xAF))
   1855          		{
   1856          			switch(stUART4.RX_BUF_MAX)
   1857          			{
   1858          				case 0x06:
   1859          
   1860          					switch(stUART4.RX_REQUEST_CMD)
   1861          					{
   1862          						case TSM_CALL_MODULE_STATUS:
   1863          
   1864          							if(stUART4.RX_BUF[1] == TSM_CALL_MODULE_STATUS)
   1865          							{
   1866          								u_Data_P1 = stUART4.RX_BUF[2];
   1867          
   1868          								if(u_Data_P1) 
   1869          								{
   1870          									stTSM.MODULE_ENABLE = 0x01;
   1871          								}
   1872          								
   1873          								stTSM.MODULE_STATUS = u_Data_P1;
   1874          								stINFO.MODULE_TYPE = TSM_MODULE;
   1875          
   1876          								stUART4.RX_REQUEST_CMD = 0x00;
   1877          							}
   1878          								
   1879          							break;
   1880          							
   1881          						case TSM_CALL_DIGITAL_ZOOM_POSITION:
   1882          
   1883          							if(stUART4.RX_BUF[1] == TSM_CALL_DIGITAL_ZOOM_POSITION)
   1884          							{
   1885          								u_Data_P1 = stUART4.RX_BUF[4];
   1886          								u16_Convert_Data |= u_Data_P1;
   1887          								stTSM.ZOOM_DATA = u16_Convert_Data;
   1888          
   1889          								stTSM.ZOOM_CNT = stTSM.ZOOM_DATA;
   1890          
   1891          								stUART4.RX_REQUEST_CMD = 0x00;
   1892          							}
   1893          
   1894          							break;
   1895          
   1896          						case TSM_CALL_OPTICAL_ZOOM_POSITION:
   1897          							break;
   1898          
   1899          						case TSM_CALL_TOTAL_ZOOM_POSITION:
   1900          							
   1901          							if(stUART4.RX_BUF[1] == TSM_CALL_TOTAL_ZOOM_POSITION)
   1902          							{
   1903          								u_Data_P1 = stUART4.RX_BUF[2];
   1904          								u_Data_P2 = stUART4.RX_BUF[3];
   1905          
   1906          								u16_Convert_Data = u_Data_P1 << 8;
   1907          								u16_Convert_Data |= u_Data_P2;
   1908          
   1909          								stTSM.ZOOM_CNT = u16_Convert_Data;
   1910          
   1911          								stUART4.RX_REQUEST_CMD = 0x00;
   1912          								stUART4.RX_REQUEST_COMPLETE = TSM_CALL_TOTAL_ZOOM_POSITION;
   1913          							}
   1914          							
   1915          							break;
   1916          
   1917          						case TSM_CALL_FOCUS_POSITION:
   1918          
   1919          							if(stUART4.RX_BUF[1] == TSM_CALL_FOCUS_POSITION)
   1920          							{
   1921          								u_Data_P1 = stUART4.RX_BUF[2];
   1922          								u_Data_P2 = stUART4.RX_BUF[3];
   1923          
   1924          								u16_Convert_Data = u_Data_P1 << 8;
   1925          								u16_Convert_Data |= u_Data_P2;
   1926          
   1927          								stTSM.FOCUS_CNT = u16_Convert_Data;
   1928          
   1929          								stUART4.RX_REQUEST_CMD = 0x00;
   1930          								stUART4.RX_REQUEST_COMPLETE = TSM_CALL_FOCUS_POSITION;								
   1931          							}
   1932          							
   1933          							break;
   1934          
   1935          						case TSM_CALL_PRODUCT_IDENTIFICATION:
   1936          
   1937          							if(stUART4.RX_BUF[1] == TSM_CALL_PRODUCT_IDENTIFICATION)
   1938          							{
   1939          								// Camera Information Data Check							
   1940          								stINFO.THERMAL_MODEL = stUART4.RX_BUF[2];
   1941          								stINFO.THERMAL_LENS = stUART4.RX_BUF[4];
   1942          								
   1943          								stUART4.RX_REQUEST_CMD = 0x00;
   1944          							}
   1945          							
   1946          							break;
   1947          
   1948          						case TSM_CALL_CAMERA_INFORMATION:
   1949          
   1950          							if(stUART4.RX_BUF[1] == TSM_CALL_CAMERA_INFORMATION)
   1951          							{
   1952          								// Camera Information Data Check
   1953          								stINFO.THERMAL_VER_HIGH = stUART4.RX_BUF[3];
   1954          								stINFO.THERMAL_VER_LOW = stUART4.RX_BUF[4];
   1955          								
   1956          								stUART4.RX_REQUEST_CMD = 0x00;
   1957          							}
   1958          							
   1959          							break;
   1960          
   1961          						case TSM_CALL_FPGA_VERSION:
   1962          
   1963          							if(stUART4.RX_BUF[1] == TSM_CALL_FPGA_VERSION)
   1964          							{
   1965          								stINFO.FPGA_VERSION_HIGH = stUART4.RX_BUF[2];
   1966          								stINFO.FPGA_VERSION_LOW = stUART4.RX_BUF[3];
   1967          
   1968          								stUART4.RX_REQUEST_CMD = 0x00;
   1969          							}
   1970          							
   1971          							break;
   1972          							
   1973          						case TSM_CALL_TEMPERATURE_MODE:
   1974          
   1975          							if(stUART4.RX_BUF[1] == TSM_CALL_TEMPERATURE_MODE)
   1976          							{
   1977          								// Camera Information Data Check
   1978          								stINFO.THERMAL_TEMP_MODE = stUART4.RX_BUF[2];
   1979          								
   1980          								stUART4.RX_REQUEST_CMD = 0x00;
   1981          							}
   1982          							
   1983          							break;
   1984          
   1985          						case TCM_TOTAL_ZOOM_POSITION_INQ:
   1986          
   1987          							if(stUART4.RX_BUF[1] == TCM_TOTAL_ZOOM_POSITION_INQ)
   1988          							{
   1989          								u_Data_P1 = stUART4.RX_BUF[2];
   1990          								u_Data_P2 = stUART4.RX_BUF[3];
   1991          
   1992          								u16_Convert_Data = u_Data_P1 << 8;
   1993          								u16_Convert_Data |= u_Data_P2;
   1994          
   1995          								stTSM.ZOOM_DATA = u16_Convert_Data;
   1996          
   1997          								stTSM.ZOOM_CNT = stTSM.ZOOM_DATA;
   1998          
   1999          								stUART4.RX_REQUEST_CMD = 0x00;
   2000          							}
   2001          							
   2002          							break;
   2003          
   2004          						case TCM_GET_FW_UPDATE_INQ:
   2005          
   2006          							if(stUART4.RX_BUF[1] == TCM_GET_FW_UPDATE_INQ)
   2007          							{
   2008          								stINFO.THERMAL_YEAR = stUART4.RX_BUF[2];
   2009          								stINFO.THERMAL_MONTH = stUART4.RX_BUF[3];
   2010          								stINFO.THERMAL_DAY = stUART4.RX_BUF[4];
   2011          									
   2012          								stUART4.RX_REQUEST_CMD = 0x00;
   2013          							}
   2014          							
   2015          							break;
   2016          
   2017          						case TCM_GET_ENGINE_VERSION:
   2018          
   2019          							if(stUART4.RX_BUF[1] == TCM_GET_ENGINE_VERSION)
   2020          							{
   2021          								stINFO.THERMAL_ENGINE_VER_HW = stUART4.RX_BUF[2];
   2022          								stINFO.THERMAL_ENGINE_VER_FW = stUART4.RX_BUF[3];
   2023          
   2024          								stUART4.RX_REQUEST_CMD = 0x00;
   2025          							}
   2026          							
   2027          							break;		
   2028          
   2029          						case TCM_FOCUS_POSITION_INQ:
   2030          
   2031          							if(stUART4.RX_BUF[1] == TCM_FOCUS_POSITION_INQ)
   2032          							{
   2033          								u_Data_P1 = stUART4.RX_BUF[2];
   2034          								u_Data_P2 = stUART4.RX_BUF[3];
   2035          
   2036          								u16_Convert_Data = u_Data_P1 << 8;
   2037          								u16_Convert_Data |= u_Data_P2;
   2038          
   2039          								stTSM.FOCUS_CNT = u16_Convert_Data;
   2040          
   2041          								stUART4.RX_REQUEST_CMD = 0x00;
   2042          							}
   2043          
   2044          							break;	
   2045          
   2046          						default:
   2047          							break;
   2048          					}
   2049          						
   2050          					break;
   2051          
   2052          				case 0x07:
   2053          					switch(stUART4.RX_REQUEST_CMD)
   2054          					{
   2055          						case TCM_COOLER_RUNTIME_INQ:
   2056          
   2057          								stINFO.THERMAL_ENGINE_TIME_DAY= 0x0000;
   2058          								stINFO.THERMAL_ENGINE_TIME_DAY |= (stUART4.RX_BUF[2]<<8);
   2059          								stINFO.THERMAL_ENGINE_TIME_DAY |= (stUART4.RX_BUF[3]&0xFF);
   2060          
   2061          								stINFO.THERMAL_ENGINE_TIME_HOUR = 0x0000;
   2062          								stINFO.THERMAL_ENGINE_TIME_HOUR |= (stUART4.RX_BUF[4]<<8);
   2063          								stINFO.THERMAL_ENGINE_TIME_HOUR |= (stUART4.RX_BUF[5]&0xFF);
   2064          
   2065          								stINFO.THERMAL_ENGINE_DAY_HIGH = stUART4.RX_BUF[2];
   2066          								stINFO.THERMAL_ENGINE_DAY_LOW = stUART4.RX_BUF[3];
   2067          								stINFO.THERMAL_ENGINE_HOUR_HIGH = stUART4.RX_BUF[4];
   2068          								stINFO.THERMAL_ENGINE_HOUR_LOW = stUART4.RX_BUF[5];								
   2069          								
   2070          								stINFO.TCM640_ENGINE_RUNTIME_COMPLETE = TRUE;
   2071          								
   2072          								stUART4.RX_REQUEST_CMD = 0x00;	
   2073          
   2074          							break;
   2075          					}
   2076          					break;
   2077          					
   2078          				case 0x08:
   2079          					
   2080          					switch(stUART4.RX_REQUEST_CMD)
   2081          					{
   2082          						case TSM_CALL_FIRMWARE_VERSION:
   2083          
   2084          							if(stUART4.RX_BUF[1] == TSM_CALL_FIRMWARE_VERSION)
   2085          							{
   2086          								// Camera Information Data Check
   2087          								stINFO.THERMAL_DAY = stUART4.RX_BUF[4];
   2088          								stINFO.THERMAL_MONTH = stUART4.RX_BUF[5];
   2089          								stINFO.THERMAL_YEAR = stUART4.RX_BUF[6];
   2090          								
   2091          								stUART4.RX_REQUEST_CMD = 0x00;
   2092          							}
   2093          							
   2094          							break;
   2095          
   2096          						default:
   2097          							break;
   2098          					}
   2099          							
   2100          					break;
   2101          					
   2102          				case 0x23:
   2103          					
   2104          					//stTEMP.TEMPERATURE_READ_COMPLETE = 0x01;	// 온도 체크 데이터 수신 완료.
   2105          					
   2106          					break;
   2107          
   2108          				default:
   2109          					break;
   2110          			}
   2111          		
   2112          			for(i=0;i<stUART4.RX_BUF_MAX;i++)
   2113          			{
   2114          				//stTEMP.RX_BUF[i] = stUART4.RX_BUF[i];
   2115          				stUART4.RX_BUF[i] = 0x00;
   2116          			}
   2117          
   2118          			stUART4.RX_ENABLE = 0x00;
   2119          			stUART4.RX_CNT = 0x00;
   2120          			stUART4.RX_BUF_MAX = 0x00;
   2121          			stUART4.RX_PARITY = 0x01;
   2122          			
   2123          		}
   2124          		else if((stUART4.RX_CNT == stUART4.RX_BUF_MAX) && (u_Buf != 0xAF))
   2125          		{
   2126          			for(i=0;i<stUART4.RX_CNT;i++)
   2127          			{
   2128          				stUART4.RX_BUF[i] = 0x00;
   2129          			}
   2130          
   2131          			stUART4.RX_ENABLE = 0x00;
   2132          			stUART4.RX_CNT = 0x00;
   2133          			stUART4.RX_BUF_MAX = 0x00;
   2134          			stUART4.RX_REQUEST_ERROR = 0x01;			
   2135          		}
   2136          	}
   2137          
   2138          	if((stUART4.RX_ENABLE == 0x00) && (u_Buf == 0xA0))
   2139          	{
   2140          		stUART4.RX_BUF[0] = u_Buf;
   2141          		stUART4.RX_CNT++;
   2142          		stUART4.RX_ENABLE = 0x01;
   2143          	}
   2144          }
   2145          
   2146          /*******************************************************************************
   2147          * Function Name  : Rx_Sony_Inquiry_Command
   2148          *******************************************************************************/
   2149          void SONY_Data_Pasher(u8 u_buf)
   2150          {
   2151          	u16 u_CZoomData = 0x0000, u_CFocusData = 0x0000;
   2152          
   2153          	// Data Save
   2154          	if(stSONY.RX_CNT >= 0x02)
   2155          	{
   2156          		stSONY.RX_BUF[stSONY.RX_CNT] = u_buf;
   2157          		stSONY.RX_CNT++;
   2158          	}
   2159          
   2160          	if(stSONY.RX_CNT == 0x04)
   2161          	{
   2162          		if((stSONY.RX_BUF[0] == SONY_BYTE_1) && (stSONY.RX_BUF[1] == SONY_BYTE_2) && (stSONY.RX_BUF[3] == SONY_BYTE_END))
   2163          		{
   2164          			switch(stUART4.RX_REQUEST_CMD)
   2165          			{
   2166          				case SONY_POWER_INQ:
   2167          
   2168          					stSONY.MODULE_STATUS = stSONY.RX_BUF[2];
   2169          
   2170          					switch(stSONY.MODULE_STATUS)
   2171          					{
   2172          						case 0x02:
   2173          							stSONY.MODULE_ENABLE = 1;
   2174          							break;
   2175          
   2176          						case 0x03:
   2177          							stSONY.MODULE_ENABLE = 0;
   2178          							break;
   2179          
   2180          						default:
   2181          							break;
   2182          					}
   2183          
   2184          					stINFO.MODULE_TYPE = SONY_MODULE;
   2185          					
   2186          					break;
   2187          
   2188          				default:
   2189          					break;
   2190          			}
   2191          
   2192          			SONY_Data_Clear();
   2193          			
   2194          			stSONY.RX_CNT = 0;
   2195          			stSONY.RX_END_FLAG = 0x01;	
   2196          		}
   2197          	}
   2198          
   2199          	// Data Compare Check
   2200          	if(stSONY.RX_CNT == 0x07)
   2201          	{
   2202          		if((stSONY.RX_BUF[0] == SONY_BYTE_1) && (stSONY.RX_BUF[1] == SONY_BYTE_2) && (stSONY.RX_BUF[6] == SONY_BYTE_END))
   2203          		{
   2204          			switch(stUART4.RX_REQUEST_CMD)
   2205          			{
   2206          				case SONY_CALL_ZOOM_POSITION:
   2207          					
   2208          					u_CZoomData = stSONY.RX_BUF[2];
   2209          					stSONY.ZOOM_CNT = u_CZoomData << 12;
   2210          					u_CZoomData = stSONY.RX_BUF[3];
   2211          					stSONY.ZOOM_CNT |= u_CZoomData << 8;
   2212          					u_CZoomData = stSONY.RX_BUF[4];
   2213          					stSONY.ZOOM_CNT |= u_CZoomData << 4;
   2214          					u_CZoomData = stSONY.RX_BUF[5];
   2215          					stSONY.ZOOM_CNT |= u_CZoomData;
   2216          
   2217          					if(stSONY.RX_BUF[6] == 0x00) 
   2218          					{
   2219          						stUART4.RX_REQUEST_ERROR = 0x01;
   2220          					}
   2221          					else 
   2222          					{
   2223          						stUART4.RX_REQUEST_CMD = 0x00;
   2224          						stUART4.RX_REQUEST_COMPLETE = SONY_CALL_ZOOM_POSITION;
   2225          					}
   2226          					
   2227          					break;
   2228          
   2229          				case SONY_CALL_FOCUS_POSITION:
   2230          					
   2231          					u_CFocusData = stSONY.RX_BUF[2];
   2232          					stSONY.FOCUS_CNT = u_CFocusData << 12;
   2233          					u_CFocusData = stSONY.RX_BUF[3];
   2234          					stSONY.FOCUS_CNT |= u_CFocusData << 8;
   2235          					u_CFocusData = stSONY.RX_BUF[4];
   2236          					stSONY.FOCUS_CNT |= u_CFocusData << 4;
   2237          					u_CFocusData = stSONY.RX_BUF[5];
   2238          					stSONY.FOCUS_CNT |= u_CFocusData;
   2239          
   2240          					if(stSONY.RX_BUF[6] == 0x00) 
   2241          					{
   2242          						stUART4.RX_REQUEST_ERROR = 0x01;
   2243          					}
   2244          					else 
   2245          					{
   2246          						stUART4.RX_REQUEST_COMPLETE = SONY_CALL_FOCUS_POSITION;
   2247          						stUART4.RX_REQUEST_CMD = 0x00;
   2248          					}
   2249          
   2250          					break;
   2251          
   2252          				default:
   2253          
   2254          					stUART4.RX_ENABLE = 0x00;
   2255          					if(stUART4.RX_REQUEST_ERROR != 0x00) stUART4.RX_REQUEST_ERROR = 0x00;
   2256          					
   2257          					break;
   2258          			}
   2259          
   2260          			SONY_Data_Clear();
   2261          			
   2262          			stSONY.RX_CNT = 0;
   2263          			stSONY.RX_END_FLAG = 0x01;
   2264          
   2265          		}
   2266          	}
   2267          	
   2268          	if(stSONY.RX_END_FLAG == 0x00)
   2269          	{
   2270          		// Second Data Check
   2271          		if((u_buf == SONY_BYTE_2) && (stSONY.RX_CNT == 1))
   2272          		{
   2273          			stSONY.RX_BUF[1] = SONY_BYTE_2;
   2274          			stSONY.RX_CNT++;
   2275          		}
   2276          		else if((u_buf != SONY_BYTE_2) && (stSONY.RX_CNT == 1))
   2277          		{
   2278          			stSONY.RX_BUF[0] = 0x00;
   2279          			stSONY.RX_CNT = 0;
   2280          		}
   2281          
   2282          		// First Data Check
   2283          		if((u_buf == SONY_BYTE_1) && (stSONY.RX_CNT == 0))
   2284          		{
   2285          			stSONY.RX_BUF[0] = SONY_BYTE_1;
   2286          			stSONY.RX_CNT++;
   2287          		}
   2288          	}
   2289          	else
   2290          	{
   2291          		stSONY.RX_END_FLAG = 0x00;
   2292          	}
   2293          
   2294          	if(stSONY.RX_CNT >= SONY_RX_BUF_MAX)
   2295          	{
   2296          		stSONY.RX_CNT = 0;
   2297          		SONY_Data_Clear();
   2298          		
   2299          	}
   2300          }
   2301          
   2302          // ============================================================================
   2303          // USART3 : UART4 Data Pasher (TSM)
   2304          // ============================================================================
   2305          void UART4_Data_Pasher(u8 u_Buf, u8 u_Index)
   2306          {
   2307          	if((u_Index == INDEX_NON) || (u_Index == INDEX_THERMAL))
   2308          	{
   2309          		TSM_Data_Pasher(u_Buf);
   2310          	}
   2311          
   2312          	if((u_Index == INDEX_NON) || (u_Index == INDEX_COLOR))
   2313          	{
   2314          		SONY_Data_Pasher(u_Buf);
   2315          	}
   2316          }
   2317          
   2318          /*******************************************************************************
   2319          * Function Name  : UART4_IRQHandler
   2320          * Description    : This function handles UART4 interrupt request.
   2321          * Input           : - PC11 UART4_RX
   2322          * Output         : - PC10 UART4_TX
   2323          *******************************************************************************/
   2324          void UART4_IRQHandler(void)
   2325          {
   2326          	u8 Rx_Buf = 0x00, Tx_Buf = 0x00;	
   2327          
   2328            	// =======================================
   2329            	// USART4 TX Process 
   2330            	// =======================================
   2331          	if (USART_GetITStatus(UART4, USART_IT_TC) != RESET)
   2332          	{
   2333          		if(stUART4.TX_CNT < stUART4.TX_MAX)
   2334          		{
   2335          			Tx_Buf = stUART4.TX_BUF[stUART4.TX_CNT];
   2336          			stUART4.TX_CNT++;				
   2337          
   2338          			USART_SendData(UART4, Tx_Buf);
   2339          		}
   2340          		else
   2341          		{
   2342          			stUART4.TX_CNT = 0x00;
   2343          			stUART4.TX_MAX = 0x00;
   2344          		}
   2345          
   2346          		USART_ClearITPendingBit(UART4, USART_IT_TC);
   2347          	}
   2348          	
   2349            	// =======================================
   2350            	// USART4 RX Process
   2351            	// =======================================
   2352          
   2353          	if (USART_GetITStatus(UART4, USART_IT_RXNE) != RESET)
   2354          	{
   2355          		Rx_Buf = USART_ReceiveData(UART4);
   2356          
   2357          		UART4_Data_Pasher(Rx_Buf, stINFO.MODULE_TYPE);
   2358          	}
   2359          }
   2360          
   2361          /*******************************************************************************
   2362          * Function Name  : Rx_Second_Comm_Check
   2363          *******************************************************************************/
   2364          void Rx_Pelco_Address_Check(u8 u_buf)
   2365          {
   2366          	stUART5.RX_BUF[1] =  u_buf;
   2367          	stUART5.RX_BUF_INDEX++;
   2368          	stUART5.RX_BUF_LENGTH = 0x01;
   2369          }
   2370          
   2371          /*******************************************************************************
   2372          * Function Name  : Rx_Pelco_Data_Check
   2373          *******************************************************************************/
   2374          void Rx_Pelco_Data_Check(void)
   2375          {
   2376          	u8 i = 0x00, u_Checksum = 0x00;
   2377          
   2378          	for(i=1; i<6; i++)
   2379          	{
   2380          		u_Checksum += stUART5.RX_BUF[i];
   2381          	}
   2382          	
   2383          	if((stUART5.RX_BUF[6] & 0xFF) == u_Checksum)		// CheckSum Check
   2384          	{
   2385          		stUART5.RX_PARITY = 0x01;	// 정상 데이터 수신 (0x00: Nondata(수신대기), 0x01: 정상데이터, 0xFF, 비정상 데이터)
   2386          		stUART5.RX_PARITY_CNT++;
   2387          		
   2388          		// DEBUG 데이터 체크 ======================================================/
   2389          		//stERROR.PARITY_CNT_CHECK++;
   2390          		//if(stERROR.PARITY_CNT_CHECK == 0x01) stERROR.TIMER_CHECK_FLAG = 0x01;
   2391          		//if(stERROR.PARITY_CNT_CHECK == 0x02) stERROR.TIMER_CHECK_FLAG = 0x00;
   2392          		// DEBUG 데이터 체크 ===================================================END/
   2393          		//if(stUSART1.RX_PRIORITY == 0x00) stUSART1.RX_PRIORITY = 0x01;
   2394          		
   2395          		stUART5.RX_BUF_INDEX = 0x00;	// Index Init
   2396          		//stUSART1.RX_BUF[stUSART1.RX_BUF_INDEX] = stUSART1.RX_PRIORITY++;
   2397          	}
   2398          	else
   2399          	{
   2400          		stUART5.RX_PARITY = 0xFF;	// 비정상 데이터 수신 (0x00: Nondata(수신대기), 0x01: 정상데이터, 0xFF, 비정상 데이터)
   2401          		stUART5.RX_ERROR_CNT++;
   2402          	}			
   2403          }
   2404          
   2405          /*******************************************************************************
   2406          * Function Name  : Rx_Second_Comm_Check
   2407          *******************************************************************************/
   2408          void Rx_Second_Comm_Check(u8 u_buf, u8 u_andbyte)
   2409          {
   2410          	if(u_buf == u_andbyte)
   2411          	{
   2412          		stUART5.RX_BUF[1] =  u_buf;
   2413          		stUART5.RX_BUF_INDEX++;
   2414          		stUART5.RX_BUF_LENGTH = 0x01;
   2415          	}
   2416          	else
   2417          	{
   2418          		stUART5.RX_BUF_INDEX = 0x00;					// Index Clear
   2419          		stUART5.RX_BUF[0] = 0x00;						// Buffer Clear
   2420          		stUART5.RX_ENABLE = 0x00;						// Command Check Byte Clear
   2421          	}	
   2422          }
   2423          
   2424          /*******************************************************************************
   2425          * Function Name  : Rx_Usart_Comm_Handling
   2426          *******************************************************************************/
   2427          void Rx_Usart_Comm_Handling(u8 u_sync, u8 u_buf)	// u_port : Uart Port, u_sync : Sync Byte Check (0 : First Byte, 1 : Second Byte)
   2428          {
   2429          	// 첫번째 바이트 체크 (Sync Byte Check)
   2430          	if(u_sync == Rx_SYNC_BYTE)	
   2431          	{
   2432          		stUART5.RX_BUF_INDEX = 0x00;	// Index Init
   2433          		stUART5.RX_BUF[stUART5.RX_BUF_INDEX] = u_buf;
   2434          		stUART5.RX_BUF_INDEX++;
   2435          		
   2436          		#if(ERROR_CHECK_BUF)
   2437          		stERROR.RX_BUF[stERROR.RX_CNT++] = u_buf;
   2438          		if(stERROR.RX_CNT >= ERROR_DATA_MAX) stERROR.RX_CNT = 0;
   2439          		#endif
   2440          	}
   2441          
   2442          	// 두번째 바이트 체크 (Sync & Byte Check)
   2443          	if(u_sync == Rx_SYNC_AND_BYTE)
   2444          	{
   2445          		#if(ERROR_CHECK_BUF)	
   2446          		stERROR.RX_BUF[stERROR.RX_CNT++] = u_buf;
   2447          		if(stERROR.RX_CNT >= ERROR_DATA_MAX) stERROR.RX_CNT = 0;
   2448          		#endif		
   2449          		
   2450          		// 두번째 명령어 체크 (Sync & Byte Check)
   2451          		if(stUART5.RX_BUF_INDEX == 0x01)
   2452          		{
   2453          			switch(stUART5.RX_ENABLE)
   2454          			{
   2455          				case IP_SONY_SECOND_BYTE:
   2456          					Rx_Second_Comm_Check(u_buf, IP_SONY_SECOND_BYTE);
   2457          					break;
   2458          
   2459          				case IP_TSM_SECOND_BYTE:
   2460          					Rx_Second_Comm_Check(u_buf, IP_TSM_SECOND_BYTE);
   2461          					break;
   2462          
   2463          				case IP_DRS_SECOND_BYTE:
   2464          					Rx_Second_Comm_Check(u_buf, IP_DRS_SECOND_BYTE);
   2465          					break;
   2466          
   2467          				case IP_TCM_SECOND_BYTE:
   2468          					Rx_Second_Comm_Check(u_buf, IP_TCM_SECOND_BYTE);
   2469          					break;
   2470          					
   2471          				case IP_PTZ_SECOND_BYTE:
   2472          					Rx_Second_Comm_Check(u_buf, IP_PTZ_SECOND_BYTE);
   2473          					break;
   2474          
   2475          				case IP_DATA_SECOND_BYTE:
   2476          					Rx_Second_Comm_Check(u_buf, IP_DATA_SECOND_BYTE);
   2477          					break;	
   2478          
   2479          				case IP_OPTION_SECOND_BYTE:
   2480          					Rx_Second_Comm_Check(u_buf, IP_OPTION_SECOND_BYTE);
   2481          					break;		
   2482          
   2483          				case IP_PELCO_CHK_BYTE:
   2484          					Rx_Pelco_Address_Check(u_buf);
   2485          					break;
   2486          
   2487          				default:
   2488          					break;
   2489          			}
   2490          		}	
   2491          	}
   2492          
   2493          	// 세번째 바이트 체크 (Data Length)
   2494          	if(u_sync == Rx_LENGTH_BYTE)
   2495          	{
   2496          		#if(ERROR_CHECK_BUF)	
   2497          		stERROR.RX_BUF[stERROR.RX_CNT++] = u_buf;
   2498          		if(stERROR.RX_CNT >= ERROR_DATA_MAX) stERROR.RX_CNT = 0;
   2499          		#endif
   2500          		
   2501          		if(stUART5.RX_ENABLE == IP_PELCO_CHK_BYTE)
   2502          		{
   2503          			// PELCO-D Command 예외처리
   2504          			if(stUART5.RX_BUF_INDEX == 0x02)
   2505          			{
   2506          				stUART5.RX_BUF_LENGTH = 0x02;
   2507          				stUART5.RX_BUF_MAX = stUART5.RX_BUF_LENGTH + 5;
   2508          				
   2509          				stUART5.RX_BUF[2] =  u_buf;
   2510          				
   2511          				stUART5.RX_BUF_INDEX++;
   2512          			}					
   2513          		}
   2514          		else
   2515          		{
   2516          			// 세번째 데이터 길이 체크 (Sync & Byte Check)
   2517          			if(stUART5.RX_BUF_INDEX == 0x02)
   2518          			{
   2519          				stUART5.RX_BUF_LENGTH = u_buf;
   2520          				stUART5.RX_BUF_MAX = stUART5.RX_BUF_LENGTH + 5;
   2521          				
   2522          				stUART5.RX_BUF[2] =  u_buf;
   2523          				
   2524          				stUART5.RX_BUF_INDEX++;
   2525          			}
   2526          		}
   2527          	}	
   2528          
   2529          	// 데이터 누적
   2530          	if(u_sync == Rx_DATA_BYTE)
   2531          	{
   2532          		#if(ERROR_CHECK_BUF)
   2533          		stERROR.RX_BUF[stERROR.RX_CNT++] = u_buf;
   2534          		if(stERROR.RX_CNT >= ERROR_DATA_MAX) stERROR.RX_CNT = 0;
   2535          		#endif		
   2536          		
   2537          		stUART5.RX_BUF[stUART5.RX_BUF_INDEX] = u_buf;
   2538          
   2539          		stUART5.RX_BUF_INDEX++;	
   2540          		
   2541          		if(stUART5.RX_BUF_INDEX == stUART5.RX_BUF_MAX)
   2542          		{
   2543          			// PELCO-D Command 예외처리
   2544          			if(stUART5.RX_ENABLE == IP_PELCO_CHK_BYTE)
   2545          			{
   2546          				Rx_Pelco_Data_Check();
   2547          			}
   2548          			else
   2549          			{
   2550          				if((stUART5.RX_BUF[stUART5.RX_BUF_INDEX - 1]&0x0F) == 0x0F)		// End Byte Check
   2551          				{
   2552          					stUART5.RX_PARITY = 0x01;	// 정상 데이터 수신 (0x00: Nondata(수신대기), 0x01: 정상데이터, 0xFF, 비정상 데이터)
   2553          					stUART5.RX_PARITY_CNT++;
   2554          
   2555          					// DEBUG 데이터 체크 ======================================================/
   2556          					//stERROR.PARITY_CNT_CHECK++;
   2557          					//if(stERROR.PARITY_CNT_CHECK == 0x01) stERROR.TIMER_CHECK_FLAG = 0x01;
   2558          					//if(stERROR.PARITY_CNT_CHECK == 0x02) stERROR.TIMER_CHECK_FLAG = 0x00;
   2559          					// DEBUG 데이터 체크 ===================================================END/
   2560          					
   2561          					//if(stUSART1.RX_PRIORITY == 0x00) stUSART1.RX_PRIORITY = 0x01;
   2562          					
   2563          					stUART5.RX_BUF_INDEX = 0x00;	// Index Init
   2564          					//stUSART1.RX_BUF[stUSART1.RX_BUF_INDEX] = stUSART1.RX_PRIORITY++;
   2565          				}
   2566          				else
   2567          				{
   2568          					stUART5.RX_PARITY = 0xFF;	// 비정상 데이터 수신 (0x00: Nondata(수신대기), 0x01: 정상데이터, 0xFF, 비정상 데이터)
   2569          					stUART5.RX_ERROR_CNT++;
   2570          				}
   2571          			}
   2572          			
   2573          			stUART5.RX_BUF_INDEX = 0x00;
   2574          			stUART5.RX_BUF_LENGTH = 0x00;
   2575          			
   2576          			stUART5.RX_ENABLE = 0x00;
   2577          		}
   2578          	}		
   2579          }
   2580          
   2581          /*******************************************************************************
   2582          * Function Name  : Protocol_Command_Check
   2583          * Description    : This function handles UART5 interrupt request.
   2584          * Input           : TILT <-> Thermal IP Board (- PA10 UART5_RX)
   2585          * Output         : TILT <-> Thermal IP Board (- PA9 UART5_TX)
   2586          *******************************************************************************/
   2587          void Protocol_Command_Check(u8 u_buf)
   2588          {
   2589          	u8 u_Index_Chk = 0;
   2590          
   2591          	if(stUART5.RX_ENABLE == 0x00)
   2592          	{
   2593          		// 첫번째 바이트 체크 (Sync Byte Check)
   2594          		switch(u_buf)
   2595          		{
   2596          			case IP_SONY_FIRST_BYTE:
   2597          				Rx_Usart_Comm_Handling(Rx_SYNC_BYTE, IP_SONY_FIRST_BYTE);
   2598          				stUART5.RX_ENABLE = IP_SONY_SECOND_BYTE;
   2599          				break;
   2600          
   2601          			case IP_TSM_FIRST_BYTE:
   2602          				Rx_Usart_Comm_Handling(Rx_SYNC_BYTE, IP_TSM_FIRST_BYTE);
   2603          				stUART5.RX_ENABLE = IP_TSM_SECOND_BYTE;
   2604          				break;
   2605          
   2606          			case IP_DRS_FIRST_BYTE:
   2607          				Rx_Usart_Comm_Handling(Rx_SYNC_BYTE, IP_DRS_FIRST_BYTE);
   2608          				stUART5.RX_ENABLE = IP_DRS_SECOND_BYTE;
   2609          				break;
   2610          
   2611          			case IP_TCM_FIRST_BYTE:
   2612          				Rx_Usart_Comm_Handling(Rx_SYNC_BYTE, IP_TCM_FIRST_BYTE);
   2613          				stUART5.RX_ENABLE = IP_TCM_SECOND_BYTE;
   2614          				break;
   2615          
   2616          			case IP_PTZ_FIRST_BYTE:
   2617          				Rx_Usart_Comm_Handling(Rx_SYNC_BYTE, IP_PTZ_FIRST_BYTE);
   2618          				stUART5.RX_ENABLE = IP_PTZ_SECOND_BYTE;
   2619          				break;
   2620          
   2621          			case IP_DATA_FIRST_BYTE:
   2622          				Rx_Usart_Comm_Handling(Rx_SYNC_BYTE, IP_DATA_FIRST_BYTE);
   2623          				stUART5.RX_ENABLE = IP_DATA_SECOND_BYTE;
   2624          				break;
   2625          
   2626          			case IP_OPTION_FIRST_BYTE:
   2627          				Rx_Usart_Comm_Handling(Rx_SYNC_BYTE, IP_OPTION_FIRST_BYTE);
   2628          				stUART5.RX_ENABLE = IP_OPTION_SECOND_BYTE;
   2629          				break;
   2630          
   2631          			case IP_PELCO_CHK_BYTE:
   2632          				Rx_Usart_Comm_Handling(Rx_SYNC_BYTE, IP_PELCO_CHK_BYTE);
   2633          				stUART5.RX_ENABLE = IP_PELCO_CHK_BYTE;
   2634          				break;	
   2635          
   2636          			default:
   2637          				break;
   2638          		}
   2639          	}
   2640          	else
   2641          	{
   2642          		if(stUART5.RX_BUF_LENGTH == 0x00) u_Index_Chk = Rx_SYNC_AND_BYTE;
   2643          		else 
   2644          		{
   2645          			if(stUART5.RX_BUF_INDEX >= 0x03)
   2646          			{
   2647          				u_Index_Chk = Rx_DATA_BYTE;
   2648          			}
   2649          			else
   2650          			{
   2651          				if(stUART5.RX_STATUS == 0x00)
   2652          				{
   2653          					u_Index_Chk = Rx_LENGTH_BYTE;
   2654          				}
   2655          			}
   2656          		}
   2657          
   2658          		// 두번째, 세번째 바이트 체크 (Rx_SYNC_AND_BYTE : Sync & Byte Check, Rx_LENGTH_BYTE : Length Check)
   2659          		Rx_Usart_Comm_Handling(u_Index_Chk, u_buf);
   2660          	}
   2661          }
   2662          
   2663          /*******************************************************************************
   2664          * Function Name  : UART5_IRQHandler
   2665          * Description    : This function handles UART5 interrupt request.
   2666          * Input           : IP Board - PD2 USART5_RX
   2667          * Output         : IP Board - PC12 USART5_TX
   2668          *******************************************************************************/
   2669          void UART5_IRQHandler(void)
   2670          {
   2671          	u8 Rx_Buf = 0x00, Tx_Buf = 0x00;	
   2672          
   2673            	// =======================================
   2674            	// USART5 TX Process 
   2675            	// =======================================
   2676          	if (USART_GetITStatus(UART5, USART_IT_TC) != RESET)
   2677          	{ 
   2678          
   2679          		if(stUART5.TX_CNT < stUART5.TX_MAX)
   2680          		{
   2681          			Tx_Buf = stUART5.TX_BUF[stUART5.TX_CNT];
   2682          			stUART5.TX_CNT++;				
   2683          
   2684          			USART_SendData(UART5, Tx_Buf);
   2685          		}
   2686          		else
   2687          		{
   2688          			stUART5.TX_CNT = 0x00;
   2689          			stUART5.TX_MAX = 0x00;
   2690          		}
   2691          		
   2692          		USART_ClearITPendingBit(UART5, USART_IT_TC);
   2693          	}
   2694          	
   2695            	// =======================================
   2696            	// USART5RX Process
   2697            	// =======================================
   2698          
   2699          	if (USART_GetITStatus(UART5, USART_IT_RXNE) != RESET)
   2700          	{
   2701          		Rx_Buf = USART_ReceiveData(UART5);
   2702          
   2703          		Protocol_Command_Check(Rx_Buf);
   2704          	}
   2705          }
   2706          
   2707          
   2708          /******************* (C) COPYRIGHT 2016 TBT System *****END OF FILE****/
   2709          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  ADC1_2_IRQHandler
        0  Boot_Status_Check_Parser
       16  Boot_Status_Data_Trans
             16 -> USART_SendData
        0  BusFault_Handler
        0  CAN1_RX1_IRQHandler
        0  CAN1_SCE_IRQHandler
        0  DMA1_Channel2_IRQHandler
        0  DMA1_Channel3_IRQHandler
        0  DMA1_Channel4_IRQHandler
        0  DMA1_Channel5_IRQHandler
        0  DMA1_Channel6_IRQHandler
        0  DMA1_Channel7_IRQHandler
        0  DebugMon_Handler
        8  EXTI0_IRQHandler
              8 -> Delay_1ms
              8 -> EXTI_ClearITPendingBit
              8 -> EXTI_GetITStatus
              8 -> LED_Off_Red
              8 -> LED_On_Red
        0  EXTI15_10_IRQHandler
        0  FLASH_IRQHandler
        0  HardFault_Handler
        0  I2C1_ER_IRQHandler
        0  I2C1_EV_IRQHandler
        0  I2C2_ER_IRQHandler
        0  I2C2_EV_IRQHandler
        0  LRF_Data_Clear
        8  LRF_Data_Pasher
              8 -> LRF_Data_Clear
              8 -> LRF_Trans_Data
        8  LRF_Trans_Data
              8 -> USART_SendData
       16  Main_Protocol_Data_Pasher
             16 -> Rx_Main_Comm_Handling
        0  MemManage_Handler
        0  NMI_Handler
        0  PVD_IRQHandler
        0  PendSV_Handler
       16  Protocol_Command_Check
             16 -> Rx_Usart_Comm_Handling
        0  RCC_IRQHandler
        0  RTCAlarm_IRQHandler
        0  RTC_IRQHandler
       16  Rx_Main_Comm_Handling
             16 -> Boot_Status_Check_Parser
             16 -> Rx_Main_Second_Comm_Check
             16 -> Rx_Pelco_Data_Check
        0  Rx_Main_Second_Comm_Check
        0  Rx_Pelco_Address_Check
        0  Rx_Pelco_Data_Check
        0  Rx_Second_Comm_Check
       16  Rx_Usart_Comm_Handling
             16 -> Rx_Pelco_Address_Check
             16 -> Rx_Pelco_Data_Check
             16 -> Rx_Second_Comm_Check
        0  SONY_Data_Clear
       16  SONY_Data_Pasher
             16 -> SONY_Data_Clear
        0  SPI1_IRQHandler
        0  SPI2_IRQHandler
        0  SVC_Handler
       12  SYSTEM_Data_Buffer
        0  SYSTEM_Data_Handling
        8  SYSTEM_Data_Parser
              8 -> SYSTEM_Data_Buffer
              8 -> SYSTEM_Data_Handling
              8 -> SYSTEM_Data_Reordering
       16  SYSTEM_Data_Reordering
        0  Sony_Data_Pasher
        8  SysTick_Handler
              8 -> Delay_Decrement
              8 -> TimingDelay_Decrement
              8 -> i2cDelay_Decrement
        0  TAMPER_IRQHandler
        0  TIM1_BRK_IRQHandler
        0  TIM1_CC_IRQHandler
        0  TIM1_TRG_COM_IRQHandler
        0  TIM1_UP_IRQHandler
        8  TIM2_IRQHandler
              8 -> GPIO_ReadInputDataBit
              8 -> Run_Wiper
              8 -> TIM_ClearITPendingBit
              8 -> TIM_GetITStatus
        8  TIM3_IRQHandler
              8 -> LED_Off_Green
              8 -> LED_On_Green
              8 -> TIM_ClearITPendingBit
              8 -> TIM_GetITStatus
        8  TIM4_IRQHandler
              8 -> LED_Off_Red
              8 -> LED_On_Red
              8 -> TIM_ClearITPendingBit
              8 -> TIM_GetITStatus
       16  TSM_Data_Pasher
       16  UART4_Data_Pasher
             16 -> SONY_Data_Pasher
             16 -> TSM_Data_Pasher
       16  UART4_IRQHandler
             16 -> UART4_Data_Pasher
             16 -> USART_ClearITPendingBit
             16 -> USART_GetITStatus
             16 -> USART_ReceiveData
             16 -> USART_SendData
       16  UART5_IRQHandler
             16 -> Protocol_Command_Check
             16 -> USART_ClearITPendingBit
             16 -> USART_GetITStatus
             16 -> USART_ReceiveData
             16 -> USART_SendData
        8  USART1_IRQHandler
              8 -> Main_Protocol_Data_Pasher
              8 -> USART_ClearITPendingBit
              8 -> USART_GetITStatus
              8 -> USART_ReceiveData
              8 -> USART_SendData
       16  USART2_IRQHandler
             16 -> USART_ClearITPendingBit
             16 -> USART_GetITStatus
             16 -> USART_ReceiveData
             16 -> USART_SendData
       16  USART3_IRQHandler
             16 -> USART_ClearITPendingBit
             16 -> USART_GetITStatus
             16 -> USART_ReceiveData
             16 -> USART_SendData
        0  USB_HP_CAN1_TX_IRQHandler
        0  UsageFault_Handler
        0  WWDG_IRQHandler
        0  assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable18
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_2
       4  ??DataTable19_3
       4  ??DataTable19_4
       4  ??DataTable19_5
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable26_2
       4  ??DataTable26_3
       4  ??DataTable27
       4  ??DataTable28
       4  ??DataTable28_1
       4  ??DataTable28_2
       4  ??DataTable28_3
       4  ??DataTable28_4
       2  ADC1_2_IRQHandler
      44  Boot_Status_Check_Parser
     406  Boot_Status_Data_Trans
       2  BusFault_Handler
       2  CAN1_RX1_IRQHandler
       2  CAN1_SCE_IRQHandler
       2  DMA1_Channel2_IRQHandler
       2  DMA1_Channel3_IRQHandler
       2  DMA1_Channel4_IRQHandler
       2  DMA1_Channel5_IRQHandler
       2  DMA1_Channel6_IRQHandler
       2  DMA1_Channel7_IRQHandler
       2  DebugMon_Handler
      56  EXTI0_IRQHandler
       2  EXTI15_10_IRQHandler
       2  FLASH_IRQHandler
       2  HardFault_Handler
       2  I2C1_ER_IRQHandler
       2  I2C1_EV_IRQHandler
       2  I2C2_ER_IRQHandler
       2  I2C2_EV_IRQHandler
      26  LRF_Data_Clear
     226  LRF_Data_Pasher
      80  LRF_Trans_Data
     148  Main_Protocol_Data_Pasher
       2  MemManage_Handler
       2  NMI_Handler
       2  PVD_IRQHandler
       2  PendSV_Handler
     236  Protocol_Command_Check
       2  RCC_IRQHandler
       2  RTCAlarm_IRQHandler
       2  RTC_IRQHandler
     632  Rx_Main_Comm_Handling
      68  Rx_Main_Second_Comm_Check
      32  Rx_Pelco_Address_Check
     102  Rx_Pelco_Data_Check
      68  Rx_Second_Comm_Check
     604  Rx_Usart_Comm_Handling
      30  SONY_Data_Clear
     780  SONY_Data_Pasher
       2  SPI1_IRQHandler
       2  SPI2_IRQHandler
       2  SVC_Handler
     194  SYSTEM_Data_Buffer
      50  SYSTEM_Data_Handling
      26  SYSTEM_Data_Parser
     382  SYSTEM_Data_Reordering
      86  Sony_Data_Pasher
      16  SysTick_Handler
       2  TAMPER_IRQHandler
       2  TIM1_BRK_IRQHandler
       2  TIM1_CC_IRQHandler
       2  TIM1_TRG_COM_IRQHandler
       2  TIM1_UP_IRQHandler
    1010  TIM2_IRQHandler
      36  TIM3_IRQHandler
      36  TIM4_IRQHandler
    1440  TSM_Data_Pasher
      48  UART4_Data_Pasher
     154  UART4_IRQHandler
     122  UART5_IRQHandler
     112  USART1_IRQHandler
     140  USART2_IRQHandler
      76  USART3_IRQHandler
       2  USB_HP_CAN1_TX_IRQHandler
       2  UsageFault_Handler
       2  WWDG_IRQHandler
       2  assert_failed
       1  g_Tx_Buf

 
     1 byte  in section .bss
 7 648 bytes in section .text
 
 7 648 bytes of CODE memory
     1 byte  of DATA memory

Errors: none
Warnings: 9
