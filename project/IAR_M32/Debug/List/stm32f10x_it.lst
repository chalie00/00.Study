###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     20/Jul/2022  18:34:54 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\Libraries\STM32F1 #
#                    0x_StdPeriph_Driver\src\stm32f10x_it.c                   #
#    Command line =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\Libraries\STM32F1 #
#                    0x_StdPeriph_Driver\src\stm32f10x_it.c -D                #
#                    USE_STDPERIPH_DRIVER -D STM32F10x_HD -D USE_FULL_ASSERT  #
#                    -lcN C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_ #
#                    M32\Debug\List\ -lb C:\Users\TTT\Desktop\zz.STDFW\00.Stu #
#                    dy\project\IAR_M32\Debug\List\ -o                        #
#                    C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_M32\D #
#                    ebug\Obj\ --no_cse --no_unroll --no_inline               #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\I #
#                    AR_M32\..\..\inc\ -I C:\Users\TTT\Desktop\zz.STDFW\00.St #
#                    udy\project\IAR_M32\..\..\Libraries\CMSIS\CM3\DeviceSupp #
#                    ort\ST\STM32F10x\ -I C:\Users\TTT\Desktop\zz.STDFW\00.St #
#                    udy\project\IAR_M32\..\..\Libraries\STM32F10x_StdPeriph_ #
#                    Driver\inc\ -I "C:\Program Files (x86)\IAR               #
#                    Systems\Embedded Workbench 6.0\arm\inc\c\" -On -I        #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_M32\D #
#                    ebug\List\stm32f10x_it.lst                               #
#    Object file  =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_M32\D #
#                    ebug\Obj\stm32f10x_it.o                                  #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\TTT\Desktop\zz.STDFW\00.Study\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_it.c
      1          /*=================================================================================
      2          Project Name 		:	TPV HD Type (HD IP THERMOGRAPHY PTZ CAMERA)
      3          Author			:	phs@tbtsys.com
      4          ==================================================================================*/ 
      5          
      6          /*******************************************************************************
      7          * INCLUDE
      8          *******************************************************************************/
      9          #include "stm32f10x_it.h"
     10          #include "I2c.h"
     11          #include "Extern.h"
     12          #include "Device.h"
     13          #include "Define.h"
     14          #include "Common.h"
     15          
     16          /*******************************************************************************
     17          * Function Name  : assert_failed
     18          * Description    : Reports the name of the source file and the source line number
     19            *   where the assert_param error has occurred.
     20          * Input          : - file: pointer to the source file name
     21          *                  - line: assert_param error line source number
     22          * Output         : None
     23          * Return         : None
     24          *******************************************************************************/
     25          void assert_failed(uint8_t* file, uint32_t line)
     26          { 
     27          	/* User can add his own implementation to report the file name and line number,
     28          	ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
     29          	//printf("Wrong parameters value: file %s on line %d\r\n", file, line);
     30          
     31          	/* Infinite loop */
     32          	while (1)
     33          	{}
     34          }
     35          
     36          /******************************************************************************/
     37          /*            Cortex-M3 Processor Exceptions Handlers                         */
     38          /******************************************************************************/
     39          
     40          /**
     41            * @brief  This function handles NMI exception.
     42            * @param  None
     43            * @retval None
     44            */
     45          void NMI_Handler(void)
     46          {
     47          }
     48          
     49          /**
     50            * @brief  This function handles Hard Fault exception.
     51            * @param  None
     52            * @retval None
     53            */
     54          void HardFault_Handler(void)
     55          {
     56              /* Go to infinite loop when Hard Fault exception occurs */
     57              while (1)
     58              {
     59              }
     60          }
     61          
     62          /**
     63            * @brief  This function handles Memory Manage exception.
     64            * @param  None
     65            * @retval None
     66            */
     67          void MemManage_Handler(void)
     68          {
     69              /* Go to infinite loop when Memory Manage exception occurs */
     70              while (1)
     71              {
     72              }
     73          }
     74          
     75          /**
     76            * @brief  This function handles Bus Fault exception.
     77            * @param  None
     78            * @retval None
     79            */
     80          void BusFault_Handler(void)
     81          {
     82              /* Go to infinite loop when Bus Fault exception occurs */
     83              while (1)
     84              {
     85              }
     86          }
     87          
     88          /**
     89            * @brief  This function handles Usage Fault exception.
     90            * @param  None
     91            * @retval None
     92            */
     93          void UsageFault_Handler(void)
     94          {
     95              /* Go to infinite loop when Usage Fault exception occurs */
     96              while (1)
     97              {
     98              }
     99          }
    100          
    101          /**
    102            * @brief  This function handles SVCall exception.
    103            * @param  None
    104            * @retval None
    105            */
    106          void SVC_Handler(void)
    107          {
    108          }
    109          
    110          /**
    111            * @brief  This function handles Debug Monitor exception.
    112            * @param  None
    113            * @retval None
    114            */
    115          void DebugMon_Handler(void)
    116          {
    117          }
    118          
    119          /**
    120            * @brief  This function handles PendSV_Handler exception.
    121            * @param  None
    122            * @retval None
    123            */
    124          void PendSV_Handler(void)
    125          {
    126          }
    127          
    128          /**
    129            * @brief  This function handles SysTick Handler.
    130            * @param  None
    131            * @retval None
    132            */
    133          void SysTick_Handler(void)
    134          {
    135              TimingDelay_Decrement();
    136              Delay_Decrement();
    137              i2cDelay_Decrement();
    138          }
    139          
    140          /******************************************************************************/
    141          /*            STM32F10x Peripherals Interrupt Handlers                        */
    142          /*  Add here the Interrupt Handler for the used peripheral(s) (PPP), for the  */
    143          /*  available peripheral interrupt handler's name please refer to the startup */
    144          /*  file (startup_stm32f10x_xx.s).                                            */
    145          /******************************************************************************/
    146          
    147          /*******************************************************************************
    148          * Function Name  : WWDG_IRQHandler
    149          * Description    : This function handles WWDG interrupt request.
    150          * Input          : None
    151          * Output         : None
    152          * Return         : None
    153          *******************************************************************************/
    154          void WWDG_IRQHandler(void)
    155          {
    156          }
    157          
    158          /*******************************************************************************
    159          * Function Name  : PVD_IRQHandler
    160          * Description    : This function handles PVD interrupt request.
    161          * Input          : None
    162          * Output         : None
    163          * Return         : None
    164          *******************************************************************************/
    165          void PVD_IRQHandler(void)
    166          {
    167          }
    168          
    169          /*******************************************************************************
    170          * Function Name  : TAMPER_IRQHandler
    171          * Description    : This function handles Tamper interrupt request. 
    172          * Input          : None
    173          * Output         : None
    174          * Return         : None
    175          *******************************************************************************/
    176          void TAMPER_IRQHandler(void)
    177          {
    178          }
    179          
    180          /*******************************************************************************
    181          * Function Name  : RTC_IRQHandler
    182          * Description    : This function handles RTC global interrupt request.
    183          * Input          : None
    184          * Output         : None
    185          * Return         : None
    186          *******************************************************************************/
    187          void RTC_IRQHandler(void)
    188          {
    189          }
    190          
    191          /*******************************************************************************
    192          * Function Name  : FLASH_IRQHandler
    193          * Description    : This function handles Flash interrupt request.
    194          * Input          : None
    195          * Output         : None
    196          * Return         : None
    197          *******************************************************************************/
    198          void FLASH_IRQHandler(void)
    199          {
    200          }
    201          
    202          /*******************************************************************************
    203          * Function Name  : RCC_IRQHandler
    204          * Description    : This function handles RCC interrupt request. 
    205          * Input          : None
    206          * Output         : None
    207          * Return         : None
    208          *******************************************************************************/
    209          void RCC_IRQHandler(void)
    210          {
    211          }
    212          
    213          /*******************************************************************************
    214          * Function Name  : EXTI0_IRQHandler
    215          * Description    : This function handles External interrupt Line 0 request.
    216          * Input          : None
    217          * Output         : None
    218          * Return         : None
    219          *******************************************************************************/
    220          
    221          //static bool toggle_data_key1 = FALSE;
    222          /*
    223          void EXTI0_IRQHandler(void)
    224          {
    225              if(EXTI_GetITStatus(GPIO_EXTI_Line_KEY1) != RESET) {
    226                  printf("Left-WKUP Button Press\n");
    227          
    228          #if 0
    229            
    230                  if (pInformation->Current_Feature & 0x20) //Remote wake-up enabled
    231                  {
    232                    Resume(RESUME_INTERNAL);
    233                  }
    234          #endif
    235          
    236                  if(TRUE == g_TestProcessState)
    237                  {
    238                      Send_Buffer[0] = 0x05;
    239          
    240                      if(toggle_data_key1)
    241                      {
    242                          toggle_data_key1 = FALSE;
    243                          Send_Buffer[1] = 0x01;
    244                      }
    245                      else
    246                      {
    247                          toggle_data_key1 = TRUE;
    248                          Send_Buffer[1] = 0x00;
    249                      }
    250          
    251                      UserToPMABufferCopy(Send_Buffer, ENDP1_TXADDR, 2);
    252                      SetEPTxCount(ENDP1, 2);
    253                      SetEPTxValid(ENDP1);
    254                  }
    255          
    256                  EXTI_ClearITPendingBit(GPIO_EXTI_Line_KEY1);
    257              }
    258          }
    259          */
    260          /*******************************************************************************
    261          * Function Name  : EXTI1_IRQHandler
    262          * Description    : This function handles External interrupt Line 1 request.
    263          * Input          : None
    264          * Output         : None
    265          * Return         : None
    266          *******************************************************************************/
    267          /*
    268          static bool toggle_data_key2 = FALSE;
    269          
    270          void EXTI1_IRQHandler(void)
    271          {
    272              if(EXTI_GetITStatus(GPIO_EXTI_Line_KEY2) != RESET) {
    273                  printf("Right-USER Button Press\n");
    274          
    275                  if(TRUE == g_TestProcessState)
    276                  {
    277                      Send_Buffer[0] = 0x06;
    278          
    279                      if(toggle_data_key2)
    280                      {
    281                          toggle_data_key2 = FALSE;
    282                          Send_Buffer[1] = 0x01;
    283                      }
    284                      else
    285                      {
    286                          toggle_data_key2 = TRUE;
    287                          Send_Buffer[1] = 0x00;
    288                      }
    289          
    290                      UserToPMABufferCopy(Send_Buffer, ENDP1_TXADDR, 2);
    291                      SetEPTxCount(ENDP1, 2);
    292                      SetEPTxValid(ENDP1);
    293                  }
    294          
    295                  EXTI_ClearITPendingBit(GPIO_EXTI_Line_KEY2);
    296              }
    297          }
    298          */
    299          /*******************************************************************************
    300          * Function Name  : EXTI2_IRQHandler
    301          * Description    : This function handles External interrupt Line 2 request.
    302          * Input          : None
    303          * Output         : None
    304          * Return         : None
    305          *******************************************************************************/
    306          /*
    307          void EXTI2_IRQHandler(void)
    308          {
    309          }
    310          */
    311          /*******************************************************************************
    312          * Function Name  : EXTI3_IRQHandler
    313          * Description    : This function handles External interrupt Line 3 request.
    314          * Input          : None
    315          * Output         : None
    316          * Return         : None
    317          *******************************************************************************/
    318          /*
    319          void EXTI3_IRQHandler(void)
    320          {
    321          }
    322          */
    323          /*******************************************************************************
    324          * Function Name  : EXTI4_IRQHandler
    325          * Description    : This function handles External interrupt Line 4 request.
    326          * Input          : None
    327          * Output         : None
    328          * Return         : None
    329          *******************************************************************************/
    330          /*
    331          void EXTI4_IRQHandler(void)
    332          {
    333          }
    334          */
    335          /*******************************************************************************
    336          * Function Name  : DMA1_Channel1_IRQHandler
    337          * Description    : This function handles DMA1 Channel 1 interrupt request.
    338          * Input          : None
    339          * Output         : None
    340          * Return         : None
    341          *******************************************************************************/
    342          /*
    343          void DMA1_Channel1_IRQHandler(void)
    344          {
    345              Send_Buffer[0] = 0x07;
    346          
    347              if((ADC_ConvertedValueX >>4) - (ADC_ConvertedValueX_1 >>4) > 4)
    348              {
    349                  Send_Buffer[1] = (uint8_t)(ADC_ConvertedValueX >>4);
    350                  UserToPMABufferCopy(Send_Buffer, ENDP1_TXADDR, 2);
    351                  SetEPTxCount(ENDP1, 2);
    352                  SetEPTxValid(ENDP1);
    353                  ADC_ConvertedValueX_1 = ADC_ConvertedValueX;
    354              }
    355          
    356              DMA_ClearFlag(DMA1_FLAG_TC1);
    357          }
    358          */
    359          /*******************************************************************************
    360          * Function Name  : DMA1_Channel2_IRQHandler
    361          * Description    : This function handles DMA1 Channel 2 interrupt request.
    362          * Input          : None
    363          * Output         : None
    364          * Return         : None
    365          *******************************************************************************/
    366          void DMA1_Channel2_IRQHandler(void)
    367          {
    368          }
    369          
    370          /*******************************************************************************
    371          * Function Name  : DMA1_Channel3_IRQHandler
    372          * Description    : This function handles DMA1 Channel 3 interrupt request.
    373          * Input          : None
    374          * Output         : None
    375          * Return         : None
    376          *******************************************************************************/
    377          void DMA1_Channel3_IRQHandler(void)
    378          {
    379          }
    380          
    381          /*******************************************************************************
    382          * Function Name  : DMA1_Channel4_IRQHandler
    383          * Description    : This function handles DMA1 Channel 4 interrupt request.
    384          * Input          : None
    385          * Output         : None
    386          * Return         : None
    387          *******************************************************************************/
    388          void DMA1_Channel4_IRQHandler(void)
    389          {
    390          }
    391          
    392          /*******************************************************************************
    393          * Function Name  : DMA1_Channel5_IRQHandler
    394          * Description    : This function handles DMA1 Channel 5 interrupt request.
    395          * Input          : None
    396          * Output         : None
    397          * Return         : None
    398          *******************************************************************************/
    399          void DMA1_Channel5_IRQHandler(void)
    400          {
    401          }
    402          
    403          /*******************************************************************************
    404          * Function Name  : DMA1_Channel6_IRQHandler
    405          * Description    : This function handles DMA1 Channel 6 interrupt request.
    406          * Input          : None
    407          * Output         : None
    408          * Return         : None
    409          *******************************************************************************/
    410          void DMA1_Channel6_IRQHandler(void)
    411          {
    412          }
    413          
    414          /*******************************************************************************
    415          * Function Name  : DMA1_Channel7_IRQHandler
    416          * Description    : This function handles DMA1 Channel 7 interrupt request.
    417          * Input          : None
    418          * Output         : None
    419          * Return         : None
    420          *******************************************************************************/
    421          void DMA1_Channel7_IRQHandler(void)
    422          {
    423          }
    424          
    425          /*******************************************************************************
    426          * Function Name  : ADC1_2_IRQHandler
    427          * Description    : This function handles ADC1 and ADC2 global interrupts requests.
    428          * Input          : None
    429          * Output         : None
    430          * Return         : None
    431          *******************************************************************************/
    432          void ADC1_2_IRQHandler(void)
    433          {
    434          }
    435          
    436          /*******************************************************************************
    437          * Function Name  : USB_HP_CAN_TX_IRQHandler
    438          * Description    : This function handles USB High Priority or CAN TX interrupts 
    439          *                  requests.
    440          * Input          : None
    441          * Output         : None
    442          * Return         : None
    443          *******************************************************************************/
    444          void USB_HP_CAN1_TX_IRQHandler(void)
    445          {
    446          }
    447          
    448          /*******************************************************************************
    449          * Function Name  : USB_LP_CAN_RX0_IRQHandler
    450          * Description    : This function handles USB Low Priority or CAN RX0 interrupts 
    451          *                  requests.
    452          * Input          : None
    453          * Output         : None
    454          * Return         : None
    455          *******************************************************************************/
    456          /*
    457          void USB_LP_CAN1_RX0_IRQHandler(void)
    458          {
    459              USB_Istr();
    460          }
    461          */
    462          /*******************************************************************************
    463          * Function Name  : CAN_RX1_IRQHandler
    464          * Description    : This function handles CAN RX1 interrupt request.
    465          * Input          : None
    466          * Output         : None
    467          * Return         : None
    468          *******************************************************************************/
    469          void CAN1_RX1_IRQHandler(void)
    470          {
    471          }
    472          
    473          /*******************************************************************************
    474          * Function Name  : CAN_SCE_IRQHandler
    475          * Description    : This function handles CAN SCE interrupt request.
    476          * Input          : None
    477          * Output         : None
    478          * Return         : None
    479          *******************************************************************************/
    480          void CAN1_SCE_IRQHandler(void)
    481          {
    482          }
    483          
    484          /*******************************************************************************
    485          * Function Name  : EXTI9_5_IRQHandler
    486          * Description    : This function handles External lines 9 to 5 interrupt request.
    487          * Input          : None
    488          * Output         : None
    489          * Return         : None
    490          *******************************************************************************/
    491          /*
    492          void EXTI9_5_IRQHandler(void)
    493          {
    494          #ifdef  BOARD_DEF_MANGO_Z1
    495              if(EXTI_GetITStatus(GPIO_EXTI_Line_RF_GPIO0) != RESET)
    496              {
    497                  basicRfRxFrmDoneIsr();
    498                  EXTI_ClearITPendingBit(GPIO_EXTI_Line_RF_GPIO0);
    499              }
    500          #endif
    501          }
    502          */
    503          /*******************************************************************************
    504          * Function Name  : TIM1_BRK_IRQHandler
    505          * Description    : This function handles TIM1 Break interrupt request.
    506          * Input          : None
    507          * Output         : None
    508          * Return         : None
    509          *******************************************************************************/
    510          void TIM1_BRK_IRQHandler(void)
    511          {
    512          }
    513          
    514          /*******************************************************************************
    515          * Function Name  : TIM1_UP_IRQHandler
    516          * Description    : This function handles TIM1 overflow and update interrupt 
    517          *                  request.
    518          * Input          : None
    519          * Output         : None
    520          * Return         : None
    521          *******************************************************************************/
    522          void TIM1_UP_IRQHandler(void)
    523          {
    524          }
    525          
    526          /*******************************************************************************
    527          * Function Name  : TIM1_TRG_COM_IRQHandler
    528          * Description    : This function handles TIM1 Trigger and commutation interrupts 
    529          *                  requests.
    530          * Input          : None
    531          * Output         : None
    532          * Return         : None
    533          *******************************************************************************/
    534          void TIM1_TRG_COM_IRQHandler(void)
    535          {
    536          }
    537          
    538          /*******************************************************************************
    539          * Function Name  : TIM1_CC_IRQHandler
    540          * Description    : This function handles TIM1 capture compare interrupt request.
    541          * Input          : None
    542          * Output         : None
    543          * Return         : None
    544          *******************************************************************************/
    545          void TIM1_CC_IRQHandler(void)
    546          {
    547          }
    548          
    549          /*******************************************************************************
    550          * Function Name  : TIM2_IRQHandler
    551          * Description    : This function handles TIM2 global interrupt request.
    552          * Input          : None
    553          * Output         : None
    554          * Return         : None
    555          * Timer		: 10ms
    556          *******************************************************************************/
    557          u8 g_Tx_Buf = 0x00;
    558          
    559          void TIM2_IRQHandler(void)
    560          {
    561          	if (TIM_GetITStatus(TIM2, TIM_IT_Update) != RESET)
    562          	{
    563          		TIM_ClearITPendingBit(TIM2, TIM_IT_Update);	
    564          
    565          		// =======================================
    566          		// LED Control : 1s
    567          		// =======================================
    568          		stLED_SET.LED_COUNT++;
    569          		if(stLED_SET.LED_COUNT >= 100)
    570          		{
    571          			stLED_SET.LED_COUNT = 0;
    572          			stLED_SET.LED_FLAG ^= 0xFF;
    573          
    574          			//if(stLED_SET.LED_FLAG) LED1_ON;
    575          			//else LED1_OFF;
    576          		}
    577          
    578          		if(stINFO.BOOT_FLAG == 0x01)
    579          		{
    580          			stINFO.BOOT_CHECK_LIMIT_ms++;
    581          
    582          			if(stINFO.BOOT_CHECK_LIMIT_ms >= 1000)
    583          			{
    584          				stINFO.BOOT_CHECK_LIMIT_ms = 0;
    585          				stINFO.BOOT_FLAG = 0x00;
    586          			}
    587          		}
    588          
    589          		// ================================================================
    590          		// Wiper Sensor Check
    591          		// ================================================================
    592          
    593          		switch(stDIP.MODE2)
    594          		{
    595          			case 0x00:
    596          
    597          				stWIPER2.SENSOR_1 = WIPER_SENSOR_1;
    598          				stWIPER2.SENSOR_2 = WIPER_SENSOR_2;
    599          				
    600          				break;
    601          
    602          			case 0x01:
    603          
    604          				stWIPER2.SENSOR_1 = WIPER_SENSOR_1;
    605          				
    606          				if(stWIPER1.SENSOR_TEMP != stWIPER2.SENSOR_1) 
    607          				{
    608          
    609          					if((stWIPER2.SENSOR_1 == WIPER_SENS1_ON) && (stWIPER1.SENSOR_TEMP == WIPER_SENS1_OFF))
    610          					{
    611          						if((stWIPER1.ACTIVE_COUNT > 0) && (stWIPER1.ACTIVE_COUNT < 0x0F)) 
    612          						{
    613          							stWIPER1.ACTIVE_COUNT--;
    614          						}
    615          						
    616          						if(stWIPER1.ACTIVE_COUNT == 0) 
    617          						{
    618          							//Run_Wiper(WIPER_OFF, DIRECTION_CW);				// Wiper Off
    619          						}
    620          						else
    621          						{
    622          							if((stWIPER1.DWELL_FLAG == 0x00) && (stWIPER1.DWELL_TIME != 0))
    623          							{
    624          								//Run_Wiper(WIPER_OFF, DIRECTION_CW);				// Wiper off
    625          								stWIPER1.DWELL_FLAG = 0x01;
    626          							}
    627          						}
    628          					}
    629          
    630          					stWIPER1.SENSOR_TEMP = WIPER_SENSOR_1;
    631          					
    632          				}
    633          				stWIPER2.SENSOR_2 = WIPER_SENSOR_2;
    634          
    635          
    636          				break;
    637          
    638          			default:
    639          				break;
    640          		}
    641          
    642          		// =======================================
    643          		// Wiper1 Dwell Timer
    644          		// =======================================
    645          		if(stWIPER1.DWELL_FLAG == 0x01)
    646          		{
    647          			stWIPER1.DWELL_TIME_10ms++;
    648          			if(stWIPER1.DWELL_TIME_10ms > 100)
    649          			{
    650          				stWIPER1.DWELL_TIME_10ms = 0;
    651          				stWIPER1.DWELL_TIME_1s++;
    652          
    653          				if(stWIPER1.DWELL_TIME <= stWIPER1.DWELL_TIME_1s)
    654          				{
    655          					stWIPER1.DWELL_FLAG = 0x00;
    656          					if(stWIPER1.ACTIVE_COUNT != 0)
    657          					{
    658          						//Run_Wiper(WIPER_ON, DIRECTION_CW);				// Wiper On
    659          					}
    660          
    661          					stWIPER1.DWELL_TIME_1s = 0;
    662          				}
    663          			}
    664          		}
    665          		
    666          		// ================================================================
    667          		// Wiper2 Dwell Timer
    668          		// ================================================================
    669          		if(stWIPER2.DWELL_TIMER_FLAG)
    670          		{
    671          			stWIPER2.DWELL_TIMER_ms++;
    672          
    673          			if(stWIPER2.DWELL_TIMER_ms >= 100)	// 1s
    674          			{
    675          				stWIPER2.DWELL_TIMER_s++;
    676          				stWIPER2.DWELL_TIMER_ms = 0x00;
    677          		
    678          				if(stWIPER2.DWELL_TIMER_s >= stWIPER2.DWELL_TIME_DATA)
    679          				{
    680          					stWIPER2.DWELL_END_FLAG = 0x01;
    681          					stWIPER2.DWELL_TIMER_s = 0x00;
    682          					stWIPER2.DWELL_TIMER_FLAG = 0x00;
    683          				}
    684          			}
    685          		}
    686          
    687          		if((stWIPER2.COUNT == 0x00) && (stWIPER2.DWELL_TIMER_FLAG != 0x00))
    688          		{
    689          			stWIPER2.DWELL_TIMER_FLAG = 0x00;
    690          			stWIPER2.DWELL_TIMER_ms = 0;
    691          			stWIPER2.DWELL_TIMER_s = 0;
    692          		}
    693          
    694          		// ================================================================
    695          		// LRF Booting Check Time
    696          		// ================================================================
    697          		if(stLRF.INIT_FLAG == 0x01)
    698          		{
    699          			stLRF.INIT_TIME++;
    700          
    701          			if(stLRF.INIT_TIME >= LRF_BOOTING_TIME)
    702          			{
    703          				stLRF.INIT_ACTIVE = 0x01;
    704          
    705          				stLRF.INIT_TIME = 0x00;
    706          				stLRF.INIT_FLAG = 0x00;
    707          			}
    708          		}
    709          
    710          		if(stLRF.CONTINUOUS_FLAG == 0x01)
    711          		{
    712          			stLRF.CONTINUOUS_TIME++;
    713          
    714          			if(stLRF.CONTINUOUS_TIME > stLRF.CONTINUOUS_TIME_MAX)
    715          			{
    716          				stLRF.CONTINUOUS_ACTIVE = 0x01;
    717          				
    718          				stLRF.CONTINUOUS_TIME = 0;
    719          			}
    720          		}
    721          
    722          		// ================================================================
    723          		// BYPASS Tx Check (전송 후 500ms 후 Clear)
    724          		// ================================================================
    725          		if(stBYPASS.TX_FLAG == 0x01)
    726          		{
    727          			stBYPASS.TX_TIMER++;
    728          
    729          			if(stBYPASS.TX_TIMER >= 50)
    730          			{
    731          				stBYPASS.TX_TIMER = 0;
    732          				stBYPASS.TX_FLAG = 0x00;
    733          			}
    734          		}
    735          
    736          		// ================================================================
    737          		// WIPER CONTINUOUS TIMER
    738          		// ================================================================
    739          		if(stWIPER2.CONTINUOUS_FLAG == 0x00)
    740          		{
    741          			if((stWIPER2.CONTINUOUS_ms != 0) || (stWIPER2.CONTINUOUS_s != 0) || (stWIPER2.CONTINUOUS_m != 0) || (stWIPER2.CONTINUOUS_h != 0))
    742          			{
    743          				stWIPER2.CONTINUOUS_ms = 0;
    744          				stWIPER2.CONTINUOUS_s = 0;
    745          				stWIPER2.CONTINUOUS_m = 0;
    746          				stWIPER2.CONTINUOUS_h = 0;
    747          			}
    748          		}
    749          			
    750          		if(stWIPER2.CONTINUOUS_FLAG == 0x01)
    751          		{
    752          			stWIPER2.CONTINUOUS_ms++;
    753          			
    754          			if(stWIPER2.CONTINUOUS_ms >= 100)
    755          			{
    756          				stWIPER2.CONTINUOUS_ms = 0;
    757          				stWIPER2.CONTINUOUS_s++;
    758          				
    759          				if(stWIPER2.CONTINUOUS_s >= 60)
    760          				{
    761          					stWIPER2.CONTINUOUS_s = 0;
    762          					stWIPER2.CONTINUOUS_m++;
    763          
    764          					if(stWIPER2.CONTINUOUS_m >= 60)
    765          					{
    766          						stWIPER2.CONTINUOUS_m = 0;
    767          						stWIPER2.CONTINUOUS_h++;
    768          
    769          						if(stWIPER2.CONTINUOUS_h >= stWIPER2.CONTINUOUS_TIME)
    770          						{
    771          							stWIPER2.CONTINUOUS_h = 0;
    772          							stWIPER2.CONTINUOUS_FLAG = 0x00;
    773          							stWIPER2.CONTINUOUS_STOP_FLAG = 0x01;
    774          						}
    775          					}
    776          				}
    777          			}
    778          		}
    779          
    780          		// ================================================================
    781          		// TEST TIMER
    782          		// ================================================================
    783          /*
    784          		if(stUSART2.TX_CNT < stUSART2.TX_MAX)
    785          		{
    786          			g_Tx_Buf = stUSART2.TX_BUF[stUSART2.TX_CNT];
    787          			stUSART2.TX_CNT++;				
    788          
    789          			USART_SendData(USART2, g_Tx_Buf);
    790          		}
    791          		else
    792          		{
    793          			stUSART2.TX_CNT = 0x00;
    794          			stUSART2.TX_MAX = 0x00;
    795          		
    796          			//USART_SendData(USART2, Tx_Buf);
    797          		}
    798          */
    799          
    800          	}	
    801          }
    802          
    803          /*******************************************************************************
    804          * Function Name  : TIM3_IRQHandler
    805          * Description    : This function handles TIM3 global interrupt request.
    806          * Input          : None
    807          * Output         : None
    808          * Return         : None
    809          * Timer		: 1ms
    810          *******************************************************************************/
    811          void TIM3_IRQHandler(void)
    812          {
    813          	if (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET)
    814          	{
    815          
    816          				TIM_ClearITPendingBit(TIM4, TIM_IT_Update);
    817          				LED_Off_Green();
    818          				LED_On_Green();
    819          				
    820          
    821          		
    822          //			TIM_ClearITPendingBit(TIM3, TIM_IT_Update);
    823          //	
    824          //			// ================================================================
    825          //			// Sony-Zoom & Light-Zoom Sync
    826          //			// ================================================================
    827          //			//Zoom_Data_Sync();
    828          //	
    829          //			// ================================================================
    830          //			// TEMPERATURE (DC-103JU)
    831          //			// ================================================================
    832          //			Temperature_Data_Check();
    833          //			Temperature_Boot_Mode();
    834          //	
    835          //			// =======================================
    836          //			// Temperature Control
    837          //			// =======================================
    838          //			if(stTEMP.STARTING_MODE == 0x00)
    839          //			{
    840          //				Fan_Heater_Control(BOOT_MODE);
    841          //			}
    842          //			else
    843          //			{
    844          //				Fan_Heater_Control(NORMAL_MODE);
    845          //			}
    846          //			
    847          //			// ================================================================
    848          //			// CDS CHECK
    849          //			// ================================================================
    850          //			//CDS_Data_Check();
    851          //			//Auto_Day_And_Night_Control();
    852          	}	
    853          }
    854          
    855          /*******************************************************************************
    856          * Function Name  : SYSTEM_Data_Reordering
    857          *******************************************************************************/
    858          void SYSTEM_Data_Reordering(void)
    859          {
    860          	u8 i = 0x00, j = 0x00, u_buf = 0x00, u_length = 0x00, u_max = 0x00;
    861          	
    862          	if((stSYS.RX_PARITY == 0x00) && (stSYS.RX_REORDERING == 0x01))
    863          	{
    864          		if(stSYS.RX_INDEX == 0x00)
    865          		{
    866          			u_buf = stSYS.RX_BUF[0][1];
    867          		
    868          			switch(u_buf)
    869          			{
    870          				case TILT_FIRST_BYTE:
    871          				case IP_SONY_FIRST_BYTE:
    872          				case IP_TSM_FIRST_BYTE:
    873          				case IP_DRS_FIRST_BYTE:
    874          				case IP_PTZ_FIRST_BYTE:
    875          				case IP_DATA_FIRST_BYTE:
    876          				case IP_OPTION_FIRST_BYTE:
    877          
    878          					u_length = stSYS.RX_BUF[i][3];		// Length Byte Check
    879          
    880          					u_max = u_length + 6;
    881          					
    882          					for(j=0; j<u_max; j++)
    883          					{
    884          						stSYS.RX_BUF[0][j] = 0x00;
    885          					}
    886          
    887          					stSYS.RX_REORDERING = 0x00;
    888          					
    889          					break;
    890          
    891          				default:
    892          					break;
    893          			}			
    894          		}
    895          		else
    896          		{
    897          			for(i=1; i<SYS_RX_BUF_CNT; i++)
    898          			{
    899          				if(stSYS.RX_BUF[i][0] != 0x00)
    900          				{
    901          					u_buf = stSYS.RX_BUF[i][1];	// Command Byte Check
    902          					
    903          					switch(u_buf)
    904          					{
    905          						case TILT_FIRST_BYTE:
    906          						case IP_SONY_FIRST_BYTE:
    907          						case IP_TSM_FIRST_BYTE:
    908          						case IP_DRS_FIRST_BYTE:
    909          						case IP_PTZ_FIRST_BYTE:
    910          						case IP_DATA_FIRST_BYTE:
    911          						case IP_OPTION_FIRST_BYTE:
    912          
    913          							u_length = stSYS.RX_BUF[i][3];		// Length Byte Check
    914          
    915          							u_max = u_length + 6;
    916          							
    917          							for(j=0; j<u_max; j++)
    918          							{
    919          								stSYS.RX_BUF[i-1][j] = stSYS.RX_BUF[i][j];
    920          								if(stSYS.RX_INDEX > 0) stSYS.RX_BUF[stSYS.RX_INDEX - 1][j] = 0x00;
    921          							}
    922          
    923          							stSYS.RX_REORDERING = 0x00;
    924          							
    925          							break;
    926          
    927          						default:
    928          							break;
    929          
    930          					}
    931          				}
    932          			}
    933          		}
    934          		
    935          		stSYS.RX_COMPLETE = 0x00;
    936          		if(stSYS.RX_INDEX > 0) stSYS.RX_INDEX--;
    937          		
    938          	}
    939          }
    940          
    941          /*******************************************************************************
    942          * Function Name  : SYSTEM_Data_Handling
    943          *******************************************************************************/
    944          void SYSTEM_Data_Handling(void)
    945          {
    946          	if((stSYS.RX_BUF[0][0] != 0x00) && (stSYS.RX_COMPLETE == 0x00) && (stSYS.RX_PARITY == 0x00) && (stSYS.RX_REORDERING == 0x00))
    947          	{
    948          		stSYS.RX_PARITY = 0x01;
    949          	}
    950          }
    951          
    952          /*******************************************************************************
    953          * Function Name  : SYSTEM_Data_Handling
    954          *******************************************************************************/
    955          void SYSTEM_Data_Buffer(void)
    956          {
    957          	u8 i = 0x00, u_buf = 0x00, u_length = 0x00, u_max = 0x00;
    958          
    959          	if(stUSART1.RX_PARITY == 0x01)
    960          	{
    961          		u_buf = stUSART1.RX_BUF[0];
    962          
    963          		switch(u_buf)
    964          		{
    965          /*
    966          			case TILT_FIRST_BYTE:
    967          
    968          				u_length = stUSART1.RX_BUF[2];
    969          
    970          				u_max = u_length + 5;
    971          
    972          				stCOOR.RX_BUF[stCOOR.RX_INDEX][0] = stCOOR.RX_INDEX + 1;
    973          
    974          				for(i=0; i<u_max; i++)
    975          				{
    976          					stCOOR.RX_BUF[stCOOR.RX_INDEX][i+1] =  stUSART1.RX_BUF[i];
    977          					stUSART1.RX_BUF[i] = 0x00;
    978          				}
    979          
    980          				stCOOR.RX_INDEX++;
    981          				
    982          				break;
    983          */				
    984          			case TILT_FIRST_BYTE:
    985          			case IP_SONY_FIRST_BYTE:
    986          			case IP_TSM_FIRST_BYTE:
    987          			case IP_DRS_FIRST_BYTE:
    988          			case IP_PTZ_FIRST_BYTE:
    989          			case IP_DATA_FIRST_BYTE:
    990          			case IP_OPTION_FIRST_BYTE:
    991          
    992          				u_length = stUSART1.RX_BUF[2];
    993          
    994          				u_max = u_length + 5;
    995          
    996          				stSYS.RX_BUF[stSYS.RX_INDEX][0] = stSYS.RX_INDEX + 1;
    997          
    998          				for(i=0; i<u_max; i++)
    999          				{
   1000          					stSYS.RX_BUF[stSYS.RX_INDEX][i+1] =  stUSART1.RX_BUF[i];
   1001          					stUSART1.RX_BUF[i] = 0x00;
   1002          				}
   1003          
   1004          				stSYS.RX_INDEX++;
   1005          
   1006          				break;
   1007          
   1008          			default:
   1009          				break;
   1010          		}
   1011          
   1012          		stUSART1.RX_PARITY = 0x00;
   1013          
   1014          	}
   1015          }
   1016          
   1017          /*******************************************************************************
   1018          * Function Name  : SYSTEM_Data_Parser
   1019          *******************************************************************************/
   1020          void SYSTEM_Data_Parser(u8 u_port)
   1021          {
   1022          	switch(u_port)
   1023          	{
   1024          		case USART1_INDEX:
   1025          
   1026          			// =======================================
   1027          			// System Data Reordering
   1028          			// =======================================
   1029          			SYSTEM_Data_Reordering();
   1030          
   1031          			// =======================================
   1032          			// System Data Handling
   1033          			// =======================================
   1034          			SYSTEM_Data_Handling();
   1035          
   1036          			// =======================================
   1037          			// Rx Buffer Check & Data Trans
   1038          			// =======================================
   1039          			SYSTEM_Data_Buffer();
   1040          
   1041          			break;
   1042          
   1043          		default:
   1044          			break;
   1045          	}
   1046          }
   1047          
   1048          /****************************************************************************************************
   1049          * Function Name  : Boot_Status_Data_Trans
   1050          * Data Architecture :
   1051          BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]		BYTE5[LENGTH+4]
   1052          0xCA		0xAC		LENGTH		ADDR		COMM		DATA...		CS
   1053          0xCA		0xAC		0x04		0x01		0xD1		DATA...		CS
   1054          
   1055          DATA : 0x00: Nondata, 0x01: ACTIVE Status, 0x02 : Boot Ready Status
   1056          *****************************************************************************************************/
   1057          void Boot_Status_Data_Trans(void)
   1058          {
   1059          	u8 u_Cmd = TILT_BOOT_STATUS, u_Leng = 0x04, u_ID = MDIN_LAYER_CENTER_MSG;
   1060          
   1061          	switch(stSYS.BOOT_STATUS)
   1062          	{
   1063          		// TILT B/D 가 POWER OFF 인 경우
   1064          		case STOP:
   1065          			break;
   1066          
   1067          		// TILT B/D 가 MODULE 을 정상 경우
   1068          		case ACTIVE:
   1069          
   1070          			stUSART1.TX_BUF[0] = TILT_FIRST_BYTE;
   1071          			stUSART1.TX_BUF[1] = TILT_SECOND_BYTE;
   1072          			stUSART1.TX_BUF[2] = u_Leng;
   1073          			stUSART1.TX_BUF[3] = u_ID;
   1074          			stUSART1.TX_BUF[4] = u_Cmd;
   1075          			stUSART1.TX_BUF[5] = ACTIVE;
   1076          			stUSART1.TX_BUF[6] = 0x00;
   1077          			
   1078          			stUSART1.TX_BUF[7] = 0x00;		
   1079          			stUSART1.TX_BUF[7] = stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5] + stUSART1.TX_BUF[6];
   1080          
   1081          			stUSART1.TX_BUF[8] = 0xCF;
   1082          			
   1083          			stUSART1.TX_CNT = 0;
   1084          			stUSART1.TX_MAX = u_Leng + 5;
   1085          
   1086          			USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   1087          
   1088          			stSYS.BOOT_STATUS = STOP;
   1089          			
   1090          			break;
   1091          
   1092          		// TILT B/D 가 MODULE 을 정상 부팅 못하였을 경우 (MAIN으로 부터 체크 송신을 받았으나 MODULE 미인식, 데이터 비정상)
   1093          		case READY:
   1094          
   1095          			stUSART1.TX_BUF[0] = TILT_FIRST_BYTE;
   1096          			stUSART1.TX_BUF[1] = TILT_SECOND_BYTE;
   1097          			stUSART1.TX_BUF[2] = u_Leng;
   1098          			stUSART1.TX_BUF[3] = u_ID;
   1099          			stUSART1.TX_BUF[4] = u_Cmd;
   1100          			stUSART1.TX_BUF[5] = READY;
   1101          			stUSART1.TX_BUF[6] = 0x00;
   1102          			
   1103          			stUSART1.TX_BUF[7] = 0x00;		
   1104          			stUSART1.TX_BUF[7] = stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5] + stUSART1.TX_BUF[6];
   1105          
   1106          			stUSART1.TX_BUF[8] = 0xCF;
   1107          
   1108          			stUSART1.TX_CNT = 0;
   1109          			stUSART1.TX_MAX = u_Leng + 5;
   1110          
   1111          			USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   1112          
   1113          			stSYS.BOOT_STATUS = STOP;
   1114          		
   1115          			break;
   1116          
   1117          		default:
   1118          			break;
   1119          	}
   1120          }
   1121          
   1122          /*******************************************************************************
   1123          * Function Name  : TIM4_IRQHandler
   1124          * Description    : This function handles TIM4 global interrupt request.
   1125          * Input          : None
   1126          * Output         : None
   1127          * Return         : None
   1128          * Timer		: 1ms
   1129          *******************************************************************************/
   1130          void TIM4_IRQHandler(void)
   1131          {
   1132          	if (TIM_GetITStatus(TIM4, TIM_IT_Update) != RESET)
   1133          	{
   1134          		
   1135          		TIM_ClearITPendingBit(TIM4, TIM_IT_Update);
   1136          		LED_On_Red();
   1137          		LED_Off_Red();
   1138          		
   1139          
   1140          
   1141          
   1142          //			if(stSYS.START == ACTIVE)
   1143          //			{
   1144          //				SYSTEM_Data_Parser(USART1_INDEX);
   1145          //			}
   1146          //			else
   1147          //			{
   1148          //				Boot_Status_Data_Trans();
   1149          //			}
   1150          	}
   1151          
   1152          }//End Of The TIM4_IRQ_Handler
   1153          
   1154          /*******************************************************************************
   1155          * Function Name  : I2C1_EV_IRQHandler
   1156          * Description    : This function handles I2C1 Event interrupt request.
   1157          * Input          : None
   1158          * Output         : None
   1159          * Return         : None
   1160          *******************************************************************************/
   1161          void I2C1_EV_IRQHandler(void)
   1162          {
   1163          }
   1164          
   1165          /*******************************************************************************
   1166          * Function Name  : I2C1_ER_IRQHandler
   1167          * Description    : This function handles I2C1 Error interrupt request.
   1168          * Input          : None
   1169          * Output         : None
   1170          
   1171          * Return         : None
   1172          *******************************************************************************/
   1173          void I2C1_ER_IRQHandler(void)
   1174          {
   1175          }
   1176          
   1177          /*******************************************************************************
   1178          * Function Name  : I2C2_EV_IRQHandler
   1179          * Description    : This function handles I2C2 Event interrupt request.
   1180          * Input          : None
   1181          * Output         : None
   1182          * Return         : None
   1183          *******************************************************************************/
   1184          void I2C2_EV_IRQHandler(void)
   1185          {
   1186          }
   1187          
   1188          /*******************************************************************************
   1189          * Function Name  : I2C2_ER_IRQHandler
   1190          * Description    : This function handles I2C2 Error interrupt request.
   1191          * Input          : None
   1192          * Output         : None
   1193          * Return         : None
   1194          *******************************************************************************/
   1195          void I2C2_ER_IRQHandler(void)
   1196          {
   1197          }
   1198          
   1199          /*******************************************************************************
   1200          * Function Name  : SPI1_IRQHandler
   1201          * Description    : This function handles SPI1 global interrupt request.
   1202          * Input          : None
   1203          * Output         : None
   1204          * Return         : None
   1205          *******************************************************************************/
   1206          void SPI1_IRQHandler(void)
   1207          {
   1208          }
   1209          
   1210          /*******************************************************************************
   1211          * Function Name  : SPI2_IRQHandler
   1212          * Description    : This function handles SPI2 global interrupt request.
   1213          * Input          : None
   1214          * Output         : None
   1215          * Return         : None
   1216          *******************************************************************************/
   1217          void SPI2_IRQHandler(void)
   1218          {
   1219          }
   1220          
   1221          /*******************************************************************************
   1222          * Function Name  : USART1_IRQHandler
   1223          * Description    : This function handles USART1 global interrupt request.
   1224          * Input          : None
   1225          * Output         : None
   1226          * Return         : None
   1227          *******************************************************************************/
   1228          /*******************************************************************************
   1229          * Function Name  : USART2_IRQHandler
   1230          * Description    : This function handles USART2 global interrupt request.
   1231          * Input          : None
   1232          * Output         : None
   1233          * Return         : None
   1234          *******************************************************************************/
   1235          /*******************************************************************************
   1236          * Function Name  : USART3_IRQHandler
   1237          * Description    : This function handles USART3 global interrupt request.
   1238          * Input          : None
   1239          * Output         : None
   1240          * Return         : None
   1241          *******************************************************************************/
   1242          /*******************************************************************************
   1243          * Function Name  : EXTI15_10_IRQHandler
   1244          * Description    : This function handles External lines 15 to 10 interrupt request.
   1245          * Input          : None
   1246          * Output         : None
   1247          * Return         : None
   1248          *******************************************************************************/
   1249          void EXTI15_10_IRQHandler(void)
   1250          {
   1251          }
   1252          
   1253          /*******************************************************************************
   1254          * Function Name  : RTCAlarm_IRQHandler
   1255          * Description    : This function handles RTC Alarm interrupt request.
   1256          * Input          : None
   1257          * Output         : None
   1258          * Return         : None
   1259          *******************************************************************************/
   1260          void RTCAlarm_IRQHandler(void)
   1261          {
   1262          }
   1263          
   1264          /*******************************************************************************
   1265          * Function Name  : USBWakeUp_IRQHandler
   1266          * Description    : This function handles USB WakeUp interrupt request.
   1267          * Input          : None
   1268          * Output         : None
   1269          * Return         : None
   1270          *******************************************************************************/
   1271          /*
   1272          void USBWakeUp_IRQHandler(void)
   1273          {
   1274          #if 1
   1275              EXTI_ClearITPendingBit(EXTI_Line18);
   1276          #endif
   1277          }
   1278          */
   1279          
   1280          
   1281          /*******************************************************************************
   1282          * Function Name  : Rx_Second_Comm_Check
   1283          *******************************************************************************/
   1284          void Rx_Main_Second_Comm_Check(u8 u_buf, u8 u_andbyte)
   1285          {
   1286          	if(u_buf == u_andbyte)
   1287          	{
   1288          		stUSART1.RX_BUF[1] =  u_buf;
   1289          		stUSART1.RX_BUF_INDEX++;
   1290          		stUSART1.RX_BUF_LENGTH = 0x01;
   1291          	}
   1292          	else
   1293          	{
   1294          		stUSART1.RX_BUF_INDEX = 0x00;					// Index Clear
   1295          		stUSART1.RX_BUF[0] = 0x00;						// Buffer Clear
   1296          		stUSART1.RX_ENABLE = 0x00;						// Command Check Byte Clear
   1297          	}	
   1298          }
   1299          
   1300          /*******************************************************************************
   1301          * Function Name  : Boot_Status_Check_Parser
   1302          *******************************************************************************/
   1303          void Boot_Status_Check_Parser(void)
   1304          {
   1305          	if((stUSART1.RX_BUF[0] == TILT_FIRST_BYTE) && (stUSART1.RX_BUF[4] == TILT_BOOT_STATUS))
   1306          	{
   1307          		if(stSYS.START == STOP)
   1308          		{
   1309          			stSYS.BOOT_STATUS = READY;
   1310          		}
   1311          		/*
   1312          		else
   1313          		{
   1314          			stSYS.BOOT_STATUS = ACTIVE;
   1315          		}
   1316          		*/
   1317          	}
   1318          }
   1319          
   1320          /*******************************************************************************
   1321          * Function Name  : Rx_Main_Comm_Handling
   1322          *******************************************************************************/
   1323          void Rx_Main_Comm_Handling(u8 u_sync, u8 u_buf)	// u_port : Uart Port, u_sync : Sync Byte Check (0 : First Byte, 1 : Second Byte)
   1324          {
   1325          	// 첫번째 바이트 체크 (Sync Byte Check)
   1326          	if(u_sync == Rx_SYNC_BYTE)	
   1327          	{
   1328          		stUSART1.RX_BUF_INDEX = 0x00;	// Index Init
   1329          		stUSART1.RX_BUF[stUSART1.RX_BUF_INDEX] = u_buf;
   1330          		stUSART1.RX_BUF_INDEX++;
   1331          		
   1332          		#if(ERROR_CHECK_BUF)
   1333          		stERROR.RX_BUF[stERROR.RX_CNT++] = u_buf;
   1334          		if(stERROR.RX_CNT >= ERROR_DATA_MAX) stERROR.RX_CNT = 0;
   1335          		#endif
   1336          	}
   1337          
   1338          	// 두번째 바이트 체크 (Sync & Byte Check)
   1339          	if(u_sync == Rx_SYNC_AND_BYTE)
   1340          	{
   1341          		#if(ERROR_CHECK_BUF)	
   1342          		stERROR.RX_BUF[stERROR.RX_CNT++] = u_buf;
   1343          		if(stERROR.RX_CNT >= ERROR_DATA_MAX) stERROR.RX_CNT = 0;
   1344          		#endif		
   1345          		
   1346          		// 두번째 명령어 체크 (Sync & Byte Check)
   1347          		if(stUSART1.RX_BUF_INDEX == 0x01)
   1348          		{
   1349          			switch(stUSART1.RX_ENABLE)
   1350          			{
   1351          				case TILT_SECOND_BYTE:
   1352          					Rx_Main_Second_Comm_Check(u_buf, TILT_SECOND_BYTE);
   1353          					break;
   1354          
   1355          				case IP_SONY_SECOND_BYTE:
   1356          					Rx_Main_Second_Comm_Check(u_buf, IP_SONY_SECOND_BYTE);
   1357          					break;
   1358          					
   1359          				case IP_TSM_SECOND_BYTE:
   1360          					Rx_Main_Second_Comm_Check(u_buf, IP_TSM_SECOND_BYTE);
   1361          					break;
   1362          
   1363          				default:
   1364          					break;
   1365          			}
   1366          		}	
   1367          	}
   1368          
   1369          	// 세번째 바이트 체크 (Data Length)
   1370          	if(u_sync == Rx_LENGTH_BYTE)
   1371          	{
   1372          		#if(ERROR_CHECK_BUF)	
   1373          		stERROR.RX_BUF[stERROR.RX_CNT++] = u_buf;
   1374          		if(stERROR.RX_CNT >= ERROR_DATA_MAX) stERROR.RX_CNT = 0;
   1375          		#endif
   1376          		
   1377          		if(stUSART1.RX_ENABLE == IP_PELCO_CHK_BYTE)
   1378          		{
   1379          			// PELCO-D Command 예외처리
   1380          			if(stUSART1.RX_BUF_INDEX == 0x02)
   1381          			{
   1382          				stUSART1.RX_BUF_LENGTH = 0x02;
   1383          				stUSART1.RX_BUF_MAX = stUSART1.RX_BUF_LENGTH + 5;
   1384          				
   1385          				stUSART1.RX_BUF[2] =  u_buf;
   1386          				
   1387          				stUSART1.RX_BUF_INDEX++;
   1388          			}					
   1389          		}
   1390          		else
   1391          		{
   1392          			// 세번째 데이터 길이 체크 (Sync & Byte Check)
   1393          			if(stUSART1.RX_BUF_INDEX == 0x02)
   1394          			{
   1395          				stUSART1.RX_BUF_LENGTH = u_buf;
   1396          				stUSART1.RX_BUF_MAX = stUSART1.RX_BUF_LENGTH + 5;
   1397          				
   1398          				stUSART1.RX_BUF[2] =  u_buf;
   1399          				
   1400          				stUSART1.RX_BUF_INDEX++;
   1401          			}
   1402          		}
   1403          	}	
   1404          
   1405          	// 데이터 누적
   1406          	if(u_sync == Rx_DATA_BYTE)
   1407          	{
   1408          		#if(ERROR_CHECK_BUF)
   1409          		stERROR.RX_BUF[stERROR.RX_CNT++] = u_buf;
   1410          		if(stERROR.RX_CNT >= ERROR_DATA_MAX) stERROR.RX_CNT = 0;
   1411          		#endif		
   1412          		
   1413          		stUSART1.RX_BUF[stUSART1.RX_BUF_INDEX] = u_buf;
   1414          
   1415          		stUSART1.RX_BUF_INDEX++;	
   1416          		
   1417          		if(stUSART1.RX_BUF_INDEX == stUSART1.RX_BUF_MAX)
   1418          		{
   1419          			// PELCO-D Command 예외처리
   1420          			if(stUSART1.RX_ENABLE == IP_PELCO_CHK_BYTE)
   1421          			{
   1422          				Rx_Pelco_Data_Check();
   1423          			}
   1424          			else
   1425          			{
   1426          				if((stUSART1.RX_BUF[stUSART1.RX_BUF_INDEX - 1]&0x0F) == 0x0F)		// End Byte Check
   1427          				{
   1428          					if(stSYS.START == ACTIVE)
   1429          					{
   1430          						stUSART1.RX_PARITY = 0x01;	// 정상 데이터 수신 (0x00: Nondata(수신대기), 0x01: 정상데이터, 0xFF, 비정상 데이터, 0xFE = Boot Check)
   1431          						stUSART1.RX_PARITY_CNT++;
   1432          						
   1433          						// DEBUG 데이터 체크 ======================================================/
   1434          						//stERROR.PARITY_CNT_CHECK++;
   1435          						//if(stERROR.PARITY_CNT_CHECK == 0x01) stERROR.TIMER_CHECK_FLAG = 0x01;
   1436          						//if(stERROR.PARITY_CNT_CHECK == 0x02) stERROR.TIMER_CHECK_FLAG = 0x00;
   1437          						// DEBUG 데이터 체크 ===================================================END/
   1438          						
   1439          						//if(stUSART1.RX_PRIORITY == 0x00) stUSART1.RX_PRIORITY = 0x01;
   1440          					}
   1441          					else
   1442          					{
   1443          						Boot_Status_Check_Parser();
   1444          					}
   1445          
   1446          					stUSART1.RX_BUF_INDEX = 0x00;	// Index Init
   1447          					//stUSART1.RX_BUF[stUSART1.RX_BUF_INDEX] = stUSART1.RX_PRIORITY++;
   1448          				}
   1449          				else
   1450          				{
   1451          					stUSART1.RX_PARITY = 0xFF;	// 비정상 데이터 수신 (0x00: Nondata(수신대기), 0x01: 정상데이터, 0xFF, 비정상 데이터, 0xFE = Boot Check)
   1452          					stUSART1.RX_ERROR_CNT++;
   1453          				}
   1454          			}
   1455          			
   1456          			stUSART1.RX_BUF_INDEX = 0x00;
   1457          			stUSART1.RX_BUF_LENGTH = 0x00;
   1458          			
   1459          			stUSART1.RX_ENABLE = 0x00;
   1460          		}
   1461          	}		
   1462          }
   1463          
   1464          /*******************************************************************************
   1465          * Function Name  : Main_Protocol_Data_Pasher
   1466          * Description    : This function handles USART1 interrupt request.
   1467          * Input           : Main - PA10 USART1_RX
   1468          * Output         : Main - PA9 USART1_TX
   1469          *******************************************************************************/
   1470          void Main_Protocol_Data_Pasher(u8 u_buf)
   1471          {
   1472          	u8 u_Index_Chk = 0;
   1473          
   1474          	if(stUSART1.RX_ENABLE == 0x00)
   1475          	{
   1476          		// 첫번째 바이트 체크 (Sync Byte Check)
   1477          		switch(u_buf)
   1478          		{
   1479          			case TILT_FIRST_BYTE:
   1480          				Rx_Main_Comm_Handling(Rx_SYNC_BYTE, TILT_FIRST_BYTE);
   1481          				stUSART1.RX_ENABLE = TILT_SECOND_BYTE;
   1482          				break;
   1483          
   1484          			case IP_SONY_FIRST_BYTE:
   1485          				Rx_Main_Comm_Handling(Rx_SYNC_BYTE, IP_SONY_FIRST_BYTE);
   1486          				stUSART1.RX_ENABLE = IP_SONY_SECOND_BYTE;
   1487          				break;
   1488          
   1489          			case IP_TSM_FIRST_BYTE:
   1490          				Rx_Main_Comm_Handling(Rx_SYNC_BYTE, IP_TSM_FIRST_BYTE);
   1491          				stUSART1.RX_ENABLE = IP_TSM_SECOND_BYTE;
   1492          				break;
   1493          
   1494          			default:
   1495          				break;
   1496          		}
   1497          	}
   1498          	else
   1499          	{
   1500          		if(stUSART1.RX_BUF_LENGTH == 0x00) u_Index_Chk = Rx_SYNC_AND_BYTE;
   1501          		else 
   1502          		{
   1503          			if(stUSART1.RX_BUF_INDEX >= 0x03)
   1504          			{
   1505          				u_Index_Chk = Rx_DATA_BYTE;
   1506          			}
   1507          			else
   1508          			{
   1509          				if(stUSART1.RX_STATUS == 0x00)
   1510          				{
   1511          					u_Index_Chk = Rx_LENGTH_BYTE;
   1512          				}
   1513          			}
   1514          		}
   1515          
   1516          		// 두번째, 세번째 바이트 체크 (Rx_SYNC_AND_BYTE : Sync & Byte Check, Rx_LENGTH_BYTE : Length Check)
   1517          		Rx_Main_Comm_Handling(u_Index_Chk, u_buf);
   1518          	}
   1519          }
   1520          
   1521          /*******************************************************************************
   1522          * Function Name  : Sony_Data_Pasher
   1523          * Description    : This function handles USART1 interrupt request.
   1524          * Input           : Main - PA10 USART1_RX
   1525          * Output         : Main - PA9 USART1_TX
   1526          *******************************************************************************/
   1527          void Sony_Data_Pasher(u8 u_buf)
   1528          {
   1529          	if(stBYPASS.RX_STATUS)
   1530          	{
   1531          		stBYPASS.RX_BUF[stBYPASS.RX_CNT++] = u_buf;
   1532          
   1533          		if(u_buf == 0xFF)
   1534          		{
   1535          			stBYPASS.RX_STATUS = 0x00;
   1536          			stBYPASS.RX_CNT = 0x00;
   1537          			stBYPASS.RX_PARITY = 0x01;			
   1538          		}
   1539          	}
   1540          	else
   1541          	{
   1542          		if(u_buf == SONY_FIRST_BYTE)
   1543          		{
   1544          			stBYPASS.RX_STATUS = 0x01;
   1545          			stBYPASS.RX_BUF[0] = u_buf;
   1546          			stBYPASS.RX_CNT++;
   1547          			
   1548          		}
   1549          	}
   1550          }
   1551          
   1552          /*******************************************************************************
   1553          * Function Name  : USART1_IRQHandler
   1554          * Description    : This function handles USART1 interrupt request.
   1555          * Input           : Main - PA10 USART1_RX
   1556          * Output         : Main - PA9 USART1_TX
   1557          *******************************************************************************/
   1558          void USART1_IRQHandler(void)
   1559          {
   1560          	u8 Rx_Buf = 0x00;
   1561          	
   1562            	// =======================================
   1563            	// USART1 TX Process : TILT -> MAIN Board
   1564            	// =======================================
   1565          	if (USART_GetITStatus(USART1, USART_IT_TC) != RESET)
   1566          	{
   1567          		if (stUSART1.TX_CNT < stUSART1.TX_MAX) 
   1568          		{
   1569          			USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   1570          		}
   1571          		else 
   1572          		{
   1573          			stUSART1.TX_MAX = 0;
   1574          			stUSART1.TX_CNT = 0;
   1575          		}
   1576          		
   1577          		USART_ClearITPendingBit(USART1, USART_IT_TC);
   1578          	}
   1579          
   1580            	// =======================================
   1581            	// USART1 RX Process : TILT <- MAIN Board
   1582            	// =======================================
   1583          	if (USART_GetITStatus(USART1, USART_IT_RXNE) != RESET)
   1584          	{
   1585          		Rx_Buf = USART_ReceiveData(USART1);
   1586          
   1587          		Main_Protocol_Data_Pasher(Rx_Buf);
   1588          		
   1589          		//Sony_Data_Pasher(Rx_Buf);
   1590          
   1591          		//if(stUSART_ERROR.RX_CNT == UART4_RX_BUF_MAX) stUSART_ERROR.RX_CNT = 0;
   1592          
   1593          		//stUSART_ERROR.RX_BUF[stUSART_ERROR.RX_CNT++] = Rx_Buf;
   1594          	}
   1595          }
   1596          
   1597          /*******************************************************************************
   1598          * Function Name  : LRF_Data_Clear
   1599          *******************************************************************************/
   1600          void LRF_Data_Clear(void)
   1601          {
   1602          	u8 i;
   1603          	
   1604          	for(i=0; i<LRF_RX_BUF_MAX; i++)
   1605          	{
   1606          		stLRF.RX_BUF[i] = 0x00;
   1607          	}
   1608          }
   1609          
   1610          /*******************************************************************************
   1611          * Function Name  : LRF_Trans_Data
   1612          *******************************************************************************/
   1613          void LRF_Trans_Data(void)
   1614          {
   1615          	u8 i;
   1616          
   1617          	if(stBYPASS.TX_FLAG == 0x00)
   1618          	{
   1619          		for(i=0; i<LRF_RX_BUF_MAX; i++)
   1620          		{
   1621          			stUSART1.TX_BUF[i] = stLRF.RX_BUF[i];
   1622          		}
   1623          
   1624          		stUSART1.TX_CNT = 0;
   1625          		stUSART1.TX_MAX = 21;
   1626          		
   1627          		USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   1628          	}
   1629          	
   1630          }
   1631          
   1632          /************************************************************************************
   1633          * Function Name  : LRF_Data_Pasher
   1634          * Description    : This function handles USART2 interrupt request.
   1635          * Input           : LRF - PA10 USART2_RX
   1636          * Output         : LRF - PA9 USART2_TX
   1637          -------------------------------------------------------------------------------------
   1638          * LRF 출력데이터 예제
   1639          [00]	[01]	[02]	[03]	[04]	[05]	[06]	[07]	[08]	[09]	[10]	[11]	[12]	[13]	[14]	[15]	[16]	[17]	[18]	[19]	[20]
   1640          44	4D	20	31	20	30	30	30	38	2E	36	20	20	39	39	39	20	33	31	0D	0A
   1641          D	M		1		0	0	0	8	.	6			9	9	9		3	1		
   1642          *************************************************************************************/
   1643          void LRF_Data_Pasher(u8 u_Data)
   1644          {
   1645          	// LRF <-> TILT
   1646          	switch(stDIP.MODE2)
   1647          	{
   1648          		case LRF_MODE:
   1649          
   1650          			// Data Compare Check
   1651          			if(stLRF.RX_CNT == 0x14)
   1652          			{
   1653          				if((stLRF.RX_BUF[0] == LRF_BYTE_1) && (stLRF.RX_BUF[1] == LRF_BYTE_2) && (stLRF.RX_BUF[19] == LRF_BYTE_END))
   1654          				{
   1655          					LRF_Trans_Data();
   1656          				}
   1657          
   1658          				LRF_Data_Clear();
   1659          				stLRF.RX_CNT = 0;
   1660          				stLRF.RX_END_FLAG = 0x01;
   1661          			}
   1662          
   1663          			// Data Save
   1664          			if(stLRF.RX_CNT >= 0x02)
   1665          			{
   1666          				stLRF.RX_BUF[stLRF.RX_CNT] = u_Data;
   1667          				stLRF.RX_CNT++;
   1668          			}
   1669          
   1670          			if(stLRF.RX_END_FLAG == 0x00)
   1671          			{
   1672          				// Second Data Check
   1673          				if((u_Data == LRF_BYTE_2) && (stLRF.RX_CNT == 1))
   1674          				{
   1675          					stLRF.RX_BUF[1] = LRF_BYTE_2;
   1676          					stLRF.RX_CNT++;
   1677          				}			
   1678          
   1679          				// First Data Check
   1680          				if((u_Data == LRF_BYTE_1) && (stLRF.RX_CNT == 0))
   1681          				{
   1682          					stLRF.RX_BUF[0] = LRF_BYTE_1;
   1683          					stLRF.RX_CNT++;
   1684          				}
   1685          			}
   1686          			else
   1687          			{
   1688          				stLRF.RX_END_FLAG = 0x00;
   1689          			}
   1690          
   1691          			if(stLRF.RX_CNT >= LRF_RX_BUF_MAX) 
   1692          			{
   1693          				stLRF.RX_CNT = 0;
   1694          				LRF_Data_Clear();
   1695          			}
   1696          			
   1697          			break;
   1698          	}
   1699          }
   1700          
   1701          /*******************************************************************************
   1702          * Function Name  : USART2_IRQHandler
   1703          * Description    : This function handles USART2 interrupt request.
   1704          * Input           : MDIN - PA3 USART2_RX
   1705          * Output         : MDIN - PA2 USART2_TX
   1706          *******************************************************************************/
   1707          void USART2_IRQHandler(void)
   1708          {
   1709          	u8 Rx_Buf = 0x00, Tx_Buf = 0x00;	
   1710          
   1711          	// =======================================
   1712          	// USART2 TX Process 
   1713          	// =======================================
   1714          	if (USART_GetITStatus(USART2, USART_IT_TC) != RESET)
   1715          	{
   1716          
   1717          		if(stUSART2.TX_CNT < stUSART2.TX_MAX)
   1718          		{
   1719          			Tx_Buf = stUSART2.TX_BUF[stUSART2.TX_CNT];
   1720          			stUSART2.TX_CNT++;				
   1721          
   1722          			USART_SendData(USART2, Tx_Buf);
   1723          		}
   1724          		else
   1725          		{
   1726          			stUSART2.TX_CNT = 0x00;
   1727          			stUSART2.TX_MAX = 0x00;
   1728          		}
   1729          
   1730          		USART_ClearITPendingBit(USART2, USART_IT_TC);
   1731          
   1732          	}
   1733          
   1734          	// =======================================
   1735          	// USART2 RX Process
   1736          	// =======================================
   1737          	if (USART_GetITStatus(USART2, USART_IT_RXNE) != RESET)
   1738          	{
   1739          		Rx_Buf = USART_ReceiveData(USART2);
   1740          	}     
   1741          }
   1742          
   1743          /*******************************************************************************
   1744          * Function Name  : USART3_IRQHandler
   1745          * Description    : This function handles USART1 interrupt request.
   1746          * Input           : Camera - PB11 USART3_RX
   1747          * Output         : Camera - PB10 USART3_TX
   1748          *******************************************************************************/
   1749          void USART3_IRQHandler(void)
   1750          {
   1751          	u8 Rx_Buf = 0x00, Tx_Buf = 0x00;	
   1752          
   1753            	// =======================================
   1754            	// USART3 TX Process 
   1755            	// =======================================
   1756          	if (USART_GetITStatus(USART3, USART_IT_TC) != RESET)
   1757          	{ 
   1758          		USART_SendData(USART3, Tx_Buf);
   1759          		
   1760          		USART_ClearITPendingBit(USART3, USART_IT_TC);
   1761          	}
   1762          	
   1763            	// =======================================
   1764            	// USART3 RX Process
   1765            	// =======================================
   1766          	if (USART_GetITStatus(USART3, USART_IT_RXNE) != RESET)
   1767          	{
   1768          		Rx_Buf = USART_ReceiveData(USART3);
   1769          	}
   1770          
   1771          }
   1772          
   1773          /*******************************************************************************
   1774          * Function Name  : SONY_Data_Clear
   1775          *******************************************************************************/
   1776          void SONY_Data_Clear(void)
   1777          {
   1778          	u8 i;
   1779          	
   1780          	for(i=0; i<SONY_RX_BUF_MAX; i++)
   1781          	{
   1782          		stSONY.RX_BUF[i] = 0x00;
   1783          	}
   1784          }
   1785          
   1786          /*******************************************************************************
   1787          * Function Name  : TSM_Data_Pasher
   1788          *******************************************************************************/
   1789          void TSM_Data_Pasher(u8 u_Buf)
   1790          {
   1791          	u8 i = 0;
   1792          	u8 u_Data_P1 = 0x00, u_Data_P2 = 0x00;
   1793          	u16 u16_Convert_Data = 0x0000;
   1794          	u8 u_Convert_Data  = 0x00;	
   1795          
   1796          	if(stUART4.RX_ENABLE == 0x01)
   1797          	{
   1798          		stUART4.RX_BUF[stUART4.RX_CNT++] = u_Buf;
   1799          
   1800          		if(stUART4.RX_BUF_MAX == 0x00)
   1801          		{
   1802          			switch(stUART4.RX_BUF[1])
   1803          			{
   1804          				case TSM_CALL_ALL_TEMPERATURE:
   1805          					stUART4.RX_BUF_MAX = 0x23;
   1806          					break;
   1807          
   1808          				case TSM_CALL_FIRMWARE_VERSION:
   1809          					stUART4.RX_BUF_MAX = 0x08;
   1810          					break;
   1811          
   1812          				case TCM_COOLER_RUNTIME_INQ:
   1813          					if(stINFO.THERMAL_MODEL == TCM_640)
   1814          					{
   1815          						stUART4.RX_BUF_MAX = 0x07;
   1816          					}
   1817          					break;
   1818          
   1819          				default:
   1820          					stUART4.RX_BUF_MAX = 0x06;
   1821          					break;
   1822          			}
   1823          		}
   1824          
   1825          		// Rx Data Check & Initialization
   1826          		if((stUART4.RX_CNT == stUART4.RX_BUF_MAX) && (u_Buf == 0xAF))
   1827          		{
   1828          			switch(stUART4.RX_BUF_MAX)
   1829          			{
   1830          				case 0x06:
   1831          
   1832          					switch(stUART4.RX_REQUEST_CMD)
   1833          					{
   1834          						case TSM_CALL_MODULE_STATUS:
   1835          
   1836          							if(stUART4.RX_BUF[1] == TSM_CALL_MODULE_STATUS)
   1837          							{
   1838          								u_Data_P1 = stUART4.RX_BUF[2];
   1839          
   1840          								if(u_Data_P1) 
   1841          								{
   1842          									stTSM.MODULE_ENABLE = 0x01;
   1843          								}
   1844          								
   1845          								stTSM.MODULE_STATUS = u_Data_P1;
   1846          								stINFO.MODULE_TYPE = TSM_MODULE;
   1847          
   1848          								stUART4.RX_REQUEST_CMD = 0x00;
   1849          							}
   1850          								
   1851          							break;
   1852          							
   1853          						case TSM_CALL_DIGITAL_ZOOM_POSITION:
   1854          
   1855          							if(stUART4.RX_BUF[1] == TSM_CALL_DIGITAL_ZOOM_POSITION)
   1856          							{
   1857          								u_Data_P1 = stUART4.RX_BUF[4];
   1858          								u16_Convert_Data |= u_Data_P1;
   1859          								stTSM.ZOOM_DATA = u16_Convert_Data;
   1860          
   1861          								stTSM.ZOOM_CNT = stTSM.ZOOM_DATA;
   1862          
   1863          								stUART4.RX_REQUEST_CMD = 0x00;
   1864          							}
   1865          
   1866          							break;
   1867          
   1868          						case TSM_CALL_OPTICAL_ZOOM_POSITION:
   1869          							break;
   1870          
   1871          						case TSM_CALL_TOTAL_ZOOM_POSITION:
   1872          							
   1873          							if(stUART4.RX_BUF[1] == TSM_CALL_TOTAL_ZOOM_POSITION)
   1874          							{
   1875          								u_Data_P1 = stUART4.RX_BUF[2];
   1876          								u_Data_P2 = stUART4.RX_BUF[3];
   1877          
   1878          								u16_Convert_Data = u_Data_P1 << 8;
   1879          								u16_Convert_Data |= u_Data_P2;
   1880          
   1881          								stTSM.ZOOM_CNT = u16_Convert_Data;
   1882          
   1883          								stUART4.RX_REQUEST_CMD = 0x00;
   1884          								stUART4.RX_REQUEST_COMPLETE = TSM_CALL_TOTAL_ZOOM_POSITION;
   1885          							}
   1886          							
   1887          							break;
   1888          
   1889          						case TSM_CALL_FOCUS_POSITION:
   1890          
   1891          							if(stUART4.RX_BUF[1] == TSM_CALL_FOCUS_POSITION)
   1892          							{
   1893          								u_Data_P1 = stUART4.RX_BUF[2];
   1894          								u_Data_P2 = stUART4.RX_BUF[3];
   1895          
   1896          								u16_Convert_Data = u_Data_P1 << 8;
   1897          								u16_Convert_Data |= u_Data_P2;
   1898          
   1899          								stTSM.FOCUS_CNT = u16_Convert_Data;
   1900          
   1901          								stUART4.RX_REQUEST_CMD = 0x00;
   1902          								stUART4.RX_REQUEST_COMPLETE = TSM_CALL_FOCUS_POSITION;								
   1903          							}
   1904          							
   1905          							break;
   1906          
   1907          						case TSM_CALL_PRODUCT_IDENTIFICATION:
   1908          
   1909          							if(stUART4.RX_BUF[1] == TSM_CALL_PRODUCT_IDENTIFICATION)
   1910          							{
   1911          								// Camera Information Data Check							
   1912          								stINFO.THERMAL_MODEL = stUART4.RX_BUF[2];
   1913          								stINFO.THERMAL_LENS = stUART4.RX_BUF[4];
   1914          								
   1915          								stUART4.RX_REQUEST_CMD = 0x00;
   1916          							}
   1917          							
   1918          							break;
   1919          
   1920          						case TSM_CALL_CAMERA_INFORMATION:
   1921          
   1922          							if(stUART4.RX_BUF[1] == TSM_CALL_CAMERA_INFORMATION)
   1923          							{
   1924          								// Camera Information Data Check
   1925          								stINFO.THERMAL_VER_HIGH = stUART4.RX_BUF[3];
   1926          								stINFO.THERMAL_VER_LOW = stUART4.RX_BUF[4];
   1927          								
   1928          								stUART4.RX_REQUEST_CMD = 0x00;
   1929          							}
   1930          							
   1931          							break;
   1932          
   1933          						case TSM_CALL_FPGA_VERSION:
   1934          
   1935          							if(stUART4.RX_BUF[1] == TSM_CALL_FPGA_VERSION)
   1936          							{
   1937          								stINFO.FPGA_VERSION_HIGH = stUART4.RX_BUF[2];
   1938          								stINFO.FPGA_VERSION_LOW = stUART4.RX_BUF[3];
   1939          
   1940          								stUART4.RX_REQUEST_CMD = 0x00;
   1941          							}
   1942          							
   1943          							break;
   1944          							
   1945          						case TSM_CALL_TEMPERATURE_MODE:
   1946          
   1947          							if(stUART4.RX_BUF[1] == TSM_CALL_TEMPERATURE_MODE)
   1948          							{
   1949          								// Camera Information Data Check
   1950          								stINFO.THERMAL_TEMP_MODE = stUART4.RX_BUF[2];
   1951          								
   1952          								stUART4.RX_REQUEST_CMD = 0x00;
   1953          							}
   1954          							
   1955          							break;
   1956          
   1957          						case TCM_TOTAL_ZOOM_POSITION_INQ:
   1958          
   1959          							if(stUART4.RX_BUF[1] == TCM_TOTAL_ZOOM_POSITION_INQ)
   1960          							{
   1961          								u_Data_P1 = stUART4.RX_BUF[2];
   1962          								u_Data_P2 = stUART4.RX_BUF[3];
   1963          
   1964          								u16_Convert_Data = u_Data_P1 << 8;
   1965          								u16_Convert_Data |= u_Data_P2;
   1966          
   1967          								stTSM.ZOOM_DATA = u16_Convert_Data;
   1968          
   1969          								stTSM.ZOOM_CNT = stTSM.ZOOM_DATA;
   1970          
   1971          								stUART4.RX_REQUEST_CMD = 0x00;
   1972          							}
   1973          							
   1974          							break;
   1975          
   1976          						case TCM_GET_FW_UPDATE_INQ:
   1977          
   1978          							if(stUART4.RX_BUF[1] == TCM_GET_FW_UPDATE_INQ)
   1979          							{
   1980          								stINFO.THERMAL_YEAR = stUART4.RX_BUF[2];
   1981          								stINFO.THERMAL_MONTH = stUART4.RX_BUF[3];
   1982          								stINFO.THERMAL_DAY = stUART4.RX_BUF[4];
   1983          									
   1984          								stUART4.RX_REQUEST_CMD = 0x00;
   1985          							}
   1986          							
   1987          							break;
   1988          
   1989          						case TCM_GET_ENGINE_VERSION:
   1990          
   1991          							if(stUART4.RX_BUF[1] == TCM_GET_ENGINE_VERSION)
   1992          							{
   1993          								stINFO.THERMAL_ENGINE_VER_HW = stUART4.RX_BUF[2];
   1994          								stINFO.THERMAL_ENGINE_VER_FW = stUART4.RX_BUF[3];
   1995          
   1996          								stUART4.RX_REQUEST_CMD = 0x00;
   1997          							}
   1998          							
   1999          							break;		
   2000          
   2001          						case TCM_FOCUS_POSITION_INQ:
   2002          
   2003          							if(stUART4.RX_BUF[1] == TCM_FOCUS_POSITION_INQ)
   2004          							{
   2005          								u_Data_P1 = stUART4.RX_BUF[2];
   2006          								u_Data_P2 = stUART4.RX_BUF[3];
   2007          
   2008          								u16_Convert_Data = u_Data_P1 << 8;
   2009          								u16_Convert_Data |= u_Data_P2;
   2010          
   2011          								stTSM.FOCUS_CNT = u16_Convert_Data;
   2012          
   2013          								stUART4.RX_REQUEST_CMD = 0x00;
   2014          							}
   2015          
   2016          							break;	
   2017          
   2018          						default:
   2019          							break;
   2020          					}
   2021          						
   2022          					break;
   2023          
   2024          				case 0x07:
   2025          					switch(stUART4.RX_REQUEST_CMD)
   2026          					{
   2027          						case TCM_COOLER_RUNTIME_INQ:
   2028          
   2029          								stINFO.THERMAL_ENGINE_TIME_DAY= 0x0000;
   2030          								stINFO.THERMAL_ENGINE_TIME_DAY |= (stUART4.RX_BUF[2]<<8);
   2031          								stINFO.THERMAL_ENGINE_TIME_DAY |= (stUART4.RX_BUF[3]&0xFF);
   2032          
   2033          								stINFO.THERMAL_ENGINE_TIME_HOUR = 0x0000;
   2034          								stINFO.THERMAL_ENGINE_TIME_HOUR |= (stUART4.RX_BUF[4]<<8);
   2035          								stINFO.THERMAL_ENGINE_TIME_HOUR |= (stUART4.RX_BUF[5]&0xFF);
   2036          
   2037          								stINFO.THERMAL_ENGINE_DAY_HIGH = stUART4.RX_BUF[2];
   2038          								stINFO.THERMAL_ENGINE_DAY_LOW = stUART4.RX_BUF[3];
   2039          								stINFO.THERMAL_ENGINE_HOUR_HIGH = stUART4.RX_BUF[4];
   2040          								stINFO.THERMAL_ENGINE_HOUR_LOW = stUART4.RX_BUF[5];								
   2041          								
   2042          								stINFO.TCM640_ENGINE_RUNTIME_COMPLETE = TRUE;
   2043          								
   2044          								stUART4.RX_REQUEST_CMD = 0x00;	
   2045          
   2046          							break;
   2047          					}
   2048          					break;
   2049          					
   2050          				case 0x08:
   2051          					
   2052          					switch(stUART4.RX_REQUEST_CMD)
   2053          					{
   2054          						case TSM_CALL_FIRMWARE_VERSION:
   2055          
   2056          							if(stUART4.RX_BUF[1] == TSM_CALL_FIRMWARE_VERSION)
   2057          							{
   2058          								// Camera Information Data Check
   2059          								stINFO.THERMAL_DAY = stUART4.RX_BUF[4];
   2060          								stINFO.THERMAL_MONTH = stUART4.RX_BUF[5];
   2061          								stINFO.THERMAL_YEAR = stUART4.RX_BUF[6];
   2062          								
   2063          								stUART4.RX_REQUEST_CMD = 0x00;
   2064          							}
   2065          							
   2066          							break;
   2067          
   2068          						default:
   2069          							break;
   2070          					}
   2071          							
   2072          					break;
   2073          					
   2074          				case 0x23:
   2075          					
   2076          					//stTEMP.TEMPERATURE_READ_COMPLETE = 0x01;	// 온도 체크 데이터 수신 완료.
   2077          					
   2078          					break;
   2079          
   2080          				default:
   2081          					break;
   2082          			}
   2083          		
   2084          			for(i=0;i<stUART4.RX_BUF_MAX;i++)
   2085          			{
   2086          				//stTEMP.RX_BUF[i] = stUART4.RX_BUF[i];
   2087          				stUART4.RX_BUF[i] = 0x00;
   2088          			}
   2089          
   2090          			stUART4.RX_ENABLE = 0x00;
   2091          			stUART4.RX_CNT = 0x00;
   2092          			stUART4.RX_BUF_MAX = 0x00;
   2093          			stUART4.RX_PARITY = 0x01;
   2094          			
   2095          		}
   2096          		else if((stUART4.RX_CNT == stUART4.RX_BUF_MAX) && (u_Buf != 0xAF))
   2097          		{
   2098          			for(i=0;i<stUART4.RX_CNT;i++)
   2099          			{
   2100          				stUART4.RX_BUF[i] = 0x00;
   2101          			}
   2102          
   2103          			stUART4.RX_ENABLE = 0x00;
   2104          			stUART4.RX_CNT = 0x00;
   2105          			stUART4.RX_BUF_MAX = 0x00;
   2106          			stUART4.RX_REQUEST_ERROR = 0x01;			
   2107          		}
   2108          	}
   2109          
   2110          	if((stUART4.RX_ENABLE == 0x00) && (u_Buf == 0xA0))
   2111          	{
   2112          		stUART4.RX_BUF[0] = u_Buf;
   2113          		stUART4.RX_CNT++;
   2114          		stUART4.RX_ENABLE = 0x01;
   2115          	}
   2116          }
   2117          
   2118          /*******************************************************************************
   2119          * Function Name  : Rx_Sony_Inquiry_Command
   2120          *******************************************************************************/
   2121          void SONY_Data_Pasher(u8 u_buf)
   2122          {
   2123          	u16 u_CZoomData = 0x0000, u_CFocusData = 0x0000;
   2124          
   2125          	// Data Save
   2126          	if(stSONY.RX_CNT >= 0x02)
   2127          	{
   2128          		stSONY.RX_BUF[stSONY.RX_CNT] = u_buf;
   2129          		stSONY.RX_CNT++;
   2130          	}
   2131          
   2132          	if(stSONY.RX_CNT == 0x04)
   2133          	{
   2134          		if((stSONY.RX_BUF[0] == SONY_BYTE_1) && (stSONY.RX_BUF[1] == SONY_BYTE_2) && (stSONY.RX_BUF[3] == SONY_BYTE_END))
   2135          		{
   2136          			switch(stUART4.RX_REQUEST_CMD)
   2137          			{
   2138          				case SONY_POWER_INQ:
   2139          
   2140          					stSONY.MODULE_STATUS = stSONY.RX_BUF[2];
   2141          
   2142          					switch(stSONY.MODULE_STATUS)
   2143          					{
   2144          						case 0x02:
   2145          							stSONY.MODULE_ENABLE = 1;
   2146          							break;
   2147          
   2148          						case 0x03:
   2149          							stSONY.MODULE_ENABLE = 0;
   2150          							break;
   2151          
   2152          						default:
   2153          							break;
   2154          					}
   2155          
   2156          					stINFO.MODULE_TYPE = SONY_MODULE;
   2157          					
   2158          					break;
   2159          
   2160          				default:
   2161          					break;
   2162          			}
   2163          
   2164          			SONY_Data_Clear();
   2165          			
   2166          			stSONY.RX_CNT = 0;
   2167          			stSONY.RX_END_FLAG = 0x01;	
   2168          		}
   2169          	}
   2170          
   2171          	// Data Compare Check
   2172          	if(stSONY.RX_CNT == 0x07)
   2173          	{
   2174          		if((stSONY.RX_BUF[0] == SONY_BYTE_1) && (stSONY.RX_BUF[1] == SONY_BYTE_2) && (stSONY.RX_BUF[6] == SONY_BYTE_END))
   2175          		{
   2176          			switch(stUART4.RX_REQUEST_CMD)
   2177          			{
   2178          				case SONY_CALL_ZOOM_POSITION:
   2179          					
   2180          					u_CZoomData = stSONY.RX_BUF[2];
   2181          					stSONY.ZOOM_CNT = u_CZoomData << 12;
   2182          					u_CZoomData = stSONY.RX_BUF[3];
   2183          					stSONY.ZOOM_CNT |= u_CZoomData << 8;
   2184          					u_CZoomData = stSONY.RX_BUF[4];
   2185          					stSONY.ZOOM_CNT |= u_CZoomData << 4;
   2186          					u_CZoomData = stSONY.RX_BUF[5];
   2187          					stSONY.ZOOM_CNT |= u_CZoomData;
   2188          
   2189          					if(stSONY.RX_BUF[6] == 0x00) 
   2190          					{
   2191          						stUART4.RX_REQUEST_ERROR = 0x01;
   2192          					}
   2193          					else 
   2194          					{
   2195          						stUART4.RX_REQUEST_CMD = 0x00;
   2196          						stUART4.RX_REQUEST_COMPLETE = SONY_CALL_ZOOM_POSITION;
   2197          					}
   2198          					
   2199          					break;
   2200          
   2201          				case SONY_CALL_FOCUS_POSITION:
   2202          					
   2203          					u_CFocusData = stSONY.RX_BUF[2];
   2204          					stSONY.FOCUS_CNT = u_CFocusData << 12;
   2205          					u_CFocusData = stSONY.RX_BUF[3];
   2206          					stSONY.FOCUS_CNT |= u_CFocusData << 8;
   2207          					u_CFocusData = stSONY.RX_BUF[4];
   2208          					stSONY.FOCUS_CNT |= u_CFocusData << 4;
   2209          					u_CFocusData = stSONY.RX_BUF[5];
   2210          					stSONY.FOCUS_CNT |= u_CFocusData;
   2211          
   2212          					if(stSONY.RX_BUF[6] == 0x00) 
   2213          					{
   2214          						stUART4.RX_REQUEST_ERROR = 0x01;
   2215          					}
   2216          					else 
   2217          					{
   2218          						stUART4.RX_REQUEST_COMPLETE = SONY_CALL_FOCUS_POSITION;
   2219          						stUART4.RX_REQUEST_CMD = 0x00;
   2220          					}
   2221          
   2222          					break;
   2223          
   2224          				default:
   2225          
   2226          					stUART4.RX_ENABLE = 0x00;
   2227          					if(stUART4.RX_REQUEST_ERROR != 0x00) stUART4.RX_REQUEST_ERROR = 0x00;
   2228          					
   2229          					break;
   2230          			}
   2231          
   2232          			SONY_Data_Clear();
   2233          			
   2234          			stSONY.RX_CNT = 0;
   2235          			stSONY.RX_END_FLAG = 0x01;
   2236          
   2237          		}
   2238          	}
   2239          	
   2240          	if(stSONY.RX_END_FLAG == 0x00)
   2241          	{
   2242          		// Second Data Check
   2243          		if((u_buf == SONY_BYTE_2) && (stSONY.RX_CNT == 1))
   2244          		{
   2245          			stSONY.RX_BUF[1] = SONY_BYTE_2;
   2246          			stSONY.RX_CNT++;
   2247          		}
   2248          		else if((u_buf != SONY_BYTE_2) && (stSONY.RX_CNT == 1))
   2249          		{
   2250          			stSONY.RX_BUF[0] = 0x00;
   2251          			stSONY.RX_CNT = 0;
   2252          		}
   2253          
   2254          		// First Data Check
   2255          		if((u_buf == SONY_BYTE_1) && (stSONY.RX_CNT == 0))
   2256          		{
   2257          			stSONY.RX_BUF[0] = SONY_BYTE_1;
   2258          			stSONY.RX_CNT++;
   2259          		}
   2260          	}
   2261          	else
   2262          	{
   2263          		stSONY.RX_END_FLAG = 0x00;
   2264          	}
   2265          
   2266          	if(stSONY.RX_CNT >= SONY_RX_BUF_MAX)
   2267          	{
   2268          		stSONY.RX_CNT = 0;
   2269          		SONY_Data_Clear();
   2270          		
   2271          	}
   2272          }
   2273          
   2274          // ============================================================================
   2275          // USART3 : UART4 Data Pasher (TSM)
   2276          // ============================================================================
   2277          void UART4_Data_Pasher(u8 u_Buf, u8 u_Index)
   2278          {
   2279          	if((u_Index == INDEX_NON) || (u_Index == INDEX_THERMAL))
   2280          	{
   2281          		TSM_Data_Pasher(u_Buf);
   2282          	}
   2283          
   2284          	if((u_Index == INDEX_NON) || (u_Index == INDEX_COLOR))
   2285          	{
   2286          		SONY_Data_Pasher(u_Buf);
   2287          	}
   2288          }
   2289          
   2290          /*******************************************************************************
   2291          * Function Name  : UART4_IRQHandler
   2292          * Description    : This function handles UART4 interrupt request.
   2293          * Input           : - PC11 UART4_RX
   2294          * Output         : - PC10 UART4_TX
   2295          *******************************************************************************/
   2296          void UART4_IRQHandler(void)
   2297          {
   2298          	u8 Rx_Buf = 0x00, Tx_Buf = 0x00;	
   2299          
   2300            	// =======================================
   2301            	// USART4 TX Process 
   2302            	// =======================================
   2303          	if (USART_GetITStatus(UART4, USART_IT_TC) != RESET)
   2304          	{
   2305          		if(stUART4.TX_CNT < stUART4.TX_MAX)
   2306          		{
   2307          			Tx_Buf = stUART4.TX_BUF[stUART4.TX_CNT];
   2308          			stUART4.TX_CNT++;				
   2309          
   2310          			USART_SendData(UART4, Tx_Buf);
   2311          		}
   2312          		else
   2313          		{
   2314          			stUART4.TX_CNT = 0x00;
   2315          			stUART4.TX_MAX = 0x00;
   2316          		}
   2317          
   2318          		USART_ClearITPendingBit(UART4, USART_IT_TC);
   2319          	}
   2320          	
   2321            	// =======================================
   2322            	// USART4 RX Process
   2323            	// =======================================
   2324          
   2325          	if (USART_GetITStatus(UART4, USART_IT_RXNE) != RESET)
   2326          	{
   2327          		Rx_Buf = USART_ReceiveData(UART4);
   2328          
   2329          		UART4_Data_Pasher(Rx_Buf, stINFO.MODULE_TYPE);
   2330          	}
   2331          }
   2332          
   2333          /*******************************************************************************
   2334          * Function Name  : Rx_Second_Comm_Check
   2335          *******************************************************************************/
   2336          void Rx_Pelco_Address_Check(u8 u_buf)
   2337          {
   2338          	stUART5.RX_BUF[1] =  u_buf;
   2339          	stUART5.RX_BUF_INDEX++;
   2340          	stUART5.RX_BUF_LENGTH = 0x01;
   2341          }
   2342          
   2343          /*******************************************************************************
   2344          * Function Name  : Rx_Pelco_Data_Check
   2345          *******************************************************************************/
   2346          void Rx_Pelco_Data_Check(void)
   2347          {
   2348          	u8 i = 0x00, u_Checksum = 0x00;
   2349          
   2350          	for(i=1; i<6; i++)
   2351          	{
   2352          		u_Checksum += stUART5.RX_BUF[i];
   2353          	}
   2354          	
   2355          	if((stUART5.RX_BUF[6] & 0xFF) == u_Checksum)		// CheckSum Check
   2356          	{
   2357          		stUART5.RX_PARITY = 0x01;	// 정상 데이터 수신 (0x00: Nondata(수신대기), 0x01: 정상데이터, 0xFF, 비정상 데이터)
   2358          		stUART5.RX_PARITY_CNT++;
   2359          		
   2360          		// DEBUG 데이터 체크 ======================================================/
   2361          		//stERROR.PARITY_CNT_CHECK++;
   2362          		//if(stERROR.PARITY_CNT_CHECK == 0x01) stERROR.TIMER_CHECK_FLAG = 0x01;
   2363          		//if(stERROR.PARITY_CNT_CHECK == 0x02) stERROR.TIMER_CHECK_FLAG = 0x00;
   2364          		// DEBUG 데이터 체크 ===================================================END/
   2365          		//if(stUSART1.RX_PRIORITY == 0x00) stUSART1.RX_PRIORITY = 0x01;
   2366          		
   2367          		stUART5.RX_BUF_INDEX = 0x00;	// Index Init
   2368          		//stUSART1.RX_BUF[stUSART1.RX_BUF_INDEX] = stUSART1.RX_PRIORITY++;
   2369          	}
   2370          	else
   2371          	{
   2372          		stUART5.RX_PARITY = 0xFF;	// 비정상 데이터 수신 (0x00: Nondata(수신대기), 0x01: 정상데이터, 0xFF, 비정상 데이터)
   2373          		stUART5.RX_ERROR_CNT++;
   2374          	}			
   2375          }
   2376          
   2377          /*******************************************************************************
   2378          * Function Name  : Rx_Second_Comm_Check
   2379          *******************************************************************************/
   2380          void Rx_Second_Comm_Check(u8 u_buf, u8 u_andbyte)
   2381          {
   2382          	if(u_buf == u_andbyte)
   2383          	{
   2384          		stUART5.RX_BUF[1] =  u_buf;
   2385          		stUART5.RX_BUF_INDEX++;
   2386          		stUART5.RX_BUF_LENGTH = 0x01;
   2387          	}
   2388          	else
   2389          	{
   2390          		stUART5.RX_BUF_INDEX = 0x00;					// Index Clear
   2391          		stUART5.RX_BUF[0] = 0x00;						// Buffer Clear
   2392          		stUART5.RX_ENABLE = 0x00;						// Command Check Byte Clear
   2393          	}	
   2394          }
   2395          
   2396          /*******************************************************************************
   2397          * Function Name  : Rx_Usart_Comm_Handling
   2398          *******************************************************************************/
   2399          void Rx_Usart_Comm_Handling(u8 u_sync, u8 u_buf)	// u_port : Uart Port, u_sync : Sync Byte Check (0 : First Byte, 1 : Second Byte)
   2400          {
   2401          	// 첫번째 바이트 체크 (Sync Byte Check)
   2402          	if(u_sync == Rx_SYNC_BYTE)	
   2403          	{
   2404          		stUART5.RX_BUF_INDEX = 0x00;	// Index Init
   2405          		stUART5.RX_BUF[stUART5.RX_BUF_INDEX] = u_buf;
   2406          		stUART5.RX_BUF_INDEX++;
   2407          		
   2408          		#if(ERROR_CHECK_BUF)
   2409          		stERROR.RX_BUF[stERROR.RX_CNT++] = u_buf;
   2410          		if(stERROR.RX_CNT >= ERROR_DATA_MAX) stERROR.RX_CNT = 0;
   2411          		#endif
   2412          	}
   2413          
   2414          	// 두번째 바이트 체크 (Sync & Byte Check)
   2415          	if(u_sync == Rx_SYNC_AND_BYTE)
   2416          	{
   2417          		#if(ERROR_CHECK_BUF)	
   2418          		stERROR.RX_BUF[stERROR.RX_CNT++] = u_buf;
   2419          		if(stERROR.RX_CNT >= ERROR_DATA_MAX) stERROR.RX_CNT = 0;
   2420          		#endif		
   2421          		
   2422          		// 두번째 명령어 체크 (Sync & Byte Check)
   2423          		if(stUART5.RX_BUF_INDEX == 0x01)
   2424          		{
   2425          			switch(stUART5.RX_ENABLE)
   2426          			{
   2427          				case IP_SONY_SECOND_BYTE:
   2428          					Rx_Second_Comm_Check(u_buf, IP_SONY_SECOND_BYTE);
   2429          					break;
   2430          
   2431          				case IP_TSM_SECOND_BYTE:
   2432          					Rx_Second_Comm_Check(u_buf, IP_TSM_SECOND_BYTE);
   2433          					break;
   2434          
   2435          				case IP_DRS_SECOND_BYTE:
   2436          					Rx_Second_Comm_Check(u_buf, IP_DRS_SECOND_BYTE);
   2437          					break;
   2438          
   2439          				case IP_TCM_SECOND_BYTE:
   2440          					Rx_Second_Comm_Check(u_buf, IP_TCM_SECOND_BYTE);
   2441          					break;
   2442          					
   2443          				case IP_PTZ_SECOND_BYTE:
   2444          					Rx_Second_Comm_Check(u_buf, IP_PTZ_SECOND_BYTE);
   2445          					break;
   2446          
   2447          				case IP_DATA_SECOND_BYTE:
   2448          					Rx_Second_Comm_Check(u_buf, IP_DATA_SECOND_BYTE);
   2449          					break;	
   2450          
   2451          				case IP_OPTION_SECOND_BYTE:
   2452          					Rx_Second_Comm_Check(u_buf, IP_OPTION_SECOND_BYTE);
   2453          					break;		
   2454          
   2455          				case IP_PELCO_CHK_BYTE:
   2456          					Rx_Pelco_Address_Check(u_buf);
   2457          					break;
   2458          
   2459          				default:
   2460          					break;
   2461          			}
   2462          		}	
   2463          	}
   2464          
   2465          	// 세번째 바이트 체크 (Data Length)
   2466          	if(u_sync == Rx_LENGTH_BYTE)
   2467          	{
   2468          		#if(ERROR_CHECK_BUF)	
   2469          		stERROR.RX_BUF[stERROR.RX_CNT++] = u_buf;
   2470          		if(stERROR.RX_CNT >= ERROR_DATA_MAX) stERROR.RX_CNT = 0;
   2471          		#endif
   2472          		
   2473          		if(stUART5.RX_ENABLE == IP_PELCO_CHK_BYTE)
   2474          		{
   2475          			// PELCO-D Command 예외처리
   2476          			if(stUART5.RX_BUF_INDEX == 0x02)
   2477          			{
   2478          				stUART5.RX_BUF_LENGTH = 0x02;
   2479          				stUART5.RX_BUF_MAX = stUART5.RX_BUF_LENGTH + 5;
   2480          				
   2481          				stUART5.RX_BUF[2] =  u_buf;
   2482          				
   2483          				stUART5.RX_BUF_INDEX++;
   2484          			}					
   2485          		}
   2486          		else
   2487          		{
   2488          			// 세번째 데이터 길이 체크 (Sync & Byte Check)
   2489          			if(stUART5.RX_BUF_INDEX == 0x02)
   2490          			{
   2491          				stUART5.RX_BUF_LENGTH = u_buf;
   2492          				stUART5.RX_BUF_MAX = stUART5.RX_BUF_LENGTH + 5;
   2493          				
   2494          				stUART5.RX_BUF[2] =  u_buf;
   2495          				
   2496          				stUART5.RX_BUF_INDEX++;
   2497          			}
   2498          		}
   2499          	}	
   2500          
   2501          	// 데이터 누적
   2502          	if(u_sync == Rx_DATA_BYTE)
   2503          	{
   2504          		#if(ERROR_CHECK_BUF)
   2505          		stERROR.RX_BUF[stERROR.RX_CNT++] = u_buf;
   2506          		if(stERROR.RX_CNT >= ERROR_DATA_MAX) stERROR.RX_CNT = 0;
   2507          		#endif		
   2508          		
   2509          		stUART5.RX_BUF[stUART5.RX_BUF_INDEX] = u_buf;
   2510          
   2511          		stUART5.RX_BUF_INDEX++;	
   2512          		
   2513          		if(stUART5.RX_BUF_INDEX == stUART5.RX_BUF_MAX)
   2514          		{
   2515          			// PELCO-D Command 예외처리
   2516          			if(stUART5.RX_ENABLE == IP_PELCO_CHK_BYTE)
   2517          			{
   2518          				Rx_Pelco_Data_Check();
   2519          			}
   2520          			else
   2521          			{
   2522          				if((stUART5.RX_BUF[stUART5.RX_BUF_INDEX - 1]&0x0F) == 0x0F)		// End Byte Check
   2523          				{
   2524          					stUART5.RX_PARITY = 0x01;	// 정상 데이터 수신 (0x00: Nondata(수신대기), 0x01: 정상데이터, 0xFF, 비정상 데이터)
   2525          					stUART5.RX_PARITY_CNT++;
   2526          
   2527          					// DEBUG 데이터 체크 ======================================================/
   2528          					//stERROR.PARITY_CNT_CHECK++;
   2529          					//if(stERROR.PARITY_CNT_CHECK == 0x01) stERROR.TIMER_CHECK_FLAG = 0x01;
   2530          					//if(stERROR.PARITY_CNT_CHECK == 0x02) stERROR.TIMER_CHECK_FLAG = 0x00;
   2531          					// DEBUG 데이터 체크 ===================================================END/
   2532          					
   2533          					//if(stUSART1.RX_PRIORITY == 0x00) stUSART1.RX_PRIORITY = 0x01;
   2534          					
   2535          					stUART5.RX_BUF_INDEX = 0x00;	// Index Init
   2536          					//stUSART1.RX_BUF[stUSART1.RX_BUF_INDEX] = stUSART1.RX_PRIORITY++;
   2537          				}
   2538          				else
   2539          				{
   2540          					stUART5.RX_PARITY = 0xFF;	// 비정상 데이터 수신 (0x00: Nondata(수신대기), 0x01: 정상데이터, 0xFF, 비정상 데이터)
   2541          					stUART5.RX_ERROR_CNT++;
   2542          				}
   2543          			}
   2544          			
   2545          			stUART5.RX_BUF_INDEX = 0x00;
   2546          			stUART5.RX_BUF_LENGTH = 0x00;
   2547          			
   2548          			stUART5.RX_ENABLE = 0x00;
   2549          		}
   2550          	}		
   2551          }
   2552          
   2553          /*******************************************************************************
   2554          * Function Name  : Protocol_Command_Check
   2555          * Description    : This function handles UART5 interrupt request.
   2556          * Input           : TILT <-> Thermal IP Board (- PA10 UART5_RX)
   2557          * Output         : TILT <-> Thermal IP Board (- PA9 UART5_TX)
   2558          *******************************************************************************/
   2559          void Protocol_Command_Check(u8 u_buf)
   2560          {
   2561          	u8 u_Index_Chk = 0;
   2562          
   2563          	if(stUART5.RX_ENABLE == 0x00)
   2564          	{
   2565          		// 첫번째 바이트 체크 (Sync Byte Check)
   2566          		switch(u_buf)
   2567          		{
   2568          			case IP_SONY_FIRST_BYTE:
   2569          				Rx_Usart_Comm_Handling(Rx_SYNC_BYTE, IP_SONY_FIRST_BYTE);
   2570          				stUART5.RX_ENABLE = IP_SONY_SECOND_BYTE;
   2571          				break;
   2572          
   2573          			case IP_TSM_FIRST_BYTE:
   2574          				Rx_Usart_Comm_Handling(Rx_SYNC_BYTE, IP_TSM_FIRST_BYTE);
   2575          				stUART5.RX_ENABLE = IP_TSM_SECOND_BYTE;
   2576          				break;
   2577          
   2578          			case IP_DRS_FIRST_BYTE:
   2579          				Rx_Usart_Comm_Handling(Rx_SYNC_BYTE, IP_DRS_FIRST_BYTE);
   2580          				stUART5.RX_ENABLE = IP_DRS_SECOND_BYTE;
   2581          				break;
   2582          
   2583          			case IP_TCM_FIRST_BYTE:
   2584          				Rx_Usart_Comm_Handling(Rx_SYNC_BYTE, IP_TCM_FIRST_BYTE);
   2585          				stUART5.RX_ENABLE = IP_TCM_SECOND_BYTE;
   2586          				break;
   2587          
   2588          			case IP_PTZ_FIRST_BYTE:
   2589          				Rx_Usart_Comm_Handling(Rx_SYNC_BYTE, IP_PTZ_FIRST_BYTE);
   2590          				stUART5.RX_ENABLE = IP_PTZ_SECOND_BYTE;
   2591          				break;
   2592          
   2593          			case IP_DATA_FIRST_BYTE:
   2594          				Rx_Usart_Comm_Handling(Rx_SYNC_BYTE, IP_DATA_FIRST_BYTE);
   2595          				stUART5.RX_ENABLE = IP_DATA_SECOND_BYTE;
   2596          				break;
   2597          
   2598          			case IP_OPTION_FIRST_BYTE:
   2599          				Rx_Usart_Comm_Handling(Rx_SYNC_BYTE, IP_OPTION_FIRST_BYTE);
   2600          				stUART5.RX_ENABLE = IP_OPTION_SECOND_BYTE;
   2601          				break;
   2602          
   2603          			case IP_PELCO_CHK_BYTE:
   2604          				Rx_Usart_Comm_Handling(Rx_SYNC_BYTE, IP_PELCO_CHK_BYTE);
   2605          				stUART5.RX_ENABLE = IP_PELCO_CHK_BYTE;
   2606          				break;	
   2607          
   2608          			default:
   2609          				break;
   2610          		}
   2611          	}
   2612          	else
   2613          	{
   2614          		if(stUART5.RX_BUF_LENGTH == 0x00) u_Index_Chk = Rx_SYNC_AND_BYTE;
   2615          		else 
   2616          		{
   2617          			if(stUART5.RX_BUF_INDEX >= 0x03)
   2618          			{
   2619          				u_Index_Chk = Rx_DATA_BYTE;
   2620          			}
   2621          			else
   2622          			{
   2623          				if(stUART5.RX_STATUS == 0x00)
   2624          				{
   2625          					u_Index_Chk = Rx_LENGTH_BYTE;
   2626          				}
   2627          			}
   2628          		}
   2629          
   2630          		// 두번째, 세번째 바이트 체크 (Rx_SYNC_AND_BYTE : Sync & Byte Check, Rx_LENGTH_BYTE : Length Check)
   2631          		Rx_Usart_Comm_Handling(u_Index_Chk, u_buf);
   2632          	}
   2633          }
   2634          
   2635          /*******************************************************************************
   2636          * Function Name  : UART5_IRQHandler
   2637          * Description    : This function handles UART5 interrupt request.
   2638          * Input           : IP Board - PD2 USART5_RX
   2639          * Output         : IP Board - PC12 USART5_TX
   2640          *******************************************************************************/
   2641          void UART5_IRQHandler(void)
   2642          {
   2643          	u8 Rx_Buf = 0x00, Tx_Buf = 0x00;	
   2644          
   2645            	// =======================================
   2646            	// USART5 TX Process 
   2647            	// =======================================
   2648          	if (USART_GetITStatus(UART5, USART_IT_TC) != RESET)
   2649          	{ 
   2650          
   2651          		if(stUART5.TX_CNT < stUART5.TX_MAX)
   2652          		{
   2653          			Tx_Buf = stUART5.TX_BUF[stUART5.TX_CNT];
   2654          			stUART5.TX_CNT++;				
   2655          
   2656          			USART_SendData(UART5, Tx_Buf);
   2657          		}
   2658          		else
   2659          		{
   2660          			stUART5.TX_CNT = 0x00;
   2661          			stUART5.TX_MAX = 0x00;
   2662          		}
   2663          		
   2664          		USART_ClearITPendingBit(UART5, USART_IT_TC);
   2665          	}
   2666          	
   2667            	// =======================================
   2668            	// USART5RX Process
   2669            	// =======================================
   2670          
   2671          	if (USART_GetITStatus(UART5, USART_IT_RXNE) != RESET)
   2672          	{
   2673          		Rx_Buf = USART_ReceiveData(UART5);
   2674          
   2675          		Protocol_Command_Check(Rx_Buf);
   2676          	}
   2677          }
   2678          
   2679          
   2680          /******************* (C) COPYRIGHT 2016 TBT System *****END OF FILE****/
   2681          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  ADC1_2_IRQHandler
        0  Boot_Status_Check_Parser
       16  Boot_Status_Data_Trans
             16 -> USART_SendData
        0  BusFault_Handler
        0  CAN1_RX1_IRQHandler
        0  CAN1_SCE_IRQHandler
        0  DMA1_Channel2_IRQHandler
        0  DMA1_Channel3_IRQHandler
        0  DMA1_Channel4_IRQHandler
        0  DMA1_Channel5_IRQHandler
        0  DMA1_Channel6_IRQHandler
        0  DMA1_Channel7_IRQHandler
        0  DebugMon_Handler
        0  EXTI15_10_IRQHandler
        0  FLASH_IRQHandler
        0  HardFault_Handler
        0  I2C1_ER_IRQHandler
        0  I2C1_EV_IRQHandler
        0  I2C2_ER_IRQHandler
        0  I2C2_EV_IRQHandler
        0  LRF_Data_Clear
        8  LRF_Data_Pasher
              8 -> LRF_Data_Clear
              8 -> LRF_Trans_Data
        8  LRF_Trans_Data
              8 -> USART_SendData
       16  Main_Protocol_Data_Pasher
             16 -> Rx_Main_Comm_Handling
        0  MemManage_Handler
        0  NMI_Handler
        0  PVD_IRQHandler
        0  PendSV_Handler
       16  Protocol_Command_Check
             16 -> Rx_Usart_Comm_Handling
        0  RCC_IRQHandler
        0  RTCAlarm_IRQHandler
        0  RTC_IRQHandler
       16  Rx_Main_Comm_Handling
             16 -> Boot_Status_Check_Parser
             16 -> Rx_Main_Second_Comm_Check
             16 -> Rx_Pelco_Data_Check
        0  Rx_Main_Second_Comm_Check
        0  Rx_Pelco_Address_Check
        0  Rx_Pelco_Data_Check
        0  Rx_Second_Comm_Check
       16  Rx_Usart_Comm_Handling
             16 -> Rx_Pelco_Address_Check
             16 -> Rx_Pelco_Data_Check
             16 -> Rx_Second_Comm_Check
        0  SONY_Data_Clear
       16  SONY_Data_Pasher
             16 -> SONY_Data_Clear
        0  SPI1_IRQHandler
        0  SPI2_IRQHandler
        0  SVC_Handler
       12  SYSTEM_Data_Buffer
        0  SYSTEM_Data_Handling
        8  SYSTEM_Data_Parser
              8 -> SYSTEM_Data_Buffer
              8 -> SYSTEM_Data_Handling
              8 -> SYSTEM_Data_Reordering
       16  SYSTEM_Data_Reordering
        0  Sony_Data_Pasher
        8  SysTick_Handler
              8 -> Delay_Decrement
              8 -> TimingDelay_Decrement
              8 -> i2cDelay_Decrement
        0  TAMPER_IRQHandler
        0  TIM1_BRK_IRQHandler
        0  TIM1_CC_IRQHandler
        0  TIM1_TRG_COM_IRQHandler
        0  TIM1_UP_IRQHandler
        8  TIM2_IRQHandler
              8 -> GPIO_ReadInputDataBit
              8 -> TIM_ClearITPendingBit
              8 -> TIM_GetITStatus
        8  TIM3_IRQHandler
              8 -> LED_Off_Green
              8 -> LED_On_Green
              8 -> TIM_ClearITPendingBit
              8 -> TIM_GetITStatus
        8  TIM4_IRQHandler
              8 -> LED_Off_Red
              8 -> LED_On_Red
              8 -> TIM_ClearITPendingBit
              8 -> TIM_GetITStatus
       16  TSM_Data_Pasher
       16  UART4_Data_Pasher
             16 -> SONY_Data_Pasher
             16 -> TSM_Data_Pasher
       16  UART4_IRQHandler
             16 -> UART4_Data_Pasher
             16 -> USART_ClearITPendingBit
             16 -> USART_GetITStatus
             16 -> USART_ReceiveData
             16 -> USART_SendData
       16  UART5_IRQHandler
             16 -> Protocol_Command_Check
             16 -> USART_ClearITPendingBit
             16 -> USART_GetITStatus
             16 -> USART_ReceiveData
             16 -> USART_SendData
        8  USART1_IRQHandler
              8 -> Main_Protocol_Data_Pasher
              8 -> USART_ClearITPendingBit
              8 -> USART_GetITStatus
              8 -> USART_ReceiveData
              8 -> USART_SendData
       16  USART2_IRQHandler
             16 -> USART_ClearITPendingBit
             16 -> USART_GetITStatus
             16 -> USART_ReceiveData
             16 -> USART_SendData
       16  USART3_IRQHandler
             16 -> USART_ClearITPendingBit
             16 -> USART_GetITStatus
             16 -> USART_ReceiveData
             16 -> USART_SendData
        0  USB_HP_CAN1_TX_IRQHandler
        0  UsageFault_Handler
        0  WWDG_IRQHandler
        0  assert_failed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable15
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable18_6
       4  ??DataTable19
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable25
       4  ??DataTable25_1
       4  ??DataTable25_2
       4  ??DataTable26
       4  ??DataTable26_1
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_2
       4  ??DataTable27_3
       4  ??DataTable27_4
       2  ADC1_2_IRQHandler
      44  Boot_Status_Check_Parser
     406  Boot_Status_Data_Trans
       2  BusFault_Handler
       2  CAN1_RX1_IRQHandler
       2  CAN1_SCE_IRQHandler
       2  DMA1_Channel2_IRQHandler
       2  DMA1_Channel3_IRQHandler
       2  DMA1_Channel4_IRQHandler
       2  DMA1_Channel5_IRQHandler
       2  DMA1_Channel6_IRQHandler
       2  DMA1_Channel7_IRQHandler
       2  DebugMon_Handler
       2  EXTI15_10_IRQHandler
       2  FLASH_IRQHandler
       2  HardFault_Handler
       2  I2C1_ER_IRQHandler
       2  I2C1_EV_IRQHandler
       2  I2C2_ER_IRQHandler
       2  I2C2_EV_IRQHandler
      26  LRF_Data_Clear
     226  LRF_Data_Pasher
      80  LRF_Trans_Data
     148  Main_Protocol_Data_Pasher
       2  MemManage_Handler
       2  NMI_Handler
       2  PVD_IRQHandler
       2  PendSV_Handler
     236  Protocol_Command_Check
       2  RCC_IRQHandler
       2  RTCAlarm_IRQHandler
       2  RTC_IRQHandler
     632  Rx_Main_Comm_Handling
      68  Rx_Main_Second_Comm_Check
      32  Rx_Pelco_Address_Check
     102  Rx_Pelco_Data_Check
      68  Rx_Second_Comm_Check
     604  Rx_Usart_Comm_Handling
      30  SONY_Data_Clear
     780  SONY_Data_Pasher
       2  SPI1_IRQHandler
       2  SPI2_IRQHandler
       2  SVC_Handler
     194  SYSTEM_Data_Buffer
      50  SYSTEM_Data_Handling
      26  SYSTEM_Data_Parser
     382  SYSTEM_Data_Reordering
      86  Sony_Data_Pasher
      16  SysTick_Handler
       2  TAMPER_IRQHandler
       2  TIM1_BRK_IRQHandler
       2  TIM1_CC_IRQHandler
       2  TIM1_TRG_COM_IRQHandler
       2  TIM1_UP_IRQHandler
     974  TIM2_IRQHandler
      36  TIM3_IRQHandler
      36  TIM4_IRQHandler
    1440  TSM_Data_Pasher
      48  UART4_Data_Pasher
     154  UART4_IRQHandler
     122  UART5_IRQHandler
     112  USART1_IRQHandler
     140  USART2_IRQHandler
      76  USART3_IRQHandler
       2  USB_HP_CAN1_TX_IRQHandler
       2  UsageFault_Handler
       2  WWDG_IRQHandler
       2  assert_failed
       1  g_Tx_Buf

 
     1 byte  in section .bss
 7 552 bytes in section .text
 
 7 552 bytes of CODE memory
     1 byte  of DATA memory

Errors: none
Warnings: 7
