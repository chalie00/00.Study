###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     01/Jul/2022  17:10:06 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\src\main.c        #
#    Command line =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\src\main.c -D     #
#                    USE_STDPERIPH_DRIVER -D STM32F10x_HD -D USE_FULL_ASSERT  #
#                    -lcN C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_ #
#                    M32\Debug\List\ -lb C:\Users\TTT\Desktop\zz.STDFW\00.Stu #
#                    dy\project\IAR_M32\Debug\List\ -o                        #
#                    C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_M32\D #
#                    ebug\Obj\ --no_cse --no_unroll --no_inline               #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\I #
#                    AR_M32\..\..\inc\ -I C:\Users\TTT\Desktop\zz.STDFW\00.St #
#                    udy\project\IAR_M32\..\..\Libraries\CMSIS\CM3\DeviceSupp #
#                    ort\ST\STM32F10x\ -I C:\Users\TTT\Desktop\zz.STDFW\00.St #
#                    udy\project\IAR_M32\..\..\Libraries\STM32F10x_StdPeriph_ #
#                    Driver\inc\ -I "C:\Program Files (x86)\IAR               #
#                    Systems\Embedded Workbench 6.0\arm\inc\c\" -On -I        #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_M32\D #
#                    ebug\List\main.lst                                       #
#    Object file  =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_M32\D #
#                    ebug\Obj\main.o                                          #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\TTT\Desktop\zz.STDFW\00.Study\src\main.c
      1          /*=================================================================================
      2          Project Name 		:	TPV HD Type - TILT BOARD (HD IP THERMOGRAPHY PTZ CAMERA)
      3          Author			:	phs@tbtsys.com
      4          ==================================================================================
      5          
      6          ---------------------------------------------------------------------------------
      7          CPU					: 	STM32F103RCT
      8          ---------------------------------------------------------------------------------
      9          Z:LQFP144 	(R:LQFP64, V:LQFP100)
     10          E:512KB 		(B:128KB, C:256KB, F:768KB, G:1024KB)
     11          T:LQFP		(H:UFBGA, Y:WLCSP)
     12          7:-40~105'C	(6:-40~85'C)
     13          ---------------------------------------------------------------------------------
     14          CPU Infomation 	:  ARM 32-bit Cortex-M3 CPU, 120MHz max
     15          Package			: 	LQFP144(20x20mm)
     16          ---------------------------------------------------------------------------------
     17          Clock			: 	4~26MHz Crystal oscillator
     18          	Internal 16MHz RC(factory-trimmed)
     19          	32kHz oscillator for RTC with calibration
     20          	Internal 32kHz RC with calibration
     21          ---------------------------------------------------------------------------------
     22          Program Memory		: 	1MBytes Flash Memory
     23          Data Memory			: 	128KBytes(112+16) + 4KBytes SRAM(BackUp)
     24          OTP Memory			: 	512 Bytes
     25          ---------------------------------------------------------------------------------
     26          Timer				: 10-General, 2-Advanced, 2-Basic, IWDG, WWDG
     27          RTC					: Yes
     28          I2C					: 3
     29          USART				: 4
     30          UART				: 2
     31          USB OTG FS			: Yes (full speed)
     32          USB OTG HS			: Yes (High Speed)
     33          CAN					: 2
     34          Camera Interface		: No
     35          GPIO				: 114
     36          SDIO				: Yes
     37          12-bit ADC			: 3 * 24Channel
     38          12-bit DAC			: 2
     39          Max CPU Frequency	: 120MHz
     40          Operation Volatage		: 1.8V ~ 3.6V
     41          ADC					: 3*12bit up to 24Channel
     42          DAC					: 2*12bit
     43          SPI					: 3 SPIs
     44          ---------------------------------------------------------------------------------
     45          //===============================================================================*/
     46          
     47          /* ==========================================
     48          	Clock Speed Compute
     49          // ==========================================
     50          Clock : 16Mhz 
     51          int Clock : 80Mhz
     52           
     53          Xtal=16Mhz
     54          SysFreq=80Mhz
     55          Desired Baud Rate = 2400 / 38400
     56          ----------2400----------------------------
     57          UxBRG = ((16000000/2400)/16)-1 
     58                = 415.667
     59          Calculated Baud Rate = 16000000/(16(416+1))
     60                               = 2403
     61                               = 0.1%
     62          ----------38400----------------------------                      
     63          UxBRG = ((16000000/38400)/16)-1 
     64                = 25.042
     65          Calculated Baud Rate = 16000000/(16(25+1))
     66                               = 38461.5
     67                               = 0.16%
     68          --------------------------------------------------------*/
     69          
     70          /*******************************************************************************
     71          * INCLUDE
     72          *******************************************************************************/
     73          #include "main.h"
     74          #include "Common.h"
     75          #include <stdio.h>
     76          #include "stm32f10x.h"
     77          #include "sysclk.h"
     78          #include "systickdelay.h"
     79          
     80          /*******************************************************************************
     81          * Function : Send_Sony_Data
     82          *******************************************************************************/
     83          void Send_Sony_Data(u8 u_Cmd, u8 u_Data1, u8 u_Data2, u8 u_Leng, u8 u_Timer)
     84          {
     85             switch (u_Leng)
     86             {
     87             case 0x05:
     88          
     89                stUART4.TX_BUF[0] = 0x81;
     90                stUART4.TX_BUF[1] = 0x09;
     91                stUART4.TX_BUF[2] = 0x04;
     92                stUART4.TX_BUF[3] = u_Cmd;
     93                stUART4.TX_BUF[4] = 0xFF;
     94          
     95                stUART4.TX_CNT = 0;
     96                stUART4.TX_MAX = u_Leng;
     97          
     98                break;
     99          
    100             case 0x06:
    101          
    102                stUART4.TX_BUF[0] = 0x81;
    103                stUART4.TX_BUF[1] = 0x01;
    104                stUART4.TX_BUF[2] = 0x04;
    105                stUART4.TX_BUF[3] = u_Cmd;
    106                stUART4.TX_BUF[4] = u_Data1;
    107                stUART4.TX_BUF[5] = 0xFF;
    108          
    109                stUART4.TX_CNT = 0;
    110                stUART4.TX_MAX = u_Leng;
    111          
    112                break;
    113          
    114             case 0x08:
    115          
    116                stUART4.TX_BUF[0] = 0x81;
    117                stUART4.TX_BUF[1] = 0x01;
    118                stUART4.TX_BUF[2] = 0x04;
    119                stUART4.TX_BUF[3] = 0x24;
    120                stUART4.TX_BUF[4] = u_Cmd;
    121                stUART4.TX_BUF[5] = u_Data1;
    122                stUART4.TX_BUF[6] = u_Data2;
    123                stUART4.TX_BUF[7] = 0xFF;
    124          
    125                stUART4.TX_CNT = 0;
    126                stUART4.TX_MAX = u_Leng;
    127          
    128                break;
    129          
    130             case 0x09:
    131          
    132                stUART4.TX_BUF[0] = 0x81;
    133                stUART4.TX_BUF[1] = 0x01;
    134                stUART4.TX_BUF[2] = 0x04;
    135                stUART4.TX_BUF[3] = u_Cmd;
    136                stUART4.TX_BUF[4] = (u_Data1 >> 4) & 0x0F;
    137                stUART4.TX_BUF[5] = u_Data1 & 0x0F;
    138                stUART4.TX_BUF[6] = (u_Data2 >> 4) & 0x0F;
    139                stUART4.TX_BUF[7] = u_Data2 & 0x0F;
    140                stUART4.TX_BUF[8] = 0xFF;
    141          
    142          
    143                stUART4.TX_CNT = 0;
    144                stUART4.TX_MAX = u_Leng;
    145          
    146             case 0xFF:
    147          
    148                stUART4.TX_CNT = 0;
    149                stUART4.TX_MAX = u_Leng;
    150          
    151                break;
    152          
    153                break;
    154          
    155             default:
    156                break;
    157             }
    158          
    159             USART_SendData(UART4, stUART4.TX_BUF[stUART4.TX_CNT++]);
    160             Delay_1ms(u_Timer);
    161          }
    162          
    163          /*******************************************************************************
    164          * Function : Send_LRF_Data
    165          *******************************************************************************/
    166          void Send_LRF_Data(u8 u_Cmd, u16 u_Timer)
    167          {
    168             switch (u_Cmd)
    169             {
    170             case LRF_INIT:
    171          
    172                //ID1
    173                stUSART2.TX_BUF[0] = 0x49;	// I
    174                stUSART2.TX_BUF[1] = 0x44;	// D
    175                stUSART2.TX_BUF[2] = 0x31;	// 1
    176                stUSART2.TX_BUF[3] = 0x0D;	// CR
    177          
    178                stUSART2.TX_CNT = 0;
    179                stUSART2.TX_MAX = 0x04;
    180          
    181                USART_SendData(USART2, stUSART2.TX_BUF[stUSART2.TX_CNT++]);
    182                Delay_1ms(u_Timer);
    183          
    184                break;
    185          
    186             case LRF_MAX_TIME:
    187          
    188                // MT 3 (500ms)
    189                stUSART2.TX_BUF[0] = 0x4D;	// M
    190                stUSART2.TX_BUF[1] = 0x54;	// T
    191                stUSART2.TX_BUF[2] = 0x20;	// SP
    192                stUSART2.TX_BUF[3] = 0x33;	// 3
    193                stUSART2.TX_BUF[4] = 0x0D;	// CR
    194          
    195                stUSART2.TX_CNT = 0;
    196                stUSART2.TX_MAX = 0x05;
    197          
    198                USART_SendData(USART2, stUSART2.TX_BUF[stUSART2.TX_CNT++]);
    199                Delay_1ms(u_Timer);
    200          
    201                break;
    202          
    203             case LRF_LIMIT:
    204          
    205                // MW 1 5000
    206                stUSART2.TX_BUF[0] = 0x4D;	// M
    207                stUSART2.TX_BUF[1] = 0x57;	// W
    208                stUSART2.TX_BUF[2] = 0x20;	// SP
    209                stUSART2.TX_BUF[3] = 0x31;	// 1
    210                stUSART2.TX_BUF[4] = 0x20;	// SP
    211                stUSART2.TX_BUF[5] = 0x35;	// 5
    212                stUSART2.TX_BUF[6] = 0x30;	// 0
    213                stUSART2.TX_BUF[7] = 0x30;	// 0
    214                stUSART2.TX_BUF[8] = 0x30;	// 0
    215                stUSART2.TX_BUF[9] = 0x0D;	// CR
    216          
    217                stUSART2.TX_CNT = 0;
    218                stUSART2.TX_MAX = 0x0A;
    219          
    220                USART_SendData(USART2, stUSART2.TX_BUF[stUSART2.TX_CNT++]);
    221                Delay_1ms(u_Timer);
    222          
    223                break;
    224          
    225             case LRF_CALL_DATA:
    226          
    227                // dm1 1
    228                stUSART2.TX_BUF[0] = 0x64;	// d
    229                stUSART2.TX_BUF[1] = 0x6D;	// m
    230                stUSART2.TX_BUF[2] = 0x31;	// 1
    231                stUSART2.TX_BUF[3] = 0x20;	// SP
    232                stUSART2.TX_BUF[4] = 0x31;	// 1
    233                stUSART2.TX_BUF[5] = 0x0D;	// CR
    234          
    235                stUSART2.TX_CNT = 0;
    236                stUSART2.TX_MAX = 0x06;
    237          
    238                USART_SendData(USART2, stUSART2.TX_BUF[stUSART2.TX_CNT++]);
    239                Delay_1ms(u_Timer);
    240          
    241                break;
    242          
    243             }
    244          }
    245          
    246          /*******************************************************************************
    247          * Function : Send_MDIN_String_Data
    248          *******************************************************************************/
    249          void Send_MDIN_String_Data(u16 u_Cmd, u8 u_Leng, u8 u_Timer)
    250          {
    251             u8 i, i_Max = 0x00;
    252             u8 u_Checksum = 0x00;
    253             u8 u_Rx_Data[50];
    254          
    255             stUSART2.TX_BUF[0] = 0xA0;
    256             stUSART2.TX_BUF[1] = 0x60;
    257             stUSART2.TX_BUF[2] = (u8)(u_Cmd & 0xFF);
    258             stUSART2.TX_BUF[3] = (u8)(u_Cmd >> 8);
    259             stUSART2.TX_BUF[4] = u_Leng - 2;
    260          
    261             i_Max = u_Leng + 3;
    262          
    263             for (i = 5; i < i_Max; i++)
    264             {
    265                stUSART2.TX_BUF[i] = stSYS.RX_BUF[0][i + 1];
    266             }
    267          
    268             for (i = 2; i < i_Max; i++)
    269             {
    270                u_Checksum += stUSART2.TX_BUF[i];
    271             }
    272          
    273             stUSART2.TX_BUF[i_Max] = 0x00;
    274             stUSART2.TX_BUF[i_Max] = (u8)(u_Checksum);
    275             stUSART2.TX_BUF[i_Max + 1] = 0x5F;
    276          
    277             stUSART2.TX_CNT = 0;
    278             stUSART2.TX_MAX = u_Leng + 0x05;
    279          
    280             USART_SendData(USART2, stUSART2.TX_BUF[stUSART2.TX_CNT++]);
    281             Delay_1ms(u_Timer);
    282          }
    283          
    284          /*******************************************************************************
    285          * Function : Send_MDIN_Data
    286          *******************************************************************************/
    287          void Send_MDIN_Data(u16 u_Cmd, u8 u_Leng, u8 u_Data1, u8 u_Data2, u8 u_Data3, u8 u_Data4, u8 u_Data5, u8 u_Data6, u8 u_Data7,
    288                              u8 u_Data8, u8 u_Data9, u8 u_Data10, u8 u_Data11, u8 u_Data12, u8 u_Data13, u8 u_Data14, u8 u_Data15, u8 u_Data16, u8 u_Data17, u8 u_Data18, u8 u_Timer)
    289          {
    290             u8 i = 0, u_Sum_Data = 0x00;
    291          
    292             switch (u_Leng)
    293             {
    294             case 0x03:
    295          
    296                stUSART2.TX_BUF[0] = 0xA0;
    297                stUSART2.TX_BUF[1] = 0x60;
    298                stUSART2.TX_BUF[2] = (u8)(u_Cmd & 0xFF);
    299                stUSART2.TX_BUF[3] = (u8)(u_Cmd >> 8);
    300                stUSART2.TX_BUF[4] = u_Leng;
    301                stUSART2.TX_BUF[5] = u_Data1;
    302                stUSART2.TX_BUF[6] = u_Data2;
    303                stUSART2.TX_BUF[7] = u_Data3;
    304                stUSART2.TX_BUF[8] = (u8)(stUSART2.TX_BUF[2] + stUSART2.TX_BUF[3] + stUSART2.TX_BUF[4] + stUSART2.TX_BUF[5] + stUSART2.TX_BUF[6] + stUSART2.TX_BUF[7]);
    305                stUSART2.TX_BUF[9] = 0x5F;
    306          
    307                stUSART2.TX_CNT = 0;
    308                stUSART2.TX_MAX = u_Leng + 0x07;
    309          
    310                USART_SendData(USART2, stUSART2.TX_BUF[stUSART2.TX_CNT++]);
    311                Delay_1ms(u_Timer);
    312          
    313                break;
    314          
    315             case 0x09:
    316          
    317                stUSART2.TX_BUF[0] = 0xA0;
    318                stUSART2.TX_BUF[1] = 0x60;
    319                stUSART2.TX_BUF[2] = (u8)(u_Cmd & 0xFF);
    320                stUSART2.TX_BUF[3] = (u8)(u_Cmd >> 8);
    321                stUSART2.TX_BUF[4] = u_Leng;
    322          
    323                stUSART2.TX_BUF[5] = u_Data1;		// ID
    324                stUSART2.TX_BUF[6] = u_Data2;		// COLUMN
    325                stUSART2.TX_BUF[7] = u_Data3;		// ROW
    326          
    327                stUSART2.TX_BUF[8] = u_Data4;
    328                stUSART2.TX_BUF[9] = u_Data5;
    329                stUSART2.TX_BUF[10] = u_Data6;
    330                stUSART2.TX_BUF[11] = u_Data7;
    331                stUSART2.TX_BUF[12] = u_Data8;
    332                stUSART2.TX_BUF[13] = u_Data9;
    333          
    334                stUSART2.TX_BUF[14] = 0x00;
    335          
    336                for (i = 2; i < 14; i++)
    337                {
    338                   u_Sum_Data = (u8)(u_Sum_Data + stUSART2.TX_BUF[i]);
    339                }
    340          
    341                stUSART2.TX_BUF[14] = u_Sum_Data;
    342          
    343                stUSART2.TX_BUF[15] = 0x5F;
    344          
    345                stUSART2.TX_CNT = 0;
    346                stUSART2.TX_MAX = u_Leng + 0x07;
    347          
    348                USART_SendData(USART2, stUSART2.TX_BUF[stUSART2.TX_CNT++]);
    349                Delay_1ms(u_Timer);
    350          
    351                break;
    352          
    353             case 0x12:
    354          
    355                stUSART2.TX_BUF[0] = 0xA0;
    356                stUSART2.TX_BUF[1] = 0x60;
    357                stUSART2.TX_BUF[2] = (u8)(u_Cmd & 0xFF);
    358                stUSART2.TX_BUF[3] = (u8)(u_Cmd >> 8);
    359                stUSART2.TX_BUF[4] = u_Leng;
    360          
    361                stUSART2.TX_BUF[5] = u_Data1;		// ID
    362                stUSART2.TX_BUF[6] = u_Data2;		// COLUMN
    363                stUSART2.TX_BUF[7] = u_Data3;		// ROW
    364          
    365                stUSART2.TX_BUF[8] = u_Data4;		// +
    366                stUSART2.TX_BUF[9] = u_Data5;		// 0
    367                stUSART2.TX_BUF[10] = u_Data6;		// 0
    368                stUSART2.TX_BUF[11] = u_Data7;		// 0
    369                stUSART2.TX_BUF[12] = u_Data8;		// .
    370                stUSART2.TX_BUF[13] = u_Data9;		// 0
    371                stUSART2.TX_BUF[14] = u_Data10;		// 0
    372                stUSART2.TX_BUF[15] = u_Data11;		// NULL
    373                stUSART2.TX_BUF[16] = u_Data12;		// -
    374                stUSART2.TX_BUF[17] = u_Data13;		// 0
    375                stUSART2.TX_BUF[18] = u_Data14;		// 0
    376                stUSART2.TX_BUF[19] = u_Data15;		// 0
    377                stUSART2.TX_BUF[20] = u_Data16;		// .
    378                stUSART2.TX_BUF[21] = u_Data17;		// 0
    379                stUSART2.TX_BUF[22] = u_Data18;		// 0
    380          
    381                stUSART2.TX_BUF[23] = 0x00;
    382          
    383                for (i = 2; i < 23; i++)
    384                {
    385                   u_Sum_Data = (u8)(u_Sum_Data + stUSART2.TX_BUF[i]);
    386                }
    387          
    388                stUSART2.TX_BUF[23] = u_Sum_Data;
    389          
    390                stUSART2.TX_BUF[24] = 0x5F;
    391          
    392                stUSART2.TX_CNT = 0;
    393                stUSART2.TX_MAX = u_Leng + 0x07;
    394          
    395                USART_SendData(USART2, stUSART2.TX_BUF[stUSART2.TX_CNT++]);
    396                Delay_1ms(u_Timer);
    397          
    398                break;
    399          
    400             default:
    401                break;
    402             }
    403          
    404          }
    405          
    406          /*******************************************************************************
    407          * Function : LRF_Initialization
    408          *******************************************************************************/
    409          void LRF_Initialization(void)
    410          {
    411             Send_LRF_Data(LRF_INIT, LRF_TRANS_DELAY);
    412             Send_LRF_Data(LRF_MAX_TIME, LRF_TRANS_DELAY);
    413             Send_LRF_Data(LRF_LIMIT, LRF_TRANS_DELAY);
    414             //Send_LRF_Data(LRF_CALL_DATA, LRF_TRANS_DELAY);
    415          
    416             stLRF.INIT_ACTIVE = 0x00;
    417          
    418             // TEST
    419             //stLRF.CONTINUOUS_FLAG = 0x01;
    420          }
    421          
    422          /*******************************************************************************
    423          * Function : Reponse_Data_Send
    424          *******************************************************************************/
    425          void Reponse_Data_Send(u8 Comm, u8 R1_data, u8 R2_data)
    426          {
    427             stUSART1.TX_BUF[0] = 0xCA;
    428             stUSART1.TX_BUF[1] = 0xAC;
    429             stUSART1.TX_BUF[2] = Comm;
    430             stUSART1.TX_BUF[3] = R1_data;
    431             stUSART1.TX_BUF[4] = R2_data;
    432             stUSART1.TX_BUF[5] = 0x00;
    433             stUSART1.TX_BUF[5] = stUSART1.TX_BUF[2] + stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4];
    434          
    435             stUSART1.TX_CNT = 0;
    436             stUSART1.TX_MAX = 6;
    437          
    438             USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
    439          }
    440          
    441          /*******************************************************************************
    442          * Function : Send_COLOR_TILT_Data
    443          *******************************************************************************/
    444          void Send_Light_Data(u8 u_Cmd, u8 u_Sign, u8 u_Data1, u8 u_Data2, u8 u_Data3, u8 u_Data4, u8 u_Leng, u8 u_Timer)
    445          {
    446             stUSART2.TX_BUF[0] = 0x24;
    447             stUSART2.TX_BUF[1] = u_Cmd;
    448             stUSART2.TX_BUF[2] = 0x31;
    449             stUSART2.TX_BUF[3] = u_Sign;
    450             stUSART2.TX_BUF[4] = u_Data1;
    451             stUSART2.TX_BUF[5] = u_Data2;
    452             stUSART2.TX_BUF[6] = u_Data3;
    453             stUSART2.TX_BUF[7] = u_Data4;
    454             stUSART2.TX_BUF[8] = 0x23;
    455          
    456             stUSART2.TX_CNT = 0;
    457             stUSART2.TX_MAX = u_Leng;
    458          
    459             USART_SendData(USART2, stUSART2.TX_BUF[stUSART2.TX_CNT++]);
    460             Delay_1ms(u_Timer);
    461          }
    462          
    463          /*******************************************************************************
    464          * Function : Send_TSM_Data
    465          *******************************************************************************/
    466          void Send_TSM_Data(u8 u_Cmd, u8 u_Data1, u8 u_Data2, u8 u_Data3, u8 u_Leng, u8 u_Timer)
    467          {
    468             stUART4.TX_BUF[0] = 0xA0;
    469             stUART4.TX_BUF[1] = u_Cmd;
    470             stUART4.TX_BUF[2] = u_Data1;
    471             stUART4.TX_BUF[3] = u_Data2;
    472             stUART4.TX_BUF[4] = u_Data3;
    473             stUART4.TX_BUF[5] = 0xAF;
    474          
    475             stUART4.TX_CNT = 0;
    476             stUART4.TX_MAX = u_Leng;
    477          
    478             USART_SendData(UART4, stUART4.TX_BUF[stUART4.TX_CNT++]);
    479             Delay_1ms(u_Timer);
    480          }
    481          
    482          /*******************************************************************************
    483          * Function : Send_TCM_Data
    484          *******************************************************************************/
    485          void Send_TCM_Data(u8 u_Cmd, u8 u_Data1, u8 u_Data2, u8 u_Data3, u8 u_Data4, u8 u_Data5, u8 u_Data6, u8 u_Data7, u8 u_Data8, u8 u_Data9, u8 u_Leng, u8 u_Timer)
    486          {
    487             switch (u_Leng)
    488             {
    489             case 0x06:
    490          
    491                stUART4.TX_BUF[0] = 0xA0;
    492                stUART4.TX_BUF[1] = u_Cmd;
    493                stUART4.TX_BUF[2] = u_Data1;
    494                stUART4.TX_BUF[3] = u_Data2;
    495                stUART4.TX_BUF[4] = u_Data3;
    496                stUART4.TX_BUF[5] = 0xAF;
    497          
    498                stUART4.TX_CNT = 0;
    499                stUART4.TX_MAX = u_Leng;
    500          
    501                break;
    502          
    503             case 0x08:
    504          
    505                stUART4.TX_BUF[0] = 0xA0;
    506                stUART4.TX_BUF[1] = u_Cmd;
    507                stUART4.TX_BUF[2] = u_Data1;
    508                stUART4.TX_BUF[3] = u_Data2;
    509                stUART4.TX_BUF[4] = u_Data3;
    510                stUART4.TX_BUF[5] = u_Data4;
    511                stUART4.TX_BUF[6] = u_Data5;
    512                stUART4.TX_BUF[7] = 0xAF;
    513          
    514                stUART4.TX_CNT = 0;
    515                stUART4.TX_MAX = u_Leng;
    516          
    517                break;
    518          
    519             case 0x0C:
    520          
    521                stUART4.TX_BUF[0] = 0xA0;
    522                stUART4.TX_BUF[1] = u_Cmd;
    523                stUART4.TX_BUF[2] = u_Data1;
    524                stUART4.TX_BUF[3] = u_Data2;
    525                stUART4.TX_BUF[4] = u_Data3;
    526                stUART4.TX_BUF[5] = u_Data4;
    527                stUART4.TX_BUF[6] = u_Data5;
    528                stUART4.TX_BUF[3] = u_Data6;
    529                stUART4.TX_BUF[4] = u_Data7;
    530                stUART4.TX_BUF[5] = u_Data8;
    531                stUART4.TX_BUF[6] = u_Data9;
    532                stUART4.TX_BUF[7] = 0xAF;
    533          
    534                stUART4.TX_CNT = 0;
    535                stUART4.TX_MAX = u_Leng;
    536          
    537                break;
    538          
    539             }
    540          
    541             USART_SendData(UART4, stUART4.TX_BUF[stUART4.TX_CNT++]);
    542             Delay_1ms(u_Timer);
    543          
    544          }
    545          
    546          /*******************************************************************************
    547          * Function : Send_USART1_Ack
    548          *******************************************************************************/
    549          void Send_UART4_Ack(u8 u_Index, u8 u_Leng, u8 u_Address, u8 u_Cmd, u8 u_Data, u8 u_timer)
    550          {
    551             u8 u_Checksum = 0x00;
    552          
    553             switch (u_Leng)
    554             {
    555             case 0x02:
    556          
    557                stUART4.TX_BUF[0] = IP_BOARD_SYNC_BYTE;
    558                stUART4.TX_BUF[1] = IP_BOARD_SYNC_AND_BYTE;
    559          
    560                stUART4.TX_BUF[2] = u_Index;
    561                stUART4.TX_BUF[3] = u_Leng;
    562                stUART4.TX_BUF[4] = u_Address;
    563                stUART4.TX_BUF[5] = u_Cmd;
    564          
    565                u_Checksum = stUART4.TX_BUF[4] + stUART4.TX_BUF[5];
    566          
    567                stUART4.TX_BUF[6] = u_Checksum;
    568          
    569                switch (u_Index)
    570                {
    571                case IP_SONY_FIRST_BYTE:
    572                   stUART4.TX_BUF[7] = 0xAF;
    573                   break;
    574          
    575                case IP_TSM_FIRST_BYTE:
    576                   stUART4.TX_BUF[7] = 0xBF;
    577                   break;
    578          
    579                case IP_OPTION_FIRST_BYTE:
    580                   stUART4.TX_BUF[7] = 0xEF;
    581                   break;
    582                }
    583          
    584                stUART4.TX_MAX = u_Leng + 6;
    585                stUART4.TX_CNT = 0x00;
    586          
    587                USART_SendData(UART4, stUART4.TX_BUF[stUART4.TX_CNT++]);
    588                Delay_1ms(u_timer);
    589          
    590                break;
    591          
    592             case 0x03:
    593          
    594                stUART4.TX_BUF[0] = IP_BOARD_SYNC_BYTE;
    595                stUART4.TX_BUF[1] = IP_BOARD_SYNC_AND_BYTE;
    596          
    597                stUART4.TX_BUF[2] = u_Index;
    598                stUART4.TX_BUF[3] = u_Leng;
    599                stUART4.TX_BUF[4] = u_Address;
    600                stUART4.TX_BUF[5] = u_Cmd;
    601                stUART4.TX_BUF[6] = u_Data;
    602          
    603                u_Checksum = stUART4.TX_BUF[4] + stUART4.TX_BUF[5];
    604          
    605                stUART4.TX_BUF[7] = u_Checksum;
    606          
    607                switch (u_Index)
    608                {
    609                case IP_SONY_FIRST_BYTE:
    610                   stUART4.TX_BUF[8] = 0xAF;
    611                   break;
    612          
    613                case IP_TSM_FIRST_BYTE:
    614                   stUART4.TX_BUF[8] = 0xBF;
    615                   break;
    616          
    617                case IP_OPTION_FIRST_BYTE:
    618                   stUART4.TX_BUF[8] = 0xEF;
    619                   break;
    620                }
    621          
    622                stUART4.TX_MAX = u_Leng + 6;
    623                stUART4.TX_CNT = 0x00;
    624          
    625                USART_SendData(UART4, stUART4.TX_BUF[stUART4.TX_CNT++]);
    626                Delay_1ms(u_timer);
    627          
    628                break;
    629             }
    630          }
    631          
    632          /*******************************************************************************
    633          * Function : Send_Pelco_Data
    634          *******************************************************************************/
    635          void Send_Pelco_Data(u8 u_Comm1, u8 u_Comm2, u8 u_Data1, u8 u_Data2, u8 u_Leng, u8 u_Timer)
    636          {
    637             stUSART1.TX_BUF[0] = 0xFF;
    638             stUSART1.TX_BUF[1] = 0x01;
    639             stUSART1.TX_BUF[2] = u_Comm1;
    640             stUSART1.TX_BUF[3] = u_Comm2;
    641             stUSART1.TX_BUF[4] = u_Data1;
    642             stUSART1.TX_BUF[5] = u_Data2;
    643             stUSART1.TX_BUF[6] = stUSART1.TX_BUF[1] + stUSART1.TX_BUF[2] + stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5];
    644          
    645             stUSART1.TX_CNT = 0;
    646             stUSART1.TX_MAX = u_Leng;
    647          
    648             USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
    649             Delay_1ms(u_Timer);
    650          }
    651          
    652          /*******************************************************************************
    653          * Function Name  : USART1_Data_Parser
    654          *******************************************************************************/
    655          void Bypass_Data_Parser(void)
    656          {
    657             u8 i = 0;
    658          
    659             /*******************************************************************************************
    660             * Data Format
    661             						BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]
    662             1) General Command		0x81		0x01		0x04		CMD			DATA1		0xFF
    663             2) Inquiry Command		0x81		0x09		0x04		CMD			0xFF
    664             3) Address Set			0x88		0x30		0x01		0xFF
    665             4) IF_Clear(Broadcast)		0x88		0x01		0x00		0x01		0xFF
    666             5) IF_Clear (For x)			0x8x		0x01		0x00		0x01		0xFF
    667             6) Command Cancel		0x8x		0x2y		0xFF
    668             *******************************************************************************************/
    669             if (stUSART1.RX_BYPASS == 0x01)
    670             {
    671                stUSART1.RX_BYPASS = 0x00;
    672          
    673                stUART5.TX_CNT = 0;
    674                stUART5.TX_MAX = stUSART1.RX_BYPASS_CNT;
    675          
    676                for (i = 0; i < stUART5.TX_MAX; i++)
    677                {
    678                   stUART5.TX_BUF[i] = stUSART1.RX_BUF[i];
    679                }
    680          
    681                USART_SendData(UART5, stUART5.TX_BUF[stUART5.TX_CNT++]);
    682                Delay_1ms(SONY_COMMAND_TIMER_DELAY);
    683             }
    684          }
    685          
    686          /*******************************************************************************
    687          * Function : Send_Data_Clear
    688          *******************************************************************************/
    689          void Send_Data_Clear(u8 u_sync, u8 u_Leng)
    690          {
    691             u8 i, i_Max = u_Leng + 5;
    692          
    693             for (i = 0; i < u_Leng; i++)
    694             {
    695                switch (u_sync)
    696                {
    697                case USART1_INDEX:
    698          
    699                   stUSART1.RX_BUF[i] = 0x00;
    700          
    701                   break;
    702                }
    703             }
    704          }
    705          
    706          /*******************************************************************************
    707          * Function : USART1_Send_Data
    708          *******************************************************************************/
    709          void USART1_Send_Data(u8 u_sync, u8 u_Comm, u8 u_Data1, u8 u_Data2, u8 u_Data3, u8 u_Leng)
    710          {
    711             u8 i, i_Max = u_Leng + 3;
    712             u8 u_Checksum = 0x00;
    713          
    714             switch (u_sync)
    715             {
    716             case IP_SONY_FIRST_BYTE:
    717          
    718                stUSART1.TX_BUF[0] = IP_SONY_FIRST_BYTE;
    719                stUSART1.TX_BUF[1] = IP_SONY_SECOND_BYTE;
    720                stUSART1.TX_BUF[u_Leng + 4] = 0xAF;
    721          
    722                break;
    723             }
    724          
    725             stUSART1.TX_BUF[2] = u_Leng;
    726             stUSART1.TX_BUF[3] = 0x01;
    727          
    728             switch (u_Leng)
    729             {
    730             case 0x05:
    731          
    732                stUSART1.TX_BUF[4] = u_Comm;
    733                stUSART1.TX_BUF[5] = u_Data1;
    734                stUSART1.TX_BUF[6] = u_Data2;
    735                stUSART1.TX_BUF[7] = u_Data3;
    736          
    737                break;
    738             }
    739          
    740             stUSART1.TX_BUF[i_Max] = 0x00;
    741          
    742             for (i = 3; i < i_Max; i++)
    743             {
    744                u_Checksum += stUSART1.TX_BUF[i];
    745             }
    746          
    747             stUSART1.TX_BUF[i_Max] = u_Checksum;
    748          
    749             stUSART1.TX_CNT = 0;
    750             stUSART1.TX_MAX = u_Leng + 5;
    751          
    752             USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
    753             Delay_1ms(MAIN_COMMAND_TIMER_DELAY);
    754          }
    755          
    756          /***************************************************************************************************************************
    757          * Function : Sony_Data_Handing
    758          * Protocol Version : 0.1 (2016.04.11)
    759          * Data Architecture :
    760          BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]		BYTE[..]		BYTE(n)[LENGTH+4]	BYTE(n+1)[LENGTH+4]
    761          0xA0		0x0A		LENGTH		ADDR		COMM		DATA		...			CS					0xAF
    762          ****************************************************************************************************************************/
    763          void Sony_Data_Handing(u8 u_Port, u8 u_Comm, u8 u_Leng)
    764          {
    765             u8 u_Cmd = 0x00, u_Data_Check = 0x00;	// Camera Command
    766             u8 u_Data[5];
    767             u16 u16_Convert_Data = 0x0000;
    768          
    769             switch (u_Port)
    770             {
    771             case SYSTEM_INDEX:
    772          
    773                u_Cmd = stSYS.RX_BUF[0][5];
    774                u_Data[0] = stSYS.RX_BUF[0][6];
    775                u_Data[1] = stSYS.RX_BUF[0][7];
    776          
    777                break;
    778          
    779             case USART1_INDEX:
    780          
    781                u_Cmd = stUSART1.RX_BUF[4];
    782                u_Data[0] = stUSART1.RX_BUF[5];
    783                u_Data[1] = stUSART1.RX_BUF[6];
    784          
    785                break;
    786          
    787             case USART5_INDEX:
    788          
    789                u_Cmd = stUART5.RX_BUF[4];
    790                u_Data[0] = stUART5.RX_BUF[5];
    791                u_Data[1] = stUART5.RX_BUF[6];
    792          
    793                break;
    794          
    795             default:
    796                break;
    797             }
    798          
    799             switch (u_Comm)
    800             {
    801                // 1.1.	Set Focus Mode (0x91)
    802             case SONY_SET_FOCUS_MODE:
    803          
    804                stSONY.SET_FOCUS_MODE = u_Data[1];
    805          
    806                AT24C256C_EEPROM_Write(EEP_SET_FOCUS_MODE, stSONY.SET_FOCUS_MODE);
    807          
    808                u_Data[0] = 0x00;
    809                u_Data[1] = 0x00;
    810          
    811                switch (stSONY.SET_FOCUS_MODE)
    812                {
    813                   // Auto Focus
    814                case 0x00:
    815          
    816                   switch (stSONY.SET_AUTO_FOCUS_MODE)
    817                   {
    818                   case 0x00:
    819          
    820                      // Normal
    821                      u_Cmd = 0x57;
    822                      u_Data[0] = 0x00;
    823          
    824                      Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    825          
    826                      u_Cmd = 0x38;
    827                      u_Data[0] = 0x02;
    828          
    829                      Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    830          
    831                      break;
    832          
    833                   case 0x01:
    834          
    835                      // Zoom Trigger
    836                      u_Cmd = 0x57;
    837                      u_Data[0] = 0x02;
    838          
    839                      Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    840          
    841                      u_Cmd = 0x38;
    842                      u_Data[0] = 0x02;
    843          
    844                      Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    845          
    846                      break;
    847          
    848                   default:
    849                      break;
    850                   }
    851          
    852                   break;
    853          
    854                   // Manual Focus
    855                case 0x01:
    856          
    857                   u_Cmd = 0x38;
    858                   u_Data[0] = 0x03;
    859          
    860                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    861          
    862                   u_Cmd = SONY_MANUAL_FOCUS_DIRECT;
    863                   u_Data[0] = (u8)(stSONY.SET_MANUAL_FOCUS_DATA >> 8);
    864                   u_Data[1] = (u8)(stSONY.SET_MANUAL_FOCUS_DATA & 0xFF);
    865          
    866                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x09, SONY_COMMAND_TIMER_DELAY);
    867          
    868                   break;
    869          
    870                   // One Push Trigger
    871                case 0x02:
    872          
    873                   u_Cmd = 0x38;
    874                   u_Data[0] = 0x03;
    875          
    876                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    877          
    878                   u_Cmd = 0x18;
    879                   u_Data[0] = 0x01;
    880          
    881                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    882          
    883                   break;
    884          
    885                default:
    886                   break;
    887                }
    888          
    889                break;
    890          
    891                // 1.2.	Set Auto Focus Mode (0x93)
    892             case SONY_SET_AUTO_FOCUS_MODE:
    893          
    894                // Command & Data Convert
    895                u_Cmd = 0x57;
    896          
    897                stSONY.SET_AUTO_FOCUS_MODE = u_Data[1];
    898          
    899                AT24C256C_EEPROM_Write(EEP_SET_AUTO_FOCUS_MODE, stSONY.SET_AUTO_FOCUS_MODE);
    900          
    901                u_Data[0] = 0x00;
    902                u_Data[1] = 0x00;
    903          
    904                switch (stSONY.SET_AUTO_FOCUS_MODE)
    905                {
    906                   // Normal
    907                case 0x00:
    908                   u_Data[0] = 0x00;
    909                   break;
    910          
    911                   // Zoom Trigger
    912                case 0x01:
    913                   u_Data[0] = 0x02;
    914                   break;
    915          
    916                default:
    917                   break;
    918                }
    919          
    920                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    921          
    922                break;
    923          
    924                // 1.3.	Manual Focus (0x08)
    925             case SONY_MANUAL_FOCUS:
    926          
    927                u_Data_Check = stSONY.SET_FOCUS_MODE;
    928          
    929                switch (u_Data_Check)
    930                {
    931                case 0x01:
    932                case 0x02:
    933                   stSONY.SET_MANUAL_FOCUS_MODE = u_Data[1];
    934                   break;
    935          
    936                default:
    937          
    938                   u_Data_Check = 0xFF;
    939          
    940                   break;
    941                }
    942          
    943                u_Data[0] = 0x00;
    944                u_Data[1] = 0x00;
    945          
    946                if (u_Data_Check == 0xFF)
    947                   break;
    948          
    949                switch (stSONY.SET_MANUAL_FOCUS_MODE)
    950                {
    951                   // Stop
    952                case 0x00:
    953          
    954                   u_Cmd = 0x08;
    955                   u_Data[0] = 0x00;
    956                   stSONY.FOCUS_STATUS = STOP;
    957          
    958                   break;
    959          
    960                   // Focus Far
    961                case 0x01:
    962          
    963                   if (stSONY.SET_FOCUS_MODE == 0x02)
    964                   {
    965                      u_Cmd = 0x38;
    966                      u_Data[0] = 0x03;
    967                      Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    968                   }
    969          
    970                   u_Cmd = 0x08;
    971                   u_Data[0] = 0x24;
    972                   stSONY.FOCUS_STATUS = ACTIVE;
    973                   stSONY.DIV_TRIGGER_NON_FOCUS = 0x01;
    974          
    975                   break;
    976          
    977                   // Focus Near
    978                case 0x02:
    979          
    980                   if (stSONY.SET_FOCUS_MODE == 0x02)
    981                   {
    982                      u_Cmd = 0x38;
    983                      u_Data[0] = 0x03;
    984                      Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    985                   }
    986          
    987                   u_Cmd = 0x08;
    988                   u_Data[0] = 0x34;
    989                   stSONY.FOCUS_STATUS = ACTIVE;
    990                   stSONY.DIV_TRIGGER_NON_FOCUS = 0x01;
    991          
    992                   break;
    993          
    994                default:
    995                   break;
    996                }
    997          
    998                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    999          
   1000                break;
   1001          
   1002                // 1.4.	Manual IRIS Mode (0x0B)
   1003             case SONY_MANUAL_IRIS:
   1004          
   1005                stSONY.SET_MANUAL_IRIS_MODE = u_Data[1];
   1006          
   1007                u_Data[0] = 0x00;
   1008                u_Data[1] = 0x00;
   1009          
   1010                switch (stSONY.SET_MANUAL_IRIS_MODE)
   1011                {
   1012                   // Stop
   1013                case 0x00:
   1014                   u_Cmd = 0x39;
   1015                   u_Data[0] = 0x03;
   1016                   stSONY.CIRIS_STATUS = STOP;
   1017                   stSONY.CIRIS_MODE_FLAG = 0x01;
   1018                   break;
   1019          
   1020                   // Iris Open
   1021                case 0x01:
   1022                   u_Cmd = 0x0B;
   1023                   u_Data[0] = 0x02;
   1024                   stSONY.CIRIS_STATUS = ACTIVE;
   1025                   stSONY.CIRIS_MODE_FLAG = 0x01;
   1026                   break;
   1027          
   1028                   // Iris Close
   1029                case 0x02:
   1030                   u_Cmd = 0x0B;
   1031                   u_Data[0] = 0x03;
   1032                   stSONY.CIRIS_STATUS = ACTIVE;
   1033                   stSONY.CIRIS_MODE_FLAG = 0x01;
   1034                   break;
   1035          
   1036                default:
   1037                   break;
   1038                }
   1039          
   1040                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1041          
   1042                break;
   1043          
   1044                // 1.4.	Manual Focus Direct (0x48)
   1045             case SONY_MANUAL_FOCUS_DIRECT:
   1046          
   1047                u_Data_Check = stSONY.SET_FOCUS_MODE;
   1048          
   1049                if (u_Data_Check != 0x01)
   1050                   break;
   1051          
   1052                u_Cmd = SONY_MANUAL_FOCUS_DIRECT;
   1053          
   1054                stSONY.SET_MANUAL_FOCUS_DATA = 0x0000;
   1055                stSONY.SET_MANUAL_FOCUS_DATA = u_Data[0] << 8;
   1056                stSONY.SET_MANUAL_FOCUS_DATA |= u_Data[1];
   1057          
   1058                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x09, SONY_COMMAND_TIMER_DELAY);
   1059          
   1060                AT24C256C_EEPROM_Write(EEP_MANUAL_FOCUS_DATA, u_Data[0]);
   1061                AT24C256C_EEPROM_Write(EEP_MANUAL_FOCUS_DATA + 1, u_Data[1]);
   1062          
   1063                break;
   1064          
   1065                // 1.5.	Manual Zoom (0x07)
   1066             case SONY_MANUAL_ZOOM:
   1067          
   1068                stSONY.SET_MANUAL_ZOOM_MODE = u_Data[1];
   1069          
   1070                u_Data[0] = 0x00;
   1071                u_Data[1] = 0x00;
   1072          
   1073                u_Cmd = 0x07;
   1074          
   1075                switch (stSONY.SET_MANUAL_ZOOM_MODE)
   1076                {
   1077                   // Stop
   1078                case 0x00:
   1079                   stSONY.ZOOM_STATUS = STOP;
   1080                   u_Data[0] = 0x00;
   1081                   break;
   1082          
   1083                   // Tele
   1084                case 0x01:
   1085                   stSONY.ZOOM_STATUS = ACTIVE;
   1086                   u_Data[0] = 0x27;
   1087                   break;
   1088          
   1089                   // Wide
   1090                case 0x02:
   1091                   stSONY.ZOOM_STATUS = ACTIVE;
   1092                   u_Data[0] = 0x37;
   1093                   break;
   1094          
   1095                default:
   1096                   break;
   1097                }
   1098          
   1099                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1100          
   1101                break;
   1102          
   1103                // 1.6.	Manual Focus Direct (0x48)
   1104             case SONY_MANUAL_ZOOM_DIRECT:
   1105          
   1106                u_Cmd = SONY_MANUAL_ZOOM_DIRECT;
   1107          
   1108                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x09, SONY_COMMAND_TIMER_DELAY);
   1109          
   1110                break;
   1111          
   1112                // 1.7.	Set BLC Mode (0x31)
   1113             case SONY_SET_BLC_MODE:
   1114          
   1115                stSONY.SET_BLC_MODE = u_Data[1];
   1116          
   1117                AT24C256C_EEPROM_Write(EEP_SET_BLC_MODE, stSONY.SET_BLC_MODE);
   1118          
   1119                u_Data[0] = 0x00;
   1120                u_Data[1] = 0x00;
   1121          
   1122                switch (stSONY.SET_BLC_MODE)
   1123                {
   1124                   // BLC/WDR OFF
   1125                case 0x00:
   1126          
   1127                   u_Cmd = 0x3D;
   1128                   u_Data[0] = 0x03;
   1129                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1130          
   1131                   u_Cmd = 0x33;
   1132                   u_Data[0] = 0x03;
   1133                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1134          
   1135                   break;
   1136          
   1137                   // BLC ON
   1138                case 0x01:
   1139          
   1140                   u_Cmd = 0x3D;
   1141                   u_Data[0] = 0x03;
   1142                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1143          
   1144                   u_Cmd = 0x33;
   1145                   u_Data[0] = 0x02;
   1146                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1147          
   1148                   break;
   1149          
   1150                   // WDR ON
   1151                case 0x10:
   1152          
   1153                   u_Cmd = 0x3D;
   1154                   u_Data[0] = 0x02;
   1155                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1156          
   1157                   u_Cmd = 0x33;
   1158                   u_Data[0] = 0x03;
   1159                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1160          
   1161                   break;
   1162          
   1163                   // BLC/WDR ON
   1164                case 0x11:
   1165          
   1166                   u_Cmd = 0x3D;
   1167                   u_Data[0] = 0x02;
   1168                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1169          
   1170                   u_Cmd = 0x33;
   1171                   u_Data[0] = 0x02;
   1172                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1173          
   1174                   break;
   1175          
   1176                default:
   1177                   break;
   1178                }
   1179          
   1180                break;
   1181          
   1182                // 1.8.	Set White Balance Mode (0x33)
   1183             case SONY_SET_WHITE_BALANCE_MODE:
   1184          
   1185                // Command & Data Convert
   1186                u_Cmd = 0x35;
   1187          
   1188                stSONY.SET_WHITE_BALANCE_MODE = u_Data[1];
   1189          
   1190                AT24C256C_EEPROM_Write(EEP_SET_WHITE_BALANCE_MODE, stSONY.SET_WHITE_BALANCE_MODE);
   1191          
   1192                u_Data[0] = 0x00;
   1193                u_Data[1] = 0x00;
   1194          
   1195                switch (stSONY.SET_WHITE_BALANCE_MODE)
   1196                {
   1197                   // Auto white balance Mode (Range : 3000 to 7500K)
   1198                case 0x00:
   1199                   u_Data[0] = 0x00;
   1200                   break;
   1201          
   1202                   // In door Mode
   1203                case 0x01:
   1204                   u_Data[0] = 0x01;
   1205                   break;
   1206          
   1207                   // Out door Mode
   1208                case 0x02:
   1209                   u_Data[0] = 0x02;
   1210                   break;
   1211          
   1212                   // Auto tracing white balance Mode (Range : 2000 to 10000K)
   1213                case 0x03:
   1214                   u_Data[0] = 0x04;
   1215                   break;
   1216          
   1217                default:
   1218                   break;
   1219                }
   1220          
   1221                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1222          
   1223                break;
   1224          
   1225                // 1.9.	Set Defog Mode (0x37)
   1226             case SONY_SET_DEFOG_MODE:
   1227          
   1228                stSONY.SET_DEFOG_MODE = u_Data[1];
   1229          
   1230                AT24C256C_EEPROM_Write(EEP_SET_DEFOG_MODE, stSONY.SET_DEFOG_MODE);
   1231          
   1232                u_Data[0] = 0x00;
   1233                u_Data[1] = 0x00;
   1234          
   1235                switch (stSONY.SET_DEFOG_MODE)
   1236                {
   1237                   // Defog Off
   1238                case 0x00:
   1239                   u_Data[0] = 0x03;
   1240                   break;
   1241          
   1242                   // Defog On
   1243                case 0x01:
   1244                   u_Data[0] = 0x02;
   1245                   break;
   1246          
   1247                   //  0x01   Defog On
   1248                default:
   1249                   u_Data[0] = 0x02;
   1250                   stSONY.SET_DEFOG_MODE = 0x02;
   1251                   break;
   1252                }
   1253          
   1254                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x07, SONY_COMMAND_TIMER_DELAY);
   1255          
   1256                break;
   1257          
   1258                // 1.10.	Set Shutter Speed (0x4A)
   1259             case SONY_SET_SHUTTER_SPEED:
   1260          
   1261                u_Data_Check = u_Data[1];
   1262          
   1263                if (u_Data_Check > 0x16)
   1264                   break;
   1265          
   1266                stSONY.SET_SHUTTER_SPEED = u_Data[1];
   1267          
   1268                AT24C256C_EEPROM_Write(EEP_SET_SHUTTER_SPEED, stSONY.SET_SHUTTER_SPEED);
   1269          
   1270                u_Data[0] = 0x00;
   1271                u_Data[1] = 0x00;
   1272          
   1273                if (stSONY.SET_SHUTTER_SPEED == 0x00)
   1274                {
   1275                   if (stSONY.SET_FLICKER_MODE)
   1276                   {
   1277                      // Flicker On   Flicker Off
   1278                      stSONY.SET_FLICKER_MODE = 0x00;
   1279          
   1280                      u_Cmd = 0x39;
   1281                      u_Data[0] = 0x00;
   1282          
   1283                      Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1284                   }
   1285          
   1286                   u_Cmd = 0x4A;
   1287                   u_Data[0] = 0x00;
   1288                   u_Data[1] = 0x06;
   1289          
   1290                   // when, NTSC:1/30, PAL:1/25
   1291                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x09, SONY_COMMAND_TIMER_DELAY);
   1292          
   1293                   u_Cmd = 0x39;
   1294                   u_Data[0] = 0x00;
   1295          
   1296                   // Full-Auto Mode
   1297                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1298          
   1299                   stSONY.SET_SHUTTER_SPEED = 0x00;
   1300                }
   1301                else
   1302                {
   1303                   if (stSONY.SET_DSS_MODE)
   1304                   {
   1305                      if (stSONY.SET_SHUTTER_SPEED <= 0x16)
   1306                      {
   1307                         if (stINFO.NTSC_PAL_STATUS == NTSC_MODE)
   1308                         {
   1309                            if (stSONY.SET_SHUTTER_SPEED == 0x09)
   1310                            {
   1311                               stSONY.SET_FLICKER_MODE = 0x01;
   1312          
   1313                               // Shutter Priority Mode
   1314                               u_Cmd = 0x39;
   1315                               u_Data[0] = 0x0A;
   1316                               Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1317                            }
   1318                            else
   1319                            {
   1320                               stSONY.SET_FLICKER_MODE = 0x00;
   1321          
   1322                               u_Cmd = 0x39;
   1323                               u_Data[0] = 0x00;
   1324          
   1325                               // Full-Auto Mode
   1326                               Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1327                            }
   1328                         }
   1329                         else if (stINFO.NTSC_PAL_STATUS == PAL_MODE)
   1330                         {
   1331                            if (stSONY.SET_SHUTTER_SPEED == 0x08)
   1332                            {
   1333                               stSONY.SET_FLICKER_MODE = 0x01;
   1334          
   1335                               // Shutter Priority Mode
   1336                               u_Cmd = 0x39;
   1337                               u_Data[0] = 0x0A;
   1338                               Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1339                            }
   1340                            else
   1341                            {
   1342                               stSONY.SET_FLICKER_MODE = 0x00;
   1343          
   1344                               u_Cmd = 0x39;
   1345                               u_Data[0] = 0x00;
   1346          
   1347                               // Full-Auto Mode
   1348                               Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1349                            }
   1350                         }
   1351          
   1352                         // Shutter Priority Mode
   1353                         u_Cmd = 0x39;
   1354                         u_Data[0] = 0x0A;
   1355                         Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1356          
   1357                         // Shutter Speed Setting
   1358                         u_Cmd = 0x4A;
   1359                         u_Data[0] = 0x00;
   1360                         u_Data[1] = stSONY.SET_SHUTTER_SPEED - 1;
   1361                         Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x09, SONY_COMMAND_TIMER_DELAY);
   1362          
   1363                      }
   1364                   }
   1365                   else
   1366                   {
   1367                      if ((stSONY.SET_SHUTTER_SPEED <= 0x16) && (stSONY.SET_SHUTTER_SPEED > 0x05))
   1368                      {
   1369                         if (stINFO.NTSC_PAL_STATUS == NTSC_MODE)
   1370                         {
   1371                            if (stSONY.SET_SHUTTER_SPEED == 0x09)
   1372                            {
   1373                               stSONY.SET_FLICKER_MODE = 0x01;
   1374          
   1375                               // Shutter Priority Mode
   1376                               u_Cmd = 0x39;
   1377                               u_Data[0] = 0x0A;
   1378                               Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1379                            }
   1380                            else
   1381                            {
   1382                               stSONY.SET_FLICKER_MODE = 0x00;
   1383          
   1384                               u_Cmd = 0x39;
   1385                               u_Data[0] = 0x00;
   1386          
   1387                               // Full-Auto Mode
   1388                               Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1389                            }
   1390                         }
   1391                         else if (stINFO.NTSC_PAL_STATUS == PAL_MODE)
   1392                         {
   1393                            if (stSONY.SET_SHUTTER_SPEED == 0x08)
   1394                            {
   1395                               stSONY.SET_FLICKER_MODE = 0x01;
   1396          
   1397                               // Shutter Priority Mode
   1398                               u_Cmd = 0x39;
   1399                               u_Data[0] = 0x0A;
   1400                               Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1401                            }
   1402                            else
   1403                            {
   1404                               stSONY.SET_FLICKER_MODE = 0x00;
   1405          
   1406                               u_Cmd = 0x39;
   1407                               u_Data[0] = 0x00;
   1408          
   1409                               // Full-Auto Mode
   1410                               Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1411                            }
   1412                         }
   1413          
   1414                         // Shutter Priority Mode
   1415                         u_Cmd = 0x39;
   1416                         u_Data[0] = 0x0A;
   1417                         Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1418          
   1419                         u_Cmd = 0x4A;
   1420                         u_Data[0] = 0x00;
   1421                         u_Data[1] = stSONY.SET_SHUTTER_SPEED - 1;
   1422          
   1423                         // when, NTSC:1/30, PAL:1/25
   1424                         Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x09, SONY_COMMAND_TIMER_DELAY);
   1425                      }
   1426                   }
   1427                }
   1428                break;
   1429          
   1430                // 1.11.	Set Flicker Mode (0x55)
   1431             case SONY_SET_FLICKER_MODE:
   1432          
   1433                stSONY.SET_FLICKER_MODE = u_Data[1];
   1434          
   1435                AT24C256C_EEPROM_Write(EEP_SET_FLICKER_MODE, stSONY.SET_FLICKER_MODE);
   1436          
   1437                u_Data[0] = 0x00;
   1438                u_Data[1] = 0x00;
   1439          
   1440                switch (stSONY.SET_FLICKER_MODE)
   1441                {
   1442                   // Flicker Off = Full-Auto Mode
   1443                case 0x00:
   1444          
   1445                   u_Cmd = 0x39;
   1446                   u_Data[0] = 0x00;
   1447                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);	// Full-Auto Mode
   1448          
   1449                   stSONY.SET_SHUTTER_SPEED = 0x00;
   1450          
   1451                   break;
   1452          
   1453                   // Flicker On = Shutter Priority Mode
   1454                case 0x01:
   1455          
   1456                   u_Cmd = 0x39;
   1457                   u_Data[0] = 0x0A;
   1458                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);	// Shutter Priority Mode
   1459          
   1460                   u_Cmd = 0x4A;
   1461          
   1462                   if (stINFO.NTSC_PAL_STATUS == NTSC_MODE)
   1463                   {
   1464                      u_Data[0] = 0x00;
   1465                      u_Data[1] = 0x08;	// 1/100s
   1466                      stSONY.SET_SHUTTER_SPEED = 0x0A;
   1467                   }
   1468                   else if (stINFO.NTSC_PAL_STATUS == PAL_MODE)
   1469                   {
   1470                      u_Data[0] = 0x00;
   1471                      u_Data[1] = 0x09;	// 1/120s
   1472                      stSONY.SET_SHUTTER_SPEED = 0x09;
   1473                   }
   1474          
   1475                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x09, SONY_COMMAND_TIMER_DELAY);	// Full-Auto Mode
   1476          
   1477                   break;
   1478                }
   1479          
   1480                break;
   1481          
   1482                // 1.12.	Set Aperture Value (0x59)
   1483             case SONY_SET_APERTURE_VALUE:
   1484          
   1485                u_Data_Check = u_Data[1];
   1486          
   1487                if (u_Data_Check > 0x0F)
   1488                   break;
   1489          
   1490                stSONY.SET_APERTURE_VALUE = u_Data[1];
   1491          
   1492                AT24C256C_EEPROM_Write(EEP_SET_APERTURE_VALUE, stSONY.SET_APERTURE_VALUE);
   1493          
   1494                u_Cmd = 0x42;
   1495                u_Data[0] = 0x00;
   1496                u_Data[1] = stSONY.SET_APERTURE_VALUE;
   1497          
   1498                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x09, SONY_COMMAND_TIMER_DELAY);
   1499          
   1500                break;
   1501          
   1502                // 1.13.	Set Digital Zoom Mode (0x5B)
   1503             case SONY_SET_DIGITAL_ZOOM_MODE:
   1504          
   1505                stSONY.SET_DIGITAL_ZOOM_MODE = u_Data[1];
   1506          
   1507                AT24C256C_EEPROM_Write(EEP_SET_DIGITAL_ZOOM_MODE, stSONY.SET_DIGITAL_ZOOM_MODE);
   1508          
   1509                u_Data[0] = 0x00;
   1510                u_Data[1] = 0x00;
   1511          
   1512                switch (stSONY.SET_DIGITAL_ZOOM_MODE)
   1513                {
   1514                   // Digital Zoom Mode Off
   1515                case 0x00:
   1516          
   1517                   u_Cmd = 0x06;
   1518                   u_Data[0] = 0x03;
   1519                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);	// Shutter Priority Mode
   1520          
   1521                   break;
   1522          
   1523                   // Digital Zoom Mode On
   1524                case 0x01:
   1525          
   1526                   u_Cmd = 0x06;
   1527                   u_Data[0] = 0x02;
   1528                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);	// Shutter Priority Mode
   1529          
   1530                   break;
   1531          
   1532                default:
   1533          
   1534                   // 0x01     Digital Zoom Mode On
   1535                   u_Cmd = 0x06;
   1536                   u_Data[0] = 0x02;
   1537                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);	// Shutter Priority Mode
   1538          
   1539                   stSONY.SET_DIGITAL_ZOOM_MODE = 0x01;
   1540          
   1541                   break;
   1542          
   1543                }
   1544          
   1545                break;
   1546          
   1547                // 1.14.	Set Day & Night Mode (0x5F)
   1548             case SONY_SET_DAY_NIGHT_MODE:
   1549          
   1550                stSONY.SET_DAY_NIGHT_MODE = u_Data[1];
   1551          
   1552                AT24C256C_EEPROM_Write(EEP_SET_DAY_NIGHT_MODE, stSONY.SET_DAY_NIGHT_MODE);
   1553          
   1554                u_Data[0] = 0x00;
   1555                u_Data[1] = 0x00;
   1556          
   1557                switch (stSONY.SET_DAY_NIGHT_MODE)
   1558                {
   1559                   // Night Mode
   1560                case 0x00:
   1561          
   1562                   // Auto Mode Off
   1563                   u_Cmd = 0x51;
   1564                   u_Data[0] = 0x03;
   1565                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1566          
   1567                   // Night Mode
   1568                   u_Cmd = 0x01;
   1569                   u_Data[0] = 0x02;
   1570                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1571          
   1572                   break;
   1573          
   1574                   // Day Mode
   1575                case 0x01:
   1576          
   1577                   // Auto Mode Off
   1578                   u_Cmd = 0x51;
   1579                   u_Data[0] = 0x03;
   1580                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1581          
   1582                   // Day Mode
   1583                   u_Cmd = 0x01;
   1584                   u_Data[0] = 0x03;
   1585                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1586          
   1587                   break;
   1588          
   1589                   // Auto Mode
   1590                case 0x02:
   1591          
   1592                   // Auto Mode On
   1593                   u_Cmd = 0x51;
   1594                   u_Data[0] = 0x02;
   1595                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1596          
   1597                   break;
   1598                }
   1599          
   1600                break;
   1601          
   1602                // 1.15.	Set DSS Mode (0x61)
   1603             case SONY_SET_DSS_MODE:
   1604          
   1605                stSONY.SET_DSS_MODE = u_Data[1];
   1606          
   1607                AT24C256C_EEPROM_Write(EEP_SET_DSS_MODE, stSONY.SET_DSS_MODE);
   1608          
   1609                u_Data[0] = 0x00;
   1610                u_Data[1] = 0x00;
   1611          
   1612                switch (stSONY.SET_DSS_MODE)
   1613                {
   1614                   // DSS OFF
   1615                case 0x00:
   1616          
   1617                   // DSS OFF
   1618                   u_Cmd = 0x5A;
   1619                   u_Data[0] = 0x03;
   1620                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1621          
   1622                   if (stSONY.SET_SHUTTER_SPEED < 0x07)
   1623                   {
   1624                      // Full-Auto Mode
   1625                      u_Cmd = 0x39;
   1626                      u_Data[0] = 0x00;
   1627                      Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1628          
   1629                      stSONY.SET_SHUTTER_SPEED = 0x00;
   1630                   }
   1631          
   1632                   break;
   1633          
   1634                   // DSS ON
   1635                case 0x01:
   1636          
   1637                   u_Cmd = 0x5A;
   1638                   u_Data[0] = 0x02;
   1639                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1640          
   1641                   break;
   1642          
   1643                default:
   1644                   break;
   1645                }
   1646          
   1647                break;
   1648          
   1649                // 1.16.	Select BLC / WDR (0x85)
   1650             case SONY_SELECT_BLC_WDR:
   1651          
   1652                stSONY.SELECT_BLC_WDR = u_Data[1];
   1653          
   1654                AT24C256C_EEPROM_Write(EEP_SELECT_BLC_WDR, stSONY.SELECT_BLC_WDR);
   1655          
   1656                u_Data[0] = 0x00;
   1657                u_Data[1] = 0x00;
   1658          
   1659                //  .
   1660                switch (stSONY.SELECT_BLC_WDR)
   1661                {
   1662                case 0x00:
   1663                   break;
   1664          
   1665                case 0x01:
   1666                   break;
   1667          
   1668                default:
   1669                   break;
   1670                }
   1671          
   1672                break;
   1673          
   1674                // 1.17.	Set High Resolution (0x87)
   1675             case SONY_SET_HIGH_RESOLUTION:
   1676          
   1677                stSONY.SET_HIGH_RESOLUTION = u_Data[1];
   1678          
   1679                AT24C256C_EEPROM_Write(EEP_SET_HIGH_RESOLUTION, stSONY.SET_HIGH_RESOLUTION);
   1680          
   1681                u_Data[0] = 0x00;
   1682                u_Data[1] = 0x00;
   1683          
   1684                switch (stSONY.SET_HIGH_RESOLUTION)
   1685                {
   1686                   // HR Mode Off
   1687                case 0x00:
   1688          
   1689                   u_Cmd = 0x52;
   1690                   u_Data[0] = 0x03;
   1691                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1692          
   1693                   break;
   1694          
   1695                   // HR Mode On
   1696                case 0x01:
   1697          
   1698                   u_Cmd = 0x52;
   1699                   u_Data[0] = 0x02;
   1700                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1701          
   1702                   break;
   1703          
   1704                default:
   1705                   break;
   1706                }
   1707          
   1708                break;
   1709          
   1710                // 1.18.	Set Image Stabilizer (0x89)
   1711             case SONY_SET_IMAGE_STABILIZER:
   1712          
   1713                stSONY.SET_IMAGE_STABILIZER = u_Data[1];
   1714          
   1715                AT24C256C_EEPROM_Write(EEP_SET_IMAGE_STABILIZER, stSONY.SET_IMAGE_STABILIZER);
   1716          
   1717                u_Data[0] = 0x00;
   1718                u_Data[1] = 0x00;
   1719          
   1720                switch (stSONY.SET_IMAGE_STABILIZER)
   1721                {
   1722                   // Image Stabilizer Off
   1723                case 0x00:
   1724          
   1725                   u_Cmd = 0x34;
   1726                   u_Data[0] = 0x03;
   1727                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1728          
   1729                   break;
   1730          
   1731                   // Image Stabilizer On
   1732                case 0x01:
   1733          
   1734                   u_Cmd = 0x34;
   1735                   u_Data[0] = 0x02;
   1736                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1737          
   1738                   break;
   1739          
   1740                default:
   1741                   break;
   1742                }
   1743          
   1744                break;
   1745          
   1746                // 1.19.	Set Noise Reduction (0x8B)
   1747             case SONY_SET_NOISE_REDUCTION:
   1748          
   1749                u_Data_Check = u_Data[1];
   1750          
   1751                if (u_Data_Check > 0x05)
   1752                   break;
   1753          
   1754                stSONY.SET_NOISE_REDUCTION = u_Data[1];
   1755          
   1756                AT24C256C_EEPROM_Write(EEP_SET_NOISE_REDUCTION, stSONY.SET_NOISE_REDUCTION);
   1757          
   1758                u_Data[0] = 0x00;
   1759                u_Data[1] = 0x00;
   1760          
   1761                switch (stSONY.SET_NOISE_REDUCTION)
   1762                {
   1763                   // Noise Reduction Off
   1764                case 0x00:
   1765          
   1766                   u_Cmd = 0x53;
   1767                   u_Data[0] = 0x00;
   1768                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1769          
   1770                   break;
   1771          
   1772                   // Image Stabilizer On [Sensitivity] (Lv.1 ~ Lv.5)
   1773                case 0x01:
   1774                case 0x02:
   1775                case 0x03:
   1776                case 0x04:
   1777                case 0x05:
   1778          
   1779                   u_Cmd = 0x53;
   1780                   u_Data[0] = stSONY.SET_NOISE_REDUCTION;
   1781                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1782          
   1783                   break;
   1784          
   1785                default:
   1786                   break;
   1787                }
   1788          
   1789                break;
   1790          
   1791                // 1.20.	Set Color Module (0xF0) -      
   1792             case SONY_SET_COLOR_MODULE:
   1793                break;
   1794          
   1795                // Set NTSC/PAL Mode (0x72)
   1796             case SONY_SET_NTSC_PAL_MODE:
   1797          
   1798                u_Data_Check = u_Data[1];
   1799          
   1800                stSONY.SET_NTSC_PAL_MODE = u_Data[1];
   1801          
   1802                AT24C256C_EEPROM_Write(EEP_SET_NTSC_PAL_MODE, stSONY.SET_NTSC_PAL_MODE);
   1803          
   1804                u_Data[0] = 0x00;
   1805                u_Data[1] = 0x00;
   1806          
   1807                u_Cmd = SONY_SET_NTSC_PAL_MODE;
   1808                u_Data[0] = 0x00;
   1809          
   1810                switch (stSONY.SET_NTSC_PAL_MODE)
   1811                {
   1812                   // NTSC MODE
   1813                case 0x01:
   1814                   u_Data[1] = 0x07;
   1815                   break;
   1816          
   1817                   // PAL MODE
   1818                case 0x02:
   1819                   u_Data[1] = 0x08;
   1820                   break;
   1821          
   1822                default:
   1823                   break;
   1824                }
   1825          
   1826                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x08, SONY_COMMAND_TIMER_DELAY);
   1827          
   1828                break;
   1829          
   1830                // Call Zoom Position (0xB8 : 0xFF - 0x47)
   1831             case 0xB8:
   1832          
   1833                switch (u_Port)
   1834                {
   1835                case USART1_INDEX:
   1836          
   1837                   u_Cmd = SONY_CALL_ZOOM_POSITION;
   1838          
   1839                   u16_Convert_Data = stSONY.ZOOM_CNT;
   1840                   u_Data[0] = (u8)(u16_Convert_Data >> 8);
   1841                   u_Data[1] = (u8)(u16_Convert_Data & 0xFF);
   1842                   u_Leng = 0x05;
   1843          
   1844                   stUSART1.TX_READY = 0x01;
   1845          
   1846                   break;
   1847          
   1848                default:
   1849                   break;
   1850                }
   1851          
   1852                break;
   1853          
   1854             default:
   1855                break;
   1856          
   1857             }
   1858          
   1859             // Send MAIN Command & Data Trans
   1860             if (stUSART1.TX_READY)
   1861             {
   1862                USART1_Send_Data(IP_SONY_FIRST_BYTE, u_Cmd, u_Data[0], u_Data[1], u_Data[2], u_Leng);
   1863          
   1864                stUSART1.TX_READY = 0;
   1865          
   1866                //Send_Data_Clear(USART1_INDEX, u_Leng);
   1867             }
   1868          
   1869             // Send SONY Command & Data Trans
   1870             if (stUART4.TX_READY)
   1871             {
   1872                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], u_Leng, TSM_COMMAND_TIMER_DELAY);
   1873          
   1874                if (!stUART4.TX_REQUEST)
   1875                   stUART4.TX_ACK = 0x01;
   1876          
   1877                stUART4.TX_READY = 0;
   1878          
   1879                //Send_Data_Clear(USART1_INDEX, u_Leng);
   1880             }
   1881          
   1882             // Send Ack Trans
   1883             if (stUART4.TX_ACK)
   1884             {
   1885                stUART4.TX_ACK = 0;
   1886             }
   1887          
   1888          }
   1889          
   1890          /***************************************************************************************************************************
   1891          * Function : TSM_Data_Handing
   1892          * Protocol Version : 0.1 (2016.04.11)
   1893          * Data Architecture :
   1894          BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]		BYTE[..]		BYTE(n)[LENGTH+4]	BYTE(n+1)[LENGTH+4]
   1895          0xB0		0x0B		LENGTH		ADDR		COMM		DATA		...			CS					0xBF
   1896          ****************************************************************************************************************************/
   1897          void TSM_Data_Handing(u8 u_Port, u8 u_Comm, u8 u_Leng)
   1898          {
   1899             u8 u_Cmd = 0x00;	// Camera Command
   1900             u8 u_Data1 = 0x00, u_Data2 = 0x00, u_Data3 = 0x00;
   1901             u8 u_Response_Data = 0x00;
   1902          
   1903             u8 u8_Convert_Data[10];
   1904             u16 u16_Convert_Data = 0x0000;
   1905          
   1906             switch (u_Port)
   1907             {
   1908             case SYSTEM_INDEX:
   1909          
   1910                u_Cmd = stSYS.RX_BUF[0][5];
   1911                u_Data1 = stSYS.RX_BUF[0][6];
   1912                u_Data2 = stSYS.RX_BUF[0][7];
   1913                u_Data3 = stSYS.RX_BUF[0][8];
   1914          
   1915                break;
   1916          
   1917             case USART1_INDEX:
   1918          
   1919                u_Cmd = stUSART1.RX_BUF[4];
   1920                u_Data1 = stUSART1.RX_BUF[5];
   1921                u_Data2 = stUSART1.RX_BUF[6];
   1922                u_Data3 = stUSART1.RX_BUF[7];
   1923          
   1924                break;
   1925          
   1926             case USART5_INDEX:
   1927          
   1928                u_Cmd = stUART5.RX_BUF[4];
   1929                u_Data1 = stUART5.RX_BUF[5];
   1930                u_Data2 = stUART5.RX_BUF[6];
   1931                u_Data3 = stUART5.RX_BUF[7];
   1932          
   1933                break;
   1934          
   1935             default:
   1936                break;
   1937             }
   1938          
   1939             switch (u_Comm)
   1940             {
   1941                // 2.1.1. Initialize (0x01)
   1942             case TSM_INITIALIZE:
   1943                stUART4.TX_READY = 0x01;
   1944                break;
   1945          
   1946                // 2.1.2. Rebooting (0x02)
   1947             case TSM_REBOOTING:
   1948                stUART4.TX_READY = 0x01;
   1949                break;
   1950          
   1951                // 2.1.3. Save Setting (0x04)
   1952             case TSM_SAVE_SETTING:
   1953                stUART4.TX_READY = 0x01;
   1954                break;
   1955          
   1956                // 2.1.4. Shutter Set (0x05)
   1957             case TSM_SHUTTER_SET:
   1958                stUART4.TX_READY = 0x01;
   1959                break;
   1960          
   1961                // 2.1.5. Digital Zoom Start (0x11)
   1962             case TSM_DIGITAL_ZOOM_START:
   1963                stUART4.TX_READY = 0x01;
   1964                break;
   1965          
   1966                // 2.1.6. Digital Zoom Stop (0x10)
   1967             case TSM_DIGITAL_ZOOM_STOP:
   1968                stUART4.TX_READY = 0x01;
   1969                break;
   1970          
   1971                // 2.1.7. Digital Zoom Direct (0x12)
   1972             case TSM_DIGITAL_ZOOM_DIRECT:
   1973                stUART4.TX_READY = 0x01;
   1974                break;
   1975          
   1976                // 2.1.8. Optical Zoom Start (0x13)
   1977             case TSM_OPTICAL_ZOOM_START:
   1978                stUART4.TX_READY = 0x01;
   1979                break;
   1980          
   1981                // 2.1.9. Optical Zoom Stop (0x14)
   1982             case TSM_OPTICAL_ZOOM_STOP:
   1983                stUART4.TX_READY = 0x01;
   1984                break;
   1985          
   1986                // 2.1.10. Optical Zoom Direct (0x15)
   1987             case TSM_OPTICAL_ZOOM_DIRECT:
   1988                stUART4.TX_READY = 0x01;
   1989                break;
   1990          
   1991                // 2.1.11. Focus Start (0x16)
   1992             case TSM_FOCUS_START:
   1993                stUART4.TX_READY = 0x01;
   1994                //stPTZ.TFOCUS_STATUS = FOCUS_ACTIVE;
   1995                break;
   1996          
   1997                // 2.1.12. Focus Stop (0x17)
   1998             case TSM_FOCUS_STOP:
   1999                stUART4.TX_READY = 0x01;
   2000                stTSM.FOCUS_CHECK_FLAG = 0x01;
   2001                //stPTZ.TFOCUS_STATUS = FOCUS_STOP;
   2002                break;
   2003          
   2004                // 2.1.13. Focus Direct (0x18)
   2005             case TSM_FOCUS_DIRECT:
   2006                stUART4.TX_READY = 0x01;
   2007                break;
   2008          
   2009                // 2.1.14. Auto Focus Set (0x19)
   2010             case TSM_AUTO_FOCUS_SET:
   2011                stUART4.TX_READY = 0x01;
   2012                break;
   2013          
   2014                // 2.1.15. Digital Zoom Enable (0x1C)
   2015             case TSM_DIZITAL_ZOOM_ENABLE:
   2016          
   2017                // IP ERROR DATA CONVERT
   2018                switch (u_Data3)
   2019                {
   2020                case 0x01:
   2021                   u_Data3 = 0x80;
   2022                   break;
   2023                }
   2024                stUART4.TX_READY = 0x01;
   2025                break;
   2026          
   2027                // 2.1.16. Total Zoom Start (0x20)
   2028             case TSM_TOTAL_ZOOM_START:
   2029          
   2030                switch (stINFO.THERMAL_MODEL)
   2031                {
   2032                case TSM_72:
   2033                case TSM_1M:
   2034          
   2035          #if(1)
   2036          
   2037                   switch (stINFO.THERMAL_LENS)
   2038                   {
   2039                   case 0x01:
   2040                      u_Cmd = TSM_TOTAL_ZOOM_START;
   2041                      u_Data2 = 0x07;
   2042                      break;
   2043          
   2044                   default:
   2045                      u_Cmd = TSM_TOTAL_ZOOM_START;
   2046                      break;
   2047                   }
   2048          #else
   2049                   switch (stINFO.THERMAL_LENS)
   2050                   {
   2051                   case 0x01:
   2052                      u_Cmd = TSM_TOTAL_ZOOM_START;
   2053                      u_Data2 = 0x07;
   2054                      break;
   2055          
   2056                   default:
   2057                      u_Cmd = TSM_DIGITAL_ZOOM_START;
   2058                      break;
   2059                   }
   2060          #endif
   2061          
   2062                   break;
   2063          
   2064                default:
   2065                   break;
   2066                }
   2067          
   2068                stUART4.TX_READY = 0x01;
   2069                //stPTZ.TZOOM_STATUS = ZOOM_ACTIVE;
   2070                break;
   2071          
   2072                // 2.1.17. Total Zoom Stop (0x21)
   2073             case TSM_TOTAL_ZOOM_STOP:
   2074                stUART4.TX_READY = 0x01;
   2075                stTSM.ZOOM_CHECK_FLAG = 0x01;
   2076                break;
   2077          
   2078                // 2.1.18. Total Zoom Direct (0x22)
   2079             case TSM_TOTAL_ZOOM_DIRECT:
   2080                stUART4.TX_READY = 0x01;
   2081                break;
   2082          
   2083                // 2.1.19. Total Zoom Stop (0x23)
   2084             case TSM_TOTAL_ZOOM_STOP_SUB:
   2085                stUART4.TX_READY = 0x01;
   2086                stTSM.ZOOM_CHECK_FLAG = 0x01;
   2087                break;
   2088          
   2089                // 2.1.20. AGC Mode Set (0x26)
   2090             case TSM_AGC_MODE_SET:
   2091                stUART4.TX_READY = 0x01;
   2092                break;
   2093          
   2094                // 2.1.21. Color Mode Set (0x27)
   2095             case TSM_COLOR_MODE_SET:
   2096                stUART4.TX_READY = 0x01;
   2097                break;
   2098          
   2099                // 2.1.22. Contrast/Brightness (0x28) (when, AGC OFF)
   2100             case TSM_CONTRAST_BRIGHTNESS:
   2101                stUART4.TX_READY = 0x01;
   2102                break;
   2103          
   2104                // 2.1.23. AGC Center Position Set (0x29)
   2105             case TSM_AGC_CENTER_POSITION_SET:
   2106                stUART4.TX_READY = 0x01;
   2107                break;
   2108          
   2109                // 2.1.24. AGC Limit Level Set (0x2A)
   2110             case TSM_AGC_LIMIT_LEVEL_SET:
   2111                stUART4.TX_READY = 0x01;
   2112                break;
   2113          
   2114                // 2.1.25. AGC ROI (AGC Region of Interest) Set (0x2B)
   2115             case TSM_AGC_ROI_SET:
   2116                stUART4.TX_READY = 0x01;
   2117                break;
   2118          
   2119                // 2.1.26. MIDE Level Set (0x2C) (when, Sharpness OFF)
   2120             case TSM_MIDE_LEVEL_SET:
   2121                stUART4.TX_READY = 0x01;
   2122                break;
   2123          
   2124                // 2.1.27. Sharpness Level Set (0x2D) (when, MIDE OFF)
   2125             case TSM_SHARPNESS_LEVEL_SET:
   2126                stUART4.TX_READY = 0x01;
   2127                break;
   2128          
   2129                // 2.1.28. Detect Mode Set (0x31)
   2130             case TSM_DETECT_MODE_SET:
   2131                stUART4.TX_READY = 0x01;
   2132                break;
   2133          
   2134                // 2.1.29. Area Position Set (0x32)
   2135             case TSM_AREA_POSITION_SET:
   2136                stUART4.TX_READY = 0x01;
   2137                break;
   2138          
   2139                // 2.1.30. Spot Position Set (0x33)
   2140             case TSM_SPOT_POSITION_SET:
   2141                stUART4.TX_READY = 0x01;
   2142                break;
   2143          
   2144                // 2.1.31. High Alarm Temperature (0x34)
   2145             case TSM_HIGH_ALARM_TEMPERATURE:
   2146                stUART4.TX_READY = 0x01;
   2147                break;
   2148          
   2149                // 2.1.32. Low Alarm Temperature (0x35)
   2150             case TSM_LOW_ALARM_TEMPERATURE:
   2151                stUART4.TX_READY = 0x01;
   2152                break;
   2153          
   2154                // 2.1.33. Select Alarm (0x36)
   2155             case TSM_SELECT_ALARM:
   2156                stUART4.TX_READY = 0x01;
   2157                break;
   2158          
   2159                // 2.1.34. Alarm Mode (0x37)
   2160             case TSM_ALARM_MODE:
   2161                stUART4.TX_READY = 0x01;
   2162                break;
   2163          
   2164                // 2.1.35. Temperature OSD (0x38)
   2165             case TSM_TEMPERATURE_OSD:
   2166                stUART4.TX_READY = 0x01;
   2167                break;
   2168          
   2169                // 2.1.36. Emissivity Set (0x39)
   2170             case TSM_EMISSIVITY_SET:
   2171                stUART4.TX_READY = 0x01;
   2172                break;
   2173          
   2174                // 2.1.37. Mirror / Flip Mode Set (0x43)
   2175             case TSM_MIRROR_FLIP_MODE_SET:
   2176                stUART4.TX_READY = 0x01;
   2177                break;
   2178          
   2179                // 2.1.38. Mirror Mode Set (0x44)
   2180             case TSM_MIRROR_MODE_SET:
   2181                stUART4.TX_READY = 0x01;
   2182                break;
   2183          
   2184                // 2.1.39. Flip Mode Set (0x45)
   2185             case TSM_FLIP_MODE_SET:
   2186                stUART4.TX_READY = 0x01;
   2187                break;
   2188          
   2189                // 2.1.40. Image Freeze Set (0x46)
   2190             case TSM_IMAGE_FREEZE_SET:
   2191                stUART4.TX_READY = 0x01;
   2192                break;
   2193          
   2194                // 2.1.41. Image Color Inverse(White/Black Hot) Set (0x47)
   2195             case TSM_IMAGE_COLOR_INVERSE:
   2196                stUART4.TX_READY = 0x01;
   2197                break;
   2198          
   2199                // 2.1.42. External Communication Option Set (0x55)
   2200             case TSM_EXTERNAL_OPTION_SET:
   2201                stUART4.TX_READY = 0x01;
   2202                break;
   2203          
   2204                // 2.1.43. Calibration Execute (0x65)
   2205             case TSM_CALIBRATION_EXECUTE:
   2206                stUART4.TX_READY = 0x01;
   2207                break;
   2208          
   2209                // 2.1.44. Calibration Option Set (0x66)
   2210             case TSM_CALIBRATION_OPTION_SET:
   2211                stUART4.TX_READY = 0x01;
   2212                break;
   2213          
   2214                // 2.1.45. OSD All Off (0x76)
   2215             case TSM_OSD_ALL_OFF:
   2216                stUART4.TX_READY = 0x01;
   2217                break;
   2218          
   2219                // 2.1.46. Temperature Mode Set (0x77)
   2220             case TSM_TEMPERATURE_MODE_SET:
   2221                stUART4.TX_READY = 0x01;
   2222                break;
   2223          
   2224                // 2.1.47. Temperature Range Set (0x78) - Not Used
   2225             case TSM_TEMPERATURE_RANGE_SET:
   2226                break;
   2227          
   2228                // 2.1.48. Video Mode Set (0x79)
   2229             case TSM_VIDEO_MODE_SET:
   2230                stUART4.TX_READY = 0x01;
   2231                break;
   2232          
   2233                // 2.1.49. OSD MENU Key Control (0xA0)
   2234             case TSM_OSD_MENU_KEY_CONTROL:
   2235                stUART4.TX_READY = 0x01;
   2236                break;
   2237          
   2238                // 2.1.50. Call Module Status (0x30)
   2239             case TSM_CALL_MODULE_STATUS:
   2240                stUART4.TX_READY = 0x01;
   2241                stUART4.TX_REQUEST = 0x01;
   2242                break;
   2243          
   2244                // 2.1.51. Call Alarm Status (0x3A)
   2245             case TSM_CALL_ALARM_STATUS:
   2246                stUART4.TX_READY = 0x01;
   2247                stUART4.TX_REQUEST = 0x01;
   2248                break;
   2249          
   2250                // 2.1.52. Call Spot Temperature (0x3B)
   2251             case TSM_CALL_SPOT_TEMPERATURE:
   2252                stUART4.TX_READY = 0x01;
   2253                stUART4.TX_REQUEST = 0x01;
   2254                break;
   2255          
   2256                // 2.1.53. Call Area Temperature (0x3C)
   2257             case TSM_CALL_AREA_TEMPERATURE:
   2258                stUART4.TX_READY = 0x01;
   2259                stUART4.TX_REQUEST = 0x01;
   2260                break;
   2261          
   2262                // 2.1.54. Call Center Temperature (0x3D)
   2263             case TSM_CALL_CENTER_TEMPERATURE:
   2264                stUART4.TX_READY = 0x01;
   2265                stUART4.TX_REQUEST = 0x01;
   2266                break;
   2267          
   2268                // 2.1.55. Call Full Temperature (0x3E)
   2269             case TSM_CALL_FULL_TEMPERATURE:
   2270                stUART4.TX_READY = 0x01;
   2271                stUART4.TX_REQUEST = 0x01;
   2272                break;
   2273          
   2274                // 2.1.56. Call External Communication (0x71)
   2275             case TSM_CALL_EXTERNAL_COMMUNICATION:
   2276                stUART4.TX_READY = 0x01;
   2277                stUART4.TX_REQUEST = 0x01;
   2278                break;
   2279          
   2280                // 2.1.57. Call Camera Information (0x80)
   2281             case TSM_CALL_CAMERA_INFORMATION:
   2282                stUART4.TX_READY = 0x01;
   2283                stUART4.TX_REQUEST = 0x01;
   2284                break;
   2285          
   2286                // 2.1.58. Call Firmware Version (0x81)
   2287             case TSM_CALL_FIRMWARE_VERSION:
   2288                stUART4.TX_READY = 0x01;
   2289                stUART4.TX_REQUEST = 0x01;
   2290                break;
   2291          
   2292                // 2.1.59. Call Digital Zoom Position (0x82)
   2293             case TSM_CALL_DIGITAL_ZOOM_POSITION:
   2294                stUART4.TX_READY = 0x01;
   2295                stUART4.TX_REQUEST = 0x01;
   2296                break;
   2297          
   2298                // 2.1.60. Call Optical Zoom Position (0x83)
   2299             case TSM_CALL_OPTICAL_ZOOM_POSITION:
   2300                stUART4.TX_READY = 0x01;
   2301                stUART4.TX_REQUEST = 0x01;
   2302                break;
   2303          
   2304                // 2.1.61. Call Focus Position (0x84)
   2305             case TSM_CALL_FOCUS_POSITION:
   2306                stUART4.TX_READY = 0x01;
   2307                stUART4.TX_REQUEST = 0x01;
   2308                break;
   2309          
   2310                // 2.1.62. Call Total Zoom Position (0x85)
   2311             case TSM_CALL_TOTAL_ZOOM_POSITION:
   2312                stUART4.TX_READY = 0x01;
   2313                stUART4.TX_REQUEST = 0x01;
   2314          
   2315                stTSM.ZOOM_CHECK_FLAG = 0x01;
   2316                break;
   2317          
   2318                // 2.1.63. Call Temperature Mode (0x86)
   2319             case TSM_CALL_TEMPERATURE_MODE:
   2320                stUART4.TX_READY = 0x01;
   2321                stUART4.TX_REQUEST = 0x01;
   2322                break;
   2323          
   2324                // 2.1.64. Call All Temperature (0x87)
   2325             case TSM_CALL_ALL_TEMPERATURE:
   2326                stUART4.TX_READY = 0x01;
   2327                stUART4.TX_REQUEST = 0x01;
   2328          
   2329                // BackUp Data
   2330                stTSM.TEMPERATURE_READ_FLAG = u_Data1;		//     
   2331          
   2332                u16_Convert_Data = (u_Data2 << 8);		//      P2
   2333                u16_Convert_Data |= u_Data3;			//      P3
   2334                stTSM.TEMPERATURE_READ_TIME = u16_Convert_Data;
   2335                break;
   2336          
   2337                // 2.1.65. Call Auto AF (0x88)
   2338             case TSM_CALL_AUTO_AF:
   2339                stUART4.TX_READY = 0x01;
   2340                stUART4.TX_REQUEST = 0x01;
   2341                break;
   2342          
   2343                // Call Focus Position (0x94)
   2344             case TSM_CALL_FOCUS_POSITION_SUB:
   2345          
   2346                u16_Convert_Data = stTSM.FOCUS_CNT;
   2347          
   2348                u8_Convert_Data[0] = (u8)(u16_Convert_Data >> 8);
   2349                u8_Convert_Data[1] = (u8)(u16_Convert_Data & 0xFF);
   2350          
   2351                stUSART1.TX_BUF[0] = IP_TSM_FIRST_BYTE;
   2352                stUSART1.TX_BUF[1] = IP_TSM_SECOND_BYTE;
   2353                stUSART1.TX_BUF[2] = 0x05;
   2354          
   2355                stUSART1.TX_BUF[3] = 0x01;
   2356          
   2357                stUSART1.TX_BUF[4] = TSM_CALL_FOCUS_POSITION_SUB;
   2358                stUSART1.TX_BUF[5] = u8_Convert_Data[0];
   2359                stUSART1.TX_BUF[6] = u8_Convert_Data[1];
   2360                stUSART1.TX_BUF[7] = u8_Convert_Data[2];
   2361          
   2362                stUSART1.TX_BUF[8] = 0x00;
   2363                stUSART1.TX_BUF[8] = stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5] + stUSART1.TX_BUF[6] + stUSART1.TX_BUF[7];
   2364          
   2365                stUSART1.TX_BUF[9] = 0xBF;
   2366          
   2367                stUSART1.TX_CNT = 0;
   2368                stUSART1.TX_MAX = 10;
   2369          
   2370                USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   2371                Delay_1ms(MAIN_COMMAND_TIMER_DELAY);
   2372          
   2373                break;
   2374          
   2375                // Call Total Zoom Position (0x95)
   2376             case TSM_CALL_TOTAL_ZOOM_POSITION_SUB:
   2377          
   2378                u16_Convert_Data = stTSM.ZOOM_CNT;
   2379          
   2380                u8_Convert_Data[0] = (u8)(u16_Convert_Data >> 8);
   2381                u8_Convert_Data[1] = (u8)(u16_Convert_Data & 0xFF);
   2382          
   2383                stUSART1.TX_BUF[0] = IP_TSM_FIRST_BYTE;
   2384                stUSART1.TX_BUF[1] = IP_TSM_SECOND_BYTE;
   2385                stUSART1.TX_BUF[2] = 0x05;
   2386          
   2387                stUSART1.TX_BUF[3] = 0x01;
   2388          
   2389                stUSART1.TX_BUF[4] = TSM_CALL_TOTAL_ZOOM_POSITION_SUB;
   2390                stUSART1.TX_BUF[5] = u8_Convert_Data[0];
   2391                stUSART1.TX_BUF[6] = u8_Convert_Data[1];
   2392                stUSART1.TX_BUF[7] = u8_Convert_Data[2];
   2393          
   2394                stUSART1.TX_BUF[8] = 0x00;
   2395                stUSART1.TX_BUF[8] = stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5] + stUSART1.TX_BUF[6] + stUSART1.TX_BUF[7];
   2396          
   2397                stUSART1.TX_BUF[9] = 0xBF;
   2398          
   2399                stUSART1.TX_CNT = 0;
   2400                stUSART1.TX_MAX = 10;
   2401          
   2402                USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   2403                Delay_1ms(MAIN_COMMAND_TIMER_DELAY);
   2404          
   2405                break;
   2406          
   2407                // 2.1.66. Call Product Identification (0xF0)
   2408             case TSM_CALL_PRODUCT_IDENTIFICATION:
   2409                stUART4.TX_READY = 0x01;
   2410                stUART4.TX_REQUEST = 0x01;
   2411                break;
   2412          
   2413                // 2.1.67. Module Mode Set (0xF1)
   2414             case TSM_MODULE_MODE_SET:
   2415                stUART4.TX_READY = 0x01;
   2416                stUART4.TX_REQUEST = 0x01;
   2417                break;
   2418          
   2419                // 2.1.68. Auto AF Set (0xF2)
   2420             case TSM_AUTO_AF_SET:
   2421                stUART4.TX_READY = 0x01;
   2422                stUART4.TX_REQUEST = 0x01;
   2423                break;
   2424          
   2425                // 2.1.69. Set Thermal Module (0xF3)
   2426             case TSM_SET_THERMAL_MODULE:
   2427                stUART4.TX_READY = 0x01;
   2428                break;
   2429          
   2430             default:
   2431                stUART4.TX_READY = 0x01;
   2432                break;
   2433          
   2434             }
   2435          
   2436             stUART4.TX_CMD = u_Cmd;
   2437             stUART4.TX_PARAMETER1 = u_Data1;
   2438             stUART4.TX_PARAMETER2 = u_Data2;
   2439             stUART4.TX_PARAMETER3 = u_Data3;
   2440          
   2441             // Send TSM Command & Data Trans
   2442             if (stUART4.TX_READY)
   2443             {
   2444                Send_TSM_Data(u_Cmd, u_Data1, u_Data2, u_Data3, 0x06, TSM_COMMAND_TIMER_DELAY);
   2445          
   2446                if (stTSM.ZOOM_CHECK_FLAG == 0x01)
   2447                {
   2448                   stTSM.ZOOM_CHECK_FLAG = 0x00;
   2449                   stUART4.RX_REQUEST_CMD = TSM_CALL_TOTAL_ZOOM_POSITION;
   2450                   Send_TSM_Data(TSM_CALL_TOTAL_ZOOM_POSITION, 0x00, 0x00, 0x00, 0x06, TSM_COMMAND_TIMER_DELAY);
   2451                }
   2452          
   2453                if (stTSM.FOCUS_CHECK_FLAG == 0x01)
   2454                {
   2455                   stTSM.FOCUS_CHECK_FLAG = 0x00;
   2456                   stUART4.RX_REQUEST_CMD = TSM_CALL_FOCUS_POSITION;
   2457                   Send_TSM_Data(TSM_CALL_FOCUS_POSITION, 0x00, 0x00, 0x00, 0x06, TSM_COMMAND_TIMER_DELAY);
   2458                }
   2459          
   2460                if (!stUART4.TX_REQUEST)
   2461                   stUART4.TX_ACK = 0x01;
   2462          
   2463                stUART4.TX_READY = 0;
   2464          
   2465                //Send_Data_Clear(u_Leng);
   2466             }
   2467          
   2468             // Send Ack Trans
   2469             if (stUART4.TX_ACK)
   2470             {
   2471                //Send_UART4_Ack(0xB0, 0x03, 0x01, u_Comm, u_Response_Data, 5);
   2472          
   2473                stUART4.TX_ACK = 0;
   2474             }
   2475          }
   2476          
   2477          /***************************************************************************************************************************
   2478          * Function : TCM_Data_Handing
   2479          * Protocol Version : 2.12 (2017.05.16)
   2480          * Data Architecture :
   2481          BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]		BYTE[..]		BYTE(n)[LENGTH+4]	BYTE(n+1)[LENGTH+4]
   2482          0xB0		0x0B		LENGTH		ADDR		COMM		DATA		...			CS					0xBF
   2483          ****************************************************************************************************************************/
   2484          void TCM_Data_Handing(u8 u_Port, u8 u_Comm, u8 u_Leng)
   2485          {
   2486             u8 u_Cmd = 0x00, u_Length = 0x06;
   2487             u8 u_Data1 = 0x00, u_Data2 = 0x00, u_Data3 = 0x00, u_Data4 = 0x00, u_Data5 = 0x00;
   2488             u8 u_Data6 = 0x00, u_Data7 = 0x00, u_Data8 = 0x00, u_Data9 = 0x00;
   2489             u8 u_Response_Data = 0x00;
   2490          
   2491             u8 u8_Convert_Data[10];
   2492             u16 u16_Convert_Data = 0x0000;
   2493          
   2494             switch (u_Port)
   2495             {
   2496             case SYSTEM_INDEX:
   2497          
   2498                u_Cmd = stSYS.RX_BUF[0][5];
   2499                u_Data1 = stSYS.RX_BUF[0][6];
   2500                u_Data2 = stSYS.RX_BUF[0][7];
   2501                u_Data3 = stSYS.RX_BUF[0][8];
   2502          
   2503                u_Data4 = stSYS.RX_BUF[0][9];
   2504                u_Data5 = stSYS.RX_BUF[0][10];
   2505                u_Data6 = stSYS.RX_BUF[0][11];
   2506          
   2507                u_Data7 = stSYS.RX_BUF[0][12];
   2508                u_Data8 = stSYS.RX_BUF[0][13];
   2509                u_Data9 = stSYS.RX_BUF[0][14];
   2510          
   2511                break;
   2512          
   2513             case USART1_INDEX:
   2514          
   2515                u_Cmd = stUSART1.RX_BUF[4];
   2516                u_Data1 = stUSART1.RX_BUF[5];
   2517                u_Data2 = stUSART1.RX_BUF[6];
   2518                u_Data3 = stUSART1.RX_BUF[7];
   2519          
   2520                u_Data4 = stUSART1.RX_BUF[8];
   2521                u_Data5 = stUSART1.RX_BUF[9];
   2522                u_Data6 = stUSART1.RX_BUF[10];
   2523          
   2524                u_Data7 = stUSART1.RX_BUF[11];
   2525                u_Data8 = stUSART1.RX_BUF[12];
   2526                u_Data9 = stUSART1.RX_BUF[13];
   2527          
   2528                break;
   2529          
   2530             case USART5_INDEX:
   2531          
   2532                u_Cmd = stUART5.RX_BUF[4];
   2533                u_Data1 = stUART5.RX_BUF[5];
   2534                u_Data2 = stUART5.RX_BUF[6];
   2535                u_Data3 = stUART5.RX_BUF[7];
   2536          
   2537                u_Data4 = stUART5.RX_BUF[8];
   2538                u_Data5 = stUART5.RX_BUF[9];
   2539                u_Data6 = stUART5.RX_BUF[10];
   2540          
   2541                u_Data7 = stUSART1.RX_BUF[11];
   2542                u_Data8 = stUSART1.RX_BUF[12];
   2543                u_Data9 = stUSART1.RX_BUF[13];
   2544          
   2545                break;
   2546          
   2547             default:
   2548                break;
   2549             }
   2550          
   2551             switch (u_Comm)
   2552             {
   2553                // 2.3.1. Camera Initialize (0x01)
   2554             case TCM_INITIALIZE:
   2555                stUART4.TX_READY = 0x01;
   2556                break;
   2557          
   2558                // 2.3.2. Rebooting (0x02)
   2559             case TCM_REBOOTING:
   2560                stUART4.TX_READY = 0x01;
   2561                break;
   2562          
   2563                // 2.3.3. Save Current Setting Option (0x04)
   2564             case TCM_SAVE_CURRENT_SETTING_OPTION:
   2565                stUART4.TX_READY = 0x01;
   2566                break;
   2567          
   2568                // 2.3.4. Zoom/Focus Stop (Digital Zoom, Optical Zoom, Focus) (0x10)
   2569             case TCM_ZOOM_FOCUS_STOP:
   2570                stUART4.TX_READY = 0x01;
   2571                break;
   2572          
   2573                // 2.3.5. Digital Zoom Start (0x11)
   2574             case TCM_DIGITAL_ZOOM_START:
   2575                stUART4.TX_READY = 0x01;
   2576                break;
   2577          
   2578                // 2.3.6. Digital Zoom Direct (0x12)
   2579             case TCM_DIGITAL_ZOOM_DIRECT:
   2580                stUART4.TX_READY = 0x01;
   2581                break;
   2582          
   2583                // 2.3.7. Optical Zoom Direct (0x13)
   2584             case TCM_OPTICAL_ZOOM_DIRECT:
   2585                u_Length = 0x08;
   2586                stUART4.TX_READY = 0x01;
   2587                break;
   2588          
   2589                // 2.3.8. Optical Zoom Start (0x14)
   2590             case TCM_OPTICAL_ZOOM_START:
   2591                stUART4.TX_READY = 0x01;
   2592                break;
   2593          
   2594                // 2.3.9. Save FOV (0x15)
   2595             case TCM_SAVE_FOV:
   2596                stUART4.TX_READY = 0x01;
   2597                break;
   2598          
   2599                // 2.3.10. Move FOV (0x16)
   2600             case TCM_MOVE_FOV:
   2601                u_Cmd = 0x18;
   2602                stUART4.TX_READY = 0x01;
   2603                break;
   2604          
   2605                // 2.3.10.1 Focus Stop Sub (0x17)
   2606             case TCM_FOCUS_STOP_SUB:
   2607                u_Cmd = 0xA2;
   2608                stUART4.TX_READY = 0x01;
   2609                break;
   2610          
   2611                // 2.3.13. Focus Start (0x18)
   2612             case TCM_FOCUS_START:
   2613                stUART4.TX_READY = 0x01;
   2614                break;
   2615          
   2616                // IP  PTZ Convert Data
   2617             case CVT_AF_EXCUTE:
   2618                u_Cmd = TCM_AF_EXECUTE;
   2619                stUART4.TX_READY = 0x01;
   2620                break;
   2621          
   2622                // 2.3.14. Integral Time Set (0x1A)
   2623             case TCM_INTEGRAL_TIME_SET:
   2624                stUART4.TX_READY = 0x01;
   2625                break;
   2626          
   2627                // 2.3.15. Digital Zoom Enable Set (0x1C)
   2628             case TCM_DIGITAL_ZOOM_ENABLE_SET:
   2629                stUART4.TX_READY = 0x01;
   2630                break;
   2631          
   2632                // 2.3.29. Total Zoom Start (0x20)
   2633             case TCM_TOTAL_ZOOM_START:
   2634                u_Data2 = 0x07;
   2635                stUART4.TX_READY = 0x01;
   2636                break;
   2637          
   2638                // 2.3.16. AGC Type Set (GAIN, OFFSET) (0x21)
   2639             case TCM_AGC_TYPE_SET:
   2640                u_Length = 0x08;
   2641                stUART4.TX_READY = 0x01;
   2642                break;
   2643          
   2644                // 2.3.28. Total Zoom Direct (0x22)
   2645             case TCM_TOTAL_ZOOM_DIRECT:
   2646                stUART4.TX_READY = 0x01;
   2647                break;
   2648          
   2649                // 2.3.28.1. Total Zoom Stop Sub (0x23)
   2650             case TCM_TOTAL_ZOOM_STOP_SUB:
   2651                stUART4.TX_READY = 0x01;
   2652                break;
   2653          
   2654                // 2.3.17. AGC Mode Set (0x26)
   2655             case TCM_AGC_MODE_SET:
   2656          
   2657                switch (u_Port)
   2658                {
   2659                case SYSTEM_INDEX:
   2660                   stUART4.TX_READY = 0x01;
   2661                   break;
   2662          
   2663                case USART1_INDEX:
   2664                   stUART4.TX_READY = 0x01;
   2665                   break;
   2666          
   2667                case USART5_INDEX:
   2668          
   2669                   switch (u_Data1)
   2670                   {
   2671                   case 0x00:
   2672                      Send_TCM_Data(TCM_AGC_TYPE_SET, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, TCM_COMMAND_TIMER_DELAY);
   2673                      stTCM.AGC_TYPE_SET = 0x00;
   2674                      break;
   2675          
   2676                   case 0x01:
   2677                      if (stTCM.AGC_TYPE_SET == 0x00)
   2678                         Send_TCM_Data(TCM_AGC_TYPE_SET, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, TCM_COMMAND_TIMER_DELAY);
   2679                      Send_TCM_Data(TCM_AGC_MODE_SET, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, TCM_COMMAND_TIMER_DELAY);
   2680                      stTCM.AGC_TYPE_SET = 0x01;
   2681                      break;
   2682          
   2683                   case 0x02:
   2684                      if (stTCM.AGC_TYPE_SET == 0x00)
   2685                         Send_TCM_Data(TCM_AGC_TYPE_SET, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, TCM_COMMAND_TIMER_DELAY);
   2686                      Send_TCM_Data(TCM_AGC_MODE_SET, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, TCM_COMMAND_TIMER_DELAY);
   2687                      stTCM.AGC_TYPE_SET = 0x02;
   2688                      break;
   2689          
   2690                   default:
   2691                      break;
   2692                   }
   2693          
   2694                   break;
   2695                }
   2696          
   2697                break;
   2698          
   2699                // 2.3.18. Color Mode Set (0x27)
   2700             case TCM_COLOR_MODE_SET:
   2701                stUART4.TX_READY = 0x01;
   2702                break;
   2703          
   2704                // 2.3.19. AGC Center Position Set (0x29)
   2705             case TCM_AGC_CENTER_POSITION_SET:
   2706                stUART4.TX_READY = 0x01;
   2707                break;
   2708          
   2709                // 2.3.20. AGC Limit Level Set (0x2A)
   2710             case TCM_AGC_LIMIT_LEVEL_SET:
   2711                stUART4.TX_READY = 0x01;
   2712                break;
   2713          
   2714                // 2.3.21. AGC ROI (Region of Interest) Set (0x2B)
   2715             case TCM_AGC_ROI_SET:
   2716                stUART4.TX_READY = 0x01;
   2717                break;
   2718          
   2719                // 2.3.22. MIDE Level Set (0x2C)
   2720             case TCM_MIDE_LEVEL_SET:
   2721                stUART4.TX_READY = 0x01;
   2722                break;
   2723          
   2724                // 2.3.23. SHARPNESS Level Set (0x2D)
   2725             case TCM_SHARPNESS_LEVEL_SET:
   2726                stUART4.TX_READY = 0x01;
   2727                break;
   2728          
   2729                // 2.3.24. AF ROI (Region of Interest) Set (0x2E)
   2730             case TCM_AF_ROI_SET:
   2731                stUART4.TX_READY = 0x01;
   2732                break;
   2733          
   2734                // 2.3.25. AF Mark Set (0x2F)
   2735             case TCM_AF_MARK_SET:
   2736                stUART4.TX_READY = 0x01;
   2737                break;
   2738          
   2739                // 2.3.26. AGC Smooth (0x31)
   2740             case TCM_AGC_SMOOTH:
   2741                stUART4.TX_READY = 0x01;
   2742                break;
   2743          
   2744                // 2.3.27. AF Execute (0x32)
   2745             case TCM_AF_EXECUTE:
   2746                stUART4.TX_READY = 0x01;
   2747                break;
   2748          
   2749                // 2.3.11. Save FOV EX (0x35)
   2750             case TCM_SAVE_FOV_EX:
   2751                stUART4.TX_READY = 0x01;
   2752                break;
   2753          
   2754                // 2.3.12. Move FOV EX (0x36)
   2755             case TCM_MOVE_FOV_EX:
   2756                stUART4.TX_READY = 0x01;
   2757                break;
   2758          
   2759                // 2.3.30. Calibration Shutter Use (0x40)
   2760             case TCM_CALIBRATION_SHUTTER_USE:
   2761                stUART4.TX_READY = 0x01;
   2762                break;
   2763          
   2764                // 2.3.31. Shutter Set (0x41)
   2765             case TCM_SHUTTER_SET:
   2766                stUART4.TX_READY = 0x01;
   2767                break;
   2768          
   2769                // 2.3.32. AF Mode Set (0x42)
   2770             case TCM_AF_MODE_SET:
   2771                stUART4.TX_READY = 0x01;
   2772                break;
   2773          
   2774                // 2.3.33. Mirror/Flip Mode (0x43)
   2775             case TCM_MIRROR_FLIP_MODE:
   2776          
   2777                // P3 : Status Enable : TCM .
   2778                u_Data3 = 0x00;
   2779          
   2780                stUART4.TX_READY = 0x01;
   2781                break;
   2782          
   2783                // 2.3.34. Mirror Mode Set (0x44)
   2784             case TCM_MIRROR_MODE_SET:
   2785                stUART4.TX_READY = 0x01;
   2786                break;
   2787          
   2788                // 2.3.35. Flip Mode Set (0x45)
   2789             case TCM_FLIP_MODE_SET:
   2790                stUART4.TX_READY = 0x01;
   2791                break;
   2792          
   2793                // 2.3.36. Image Freeze Set (0x46)
   2794             case TCM_IMAGE_FREEZE_SET:
   2795                stUART4.TX_READY = 0x01;
   2796                break;
   2797          
   2798                // 2.3.37. Image Color Inverse (White/Black Hot) Set (0x47)
   2799             case TCM_IMAGE_COLOR_INVERSE:
   2800                stUART4.TX_READY = 0x01;
   2801                break;
   2802          
   2803                // 2.3.38. External Communication Option Set (0x55)
   2804             case TCM_EXTERNAL_COMMUNICATION_OPTION:
   2805                stUART4.TX_READY = 0x01;
   2806                break;
   2807          
   2808                // 2.3.39. Calibration Execute (0x65)
   2809             case TCM_CALIBRATION_EXECUTE:
   2810                stUART4.TX_READY = 0x01;
   2811                break;
   2812          
   2813                // 2.3.40. Calibration Option Set (0x66)
   2814             case TCM_CALIBRATION_OPTION_SET:
   2815                stUART4.TX_READY = 0x01;
   2816                break;
   2817          
   2818                // 2.3.41. Video Mode Set (0x79)
   2819             case TCM_VIDEO_MODE_SET:
   2820                stUART4.TX_READY = 0x01;
   2821                break;
   2822          
   2823                // 2.3.42. OSD MENU Key Control (0xA0)
   2824             case TCM_OSD_MENU_KEY_CONTROL:
   2825                stUART4.TX_READY = 0x01;
   2826                break;
   2827          
   2828                // 2.3.43. ZOOM Stop (0xA1)
   2829             case TCM_ZOOM_STOP:
   2830                stUART4.TX_READY = 0x01;
   2831                break;
   2832          
   2833                // 2.3.44. FOCUS Stop (0xA2)
   2834             case TCM_FOCUS_STOP:
   2835                stUART4.TX_READY = 0x01;
   2836                break;
   2837          
   2838                // 2.3.45. ZOOM Direct (0xA3)
   2839             case TCM_ZOOM_DIRECT:
   2840                stUART4.TX_READY = 0x01;
   2841                break;
   2842          
   2843                // 2.3.46. FOCUS Direct (0xA4)
   2844             case TCM_FOCUS_DIRECT:
   2845                stUART4.TX_READY = 0x01;
   2846                break;
   2847          
   2848                // 2.3.47. OSD Information Print (0xA5)
   2849             case TCM_OSD_INFORMATION_PRINT:
   2850                stUART4.TX_READY = 0x01;
   2851                break;
   2852          
   2853                // 2.3.48. Zoom Focus Speed Set (0xA6)
   2854             case TCM_ZOOM_FOCUS_SPEED_SET:
   2855                stUART4.TX_READY = 0x01;
   2856                break;
   2857          
   2858                // 2.3.49. FOV All Initialize (0xA7)
   2859             case TCM_FOV_ALL_INITIALIZE:
   2860                stUART4.TX_READY = 0x01;
   2861                break;
   2862          
   2863                // 2.3.50. EEPROM Save (0xA8)
   2864             case TCM_EEPROM_SAVE:
   2865                stUART4.TX_READY = 0x01;
   2866                break;
   2867          
   2868                // 2.3.51. NUC Execute (0xF1)
   2869             case TCM_NUC_EXECUTE:
   2870                stUART4.TX_READY = 0x01;
   2871                break;
   2872          
   2873                // 2.3.52. Spot for BPR Set (0xF2)
   2874             case TCM_SPOT_FOR_BPR_SET:
   2875                stUART4.TX_READY = 0x01;
   2876                break;
   2877          
   2878                // 2.3.53. Move Spot (0xF3)
   2879             case TCM_MOVE_SPOT:
   2880                stUART4.TX_READY = 0x01;
   2881                break;
   2882          
   2883                // 2.3.54. Active BPR (0xF4)
   2884             case TCM_ACTIVE_BPR:
   2885                stUART4.TX_READY = 0x01;
   2886                break;
   2887          
   2888                // 2.3.55. Active BPR (0x95)
   2889             case TCM_SET_FRAME_RATE:
   2890                stUART4.TX_READY = 0x01;
   2891                break;
   2892          
   2893                // 2.3.56. Set Integral Time (0x96)
   2894             case TCM_SET_INTEGRAL_TIME:
   2895                stUART4.TX_READY = 0x01;
   2896                break;
   2897          
   2898                // 2.3.57. Operation Parameter Save (0x98)
   2899             case TCM_OPERATION_PARAMETER_SAVE:
   2900                stUART4.TX_READY = 0x01;
   2901                break;
   2902          
   2903             case TCM_DNR_MODE_SET:
   2904                stUART4.TX_READY = 0x01;
   2905                break;
   2906          
   2907             case TCM_DIS_MODE_SET:
   2908                stUART4.TX_READY = 0x01;
   2909                break;
   2910          
   2911                // 2.3.I.1. Module Status Inquiry (0x30)
   2912             case TCM_MODULE_STATUS_INQ:
   2913                stUART4.TX_READY = 0x01;
   2914                stUART4.TX_REQUEST = 0x01;
   2915                break;
   2916          
   2917                // 2.3.I.2. Camera Information Inquiry (0x80)
   2918             case TCM_CAMERA_INFORMATION_INQ:
   2919                stUART4.TX_READY = 0x01;
   2920                stUART4.TX_REQUEST = 0x01;
   2921                break;
   2922          
   2923                // 2.3.I.3. Digital Zoom Position Inquiry (0x82)
   2924             case TCM_DIGITAL_ZOOM_POSITION_INQ:
   2925                stUART4.TX_READY = 0x01;
   2926                stUART4.TX_REQUEST = 0x01;
   2927                break;
   2928          
   2929                // 2.3.I.4. AGC Mode Inquiry (0xB0)
   2930             case TCM_AGC_MODE_INQ:
   2931                stUART4.TX_READY = 0x01;
   2932                stUART4.TX_REQUEST = 0x01;
   2933                break;
   2934          
   2935                // 2.3.I.5. CONTRAST/BRIGHTNESS Level Inquiry (0xB1)
   2936             case TCM_CON_BRI_LEVEL_INQ:
   2937                stUART4.TX_READY = 0x01;
   2938                stUART4.TX_REQUEST = 0x01;
   2939                break;
   2940          
   2941                // 2.3.I.6. AGC Limit Level Inquiry (0xB2)
   2942             case TCM_AGC_LIMIT_LEVEL_INQ:
   2943                stUART4.TX_READY = 0x01;
   2944                stUART4.TX_REQUEST = 0x01;
   2945                break;
   2946          
   2947                // 2.3.I.7. AGC Center Position Inquiry (0xB3)
   2948             case TCM_AGC_CENTER_POSITION_INQ:
   2949                stUART4.TX_READY = 0x01;
   2950                stUART4.TX_REQUEST = 0x01;
   2951                break;
   2952          
   2953                // 2.3.I.8. MIDE Level Inquiry (0xB4)
   2954             case TCM_MIDE_LEVEL_INQ:
   2955                stUART4.TX_READY = 0x01;
   2956                stUART4.TX_REQUEST = 0x01;
   2957                break;
   2958          
   2959                // 2.3.I.9. SHARPNESS Level Inquiry (0xB5)
   2960             case TCM_SHARPNESS_LEVEL_INQ:
   2961                stUART4.TX_READY = 0x01;
   2962                stUART4.TX_REQUEST = 0x01;
   2963                break;
   2964          
   2965                // 2.3.I.10. Color Mode Inquiry (0xB6)
   2966             case TCM_COLOR_MODE_INQ:
   2967                stUART4.TX_READY = 0x01;
   2968                stUART4.TX_REQUEST = 0x01;
   2969                break;
   2970          
   2971                // 2.3.I.11. Mirror Mode Inquiry (0xB7)
   2972             case TCM_MIRROR_MODE_INQ:
   2973                stUART4.TX_READY = 0x01;
   2974                stUART4.TX_REQUEST = 0x01;
   2975                break;
   2976          
   2977                // 2.3.I.12. Flip Mode Inquiry (0xB8)
   2978             case TCM_FLIP_MODE_INQ:
   2979                stUART4.TX_READY = 0x01;
   2980                stUART4.TX_REQUEST = 0x01;
   2981                break;
   2982          
   2983                // 2.3.I.13. Image Freeze Inquiry (0xB9)
   2984             case TCM_IMAGE_FREEZE_INQ:
   2985                stUART4.TX_READY = 0x01;
   2986                stUART4.TX_REQUEST = 0x01;
   2987                break;
   2988          
   2989                // 2.3.I.14. Image Color Inverse (White/Black Hot) Inquiry (0xBA)
   2990             case TCM_IMAGE_COLOR_INVERSE_INQ:
   2991                stUART4.TX_READY = 0x01;
   2992                stUART4.TX_REQUEST = 0x01;
   2993                break;
   2994          
   2995                // 2.3.I.15. Digital Zoom Set Inquiry (0xBB)
   2996             case TCM_DIGITAL_ZOOM_SET_INQ:
   2997                stUART4.TX_READY = 0x01;
   2998                stUART4.TX_REQUEST = 0x01;
   2999                break;
   3000          
   3001                // 2.3.I.16. Video Mode Inquiry (0xBC)
   3002             case TCM_VIDEO_MODE_INQ:
   3003                stUART4.TX_READY = 0x01;
   3004                stUART4.TX_REQUEST = 0x01;
   3005                break;
   3006          
   3007                // 2.3.I.17. Calibration Option Inquiry (0xBD)
   3008             case TCM_CALIBRATION_OPTION_INQ:
   3009                stUART4.TX_READY = 0x01;
   3010                stUART4.TX_REQUEST = 0x01;
   3011                break;
   3012          
   3013                // 2.3.I.18. External Communication Option Inquiry (0xBE)
   3014             case TCM_EXTERNAL_COMMUNICATION_INQ:
   3015                stUART4.TX_READY = 0x01;
   3016                stUART4.TX_REQUEST = 0x01;
   3017                break;
   3018          
   3019                // 2.3.I.19. Focus Position Inquiry (0xBF)
   3020             case TCM_FOCUS_POSITION_INQ:
   3021                stUART4.TX_READY = 0x01;
   3022                stUART4.TX_REQUEST = 0x01;
   3023                break;
   3024          
   3025          
   3026                // 2.3.I.20. Integral Time Inquiry (0xC0)
   3027             case TCM_INTEGRAL_TIME_INQ:
   3028                stUART4.TX_READY = 0x01;
   3029                stUART4.TX_REQUEST = 0x01;
   3030                break;
   3031          
   3032                // 2.3.I.21. AF ROI (Region of Interest) Inquiry (0xC1)
   3033             case TCM_AF_ROI_INQ:
   3034                stUART4.TX_READY = 0x01;
   3035                stUART4.TX_REQUEST = 0x01;
   3036                break;
   3037          
   3038                // 2.3.I.22. AGC Type Inquiry (GAIN, OFFSET) (0xC2)
   3039             case TCM_AGC_TYPE_INQ:
   3040                stUART4.TX_READY = 0x01;
   3041                stUART4.TX_REQUEST = 0x01;
   3042                break;
   3043          
   3044                // 2.3.I.23. AGC Smooth Inquiry (0xC3)
   3045             case TCM_AGC_SMOOTH_INQ:
   3046                stUART4.TX_READY = 0x01;
   3047                stUART4.TX_REQUEST = 0x01;
   3048                break;
   3049          
   3050                // 2.3.I.24. Optical Zoom & Focus Position Inquiry (0xC4)
   3051             case TCM_OPTICAL_ZOOM_FOCUS_POS_INQ:
   3052                stUART4.TX_READY = 0x01;
   3053                stUART4.TX_REQUEST = 0x01;
   3054                break;
   3055          
   3056                // 2.3.I.25. Zoom & Focus Speed Inquiry (0xC5)
   3057             case TCM_ZOOM_FOCUS_SPEED_INQ:
   3058                stUART4.TX_READY = 0x01;
   3059                stUART4.TX_REQUEST = 0x01;
   3060                break;
   3061          
   3062                // 2.3.I.26. AF Mark Inquiry (0xC6)
   3063             case TCM_AF_MARK_INQ:
   3064                stUART4.TX_READY = 0x01;
   3065                stUART4.TX_REQUEST = 0x01;
   3066                break;
   3067          
   3068                // 2.3.I.27. Shutter Set Inquiry (0xC7)
   3069             case TCM_SHUTTER_SET_INQ:
   3070                stUART4.TX_READY = 0x01;
   3071                stUART4.TX_REQUEST = 0x01;
   3072                break;
   3073          
   3074                // 2.3.I.28. AF Mode Inquiry (0xC8)
   3075             case TCM_AF_MODE_INQ:
   3076                stUART4.TX_READY = 0x01;
   3077                stUART4.TX_REQUEST = 0x01;
   3078                break;
   3079          
   3080                // 2.3.I.29. AGC ROI Inquiry (0xC9)
   3081             case TCM_AGC_ROI_INQ:
   3082                stUART4.TX_READY = 0x01;
   3083                stUART4.TX_REQUEST = 0x01;
   3084                break;
   3085          
   3086                // 2.3.I.30. Cooler Runtime Inquiry (0xCA)
   3087             case TCM_COOLER_RUNTIME_INQ:
   3088                stUART4.TX_READY = 0x01;
   3089                stUART4.TX_REQUEST = 0x01;
   3090                break;
   3091          
   3092                // 2.3.I.31. ZOOM POS Inquiry (0xCB)
   3093             case TCM_ZOOM_POS_INQ:
   3094                stUART4.TX_READY = 0x01;
   3095                stUART4.TX_REQUEST = 0x01;
   3096                break;
   3097          
   3098                // 2.3.I.32. Power Cycle Inquiry (0xCE)
   3099             case TCM_POWER_CYCLE_INQ:
   3100                stUART4.TX_READY = 0x01;
   3101                stUART4.TX_REQUEST = 0x01;
   3102                break;
   3103          
   3104                // 2.3.I.33. Get Temperature (0xD0)
   3105             case TCM_GET_TEMPERATURE_INQ:
   3106                stUART4.TX_READY = 0x01;
   3107                stUART4.TX_REQUEST = 0x01;
   3108                break;
   3109          
   3110                // 2.3.I.34. Shutter Use Calibration (0xD1)
   3111             case TCM_CALIBRATION_METHOD_INQ:
   3112                stUART4.TX_READY = 0x01;
   3113                stUART4.TX_REQUEST = 0x01;
   3114                break;
   3115          
   3116                // 2.3.I.35. LENS Information Inquiry (0xD2)
   3117             case TCM_LENS_INFORMATION_INQ:
   3118                stUART4.TX_READY = 0x01;
   3119                stUART4.TX_REQUEST = 0x01;
   3120                break;
   3121          
   3122                // 2.3.I.36.  Total Zoom Position Inquiry (0xD5)
   3123             case TCM_TOTAL_ZOOM_POSITION_INQ:
   3124                stUART4.TX_READY = 0x01;
   3125                stUART4.RX_REQUEST_CMD = TCM_TOTAL_ZOOM_POSITION_INQ;
   3126                break;
   3127          
   3128                // 2.3.I.37. MY ID Inquiry (0xF0)
   3129             case TCM_MY_ID_INQ:
   3130                stUART4.TX_READY = 0x01;
   3131                stUART4.TX_REQUEST = 0x01;
   3132                break;
   3133          
   3134                // 2.3.I.38. Get F/W Update (0xFA)
   3135             case TCM_GET_FW_UPDATE_INQ:
   3136                stUART4.TX_READY = 0x01;
   3137                stUART4.TX_REQUEST = 0x01;
   3138                break;
   3139          
   3140                // 2.3.I.38. Get FPGA Version (0xF8)
   3141             case TCM_GET_FPGA_VERSION:
   3142                stUART4.TX_READY = 0x01;
   3143                stUART4.TX_REQUEST = 0x01;
   3144                break;
   3145          
   3146                // Get ENGINE Version (0xF9)
   3147             case TCM_GET_ENGINE_VERSION:
   3148                stUART4.TX_READY = 0x01;
   3149                stUART4.TX_REQUEST = 0x01;
   3150                break;
   3151          
   3152             default:
   3153                stUART4.TX_READY = 0x01;
   3154                break;
   3155             }
   3156          
   3157             stUART4.TX_CMD = u_Cmd;
   3158             stUART4.TX_PARAMETER1 = u_Data1;
   3159             stUART4.TX_PARAMETER2 = u_Data2;
   3160             stUART4.TX_PARAMETER3 = u_Data3;
   3161             stUART4.TX_PARAMETER4 = u_Data4;
   3162             stUART4.TX_PARAMETER5 = u_Data5;
   3163             stUART4.TX_PARAMETER6 = u_Data6;
   3164             stUART4.TX_PARAMETER7 = u_Data7;
   3165             stUART4.TX_PARAMETER8 = u_Data8;
   3166             stUART4.TX_PARAMETER9 = u_Data9;
   3167          
   3168             // Send TSM Command & Data Trans
   3169             if (stUART4.TX_READY)
   3170             {
   3171                switch (u_Length)
   3172                {
   3173                case 0x06:
   3174                   Send_TCM_Data(u_Cmd, u_Data1, u_Data2, u_Data3, u_Data4, u_Data5, u_Data6, u_Data7, u_Data8, u_Data9, 0x06, TCM_COMMAND_TIMER_DELAY);
   3175                   break;
   3176          
   3177                case 0x08:
   3178                   Send_TCM_Data(u_Cmd, u_Data1, u_Data2, u_Data3, u_Data4, u_Data5, u_Data6, u_Data7, u_Data8, u_Data9, 0x08, TCM_COMMAND_TIMER_DELAY);
   3179                   break;
   3180          
   3181                case 0x0C:
   3182                   Send_TCM_Data(u_Cmd, u_Data1, u_Data2, u_Data3, u_Data4, u_Data5, u_Data6, u_Data7, u_Data8, u_Data9, 0x0C, TCM_COMMAND_TIMER_DELAY);
   3183                   break;
   3184                }
   3185          
   3186                if (stTSM.ZOOM_CHECK_FLAG == 0x01)
   3187                {
   3188                   stTSM.ZOOM_CHECK_FLAG = 0x00;
   3189                   stUART4.RX_REQUEST_CMD = TCM_TOTAL_ZOOM_POSITION_INQ;
   3190                   Send_TCM_Data(TCM_TOTAL_ZOOM_POSITION_INQ, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, TCM_COMMAND_TIMER_DELAY);
   3191                }
   3192          
   3193                if (stTSM.FOCUS_CHECK_FLAG == 0x01)
   3194                {
   3195                   stTSM.FOCUS_CHECK_FLAG = 0x00;
   3196                   stUART4.RX_REQUEST_CMD = TCM_FOCUS_POSITION_INQ;
   3197                   Send_TCM_Data(TCM_FOCUS_POSITION_INQ, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, TCM_COMMAND_TIMER_DELAY);
   3198                }
   3199          
   3200                if (!stUART4.TX_REQUEST)
   3201                   stUART4.TX_ACK = 0x01;
   3202          
   3203                stUART4.TX_READY = 0;
   3204          
   3205                //Send_Data_Clear(u_Leng);
   3206             }
   3207          
   3208             // Send Ack Trans
   3209             if (stUART4.TX_ACK)
   3210             {
   3211                //Send_UART4_Ack(0xB0, 0x03, 0x01, u_Comm, u_Response_Data, 5);
   3212          
   3213                stUART4.TX_ACK = 0;
   3214             }
   3215          }
   3216          
   3217          /***************************************************************************************************************************
   3218          * Function : PTZ_Data_Handing
   3219          * Protocol Version : 0.1 (2016.04.11)
   3220          * Data Architecture :
   3221          BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]		BYTE[..]		BYTE(n)[LENGTH+4]	BYTE(n+1)[LENGTH+4]
   3222          0xC0		0x0C		LENGTH		ADDR		COMM		DATA		...			CS					0xCF
   3223          ****************************************************************************************************************************/
   3224          void PTZ_Data_Handing(u8 u_Comm, u8 u_Leng)
   3225          {
   3226             u8 i = 0, i_Max = u_Leng + 5;
   3227          
   3228             switch (u_Comm)
   3229             {
   3230                // 3.10. Set Preset & Temperature Option (0x10)
   3231             case PTZ_SET_PRESET_TEMPERATURE_OPTION:
   3232          
   3233                stUSART1.TX_READY = 0x01;
   3234          
   3235                break;
   3236          
   3237                // 3.11. Set Preset Index & Name (0x11)
   3238             case PTZ_SET_PRESET_AND_INDEX_NAME:
   3239          
   3240                stUSART1.TX_READY = 0x01;
   3241          
   3242                break;
   3243          
   3244                // 3.F1. PTZ Remote Reset (0xF1)
   3245             case PTZ_REMOTE_RESET:
   3246          
   3247                stUSART1.TX_READY = 0x01;
   3248          
   3249                break;
   3250             }
   3251          
   3252          
   3253             // Send USART1 Command & Data Trans
   3254             if (stUSART1.TX_READY)
   3255             {
   3256                for (i = 0; i < i_Max; i++)
   3257                {
   3258                   stUSART1.TX_BUF[i] = stUART5.RX_BUF[i];
   3259                }
   3260          
   3261                stUSART1.TX_CNT = 0;
   3262                stUSART1.TX_MAX = i_Max;
   3263          
   3264                USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   3265                Delay_1ms(MAIN_COMMAND_TIMER_DELAY);
   3266          
   3267                stUSART1.TX_READY = 0x00;
   3268          
   3269             }
   3270          }
   3271          
   3272          /***************************************************************************************************************************
   3273          * Function : DATA_Request_Handing
   3274          * Protocol Version : 0.1 (2016.04.11)
   3275          * Data Architecture :
   3276          BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]		BYTE[..]		BYTE(n)[LENGTH+4]	BYTE(n+1)[LENGTH+4]
   3277          0xD0		0x0D		LENGTH		ADDR		COMM		DATA		...			CS					0xDF
   3278          ****************************************************************************************************************************/
   3279          void DATA_Request_Handing(u8 u_Comm, u8 u_Leng)
   3280          {}
   3281          
   3282          /***************************************************************************************************************************
   3283          * Function : OPTION_Data_Handing
   3284          * Protocol Version : 0.1 (2016.04.11)
   3285          * Data Architecture :
   3286          BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]		BYTE[..]		BYTE(n)[LENGTH+4]	BYTE(n+1)[LENGTH+4]
   3287          0xE0		0x0E		LENGTH		ADDR		COMM		DATA		...			CS					0xEF
   3288          ****************************************************************************************************************************/
   3289          void OPTION_Data_Handing(u8 u_Port, u8 u_Comm, u8 u_Leng)
   3290          {
   3291             u8 i = 0, i_Max = u_Leng + 5;
   3292          
   3293             u8 u_Cmd = 0x00;	// Camera Command
   3294             u8 u_Data1 = 0x00, u_Data2 = 0x00, u_Data3 = 0x00, u_Data4 = 0x00, u_Data5 = 0x00;
   3295             u8 u_Response_Data = 0x00;
   3296          
   3297             u8 u8_Convert_Data[10];
   3298             u16 u16_Convert_Data = 0x0000;
   3299          
   3300             switch (u_Port)
   3301             {
   3302             case SYSTEM_INDEX:
   3303          
   3304                u_Cmd = stSYS.RX_BUF[0][5];
   3305                u_Data1 = stSYS.RX_BUF[0][6];
   3306                u_Data2 = stSYS.RX_BUF[0][7];
   3307                u_Data3 = stSYS.RX_BUF[0][8];
   3308          
   3309                break;
   3310          
   3311             case USART1_INDEX:
   3312          
   3313                u_Cmd = stUSART1.RX_BUF[4];
   3314                u_Data1 = stUSART1.RX_BUF[5];
   3315                u_Data2 = stUSART1.RX_BUF[6];
   3316                u_Data3 = stUSART1.RX_BUF[7];
   3317          
   3318                break;
   3319          
   3320             case USART5_INDEX:
   3321          
   3322                u_Cmd = stUART5.RX_BUF[4];
   3323                u_Data1 = stUART5.RX_BUF[5];
   3324                u_Data2 = stUART5.RX_BUF[6];
   3325                u_Data3 = stUART5.RX_BUF[7];
   3326                u_Data4 = stUART5.RX_BUF[8];
   3327                u_Data5 = stUART5.RX_BUF[9];
   3328          
   3329                break;
   3330          
   3331             default:
   3332                break;
   3333             }
   3334          
   3335             switch (u_Comm)
   3336             {
   3337             case OPTION_SET_ETHERNET_INIT:
   3338          
   3339                stUSART1.TX_READY = 0x01;
   3340          
   3341                break;
   3342          
   3343             case OPTION_SET_WIPER:
   3344          
   3345                switch (stDIP.MODE2)
   3346                {
   3347                case 0x00:
   3348          
   3349                   if ((u_Data2 == 0x00) || (u_Data2 > 0x0F))
   3350                      break;
   3351          
   3352                   stWIPER2.OPTION = u_Data1;
   3353                   stWIPER2.COUNT = u_Data2;
   3354                   stWIPER2.DWELL_TIME = u_Data3;
   3355          
   3356                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_OPTION, stWIPER2.OPTION);
   3357                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_COUNT, stWIPER2.COUNT);
   3358                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_DWELL_TIME, stWIPER2.DWELL_TIME);
   3359          
   3360                   break;
   3361          
   3362                case 0x01:
   3363          
   3364                   if ((u_Data2 == 0x00) || (u_Data2 > 0x0F))
   3365                      break;
   3366          
   3367                   stWIPER2.OPTION = u_Data1;
   3368                   stWIPER2.COUNT = u_Data2;
   3369                   stWIPER2.DWELL_TIME = u_Data3;
   3370          
   3371                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_OPTION, u_Data1);
   3372                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_COUNT, u_Data2);
   3373                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_DWELL_TIME, u_Data3);
   3374          
   3375                   break;
   3376          
   3377                default:
   3378                   break;
   3379                }
   3380          
   3381          
   3382          
   3383                break;
   3384          
   3385             case OPTION_STOP_WIPER:
   3386          
   3387                switch (stDIP.MODE2)
   3388                {
   3389                case 0x00:
   3390          
   3391                   switch (u_Data1)
   3392                   {
   3393                   case 0x00:
   3394                      stWIPER2.STOP_MODE = WIPER_STOP_ORIGIN;
   3395                      break;
   3396          
   3397                   case 0x01:
   3398                      stWIPER2.STOP_MODE = WIPER_STOP_EMERGENCY;
   3399                      break;
   3400                   }
   3401          
   3402                   if (stWIPER2.DWELL_TIMER_FLAG)
   3403                      stWIPER2.DWELL_TIMER_FLAG = 0x00;
   3404                   if (stWIPER2.CONTINUOUS_FLAG == 0x01)
   3405                   {
   3406                      stWIPER2.CONTINUOUS_FLAG = 0x00;
   3407                   }
   3408          
   3409                   break;
   3410          
   3411                case 0x01:
   3412          
   3413                   stWIPER1.ACTIVE_COUNT = 0;
   3414                   stWIPER1.DWELL_TIME = 0;
   3415          
   3416                   break;
   3417          
   3418                default:
   3419                   break;
   3420                }
   3421          
   3422                break;
   3423          
   3424             case OPTION_RUN_WIPER:
   3425          
   3426                switch (stDIP.MODE2)
   3427                {
   3428                case 0x00:
   3429          
   3430                   stWIPER2.OPTION = u_Data1;
   3431          
   3432                   stWIPER2.COUNT = AT24C256C_EEPROM_Read(EEP_SET_WIPER_COUNT);
   3433                   stWIPER2.DWELL_TIME = AT24C256C_EEPROM_Read(EEP_SET_WIPER_DWELL_TIME);
   3434                   stWIPER2.SPRITE_TIME = AT24C256C_EEPROM_Read(EEP_SET_WASHER_SPRITE_TIME);
   3435                   stWIPER2.CONTINUOUS_TIME = AT24C256C_EEPROM_Read(EEP_SET_WIPER_CONTINUOUS_TIME);
   3436          
   3437                   switch (stWIPER2.OPTION)
   3438                   {
   3439                   case WIPER_NORMAL_MODE:
   3440          
   3441                      stWIPER2.COUNT = AT24C256C_EEPROM_Read(EEP_SET_WIPER_COUNT);
   3442                      if (stWIPER2.COUNT >= 0x0F)
   3443                         break;
   3444          
   3445                      stWIPER2.DWELL_TIME = AT24C256C_EEPROM_Read(EEP_SET_WIPER_DWELL_TIME);
   3446          
   3447                      stWIPER2.DWELL_TIME_DATA = stWIPER2.DWELL_TIME;
   3448                      stWIPER2.FLAG = 0x01;
   3449          
   3450                      stWIPER2.STOP_MODE = WIPER_STOP_READY;
   3451                      stWIPER2.STEP = WIPER_READY;
   3452          
   3453                      break;
   3454          
   3455                   case WIPER_SPRITE_MODE:
   3456                      break;
   3457          
   3458                   case WIPER_CONTINUOUS_MODE:
   3459          
   3460                      stWIPER2.COUNT = AT24C256C_EEPROM_Read(EEP_SET_WIPER_COUNT);
   3461                      if (stWIPER2.COUNT < 0x0F)
   3462                         break;
   3463          
   3464                      stWIPER2.DWELL_TIME = AT24C256C_EEPROM_Read(EEP_SET_WIPER_DWELL_TIME);
   3465          
   3466                      stWIPER2.DWELL_TIME_DATA = stWIPER2.DWELL_TIME;
   3467                      stWIPER2.FLAG = 0x01;
   3468          
   3469                      stWIPER2.STOP_MODE = WIPER_STOP_READY;
   3470                      stWIPER2.STEP = WIPER_READY;
   3471          
   3472                      if (stWIPER2.COUNT >= 0x0F)
   3473                      {
   3474                         stWIPER2.CONTINUOUS_FLAG = 0x01;
   3475                         stWIPER2.CONTINUOUS_ms = 0;
   3476                         stWIPER2.CONTINUOUS_s = 0;
   3477                      }
   3478          
   3479                      break;
   3480          
   3481                   default:
   3482                      break;
   3483                   }
   3484          
   3485                   break;
   3486          
   3487                case 0x01:
   3488          
   3489                   stWIPER1.ACTIVE_COUNT = AT24C256C_EEPROM_Read(EEP_SET_WIPER_COUNT);
   3490                   stWIPER1.DWELL_TIME = AT24C256C_EEPROM_Read(EEP_SET_WIPER_DWELL_TIME);
   3491          
   3492                   break;
   3493          
   3494                default:
   3495                   break;
   3496                }
   3497          
   3498          
   3499          
   3500                break;
   3501          
   3502                // 5.22. Set Wiper Option (0x22)
   3503             case OPTION_SET_WIPER_OPTION:
   3504          
   3505                if ((u_Data2 == 0x00) || (u_Data2 > 0x0F))
   3506                   break;
   3507          
   3508                stWIPER2.OPTION = u_Data1;
   3509                stWIPER2.COUNT = u_Data2;
   3510                stWIPER2.DWELL_TIME = u_Data3;
   3511                stWIPER2.SPRITE_TIME = u_Data4;
   3512                stWIPER2.CONTINUOUS_TIME = u_Data5;
   3513          
   3514                AT24C256C_EEPROM_Write(EEP_SET_WIPER_OPTION, stWIPER2.OPTION);
   3515                AT24C256C_EEPROM_Write(EEP_SET_WIPER_COUNT, stWIPER2.COUNT);
   3516                AT24C256C_EEPROM_Write(EEP_SET_WIPER_DWELL_TIME, stWIPER2.DWELL_TIME);
   3517                AT24C256C_EEPROM_Write(EEP_SET_WASHER_SPRITE_TIME, stWIPER2.SPRITE_TIME);
   3518          
   3519                if (stWIPER2.CONTINUOUS_TIME != 0xFF)
   3520                {
   3521                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_CONTINUOUS_TIME, stWIPER2.CONTINUOUS_TIME);
   3522                }
   3523          
   3524                break;
   3525          
   3526             default:
   3527                break;
   3528             }
   3529          
   3530             // Send USART1 Command & Data Trans
   3531             if (stUSART1.TX_READY)
   3532             {
   3533                for (i = 0; i < i_Max; i++)
   3534                {
   3535                   stUSART1.TX_BUF[i] = stUART5.RX_BUF[i];
   3536                }
   3537          
   3538                stUSART1.TX_CNT = 0;
   3539                stUSART1.TX_MAX = i_Max;
   3540          
   3541                USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   3542                Delay_1ms(MAIN_COMMAND_TIMER_DELAY);
   3543          
   3544                stUSART1.TX_READY = 0x00;
   3545          
   3546             }
   3547          }
   3548          
   3549          /****************************************************************************************************
   3550          * Define : PELCO_Data_Handing
   3551          * Protocol Version : 0.1 (2016.04.11)
   3552          * Data Architecture :
   3553          BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]		BYTE5[6]
   3554          0xFF			ADDR		COMM1		COMM2		DATA1		DATA2		CS		
   3555          *****************************************************************************************************/
   3556          void PELCO_Data_Handing(u8 u_Comm_High, u8 u_Comm_Low, u8 u_Data_High, u8 u_Data_Low)
   3557          {
   3558             u8 u_Cmd = 0x00, u_Data1 = 0x00, u_Data2 = 0x00, u_Data3 = 0x00;
   3559             u8 u_MCmd = 0x00, u_MData1 = 0x00, u_MData2 = 0x00, u_MData3 = 0x00;
   3560             u16 u_Pelco_Comm = 0x0000;
   3561          
   3562             u_Pelco_Comm = (u_Comm_High << 8) | u_Comm_Low;
   3563             u_Data1 = u_Data_High;
   3564             u_Data2 = u_Data_Low;
   3565          
   3566             switch (u_Pelco_Comm)
   3567             {
   3568                // Move Stop Command
   3569             case PELCO_MOVE_STOP:
   3570          
   3571                stUSART1.TX_READY = 0x01;
   3572          
   3573                switch (stINFO.MODULE_TYPE)
   3574                {
   3575                case SONY_MODULE:
   3576          
   3577                   if (stSONY.ZOOM_STATUS == ACTIVE)
   3578                   {
   3579                      u_MCmd = SONY_MANUAL_ZOOM;
   3580          
   3581                      stSONY.ZOOM_STATUS = STOP;
   3582                      stSONY.ZOOM_CHECK_FLAG = 0x01;
   3583                   }
   3584          
   3585                   if (stSONY.FOCUS_STATUS == ACTIVE)
   3586                   {
   3587                      u_MCmd = SONY_MANUAL_FOCUS;
   3588          
   3589                      stSONY.FOCUS_STATUS = STOP;
   3590                      stSONY.FOCUS_CHECK_FLAG = 0x01;
   3591                   }
   3592          
   3593          
   3594                   break;
   3595          
   3596                case TSM_MODULE:
   3597          
   3598                   if (stTSM.ZOOM_STATUS == ACTIVE)
   3599                   {
   3600                      u_MCmd = TCM_TOTAL_ZOOM_STOP_SUB;
   3601          
   3602                      stTSM.ZOOM_STATUS = STOP;
   3603                      stTSM.ZOOM_CHECK_FLAG = 0x01;
   3604                   }
   3605          
   3606                   if (stTSM.FOCUS_STATUS == ACTIVE)
   3607                   {
   3608                      u_MCmd = TCM_FOCUS_STOP_SUB;
   3609          
   3610                      stTSM.FOCUS_STATUS = STOP;
   3611                      stTSM.FOCUS_CHECK_FLAG = 0x01;
   3612                   }
   3613          
   3614                   break;
   3615          
   3616                default:
   3617                   break;
   3618          
   3619                }
   3620          
   3621                stUART4.TX_READY = 0x01;
   3622          
   3623                break;
   3624          
   3625                // Move Right Command
   3626             case PELCO_MOVE_RIGHT:
   3627                stUSART1.TX_READY = 0x01;
   3628                break;
   3629          
   3630                // Move Left Command
   3631             case PELCO_MOVE_LEFT:
   3632                stUSART1.TX_READY = 0x01;
   3633                break;
   3634          
   3635                // Move Up Command
   3636             case PELCO_MOVE_UP:
   3637                stUSART1.TX_READY = 0x01;
   3638                break;
   3639          
   3640                // Move Down Command
   3641             case PELCO_MOVE_DOWN:
   3642                stUSART1.TX_READY = 0x01;
   3643                break;
   3644          
   3645                // Move Right-Up Command
   3646             case PELCO_MOVE_RIGHT_UP:
   3647                stUSART1.TX_READY = 0x01;
   3648                break;
   3649          
   3650                // Move Left-Up Command
   3651             case PELCO_MOVE_LEFT_UP:
   3652                stUSART1.TX_READY = 0x01;
   3653                break;
   3654          
   3655                // Move Right-Down Command
   3656             case PELCO_MOVE_RIGHT_DOWN:
   3657                stUSART1.TX_READY = 0x01;
   3658                break;
   3659          
   3660                // Move Left-Down Command
   3661             case PELCO_MOVE_LEFT_DOWN:
   3662                stUSART1.TX_READY = 0x01;
   3663                break;
   3664          
   3665                // Zoom-Tele Command
   3666             case PELCO_ZOOM_TELE:
   3667          
   3668                switch (stINFO.MODULE_TYPE)
   3669                {
   3670                case SONY_MODULE:
   3671          
   3672                   u_MCmd = SONY_MANUAL_ZOOM;
   3673                   u_MData1 = 0x27;
   3674          
   3675                   stSONY.ZOOM_STATUS = ACTIVE;
   3676          
   3677                   break;
   3678          
   3679                case TSM_MODULE:
   3680          
   3681                   u_MCmd = TCM_TOTAL_ZOOM_START;
   3682                   u_MData1 = 0x00;
   3683                   u_MData2 = 0x09;
   3684          
   3685                   stTSM.ZOOM_STATUS = ACTIVE;
   3686          
   3687                   break;
   3688          
   3689                default:
   3690                   break;
   3691                }
   3692          
   3693                stUART4.TX_READY = 0x01;
   3694          
   3695                break;
   3696          
   3697                // Zoom-Wide Command
   3698             case PELCO_ZOOM_WIDE:
   3699          
   3700                switch (stINFO.MODULE_TYPE)
   3701                {
   3702                case SONY_MODULE:
   3703          
   3704                   u_MCmd = SONY_MANUAL_ZOOM;
   3705                   u_MData1 = 0x37;
   3706          
   3707                   stSONY.ZOOM_STATUS = ACTIVE;
   3708          
   3709                   break;
   3710          
   3711                case TSM_MODULE:
   3712          
   3713                   u_MCmd = TCM_TOTAL_ZOOM_START;
   3714                   u_MData1 = 0x01;
   3715                   u_MData2 = 0x09;
   3716          
   3717                   stTSM.ZOOM_STATUS = ACTIVE;
   3718          
   3719                   break;
   3720          
   3721                default:
   3722                   break;
   3723                }
   3724          
   3725                stUART4.TX_READY = 0x01;
   3726          
   3727                break;
   3728          
   3729                // Focus-Far Command
   3730             case PELCO_FOCUS_FAR:
   3731          
   3732                switch (stINFO.MODULE_TYPE)
   3733                {
   3734                case SONY_MODULE:
   3735          
   3736                   u_MCmd = SONY_MANUAL_FOCUS;
   3737                   u_MData1 = 0x24;
   3738          
   3739                   stSONY.FOCUS_STATUS = ACTIVE;
   3740          
   3741                   break;
   3742          
   3743                case TSM_MODULE:
   3744          
   3745                   u_MCmd = TSM_FOCUS_START;
   3746                   u_MData1 = 0x00;
   3747                   u_MData2 = 0x03;
   3748          
   3749                   stTSM.FOCUS_STATUS = ACTIVE;
   3750          
   3751                   break;
   3752          
   3753                default:
   3754                   break;
   3755                }
   3756          
   3757                stUART4.TX_READY = 0x01;
   3758          
   3759                break;
   3760          
   3761                // Focus-Near Command
   3762             case PELCO_FOCUS_NEAR:
   3763          
   3764                switch (stINFO.MODULE_TYPE)
   3765                {
   3766                case SONY_MODULE:
   3767          
   3768                   u_MCmd = SONY_MANUAL_FOCUS;
   3769                   u_MData1 = 0x34;
   3770          
   3771                   stSONY.FOCUS_STATUS = ACTIVE;
   3772          
   3773                   break;
   3774          
   3775                case TSM_MODULE:
   3776          
   3777                   u_MCmd = TSM_FOCUS_START;
   3778                   u_MData1 = 0x01;
   3779                   u_MData2 = 0x03;
   3780          
   3781                   stTSM.FOCUS_STATUS = ACTIVE;
   3782          
   3783                   break;
   3784          
   3785                default:
   3786                   break;
   3787                }
   3788          
   3789                stUART4.TX_READY = 0x01;
   3790          
   3791                break;
   3792          
   3793                // 5.2. Set Preset (0x03)
   3794             case PELCO_SET_PRESET:
   3795                stUSART1.TX_READY = 0x01;
   3796                break;
   3797          
   3798                // 5.3. Clear Preset (0x05)
   3799             case PELCO_CLEAR_PRESET:
   3800                stUSART1.TX_READY = 0x01;
   3801                break;
   3802          
   3803                // 5.4. Call Preset (0x07)
   3804             case PELCO_CALL_PRESET:
   3805                stUSART1.TX_READY = 0x01;
   3806                break;
   3807          
   3808                // 5.5. Set Zone(Scan) Start (0x11)
   3809             case PELCO_SET_ZONE_START:
   3810                stUSART1.TX_READY = 0x01;
   3811                break;
   3812          
   3813                // 5.6. Set Zone(Scan) End (0x13)
   3814             case PELCO_SET_ZONE_END:
   3815                stUSART1.TX_READY = 0x01;
   3816                break;
   3817          
   3818                // 5.7. Zone(Scan) On (0x1B)
   3819             case PELCO_ZONE_ON:
   3820                stUSART1.TX_READY = 0x01;
   3821                break;
   3822          
   3823                // 5.8. Zone(Scan) Off (0x1D)
   3824             case PELCO_ZONE_OFF:
   3825                stUSART1.TX_READY = 0x01;
   3826                break;
   3827          
   3828                // 5.12. Set Zero Position (0x49)
   3829             case PELCO_SET_ZERO:
   3830                stUSART1.TX_READY = 0x01;
   3831                break;
   3832             }
   3833          
   3834             // Send TSM Command & Data Trans
   3835             if (stUART4.TX_READY)
   3836             {
   3837                stUART4.TX_CMD = u_MCmd;
   3838                stUART4.TX_PARAMETER1 = u_MData1;
   3839                stUART4.TX_PARAMETER2 = u_MData2;
   3840                stUART4.TX_PARAMETER3 = u_MData3;
   3841          
   3842                switch (stINFO.MODULE_TYPE)
   3843                {
   3844                case SONY_MODULE:
   3845          
   3846                   Send_Sony_Data(u_MCmd, u_MData1, u_MData2, 0x06, SONY_COMMAND_TIMER_DELAY);
   3847          
   3848                   if (stSONY.ZOOM_CHECK_FLAG == 0x01)
   3849                   {
   3850                      stSONY.ZOOM_CHECK_FLAG = 0x00;
   3851                      stUART4.RX_REQUEST_CMD = SONY_CALL_ZOOM_POSITION;
   3852                      Send_Sony_Data(SONY_CALL_ZOOM_POSITION, 0x00, 0x00, 0x05, SONY_COMMAND_TIMER_DELAY);
   3853                   }
   3854          
   3855                   if (stSONY.FOCUS_CHECK_FLAG == 0x01)
   3856                   {
   3857                      stSONY.FOCUS_CHECK_FLAG = 0x00;
   3858                      stUART4.RX_REQUEST_CMD = SONY_CALL_FOCUS_POSITION;
   3859                      Send_Sony_Data(SONY_CALL_FOCUS_POSITION, 0x00, 0x00, 0x05, SONY_COMMAND_TIMER_DELAY);
   3860                   }
   3861          
   3862                   break;
   3863          
   3864                case TSM_MODULE:
   3865          
   3866                   Send_TSM_Data(u_MCmd, u_MData1, u_MData2, u_MData3, 0x06, TSM_COMMAND_TIMER_DELAY);
   3867          
   3868                   if (stTSM.ZOOM_CHECK_FLAG == 0x01)
   3869                   {
   3870                      stTSM.ZOOM_CHECK_FLAG = 0x00;
   3871                      stUART4.RX_REQUEST_CMD = TSM_CALL_TOTAL_ZOOM_POSITION;
   3872                      Send_TSM_Data(TSM_CALL_TOTAL_ZOOM_POSITION, 0x00, 0x00, 0x00, 0x06, TSM_COMMAND_TIMER_DELAY);
   3873                   }
   3874          
   3875                   if (stTSM.FOCUS_CHECK_FLAG == 0x01)
   3876                   {
   3877                      stTSM.FOCUS_CHECK_FLAG = 0x00;
   3878                      stUART4.RX_REQUEST_CMD = TSM_CALL_FOCUS_POSITION;
   3879                      Send_TSM_Data(TSM_CALL_FOCUS_POSITION, 0x00, 0x00, 0x00, 0x06, TSM_COMMAND_TIMER_DELAY);
   3880                   }
   3881          
   3882                   break;
   3883          
   3884                default:
   3885                   stUSART1.TX_READY = 0x01;
   3886                   break;
   3887                }
   3888          
   3889                stUART4.TX_READY = 0;
   3890          
   3891                //Send_Data_Clear(u_Leng);
   3892             }
   3893          
   3894             // Send USART1 Command & Data Trans
   3895             if (stUSART1.TX_READY)
   3896             {
   3897                stUSART1.TX_CMD = u_Cmd;
   3898                stUSART1.TX_PARAMETER1 = u_Data1;
   3899                stUSART1.TX_PARAMETER2 = u_Data2;
   3900          
   3901                Send_Pelco_Data(u_Comm_High, u_Comm_Low, u_Data1, u_Data2, 0x07, MAIN_COMMAND_TIMER_DELAY);
   3902          
   3903                if (!stUSART1.TX_REQUEST)
   3904                   stUSART1.TX_ACK = 0x01;
   3905          
   3906                stUSART1.TX_READY = 0x00;
   3907          
   3908                //Send_Data_Clear(u_Leng);
   3909             }
   3910          
   3911          }
   3912          
   3913          /*******************************************************************************
   3914          * Function Name  : OSD_Layer_Select
   3915          *******************************************************************************/
   3916          void OSD_Layer_Select(u8 u_Num)
   3917          {
   3918             switch (u_Num)
   3919             {
   3920             case MDIN_LAYER_INFORMATION:
   3921          
   3922                // ALL OFF
   3923                MDIN_Sprite_Initialization(MDIN_LAYER_COORDINATE, bOFF);
   3924                MDIN_Sprite_Initialization(MDIN_LAYER_CENTER_MSG, bOFF);
   3925                MDIN_Sprite_Initialization(MDIN_LAYER_TARGET, bOFF);
   3926          
   3927                // INFORMATION ON
   3928                MDIN_Sprite_Initialization(MDIN_LAYER_INFORMATION, bON);
   3929          
   3930                break;
   3931          
   3932             case MDIN_LAYER_TARGET:
   3933          
   3934                // ALL OFF
   3935                MDIN_Sprite_Initialization(MDIN_LAYER_COORDINATE, bOFF);
   3936                MDIN_Sprite_Initialization(MDIN_LAYER_CENTER_MSG, bOFF);
   3937                MDIN_Sprite_Initialization(MDIN_LAYER_INFORMATION, bOFF);
   3938          
   3939                // CENTER ON
   3940                MDIN_Sprite_Initialization(MDIN_LAYER_TARGET, bON);
   3941          
   3942                break;
   3943          
   3944             case MDIN_LAYER_CENTER_MSG:
   3945          
   3946                // ALL OFF
   3947                MDIN_Sprite_Initialization(MDIN_LAYER_INFORMATION, bOFF);
   3948                MDIN_Sprite_Initialization(MDIN_LAYER_COORDINATE, bOFF);
   3949                MDIN_Sprite_Initialization(MDIN_LAYER_TARGET, bOFF);
   3950          
   3951                // CENTER ON
   3952                MDIN_Sprite_Initialization(MDIN_LAYER_CENTER_MSG, bON);
   3953          
   3954                break;
   3955          
   3956             case MDIN_LAYER_COORDINATE:
   3957             default:
   3958          
   3959                // ALL OFF
   3960                MDIN_Sprite_Initialization(MDIN_LAYER_INFORMATION, bOFF);
   3961                MDIN_Sprite_Initialization(MDIN_LAYER_CENTER_MSG, bOFF);
   3962                MDIN_Sprite_Initialization(MDIN_LAYER_TARGET, bOFF);
   3963          
   3964                // COORDINATE ON
   3965                MDIN_Sprite_Initialization(MDIN_LAYER_COORDINATE, bON);
   3966          
   3967                break;
   3968             }
   3969          }
   3970          
   3971          /*******************************************************************************
   3972          * Function Name  : UART5_Data_Parser
   3973          *******************************************************************************/
   3974          void UART5_Data_Parser(void)
   3975          {
   3976             u8 u_buf[10];
   3977          
   3978             u_buf[0] = stUART5.RX_BUF[0];	// stUART5.RX_BUF[0] : Protocol Check
   3979             u_buf[2] = stUART5.RX_BUF[2];	// stUART5.RX_BUF[2] : Length Check (when, TBT Protocol), Command High Byte Check (when, PELCO Protocol)
   3980             u_buf[3] = stUART5.RX_BUF[3];	// stUART5.RX_BUF[3] : Command Low Byte Check (when, PELCO Protocol)
   3981             u_buf[4] = stUART5.RX_BUF[4];	// stUART5.RX_BUF[4] : Command Check (when, TBT Protocol), Data High Byte Check (when, PELCO Protocol)
   3982             u_buf[5] = stUART5.RX_BUF[5];	// stUART5.RX_BUF[5] : Data Low Byte Check (when, PELCO Protocol)
   3983          
   3984             /*******************************************************************************
   3985             * Status :   
   3986             *******************************************************************************/ 
   3987             //    (Sync Byte Check)
   3988             switch (u_buf[0])
   3989             {
   3990             case IP_SONY_FIRST_BYTE:
   3991          
   3992                //  
   3993                Sony_Data_Handing(USART5_INDEX, u_buf[4], u_buf[2]);	// Command Check, Length Check
   3994          
   3995                break;
   3996          
   3997             case IP_TSM_FIRST_BYTE:
   3998          
   3999                //  
   4000                switch (stINFO.THERMAL_MODEL)
   4001                {
   4002                case TSM_72:
   4003                case TSM_72T:
   4004                case TSM_1M:
   4005                case TSM_1MT:
   4006                   TSM_Data_Handing(USART5_INDEX, u_buf[4], u_buf[2]);		// Command Check, Length Check
   4007                   break;
   4008          
   4009                case TCM_640:
   4010                   TCM_Data_Handing(USART5_INDEX, u_buf[4], u_buf[2]);		// Command Check, Length Check
   4011                   break;
   4012                }
   4013          
   4014                break;
   4015          
   4016             case IP_TCM_FIRST_BYTE:
   4017          
   4018                //  
   4019                //TCM_Data_Handing(u_buf[4], u_buf[2]);	// Command Check, Length Check
   4020          
   4021                break;
   4022          
   4023             case IP_PTZ_FIRST_BYTE:
   4024          
   4025                //  
   4026                PTZ_Data_Handing(u_buf[4], u_buf[2]);		// Command Check, Length Check
   4027          
   4028                break;
   4029          
   4030             case IP_DATA_FIRST_BYTE:
   4031          
   4032                //  
   4033                DATA_Request_Handing(u_buf[4], u_buf[2]);	// Command Check, Length Check
   4034                break;
   4035          
   4036             case IP_OPTION_FIRST_BYTE:
   4037          
   4038                //  
   4039                OPTION_Data_Handing(USART5_INDEX, u_buf[4], u_buf[2]);	// Command Check, Length Check
   4040                break;
   4041          
   4042             case IP_PELCO_CHK_BYTE:
   4043          
   4044                //  
   4045                PELCO_Data_Handing(u_buf[2], u_buf[3], u_buf[4], u_buf[5]);	// Command Check, Data Check
   4046          
   4047                break;
   4048          
   4049             default:
   4050                break;
   4051             }
   4052          }
   4053          
   4054          u8 g_Po_Data[30];
   4055          
   4056          /*******************************************************************************
   4057          * Function Name  : System_Data_Parser
   4058          *******************************************************************************/
   4059          void System_Data_Parser(void)
   4060          {
   4061             u8 i = 0, i_Max = 0x00;
   4062             u8 u_Sync_Byte = 0x00;
   4063             u8 u_Cmd = 0x00, u_Leng = 0x00;
   4064             u8 u_ID = 0x00, u_Position_x = 0x00, u_Position_y = 0x00;
   4065             u8 u_Rx_Data[50];
   4066          
   4067             u8 u_PT_PAN_SIGN = 0x00, u_PT_TILT_SIGN = 0x00;
   4068             u16 u_PT_PAN_INT = 0x0000, u_PT_PAN_DECIMAL = 0x0000;
   4069             u16 u_PT_TILT_INT = 0x0000, u_PT_TILT_DECIMAL = 0x0000;
   4070          
   4071             u8 u8_Convert_Data = 0x00;
   4072             u16 u16_Convert_Data = 0x0000;
   4073          
   4074             u_Sync_Byte = stSYS.RX_BUF[0][1];
   4075          
   4076             u_Cmd = stSYS.RX_BUF[0][5];
   4077             u_Leng = stSYS.RX_BUF[0][3];
   4078             i_Max = u_Leng + 5;
   4079          
   4080             for (i = 6; i < i_Max; i++)
   4081             {
   4082                u_Rx_Data[i - 6] = stSYS.RX_BUF[0][i];
   4083                g_Po_Data[i - 6] = u_Rx_Data[i - 6];
   4084             }
   4085          
   4086             switch (u_Sync_Byte)
   4087             {
   4088             case TILT_FIRST_BYTE:
   4089          
   4090                switch (u_Cmd)
   4091                {
   4092                case MDIN_OSD_CLEAR:
   4093          
   4094                   if (stOSD.LAYER_NUM != stSYS.RX_BUF[0][6])
   4095                   {
   4096                      stOSD.LAYER_NUM = stSYS.RX_BUF[0][6];
   4097          
   4098                      OSD_Layer_Select(stOSD.LAYER_NUM);
   4099                   }
   4100          
   4101                   Send_MDIN_String_Data(MDIN_SPRITE_CLEAR, u_Leng, MDIN_COMMAND_TIMER_DELAY);
   4102          
   4103                   break;
   4104          
   4105                case MDIN_OSD_DATA:
   4106          
   4107                   if (stOSD.LAYER_NUM != stSYS.RX_BUF[0][6])
   4108                   {
   4109                      stOSD.LAYER_NUM = stSYS.RX_BUF[0][6];
   4110          
   4111                      OSD_Layer_Select(stOSD.LAYER_NUM);
   4112                   }
   4113          
   4114                   Send_MDIN_String_Data(MDIN_SPRITE_STRING, u_Leng, MDIN_COMMAND_TIMER_DELAY);
   4115          
   4116                   break;
   4117          
   4118                case MDIN_COORDINATE_DATA:
   4119          
   4120                   if (stOSD.LAYER_NUM != MDIN_LAYER_COORDINATE)
   4121                   {
   4122                      stOSD.LAYER_NUM = MDIN_LAYER_COORDINATE;
   4123          
   4124                      OSD_Layer_Select(stOSD.LAYER_NUM);
   4125                   }
   4126          
   4127                   u_PT_PAN_INT = (u_Rx_Data[1] << 4);
   4128                   u_PT_PAN_INT |= (u_Rx_Data[2]);
   4129          
   4130                   u_PT_PAN_DECIMAL = (u_Rx_Data[3] << 4);
   4131                   u_PT_PAN_DECIMAL |= (u_Rx_Data[4]);
   4132          
   4133                   switch (u_Rx_Data[5])
   4134                   {
   4135                   case 0x00:
   4136                      u_PT_TILT_SIGN = 0x00;	// NULL
   4137                      break;
   4138          
   4139                   case 0x01:
   4140                      u_PT_TILT_SIGN = 0x2D;	// -
   4141                      break;
   4142          
   4143                   default:
   4144                      break;
   4145                   }
   4146          
   4147                   u_PT_TILT_INT = (u_Rx_Data[6] << 4);
   4148                   u_PT_TILT_INT |= (u_Rx_Data[7]);
   4149                   u_PT_TILT_DECIMAL = (u_Rx_Data[8] << 4);
   4150                   u_PT_TILT_DECIMAL |= (u_Rx_Data[9]);
   4151          
   4152                   /*
   4153                   u_ID = MDIN_LAYER_CENTER_MSG;				// ID
   4154                   u_Rx_Data[0] = 0x00;		// ON
   4155                   u_Rx_Data[1] = 0x00;		// RESERVED
   4156          
   4157                   Send_MDIN_Data(MDIN_FREEZE, 0x03, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   4158                   				u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   4159                   */
   4160          
   4161                   u_ID = MDIN_LAYER_COORDINATE;										// ID : Main 0
   4162                   u_Position_x = 0x01;								// COLUMN : 1
   4163                   u_Position_y = 0x00;								// ROW : 0
   4164          
   4165                   u_Rx_Data[0] = 0x00;								// NULL
   4166                   u_Rx_Data[1] = (u_PT_PAN_INT / 100) + 0x30;			// 1
   4167                   u_Rx_Data[2] = ((u_PT_PAN_INT % 100) / 10) + 0x30;	// 8
   4168                   u_Rx_Data[3] = (u_PT_PAN_INT % 10) + 0x30;			// 0
   4169                   u_Rx_Data[4] = 0x2E;								// .
   4170                   u8_Convert_Data = (u_PT_PAN_DECIMAL / 10) + 0x30;
   4171                   u_Rx_Data[5] = u8_Convert_Data;					// 0
   4172                   u8_Convert_Data = (u_PT_PAN_DECIMAL % 10) + 0x30;
   4173                   u_Rx_Data[6] = u8_Convert_Data;					// 0
   4174                   u_Rx_Data[7] = 0x00;								// NULL
   4175                   u_Rx_Data[8] = u_PT_TILT_SIGN;					// NULL / -
   4176                   u_Rx_Data[9] = (u_PT_TILT_INT / 100) + 0x30;		// 1
   4177                   u_Rx_Data[10] = ((u_PT_TILT_INT % 100) / 10) + 0x30;	// 8
   4178                   u_Rx_Data[11] = (u_PT_TILT_INT % 10) + 0x30;		// 0
   4179                   u_Rx_Data[12] = 0x2E;								// .
   4180                   u8_Convert_Data = (u_PT_TILT_DECIMAL / 10) + 0x30;
   4181                   u_Rx_Data[13] = u8_Convert_Data;					// 0
   4182                   u8_Convert_Data = (u_PT_TILT_DECIMAL % 10) + 0x30;
   4183                   u_Rx_Data[14] = u8_Convert_Data;					// 0
   4184          
   4185                   Send_MDIN_Data(MDIN_SPRITE_STRING, 0x12, u_ID, u_Position_x, u_Position_y, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7],
   4186                                  u_Rx_Data[8], u_Rx_Data[9], u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], MDIN_COMMAND_TIMER_DELAY);
   4187          
   4188                   break;
   4189          
   4190                case MDIN_BYPASS_DATA:
   4191          
   4192                   u16_Convert_Data = u_Rx_Data[0];
   4193                   u16_Convert_Data |= (u_Rx_Data[1] << 8);
   4194          
   4195                   Send_MDIN_Data(u16_Convert_Data, u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9], u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13],
   4196                                  u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], u_Rx_Data[17], u_Rx_Data[18], u_Rx_Data[19], u_Rx_Data[20], MDIN_COMMAND_TIMER_DELAY);
   4197                   break;
   4198          
   4199                case TILT_BOOT_STATUS:
   4200          
   4201                   u_Cmd = TILT_BOOT_STATUS;
   4202                   u_Leng = 0x04;
   4203                   u_ID = MDIN_LAYER_CENTER_MSG;
   4204          
   4205                   stUSART1.TX_BUF[0] = TILT_FIRST_BYTE;
   4206                   stUSART1.TX_BUF[1] = TILT_SECOND_BYTE;
   4207                   stUSART1.TX_BUF[2] = u_Leng;
   4208                   stUSART1.TX_BUF[3] = u_ID;
   4209                   stUSART1.TX_BUF[4] = u_Cmd;
   4210                   stUSART1.TX_BUF[5] = ACTIVE;
   4211                   stUSART1.TX_BUF[6] = 0x00;
   4212          
   4213                   stUSART1.TX_BUF[7] = 0x00;
   4214                   stUSART1.TX_BUF[7] = stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5] + stUSART1.TX_BUF[6];
   4215          
   4216                   stUSART1.TX_BUF[8] = 0xCF;
   4217          
   4218                   stUSART1.TX_CNT = 0;
   4219                   stUSART1.TX_MAX = u_Leng + 5;
   4220          
   4221                   USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   4222          
   4223                   break;
   4224          
   4225                case TILT_RESET:
   4226          
   4227                   RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE);
   4228                   WWDG_SetPrescaler(WWDG_Prescaler_8);
   4229                   WWDG_SetWindowValue(80);
   4230                   WWDG_Enable(127);
   4231          
   4232                   break;
   4233          
   4234                case TILT_MDIN_RESET:
   4235          
   4236                   stINFO.BOOT_FLAG = 0x01;
   4237          
   4238                   while (stINFO.BOOT_FLAG)
   4239                   {
   4240                      Module_Auto_Sync();
   4241          
   4242                      if (stINFO.MODULE_TYPE != INDEX_NON)
   4243                         stINFO.BOOT_FLAG = 0x00;
   4244                   }
   4245          
   4246                   switch (stINFO.MODULE_TYPE)
   4247                   {
   4248                   case SONY_MODULE:
   4249          
   4250                      UART4_Init(9600);
   4251                      Delay_1ms(200);
   4252          
   4253                      break;
   4254          
   4255                   case TSM_MODULE:
   4256          
   4257                      UART4_Init(38400);
   4258          
   4259                      VIDEO_Initialization(PAL_MODE);
   4260                      Delay_1ms(200);
   4261                      MDIN_I550_Initialization();
   4262          
   4263                      stUART4.RX_REQUEST_CMD = TSM_CALL_PRODUCT_IDENTIFICATION;
   4264                      Send_TSM_Data(TSM_CALL_PRODUCT_IDENTIFICATION, 0x00, 0x00, 0x00, 0x06, TSM_COMMAND_TIMER_DELAY);
   4265                      Delay_1ms(TSM_REQUEST_TIMER_MAX);
   4266          
   4267                      stUART4.RX_REQUEST_CMD = TSM_CALL_CAMERA_INFORMATION;
   4268                      Send_TSM_Data(TSM_CALL_CAMERA_INFORMATION, 0x00, 0x00, 0x00, 0x06, TSM_COMMAND_TIMER_DELAY);
   4269                      Delay_1ms(TSM_REQUEST_TIMER_MAX);
   4270          
   4271                      stUART4.RX_REQUEST_CMD = TSM_CALL_FIRMWARE_VERSION;
   4272                      Send_TSM_Data(TSM_CALL_FIRMWARE_VERSION, 0x00, 0x00, 0x00, 0x06, TSM_COMMAND_TIMER_DELAY);
   4273                      Delay_1ms(TSM_REQUEST_TIMER_MAX);
   4274          
   4275                      break;
   4276          
   4277                   default:
   4278          
   4279                      UART4_Init(38400);
   4280          
   4281                      VIDEO_Initialization(PAL_MODE);
   4282                      Delay_1ms(200);
   4283                      MDIN_I550_Initialization();
   4284                      Delay_1ms(200);
   4285          
   4286                      Send_MDIN_Data(MDIN_OUTPUT_PATTERN, 0x03, 0x0D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, MDIN_COMMAND_TIMER_DELAY);
   4287                      Send_MDIN_Data(MDIN_OUTPUT_PATTERN, 0x03, 0x0D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, MDIN_COMMAND_TIMER_DELAY);
   4288                      Send_MDIN_Data(MDIN_OUTPUT_PATTERN, 0x03, 0x0D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, MDIN_COMMAND_TIMER_DELAY);
   4289          
   4290                      break;
   4291          
   4292                   }
   4293          
   4294                   break;
   4295          
   4296                case CALL_INFORMATION:
   4297          
   4298                   u_Cmd = CALL_INFORMATION;
   4299                   u_Leng = 0x0E;
   4300                   u_ID = 0x01;
   4301          
   4302                   stUSART1.TX_BUF[0] = TILT_FIRST_BYTE;
   4303                   stUSART1.TX_BUF[1] = TILT_SECOND_BYTE;
   4304                   stUSART1.TX_BUF[2] = u_Leng;
   4305                   stUSART1.TX_BUF[3] = u_ID;
   4306                   stUSART1.TX_BUF[4] = u_Cmd;
   4307          
   4308                   stUSART1.TX_BUF[5] = Version_High;
   4309                   stUSART1.TX_BUF[6] = Version_Low;
   4310          
   4311                   stUSART1.TX_BUF[7] = Upgrade_Year_Month;
   4312                   stUSART1.TX_BUF[8] = Upgrade_Day;
   4313          
   4314                   stUSART1.TX_BUF[9] = stINFO.MODULE_TYPE;
   4315          
   4316                   switch (stINFO.MODULE_TYPE)
   4317                   {
   4318                   case SONY_MODULE:
   4319          
   4320                      stUSART1.TX_BUF[10] = 0x00;
   4321                      stUSART1.TX_BUF[11] = 0x00;
   4322                      stUSART1.TX_BUF[12] = 0x00;
   4323                      stUSART1.TX_BUF[13] = 0x00;
   4324                      stUSART1.TX_BUF[14] = 0x00;
   4325                      stUSART1.TX_BUF[15] = 0x00;
   4326                      stUSART1.TX_BUF[16] = 0x00;
   4327          
   4328                      break;
   4329          
   4330                   case TSM_MODULE:
   4331          
   4332                      stUSART1.TX_BUF[10] = stINFO.THERMAL_MODEL;
   4333                      stUSART1.TX_BUF[11] = stINFO.THERMAL_LENS;
   4334                      stUSART1.TX_BUF[12] = stINFO.THERMAL_VER_HIGH;
   4335                      stUSART1.TX_BUF[13] = stINFO.THERMAL_VER_LOW;
   4336                      stUSART1.TX_BUF[14] = stINFO.THERMAL_DAY;
   4337                      stUSART1.TX_BUF[15] = stINFO.THERMAL_MONTH;
   4338                      stUSART1.TX_BUF[16] = stINFO.THERMAL_YEAR;
   4339          
   4340                      break;
   4341          
   4342                   default:
   4343                      break;
   4344                   }
   4345          
   4346                   stUSART1.TX_BUF[17] = 0x00;
   4347                   stUSART1.TX_BUF[17] = stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5] + stUSART1.TX_BUF[6];
   4348          
   4349                   stUSART1.TX_BUF[18] = 0xCF;
   4350          
   4351                   stUSART1.TX_CNT = 0;
   4352                   stUSART1.TX_MAX = u_Leng + 5;
   4353          
   4354                   USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   4355          
   4356                   break;
   4357          
   4358                default:
   4359                   break;
   4360                }
   4361          
   4362                break;
   4363          
   4364             case IP_SONY_FIRST_BYTE:
   4365          
   4366                Sony_Data_Handing(SYSTEM_INDEX, u_Cmd, u_Leng);		// Command Check, Length Check
   4367          
   4368                break;
   4369          
   4370             case IP_TSM_FIRST_BYTE:
   4371          
   4372                //  
   4373                switch (stINFO.THERMAL_MODEL)
   4374                {
   4375                case TSM_72:
   4376                case TSM_72T:
   4377                case TSM_1M:
   4378                case TSM_1MT:
   4379                   TSM_Data_Handing(SYSTEM_INDEX, u_Cmd, u_Leng);		// Command Check, Length Check
   4380                   break;
   4381          
   4382                case TCM_640:
   4383                   TCM_Data_Handing(SYSTEM_INDEX, u_Cmd, u_Leng);		// Command Check, Length Check
   4384                   break;
   4385                }
   4386          
   4387                break;
   4388          
   4389             case IP_OPTION_FIRST_BYTE:
   4390                OPTION_Data_Handing(SYSTEM_INDEX, u_Cmd, u_Leng);		// Command Check, Length Check
   4391                break;
   4392          
   4393             default:
   4394                break;
   4395             }
   4396          }
   4397          
   4398          /*******************************************************************************
   4399          * Function Name  : USART1_Data_Parser
   4400          *******************************************************************************/
   4401          void USART1_Data_Parser(void)
   4402          {
   4403             u8 i = 0, i_Max = 0x00;
   4404             u8 u_Cmd = 0x00, u_Leng = 0x00;
   4405             u8 u_ID = 0x00, u_Position_x = 0x00, u_Position_y = 0x00;
   4406             u8 u_Rx_Data[50];
   4407          
   4408             u8 u_PT_PAN_SIGN = 0x00, u_PT_TILT_SIGN = 0x00;
   4409             u16 u_PT_PAN_INT = 0x0000, u_PT_PAN_DECIMAL = 0x0000;
   4410             u16 u_PT_TILT_INT = 0x0000, u_PT_TILT_DECIMAL = 0x0000;
   4411          
   4412             u8 u8_Convert_Data = 0x00;
   4413             u16 u16_Convert_Data = 0x0000;
   4414          
   4415             u_Cmd = stUSART1.RX_BUF[4];
   4416             u_Leng = stUSART1.RX_BUF[2];
   4417             i_Max = u_Leng + 4;
   4418          
   4419             for (i = 5; i < i_Max; i++)
   4420             {
   4421                u_Rx_Data[i - 5] = stUSART1.RX_BUF[i];
   4422             }
   4423          
   4424             switch (stUSART1.RX_BUF[0])
   4425             {
   4426             case TILT_FIRST_BYTE:
   4427          
   4428                switch (u_Cmd)
   4429                {
   4430                case MDIN_OSD_CLEAR:
   4431          
   4432                   if (stOSD.LAYER_NUM != stUSART2.TX_BUF[5])
   4433                   {
   4434                      stOSD.LAYER_NUM = stUSART2.TX_BUF[5];
   4435          
   4436                      OSD_Layer_Select(stOSD.LAYER_NUM);
   4437                   }
   4438          
   4439                   Send_MDIN_String_Data(MDIN_SPRITE_CLEAR, u_Leng, MDIN_COMMAND_TIMER_DELAY);
   4440          
   4441                   break;
   4442          
   4443                case MDIN_OSD_DATA:
   4444          
   4445                   if (stOSD.LAYER_NUM != stUSART2.TX_BUF[5])
   4446                   {
   4447                      stOSD.LAYER_NUM = stUSART2.TX_BUF[5];
   4448          
   4449                      OSD_Layer_Select(stOSD.LAYER_NUM);
   4450                   }
   4451          
   4452                   Send_MDIN_String_Data(MDIN_SPRITE_STRING, u_Leng, MDIN_COMMAND_TIMER_DELAY);
   4453          
   4454                   break;
   4455          
   4456                case MDIN_COORDINATE_DATA:
   4457          
   4458                   if (stOSD.LAYER_NUM != MDIN_LAYER_COORDINATE)
   4459                   {
   4460                      stOSD.LAYER_NUM = MDIN_LAYER_COORDINATE;
   4461          
   4462                      OSD_Layer_Select(stOSD.LAYER_NUM);
   4463                   }
   4464          
   4465                   u_PT_PAN_INT = (u_Rx_Data[1] << 4);
   4466                   u_PT_PAN_INT |= (u_Rx_Data[2]);
   4467          
   4468                   u_PT_PAN_DECIMAL = (u_Rx_Data[3] << 4);
   4469                   u_PT_PAN_DECIMAL |= (u_Rx_Data[4]);
   4470          
   4471                   switch (u_Rx_Data[5])
   4472                   {
   4473                   case 0x00:
   4474                      u_PT_TILT_SIGN = 0x00;	// NULL
   4475                      break;
   4476          
   4477                   case 0x01:
   4478                      u_PT_TILT_SIGN = 0x2D;	// -
   4479                      break;
   4480          
   4481                   default:
   4482                      break;
   4483                   }
   4484          
   4485                   u_PT_TILT_INT = (u_Rx_Data[6] << 4);
   4486                   u_PT_TILT_INT |= (u_Rx_Data[7]);
   4487                   u_PT_TILT_DECIMAL = (u_Rx_Data[8] << 4);
   4488                   u_PT_TILT_DECIMAL |= (u_Rx_Data[9]);
   4489          
   4490                   /*
   4491                   u_ID = MDIN_LAYER_CENTER_MSG;				// ID : Main 0
   4492                   u_Rx_Data[0] = 0x00;		// ON
   4493                   u_Rx_Data[1] = 0x00;		// RESERVED
   4494          
   4495                   Send_MDIN_Data(MDIN_FREEZE, 0x03, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   4496                   				u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   4497                   */
   4498          
   4499                   u_ID = MDIN_LAYER_COORDINATE;					// ID
   4500                   u_Position_x = 0x01;								// COLUMN : 1
   4501                   u_Position_y = 0x00;								// ROW : 0
   4502          
   4503                   u_Rx_Data[0] = 0x00;								// NULL
   4504                   u_Rx_Data[1] = (u_PT_PAN_INT / 100) + 0x30;			// 1
   4505                   u_Rx_Data[2] = ((u_PT_PAN_INT % 100) / 10) + 0x30;	// 8
   4506                   u_Rx_Data[3] = (u_PT_PAN_INT % 10) + 0x30;			// 0
   4507                   u_Rx_Data[4] = 0x2E;								// .
   4508                   u8_Convert_Data = (u_PT_PAN_DECIMAL / 10) + 0x30;
   4509                   u_Rx_Data[5] = u8_Convert_Data;					// 0
   4510                   u8_Convert_Data = (u_PT_PAN_DECIMAL % 10) + 0x30;
   4511                   u_Rx_Data[6] = u8_Convert_Data;					// 0
   4512                   u_Rx_Data[7] = 0x00;								// NULL
   4513                   u_Rx_Data[8] = u_PT_TILT_SIGN;					// NULL / -
   4514                   u_Rx_Data[9] = (u_PT_TILT_INT / 100) + 0x30;		// 1
   4515                   u_Rx_Data[10] = ((u_PT_TILT_INT % 100) / 10) + 0x30;	// 8
   4516                   u_Rx_Data[11] = (u_PT_TILT_INT % 10) + 0x30;		// 0
   4517                   u_Rx_Data[12] = 0x2E;								// .
   4518                   u8_Convert_Data = (u_PT_TILT_DECIMAL / 10) + 0x30;
   4519                   u_Rx_Data[13] = u8_Convert_Data;					// 0
   4520                   u8_Convert_Data = (u_PT_TILT_DECIMAL % 10) + 0x30;
   4521                   u_Rx_Data[14] = u8_Convert_Data;					// 0
   4522          
   4523                   Send_MDIN_Data(MDIN_SPRITE_STRING, 0x12, u_ID, u_Position_x, u_Position_y, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7],
   4524                                  u_Rx_Data[8], u_Rx_Data[9], u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], MDIN_COMMAND_TIMER_DELAY);
   4525          
   4526                   break;
   4527          
   4528                default:
   4529                   break;
   4530                }
   4531          
   4532                break;
   4533          
   4534             case IP_SONY_FIRST_BYTE:
   4535          
   4536                Sony_Data_Handing(USART1_INDEX, u_Cmd, u_Leng);		// Command Check, Length Check
   4537          
   4538                break;
   4539          
   4540             case IP_TSM_FIRST_BYTE:
   4541          
   4542                //  
   4543                switch (stINFO.THERMAL_MODEL)
   4544                {
   4545                case TSM_72:
   4546                case TSM_72T:
   4547                case TSM_1M:
   4548                case TSM_1MT:
   4549                   TSM_Data_Handing(USART1_INDEX, u_Cmd, u_Leng);		// Command Check, Length Check
   4550                   break;
   4551          
   4552                case TCM_640:
   4553                   //TCM_Data_Handing(u_buf[4], u_buf[2]);		// Command Check, Length Check
   4554                   break;
   4555                }
   4556          
   4557                break;
   4558          
   4559             default:
   4560                break;
   4561             }
   4562          }
   4563          
   4564          /*******************************************************************************
   4565          * Function Name  : Before_USART1_Data_Parser
   4566          *******************************************************************************/
   4567          void Before_USART1_Data_Parser(void)
   4568          {
   4569             /*******************************************************************************
   4570             * Data Format
   4571             BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]
   4572             0xCA		0xAC		CMD			DATA1(P1)	DATA2(P2)	CS
   4573             *******************************************************************************/
   4574             u8 u_Cmd = 0x00, u_Rx_Data1 = 0x00, u_Rx_Data2 = 0x00;
   4575             u8 u_Tx_Data1 = 0x00, u_Tx_Data2 = 0x00, u_Tx_Data3 = 0x00, u_Tx_Data4 = 0x00;
   4576             u16 u_Convert_Data = 0x0000;
   4577          
   4578             if (stUSART1.RX_PARITY == 0x01)
   4579             {
   4580                stUSART1.RX_PARITY = 0x00;
   4581                u_Cmd = stUSART1.RX_BUF[2];
   4582                u_Rx_Data1 = stUSART1.RX_BUF[3];
   4583                u_Rx_Data2 = stUSART1.RX_BUF[4];
   4584          
   4585                switch (u_Cmd)
   4586                {
   4587                   /*******************************************************************************
   4588                   * Command : 0x02
   4589                   * Mode : Set Wiper
   4590                   BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]
   4591                   0xCA		0xAC		0x02		P1			P2			CS
   4592                   - P1 : Count - 0x01 ~ 0x0E (1~14), 0x0F : Continuous Active
   4593                   - P2 : Dwell Time (s) - 0x00 ~ 0x3B (0~59)
   4594                   *******************************************************************************/ 
   4595                   // 5.2. Set Wiper (0x02)
   4596                case SET_WIPER:
   4597          
   4598                   stWIPER2.COUNT = u_Rx_Data1;
   4599                   stWIPER2.DWELL_TIME_DATA = u_Rx_Data2;
   4600                   stWIPER2.FLAG = 0x01;
   4601          
   4602                   stWIPER2.STOP_MODE = WIPER_STOP_READY;
   4603                   stWIPER2.STEP = WIPER_READY;
   4604          
   4605                   if (stWIPER2.COUNT >= 0x0F)
   4606                   {
   4607                      stWIPER2.CONTINUOUS_FLAG = 0x01;
   4608                      stWIPER2.CONTINUOUS_ms = 0;
   4609                      stWIPER2.CONTINUOUS_s = 0;
   4610                   }
   4611          
   4612                   break;
   4613          
   4614                   /*******************************************************************************
   4615                   * Command : 0x03
   4616                   * Mode : Stop Wiper
   4617                   BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]
   4618                   0xCA		0xAC		0x03		P1			0x00			CS
   4619                   - P1 : 
   4620                   0x00 : Origin Stop
   4621                   0x01 : Emergency Stop 
   4622                   *******************************************************************************/ 
   4623                   // 5.3. Stop Wiper (0x03)
   4624                case STOP_WIPER:
   4625          
   4626                   switch (u_Rx_Data1)
   4627                   {
   4628                   case 0x00:
   4629                      stWIPER2.STOP_MODE = WIPER_STOP_ORIGIN;
   4630                      break;
   4631          
   4632                   case 0x01:
   4633                      stWIPER2.STOP_MODE = WIPER_STOP_EMERGENCY;
   4634                      break;
   4635                   }
   4636          
   4637                   if (stWIPER2.DWELL_TIMER_FLAG)
   4638                      stWIPER2.DWELL_TIMER_FLAG = 0x00;
   4639                   if (stWIPER2.CONTINUOUS_FLAG == 0x01)
   4640                   {
   4641                      stWIPER2.CONTINUOUS_FLAG = 0x00;
   4642                   }
   4643          
   4644                   break;
   4645          
   4646                   // 5.5. Set LRF (0x05)
   4647                case SET_LRF:
   4648          
   4649                   switch (u_Rx_Data2)
   4650                   {
   4651                   case 0x00:
   4652                      break;
   4653          
   4654                   default:
   4655          
   4656                      stLRF.CONTINUOUS_TIME_MAX = u_Rx_Data2 * 50;
   4657          
   4658                      break;
   4659                   }
   4660          
   4661                   switch (u_Rx_Data1)
   4662                   {
   4663                   case 0x01:
   4664          
   4665                      stLRF.CONTINUOUS_FLAG = 0x01;
   4666          
   4667                      break;
   4668          
   4669                   default:
   4670          
   4671                      stLRF.CONTINUOUS_FLAG = 0x00;
   4672          
   4673                      break;
   4674                   }
   4675          
   4676                   break;
   4677          
   4678          
   4679                   /*******************************************************************************
   4680                   * Command : 0x07
   4681                   * Mode : Light On/Off [0x00:Off, 0x01:On]
   4682                   BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]
   4683                   0xCA		0xAC		0x07		P1			0x00		CS
   4684                   - P1 :
   4685                   0x00 : Light Off
   4686                   0x01 : Light On
   4687                   *******************************************************************************/ 
   4688                   // 5.7. Set Light On/Off (0x07)
   4689                case SET_LIGHT:
   4690          
   4691                   switch (u_Rx_Data1)
   4692                   {
   4693                   case 0x00:
   4694          
   4695                      EXTERNAL_LIGHT_PORT_OFF;
   4696                      stLIGHT.EXTERNAL_STATUS = LIGHT_OFF;
   4697          
   4698                      break;
   4699          
   4700                   case 0x01:
   4701          
   4702                      EXTERNAL_LIGHT_PORT_ON;
   4703                      stLIGHT.EXTERNAL_STATUS = LIGHT_ON;
   4704          
   4705                      break;
   4706          
   4707                   default:
   4708                      break;
   4709                   }
   4710          
   4711                   break;
   4712          
   4713                   // 5.8. Set Zoom-Light On/Off (0x08)
   4714                case SET_ZOOM_LIGHT:
   4715          
   4716                   switch (u_Rx_Data1)
   4717                   {
   4718                   case 0x00:
   4719          
   4720                      // Zoom Light Off
   4721                      Send_Light_Data(ZOOM_LIGHT_ENABLE, 0x30, 0x30, 0x30, 0x30, 0x30, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4722                      stLIGHT.ZOOM_STATUS = LIGHT_OFF;
   4723          
   4724                      break;
   4725          
   4726                   case 0x01:
   4727          
   4728                      // Zoom Light On
   4729                      Send_Light_Data(ZOOM_LIGHT_ENABLE, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4730                      stLIGHT.ZOOM_STATUS = LIGHT_ON;
   4731          
   4732                      break;
   4733          
   4734                   default:
   4735                      break;
   4736                   }
   4737          
   4738                   break;
   4739          
   4740                   // 5.9. Set Zoom-Light Direct Position (0x09)
   4741                case SET_ZOOM_LIGHT_DIRECT_POSITION:
   4742          
   4743                   u_Convert_Data = (u_Rx_Data1 << 8);
   4744                   u_Convert_Data |= u_Rx_Data2;
   4745          
   4746                   u_Tx_Data1 = (u_Convert_Data / 1000) & 0xFF;
   4747                   if (u_Tx_Data1 >= 9)
   4748                      u_Tx_Data1 = 9;
   4749                   u_Tx_Data1 = u_Tx_Data1 + 0x30;
   4750          
   4751                   u_Convert_Data = u_Convert_Data % 1000;
   4752                   u_Tx_Data2 = (u_Convert_Data / 100) & 0xFF;
   4753                   u_Tx_Data2 = u_Tx_Data2 + 0x30;
   4754          
   4755                   u_Convert_Data = u_Convert_Data % 100;
   4756                   u_Tx_Data3 = (u_Convert_Data / 10) & 0xFF;
   4757                   u_Tx_Data3 = u_Tx_Data3 + 0x30;
   4758          
   4759                   u_Tx_Data4 = (u_Convert_Data % 10) & 0xFF;
   4760                   u_Tx_Data4 = u_Tx_Data4 + 0x30;
   4761          
   4762                   Send_Light_Data(ZOOM_LIGHT_DIRECT, 0x2B, u_Tx_Data1, u_Tx_Data2, u_Tx_Data3, u_Tx_Data4, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4763          
   4764                   break;
   4765          
   4766                   // 5.A. (Special CMD) Call Zoom-Light Data (0x0A)
   4767                case CALL_ZOOM_LIGHT_DATA:
   4768          
   4769                   Send_Light_Data(CALL_ZOOM_LIGHT_POSITION, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4770          
   4771                   break;
   4772          
   4773                   // 5.B. (Special CMD) Set Zoom-Light Manual Control (0x0B)
   4774                case SET_ZOOM_LIGHT_MANUAL_CONTROL:
   4775          
   4776                   switch (u_Rx_Data1)
   4777                   {
   4778                   case 0x00:
   4779          
   4780                      stLIGHT.DIRECTION = CMD_ZOOM_LIGHT_WIDE;
   4781                      u_Tx_Data1 = 0x30;
   4782          
   4783                      u_Tx_Data2 = u_Rx_Data2 / 100;
   4784                      u_Tx_Data2 = u_Tx_Data2 + 0x30;
   4785          
   4786                      u_Rx_Data2 = u_Rx_Data2 % 100;
   4787                      u_Tx_Data3 = u_Rx_Data2 / 10;
   4788                      u_Tx_Data3 = u_Tx_Data3 + 0x30;
   4789          
   4790                      u_Tx_Data4 = u_Rx_Data2 % 10;
   4791                      u_Tx_Data4 = u_Tx_Data4 + 0x30;
   4792          
   4793                      Send_Light_Data(ZOOM_LIGHT_STEP, CMD_ZOOM_LIGHT_WIDE, u_Tx_Data1, u_Tx_Data2, u_Tx_Data3, u_Tx_Data4, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4794          
   4795                      break;
   4796          
   4797                   case 0x01:
   4798          
   4799                      stLIGHT.DIRECTION = CMD_ZOOM_LIGHT_TELE;
   4800          
   4801                      u_Tx_Data1 = 0x30;
   4802          
   4803                      u_Tx_Data2 = u_Rx_Data2 / 100;
   4804                      u_Tx_Data2 = u_Tx_Data2 + 0x30;
   4805          
   4806                      u_Rx_Data2 = u_Rx_Data2 % 100;
   4807                      u_Tx_Data3 = u_Rx_Data2 / 10;
   4808                      u_Tx_Data3 = u_Tx_Data3 + 0x30;
   4809          
   4810                      u_Tx_Data4 = u_Rx_Data2 % 10;
   4811                      u_Tx_Data4 = u_Tx_Data4 + 0x30;
   4812          
   4813                      Send_Light_Data(ZOOM_LIGHT_STEP, CMD_ZOOM_LIGHT_TELE, u_Tx_Data1, u_Tx_Data2, u_Tx_Data3, u_Tx_Data4, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4814          
   4815                      break;
   4816          
   4817                   default:
   4818                      break;
   4819                   }
   4820          
   4821                   break;
   4822          
   4823                   // 5.C. (Special CMD) Initialization Zoom-Light (0x0C)
   4824                case INITIALIZATION_ZOOM_LIGHT:
   4825          
   4826                   Send_Light_Data(ZOOM_LIGHT_INITIALIZATION, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4827          
   4828                   break;
   4829          
   4830                   // 5.10. LRF Initialization (0x10)
   4831                case LRF_INITIALIZATION:
   4832          
   4833                   // =======================================
   4834                   // Set LRF Initialization Flag
   4835                   // =======================================
   4836                   stLRF.INIT_FLAG = 0x01;
   4837          
   4838                   break;
   4839          
   4840                   // 5.18. Set Dual Light On/Off (0x18)
   4841                case OPTION_SET_EXTERNAL_IR_MODE:
   4842          
   4843                   switch (u_Rx_Data1)
   4844                   {
   4845                   case 0x00:
   4846          
   4847                      stCDS.IR_AUTO_ENABLE = 0x01;
   4848          
   4849                      switch (stCDS.DAY_AND_NIGHT_STATUS)
   4850                      {
   4851                         // Day Mode
   4852                      case 0x00:
   4853          
   4854                         EXTERNAL_LIGHT_PORT_OFF;
   4855                         stLIGHT.EXTERNAL_STATUS = LIGHT_OFF;
   4856          
   4857                         // Zoom Light Off
   4858                         Send_Light_Data(ZOOM_LIGHT_ENABLE, 0x30, 0x30, 0x30, 0x30, 0x30, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4859                         stLIGHT.ZOOM_STATUS = LIGHT_OFF;
   4860          
   4861                         break;
   4862          
   4863                         // Night Mode
   4864                      case 0x01:
   4865          
   4866                         EXTERNAL_LIGHT_PORT_ON;
   4867                         stLIGHT.EXTERNAL_STATUS = LIGHT_ON;
   4868          
   4869                         // Zoom Light On
   4870                         Send_Light_Data(ZOOM_LIGHT_ENABLE, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4871                         stLIGHT.ZOOM_STATUS = LIGHT_ON;
   4872          
   4873                         break;
   4874                      }
   4875          
   4876                      break;
   4877          
   4878                   case 0x01:
   4879          
   4880                      stCDS.IR_AUTO_ENABLE = 0x00;
   4881          
   4882                      EXTERNAL_LIGHT_PORT_ON;
   4883                      stLIGHT.EXTERNAL_STATUS = LIGHT_ON;
   4884          
   4885                      // Zoom Light On
   4886                      Send_Light_Data(ZOOM_LIGHT_ENABLE, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4887                      stLIGHT.ZOOM_STATUS = LIGHT_ON;
   4888          
   4889                      break;
   4890          
   4891                   case 0x02:
   4892          
   4893                      stCDS.IR_AUTO_ENABLE = 0x00;
   4894          
   4895                      EXTERNAL_LIGHT_PORT_OFF;
   4896                      stLIGHT.EXTERNAL_STATUS = LIGHT_OFF;
   4897          
   4898                      // Zoom Light Off
   4899                      Send_Light_Data(ZOOM_LIGHT_ENABLE, 0x30, 0x30, 0x30, 0x30, 0x30, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4900                      stLIGHT.ZOOM_STATUS = LIGHT_OFF;
   4901          
   4902                      break;
   4903          
   4904                   default:
   4905                      break;
   4906                   }
   4907          
   4908                   break;
   4909          
   4910                   // 5.19. Set External IR Change Lux (0x19)
   4911                case OPTION_SET_EXTERNAL_IR_CHANGE_LUX:
   4912          
   4913                   stCDS.LUX = u_Rx_Data1;
   4914          
   4915                   switch (stCDS.LUX)
   4916                   {
   4917                      // -5
   4918                   case 0x75:
   4919                      stCDS.DAY_AND_NIGHT_LEVEL = 10;
   4920                      break;
   4921          
   4922                      // -4
   4923                   case 0x77:
   4924                      stCDS.DAY_AND_NIGHT_LEVEL = 9;
   4925                      break;
   4926          
   4927                      // -3
   4928                   case 0x79:
   4929                      stCDS.DAY_AND_NIGHT_LEVEL = 8;
   4930                      break;
   4931          
   4932                      // -2
   4933                   case 0x7B:
   4934                      stCDS.DAY_AND_NIGHT_LEVEL = 7;
   4935                      break;
   4936          
   4937                      // -1
   4938                   case 0x7D:
   4939                      stCDS.DAY_AND_NIGHT_LEVEL = 6;
   4940                      break;
   4941          
   4942                      // Default
   4943                   case 0x7F:
   4944                      stCDS.DAY_AND_NIGHT_LEVEL = 5;
   4945                      break;
   4946          
   4947                      // +1
   4948                   case 0x81:
   4949                      stCDS.DAY_AND_NIGHT_LEVEL = 4;
   4950                      break;
   4951          
   4952                      // +2
   4953                   case 0x83:
   4954                      stCDS.DAY_AND_NIGHT_LEVEL = 3;
   4955                      break;
   4956          
   4957                      // +3
   4958                   case 0x85:
   4959                      stCDS.DAY_AND_NIGHT_LEVEL = 2;
   4960                      break;
   4961          
   4962                      // +4
   4963                   case 0x87:
   4964                      stCDS.DAY_AND_NIGHT_LEVEL = 1;
   4965                      break;
   4966          
   4967                      // +5
   4968                   case 0x89:
   4969                      stCDS.DAY_AND_NIGHT_LEVEL = 0;
   4970                      break;
   4971                   }
   4972          
   4973                   break;
   4974          
   4975                   // 5.20. Set External IR Offset (0x20)
   4976                case OPTION_SET_EXTERNAL_IR_OFFSET:
   4977          
   4978                   stCDS.OFFSET = u_Rx_Data1 * 1000;
   4979          
   4980                   break;
   4981          
   4982                   // 5.21. Set Wiper Continuous Time (0x21)
   4983                case OPTION_SET_WIPER_CONTINUOUS_TIME:
   4984          
   4985                   stWIPER2.CONTINUOUS_TIME = u_Rx_Data1;
   4986          
   4987                   break;
   4988          
   4989                   // 5.90. Call Version Data (0x90)
   4990                case CALL_VERSION:
   4991          
   4992                   Reponse_Data_Send(CALL_VERSION, Version_High, Version_Low);
   4993          
   4994                   break;
   4995          
   4996                   // 5.91. Call Update Data (0x91)
   4997                case CALL_UPGRADE_DATE:
   4998          
   4999                   Reponse_Data_Send(CALL_UPGRADE_DATE, Upgrade_Year_Month, Upgrade_Day);
   5000          
   5001                   break;
   5002          
   5003                   // 5.A0. CDS - Day & Night (Auto Mode) (0xA0)
   5004                case DAY_AND_NIGHT_AUTO_MODE:
   5005          
   5006                   switch (u_Rx_Data1)
   5007                   {
   5008                      // Night Mode
   5009                   case 0x00:
   5010          
   5011                      stCDS.DAY_AND_NIGHT_AUTO_ENABLE = 0x00;
   5012                      stCDS.DAY_AND_NIGHT_STATUS = 0x01;
   5013          
   5014                      // Auto Mode Off
   5015                      Send_Sony_Data(0x51, 0x03, 0x00, 0x06, SONY_COMMAND_TIMER_DELAY);
   5016          
   5017                      // Night Mode
   5018                      Send_Sony_Data(0x01, 0x02, 0x00, 0x06, SONY_COMMAND_TIMER_DELAY);
   5019          
   5020                      EXTERNAL_LIGHT_PORT_ON;
   5021                      stLIGHT.EXTERNAL_STATUS = LIGHT_ON;
   5022          
   5023                      // Zoom Light On
   5024                      Send_Light_Data(ZOOM_LIGHT_ENABLE, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   5025                      stLIGHT.ZOOM_STATUS = LIGHT_ON;
   5026          
   5027                      break;
   5028          
   5029                      // Day Mode
   5030                   case 0x01:
   5031          
   5032                      stCDS.DAY_AND_NIGHT_AUTO_ENABLE = 0x00;
   5033                      stCDS.DAY_AND_NIGHT_STATUS = 0x00;
   5034          
   5035                      // Auto Mode Off
   5036                      Send_Sony_Data(0x51, 0x03, 0x00, 0x06, SONY_COMMAND_TIMER_DELAY);
   5037          
   5038                      // Day Mode
   5039                      Send_Sony_Data(0x01, 0x03, 0x00, 0x06, SONY_COMMAND_TIMER_DELAY);
   5040          
   5041                      EXTERNAL_LIGHT_PORT_OFF;
   5042                      stLIGHT.EXTERNAL_STATUS = LIGHT_OFF;
   5043          
   5044                      // Zoom Light Off
   5045                      Send_Light_Data(ZOOM_LIGHT_ENABLE, 0x30, 0x30, 0x30, 0x30, 0x30, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   5046                      stLIGHT.ZOOM_STATUS = LIGHT_OFF;
   5047          
   5048                      break;
   5049          
   5050                      // Auto Mode
   5051                   case 0x02:
   5052          
   5053                      // Auto Mode Off
   5054                      Send_Sony_Data(0x51, 0x02, 0x00, 0x06, SONY_COMMAND_TIMER_DELAY);
   5055          
   5056                      stCDS.DAY_AND_NIGHT_AUTO_ENABLE = 0x01;
   5057          
   5058                      break;
   5059                   }
   5060          
   5061                   break;
   5062          
   5063                   // TEST_ZOOM_DATA
   5064                case TEST_ZOOM_DATA:
   5065          
   5066                   Send_Sony_Data(0x07, 0x27, 0x00, 0x06, SONY_COMMAND_TIMER_DELAY);
   5067          
   5068                   stTEST.TIMER_FLAG = 0x01;
   5069          
   5070                   break;
   5071          
   5072                default:
   5073                   break;
   5074                }
   5075             }
   5076          }
   5077          
   5078          /*******************************************************************************
   5079          * Function Name  : Zoom_Data_Sync
   5080          /=============================================================/
   5081          Step		Light-Zoom(DEC)	Light-Zoom(HEX)	Sony-Zoom(DEC)	Sony-Zoom(HEX)
   5082          0		1036			0x040B			0				0x0000
   5083          1		1000			0x03E8			550				0x0226
   5084          2		964				0x03C4			1096			0x0448
   5085          3		929				0x03A0			1642			0x066A
   5086          4		893				0x037D			2188			0x088C
   5087          5		857				0x0359			2734			0x0AAE
   5088          6		822				0x0335			3280			0x0CD0
   5089          7		786				0x0311			3826			0x0EF2
   5090          8		750				0x02EE			4372			0x1114
   5091          9		714				0x02CA			4918			0x1336
   5092          10		679				0x02A6			5464			0x1558
   5093          11		643				0x0282			6010			0x177A
   5094          12		607				0x025F			6556			0x199C
   5095          13		572				0x023B			7102			0x1BBE
   5096          14		536				0x0217			7648			0x1DE0
   5097          15		500				0x01F4			8194			0x2002
   5098          16		464				0x01D0			8740			0x2224
   5099          17		429				0x01AC			9286			0x2446
   5100          18		393				0x0188			9832			0x2668
   5101          19		357				0x0165			10378			0x288A
   5102          20		321				0x0141			10924			0x2AAC
   5103          21		286				0x011D			11470			0x2CCE
   5104          22		250				0x00FA			12016			0x2EF0
   5105          23		214				0x00D6			12562			0x3112
   5106          24		179				0x00B2			13108			0x3334
   5107          25		143				0x008E			13654			0x3556
   5108          26		107				0x006B			14200			0x3778
   5109          27		71				0x0047			14746			0x399A
   5110          28		36				0x0023			15292			0x3BBC
   5111          29		0				0x0000			15838			0x3DDE
   5112          30										16384			0x4000
   5113          *******************************************************************************/
   5114          void Zoom_Data_Sync(void)
   5115          {
   5116             // STEP 0 - HEX : 0x0000 ~ 0x0226 (DEC : 0 ~ 550)
   5117             if (stSONY.ZOOM_POSITION < 0x0225)
   5118             {
   5119                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_0;
   5120             }
   5121             // STEP 1 - HEX : 0x0226 ~ 0x0448 (DEC : 550 ~ 1096)
   5122             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_0) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_1))
   5123             {
   5124                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_1;
   5125             }
   5126             // STEP 2 - HEX : 0x0448 ~ 0x066A (DEC : 1096 ~ 1642)
   5127             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_1) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_2))
   5128             {
   5129                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_2;
   5130             }
   5131             // STEP 3 - HEX : 0x066A ~ 0x088C (DEC : 1642 ~ 2188)
   5132             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_2) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_3))
   5133             {
   5134                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_3;
   5135             }
   5136             // STEP 4 - HEX : 0x088C ~ 0x0AAE (DEC : 2188 ~ 2734)
   5137             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_3) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_4))
   5138             {
   5139                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_4;
   5140             }
   5141             // STEP 5 - HEX : 0x0AAE ~ 0x0CD0 (DEC : 2734 ~ 3280)
   5142             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_4) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_5))
   5143             {
   5144                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_5;
   5145             }
   5146             // STEP 6 - HEX : 0x0CD0 ~ 0x0EF2 (DEC : 3280 ~ 3826)
   5147             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_5) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_6))
   5148             {
   5149                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_6;
   5150             }
   5151             // STEP 7 - HEX : 0x0EF2 ~ 0x1114 (DEC : 3826 ~ 4372)
   5152             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_6) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_7))
   5153             {
   5154                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_7;
   5155             }
   5156             // STEP 8 - HEX : 0x1114 ~ 0x1336 (DEC : 4372 ~ 4918)
   5157             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_7) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_8))
   5158             {
   5159                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_8;
   5160             }
   5161             // STEP 9 - HEX : 0x1336 ~ 0x1558 (DEC : 4918 ~ 5464)
   5162             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_8) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_9))
   5163             {
   5164                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_9;
   5165             }
   5166             // STEP 10 - HEX : 0x1558 ~ 0x177A (DEC : 5464 ~ 6010)
   5167             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_9) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_10))
   5168             {
   5169                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_10;
   5170             }
   5171             // STEP 11 - HEX : 0x177A ~ 0x199C (DEC : 6010 ~ 6556)
   5172             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_10) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_11))
   5173             {
   5174                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_11;
   5175             }
   5176             // STEP 12 - HEX : 0x199C ~ 0x1BBE (DEC : 6556 ~ 7102)
   5177             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_11) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_12))
   5178             {
   5179                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_12;
   5180             }
   5181             // STEP 13 - HEX : 0x1BBE ~ 0x1DE0 (DEC : 7102 ~ 7648)
   5182             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_12) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_13))
   5183             {
   5184                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_13;
   5185             }
   5186             // STEP 14 - HEX : 0x1DE0 ~ 0x2002 (DEC : 7648 ~ 8194)
   5187             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_13) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_14))
   5188             {
   5189                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_14;
   5190             }
   5191             // STEP 15 - HEX : 0x2002 ~ 0x2224 (DEC : 8194 ~ 8740)
   5192             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_14) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_15))
   5193             {
   5194                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_15;
   5195             }
   5196             // STEP 16 - HEX : 0x2224 ~ 0x2446 (DEC : 8740 ~ 9286)
   5197             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_15) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_16))
   5198             {
   5199                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_16;
   5200             }
   5201             // STEP 17 - HEX : 0x2446 ~ 0x2668 (DEC : 9286 ~ 9832)
   5202             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_16) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_17))
   5203             {
   5204                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_17;
   5205             }
   5206             // STEP 18 - HEX : 0x2668 ~ 0x288A (DEC : 9832 ~ 10378)
   5207             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_17) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_18))
   5208             {
   5209                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_18;
   5210             }
   5211             // STEP 19 - HEX : 0x288A ~ 0x2AAC (DEC : 10378 ~ 10924)
   5212             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_18) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_19))
   5213             {
   5214                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_19;
   5215             }
   5216             // STEP 20 - HEX : 0x2AAC ~ 0x2CCE (DEC : 10924 ~ 11470)
   5217             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_19) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_20))
   5218             {
   5219                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_20;
   5220             }
   5221             // STEP 21 - HEX : 0x2CCE ~ 0x2EF0 (DEC : 11470 ~ 12016)
   5222             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_20) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_21))
   5223             {
   5224                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_21;
   5225             }
   5226             // STEP 22 - HEX : 0x2EF0 ~ 0x3112 (DEC : 12016 ~ 12562)
   5227             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_21) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_22))
   5228             {
   5229                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_22;
   5230             }
   5231             // STEP 23 - HEX : 0x3112 ~ 0x3334 (DEC : 12562 ~ 13108)
   5232             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_22) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_23))
   5233             {
   5234                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_23;
   5235             }
   5236             // STEP 24 - HEX : 0x3334 ~ 0x3556 (DEC : 13108 ~ 13654)
   5237             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_23) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_24))
   5238             {
   5239                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_24;
   5240             }
   5241             // STEP 25 - HEX : 0x3556 ~ 0x3778 (DEC : 13654 ~ 14200)
   5242             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_24) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_25))
   5243             {
   5244                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_25;
   5245             }
   5246             // STEP 26 - HEX : 0x3778 ~ 0x399A (DEC : 14200 ~ 14746)
   5247             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_25) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_26))
   5248             {
   5249                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_26;
   5250             }
   5251             // STEP 27 - HEX : 0x399A ~ 0x3BBC (DEC : 14746 ~ 15292)
   5252             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_26) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_27))
   5253             {
   5254                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_27;
   5255             }
   5256             // STEP 28 - HEX : 0x3BBC ~ 0x3DDE (DEC : 15292 ~ 15838)
   5257             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_27) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_28))
   5258             {
   5259                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_28;
   5260             }
   5261             // STEP 29 - HEX : 0x3DDE ~ 0x4000 (DEC : 15838 ~ 16384)
   5262             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_28) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_29))
   5263             {
   5264                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_29;
   5265             }
   5266          }
   5267          
   5268          /*******************************************************************************
   5269          * Function Name  : Temperature_Convert_Data
   5270          :  ADC  
   5271          *******************************************************************************/
   5272          u16 Temperature_Convert_Data(u8 u_Celsius_Data)
   5273          {
   5274             u16 u_ADC_Data;
   5275          
   5276             switch (u_Celsius_Data)
   5277             {
   5278             case 0:     		//-30'
   5279                u_ADC_Data = 2875;
   5280                break;
   5281             case 1:
   5282                u_ADC_Data = 2857;
   5283                break;
   5284             case 2:
   5285                u_ADC_Data = 2838;
   5286                break;
   5287             case 3:
   5288                u_ADC_Data = 2819;
   5289                break;
   5290             case 4:
   5291                u_ADC_Data = 2799;
   5292                break;
   5293             case 5:    		//-15'
   5294                u_ADC_Data = 2779;
   5295                break;
   5296             case 6:
   5297                u_ADC_Data = 2758;
   5298                break;
   5299             case 7:
   5300                u_ADC_Data = 2737;
   5301                break;
   5302             case 8:
   5303                u_ADC_Data = 2715;
   5304                break;
   5305             case 9:
   5306                u_ADC_Data = 2693;
   5307                break;
   5308             case 10:    		//-10'
   5309                u_ADC_Data = 2670;
   5310                break;
   5311             case 11:
   5312                u_ADC_Data = 2647;
   5313                break;
   5314             case 12:
   5315                u_ADC_Data = 2623;
   5316                break;
   5317             case 13:
   5318                u_ADC_Data = 2598;
   5319                break;
   5320             case 14:
   5321                u_ADC_Data = 2574;
   5322                break;
   5323             case 15:    		//-5'
   5324                u_ADC_Data = 2548;
   5325                break;
   5326             case 16:
   5327                u_ADC_Data = 2522;
   5328                break;
   5329             case 17:
   5330                u_ADC_Data = 2496;
   5331                break;
   5332             case 18:
   5333                u_ADC_Data = 2469;
   5334                break;
   5335             case 19:
   5336                u_ADC_Data = 2442;
   5337                break;
   5338             case 20:    		//0'
   5339                u_ADC_Data = 2414;
   5340                break;
   5341             case 21:
   5342                u_ADC_Data = 2386;
   5343                break;
   5344             case 22:
   5345                u_ADC_Data = 2358;
   5346                break;
   5347             case 23:
   5348                u_ADC_Data = 2329;
   5349                break;
   5350             case 24:
   5351                u_ADC_Data = 2300;
   5352                break;
   5353             case 25:    		//5'
   5354                u_ADC_Data = 2271;
   5355                break;
   5356             case 26:
   5357                u_ADC_Data = 2241;
   5358                break;
   5359             case 27:
   5360                u_ADC_Data = 2211;
   5361                break;
   5362             case 28:
   5363                u_ADC_Data = 2181;
   5364                break;
   5365             case 29:
   5366                u_ADC_Data = 2150;
   5367                break;
   5368             case 30:    		//10'
   5369                u_ADC_Data = 2119;
   5370                break;
   5371             case 31:
   5372                u_ADC_Data = 2088;
   5373                break;
   5374             case 32:
   5375                u_ADC_Data = 2057;
   5376                break;
   5377             case 33:
   5378                u_ADC_Data = 2026;
   5379                break;
   5380             case 34:
   5381                u_ADC_Data = 1995;
   5382                break;
   5383             case 35:
   5384                u_ADC_Data = 1963;
   5385                break;
   5386             case 36:
   5387                u_ADC_Data = 1932;
   5388                break;
   5389             case 37:
   5390                u_ADC_Data = 1900;
   5391                break;
   5392             case 38:
   5393                u_ADC_Data = 1869;
   5394                break;
   5395             case 39:
   5396                u_ADC_Data = 1837;
   5397                break;
   5398             case 40:    		//20'
   5399                u_ADC_Data = 1806;
   5400                break;
   5401             case 41:
   5402                u_ADC_Data = 1774;
   5403                break;
   5404             case 42:
   5405                u_ADC_Data = 1743;
   5406                break;
   5407             case 43:
   5408                u_ADC_Data = 1712;
   5409                break;
   5410             case 44:
   5411                u_ADC_Data = 1680;
   5412                break;
   5413             case 45:    		//25'
   5414                u_ADC_Data = 1650;
   5415                break;
   5416             case 46:
   5417                u_ADC_Data = 1619;
   5418                break;
   5419             case 47:
   5420                u_ADC_Data = 1588;
   5421                break;
   5422             case 48:
   5423                u_ADC_Data = 1558;
   5424                break;
   5425             case 49:
   5426                u_ADC_Data = 1527;
   5427                break;
   5428             case 50:    		//30'
   5429                u_ADC_Data = 1497;
   5430                break;
   5431             case 51:
   5432                u_ADC_Data = 1468;
   5433                break;
   5434             case 52:
   5435                u_ADC_Data = 1438;
   5436                break;
   5437             case 53:
   5438                u_ADC_Data = 1409;
   5439                break;
   5440             case 54:
   5441                u_ADC_Data = 1380;
   5442                break;
   5443             case 55:
   5444                u_ADC_Data = 1352;
   5445                break;
   5446             case 56:
   5447                u_ADC_Data = 1324;
   5448                break;
   5449             case 57:
   5450                u_ADC_Data = 1296;
   5451                break;
   5452             case 58:
   5453                u_ADC_Data = 1268;
   5454                break;
   5455             case 59:
   5456                u_ADC_Data = 1241;
   5457                break;
   5458             case 60:    		// 40'
   5459                u_ADC_Data = 1214;
   5460                break;
   5461             case 61:    		// 41'
   5462                u_ADC_Data = 1188;
   5463                break;
   5464             case 62:    		// 42'
   5465                u_ADC_Data = 1162;
   5466                break;
   5467             case 63:    		// 43'
   5468                u_ADC_Data = 1136;
   5469                break;
   5470             case 64:    		// 44'
   5471                u_ADC_Data = 1111;
   5472                break;
   5473             case 65:    		// 45'
   5474                u_ADC_Data = 1087;
   5475                break;
   5476             case 66:    		// 46'
   5477                u_ADC_Data = 1062;
   5478                break;
   5479             case 67:    		// 47'
   5480                u_ADC_Data = 1038;
   5481                break;
   5482             case 68:    		// 48'
   5483                u_ADC_Data = 1015;
   5484                break;
   5485             case 69:    		// 49'
   5486                u_ADC_Data = 992;
   5487                break;
   5488             case 70:    		// 50'
   5489                u_ADC_Data = 969;
   5490                break;
   5491             }
   5492             return u_ADC_Data;
   5493          }
   5494          
   5495          /*******************************************************************************
   5496          * Function Name  : Temperature_Data_Check
   5497          *******************************************************************************/
   5498          void Temperature_Data_Check(void)
   5499          {
   5500             if (stTEMP.ENABLE)
   5501             {
   5502                stTEMP.DATA_CHECK_1ms++;
   5503                stTEMP.TOTAL_VALUE_1ms = stTEMP.TOTAL_VALUE_1ms + ((stADC.DMA1_ADC_VALUE[0] * 3300) / 4096);
   5504          
   5505                if (stTEMP.DATA_CHECK_1ms >= TEMP_CHECK_DATA_COUNT_1ms)
   5506                {
   5507                   stTEMP.DATA_CHECK_1ms = 0;
   5508          
   5509                   stTEMP.DATA_CHECK_10ms++;
   5510                   stTEMP.TOTAL_VALUE_10ms = stTEMP.TOTAL_VALUE_10ms + (stTEMP.TOTAL_VALUE_1ms / TEMP_CHECK_DATA_COUNT_1ms);
   5511                   stTEMP.TOTAL_VALUE_1ms = 0;
   5512          
   5513                   if (stTEMP.DATA_CHECK_10ms >= TEMP_CHECK_DATA_COUNT_10ms)
   5514                   {
   5515                      stTEMP.DATA_CHECK_10ms = 0;
   5516          
   5517                      stTEMP.AVERAGE_DATA = stTEMP.TOTAL_VALUE_10ms / TEMP_CHECK_DATA_COUNT_10ms;
   5518                      stTEMP.TOTAL_VALUE_10ms = 0;
   5519                   }
   5520                }
   5521             }
   5522          }
   5523          
   5524          /*******************************************************************************
   5525          * Function Name  : CDS_Data_Check
   5526          *******************************************************************************/
   5527          void CDS_Data_Check(void)
   5528          {
   5529             if (stCDS.ENABLE)
   5530             {
   5531                stCDS.DATA_CHECK_1ms++;
   5532                stCDS.TOTAL_VALUE_1ms = stCDS.TOTAL_VALUE_1ms + ((stADC.DMA1_ADC_VALUE[1] * 3300) / 4096);
   5533          
   5534                if (stCDS.DATA_CHECK_1ms >= TEMP_CHECK_DATA_COUNT_1ms)
   5535                {
   5536                   stCDS.DATA_CHECK_1ms = 0;
   5537          
   5538                   stCDS.DATA_CHECK_10ms++;
   5539                   stCDS.TOTAL_VALUE_10ms = stCDS.TOTAL_VALUE_10ms + (stCDS.TOTAL_VALUE_1ms / TEMP_CHECK_DATA_COUNT_1ms);
   5540                   stCDS.TOTAL_VALUE_1ms = 0;
   5541          
   5542                   if (stCDS.DATA_CHECK_10ms >= TEMP_CHECK_DATA_COUNT_10ms)
   5543                   {
   5544                      stCDS.DATA_CHECK_10ms = 0;
   5545          
   5546                      stCDS.AVERAGE_DATA = stCDS.TOTAL_VALUE_10ms / TEMP_CHECK_DATA_COUNT_10ms;
   5547                      stCDS.TOTAL_VALUE_10ms = 0;
   5548                   }
   5549                }
   5550             }
   5551          }
   5552          
   5553          /*******************************************************************************
   5554          * Function Name  : Temperature_Boot_Mode
   5555          *******************************************************************************/
   5556          void Temperature_Boot_Mode(void)
   5557          {
   5558             if (stTEMP.STARTING_MODE_TIMER_FLAG)
   5559             {
   5560                stTEMP.STARTING_MODE_TIMER_ms++;
   5561          
   5562                if (stTEMP.STARTING_MODE_TIMER_ms >= TEMP_BOOT_START_TIME)
   5563                {
   5564                   stTEMP.STARTING_MODE_TIMER_ms = 0;
   5565          
   5566                   stTEMP.STARTING_MODE_TIMER_FLAG = 0x00;
   5567                   stTEMP.STARTING_MODE_COMPLETE = 0x01;
   5568                }
   5569             }
   5570          }
   5571          
   5572          /*******************************************************************************
   5573          * Function Name  : Zoom_Light_Auto_Control
   5574          *******************************************************************************/
   5575          void Zoom_Light_Auto_Control(void)
   5576          {
   5577             u8 u_Tx_Data1 = 0x00, u_Tx_Data2 = 0x00, u_Tx_Data3 = 0x00, u_Tx_Data4 = 0x00;
   5578             u16 u_Convert_Data = 0x0000;
   5579          
   5580             if (stLIGHT.POSITION_STATUS != stLIGHT.POSITION_DATA)
   5581             {
   5582                u_Convert_Data = stLIGHT.POSITION_DATA;
   5583          
   5584                if (u_Convert_Data >= 1035)
   5585                   u_Convert_Data = 1035;
   5586          
   5587                u_Tx_Data1 = (u_Convert_Data / 1000) & 0xFF;
   5588                if (u_Tx_Data1 >= 9)
   5589                   u_Tx_Data1 = 9;
   5590                u_Tx_Data1 = u_Tx_Data1 + 0x30;
   5591          
   5592                u_Convert_Data = u_Convert_Data % 1000;
   5593                u_Tx_Data2 = (u_Convert_Data / 100) & 0xFF;
   5594                u_Tx_Data2 = u_Tx_Data2 + 0x30;
   5595          
   5596                u_Convert_Data = u_Convert_Data % 100;
   5597                u_Tx_Data3 = (u_Convert_Data / 10) & 0xFF;
   5598                u_Tx_Data3 = u_Tx_Data3 + 0x30;
   5599          
   5600                u_Tx_Data4 = (u_Convert_Data % 10) & 0xFF;
   5601                u_Tx_Data4 = u_Tx_Data4 + 0x30;
   5602          
   5603                Send_Light_Data(ZOOM_LIGHT_DIRECT, 0x2B, u_Tx_Data1, u_Tx_Data2, u_Tx_Data3, u_Tx_Data4, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   5604          
   5605                stLIGHT.POSITION_STATUS = stLIGHT.POSITION_DATA;
   5606             }
   5607          }
   5608          
   5609          /*******************************************************************************
   5610          * Function Name  : Fan_Heater_Control
   5611          *******************************************************************************/
   5612          void Fan_Heater_Control(u8 u_Mode)
   5613          {
   5614             switch (u_Mode)
   5615             {
   5616             case DISABLE_MODE:
   5617                break;
   5618          
   5619             case BOOT_MODE:
   5620          
   5621                if (stTEMP.STARTING_MODE_ENABLE == 0x00)
   5622                {
   5623                   Heater_ON;
   5624                   Fan_ON;
   5625          
   5626                   stTEMP.STARTING_MODE_ENABLE = 0x01;
   5627                   stTEMP.STARTING_MODE_TIMER_FLAG = 0x01;
   5628                }
   5629                else
   5630                {
   5631                   if (stTEMP.STARTING_MODE_COMPLETE == 0x01)
   5632                   {
   5633                      Heater_OFF;
   5634                      Fan_OFF;
   5635          
   5636                      stTEMP.STARTING_MODE_COMPLETE = 0x00;
   5637                      stTEMP.STARTING_MODE = 0x01;
   5638                      stTEMP.ENABLE = 0x01;
   5639                   }
   5640                }
   5641          
   5642                break;
   5643          
   5644             case NORMAL_MODE:
   5645          
   5646                // FAN 30   
   5647                if (stFAN.FAN_DWELL_FLAG)
   5648                {
   5649                   Fan_OFF;
   5650                   stFAN.STATUS = bOFF;
   5651          
   5652                   stFAN.FAN_DWELL_FLAG = 0x00;
   5653                   stFAN.FAN_DWELL_END_FLAG = 0x00;
   5654          
   5655                   stFAN.FAN_DWELL_TIMER_ms = 0;
   5656                   stFAN.FAN_DWELL_TIMER_s = 0;
   5657                }
   5658          
   5659                /*******************************************************************************
   5660                * FAN  
   5661                 50(969)  : FAN ON
   5662                 40(1214)  & 50(969)    : 
   5663                 40(1214)  : FAN OFF
   5664                 IR LED ON  : FAN ON
   5665                 LRF ON  : FAN ON
   5666          
   5667          
   5668                * HEATER  
   5669                 -10(1806)  : HEATER ON
   5670                 0(1497)  : HEATER OFF
   5671          
   5672                * stFAN.FAN_DWELL_FLAG = 1  FAN 30  . (  FAN ON     FLAG  .)
   5673                * stFAN.FAN_DWELL_FLAG = 0  FAN .
   5674                *******************************************************************************/
   5675          
   5676                if (stFAN.FAN_DWELL_FLAG == 0x01)
   5677                {
   5678                   //  -10(2670)  : HEATER ON
   5679                   if (stTEMP.AVERAGE_DATA >= Temperature_Convert_Data(TEMP_COMPARE_VALUE - 10))
   5680                   {
   5681                      Heater_ON;
   5682                      stHEATER.STATUS = bON;
   5683                   }
   5684          
   5685                   //  0(2414)  : HEATER OFF
   5686                   else if (stTEMP.AVERAGE_DATA < Temperature_Convert_Data(TEMP_COMPARE_VALUE + 0))
   5687                   {
   5688                      Heater_OFF;
   5689                      stHEATER.STATUS = bOFF;
   5690                   }
   5691                }
   5692                else
   5693                {
   5694                   //  50(969)  : FAN ON
   5695                   if (stTEMP.AVERAGE_DATA < Temperature_Convert_Data(TEMP_COMPARE_VALUE + 50))
   5696                   {
   5697                      Fan_ON;
   5698                      stFAN.STATUS = bON;
   5699                   }
   5700          
   5701                   //  40(1214)  & 50(969)    : 
   5702                   else if ((stTEMP.AVERAGE_DATA < Temperature_Convert_Data(TEMP_COMPARE_VALUE + 40)) && (stTEMP.AVERAGE_DATA >= Temperature_Convert_Data(TEMP_COMPARE_VALUE + 50)))
   5703                   {
   5704                      if (stFAN.STATUS == bOFF)
   5705                      {
   5706                         if ((stLIGHT.ZOOM_STATUS == LIGHT_OFF) && (stLRF.CONTINUOUS_FLAG == 0x00))
   5707                         {
   5708                            Fan_OFF;
   5709                            stFAN.STATUS = bOFF;
   5710                         }
   5711                      }
   5712                      else
   5713                      {
   5714                         Fan_ON;
   5715                         stFAN.STATUS = bON;
   5716                      }
   5717                   }
   5718          
   5719                   //  40(1214)  : FAN OFF
   5720                   else if (stTEMP.AVERAGE_DATA >= Temperature_Convert_Data(TEMP_COMPARE_VALUE + 40))
   5721                   {
   5722                      //  -10(1806)  : HEATER ON
   5723                      if (stTEMP.AVERAGE_DATA >= Temperature_Convert_Data(TEMP_COMPARE_VALUE - 10))
   5724                      {
   5725                         Heater_ON;
   5726                         stHEATER.STATUS = bON;
   5727          
   5728                         if (stFAN.STATUS == bOFF)
   5729                         {
   5730                            Fan_ON;
   5731                            stFAN.STATUS = bON;
   5732                         }
   5733                      }
   5734          
   5735                      //  0(1497)  : HEATER OFF
   5736                      else if (stTEMP.AVERAGE_DATA < Temperature_Convert_Data(TEMP_COMPARE_VALUE + 0))
   5737                      {
   5738                         Heater_OFF;
   5739                         stHEATER.STATUS = bOFF;
   5740          
   5741                         if (stFAN.STATUS == bON)
   5742                         {
   5743                            if ((stLIGHT.ZOOM_STATUS == LIGHT_OFF) && (stLRF.CONTINUOUS_FLAG == 0x00))
   5744                               stFAN.FAN_DWELL_FLAG = 0x01;
   5745                         }
   5746                      }
   5747                   }
   5748          
   5749                   break;
   5750          
   5751                default:
   5752                   break;
   5753                }
   5754             }
   5755          }
   5756          
   5757          /*******************************************************************************
   5758          * Function Name  : Auto_Day_And_Night_Control
   5759          *******************************************************************************/ 
   5760          /* TNS 3.3V Table ()
   5761          ==========================================================
   5762          Lux           7     10    15   20   25   30   40   50
   5763          ----------------------------------------------------------
   5764          ADCValue1    875   547   358  277  240  206  166  140 
   5765          ==========================================================*/
   5766          void Auto_Day_And_Night_Control(void)
   5767          {
   5768             u16 u_Data_Convert = 0;
   5769          
   5770             if (stCDS.ENABLE)
   5771             {
   5772                u_Data_Convert = stCDS.AVERAGE_DATA;
   5773          
   5774                if (stCDS.DAY_AND_NIGHT_AUTO_ENABLE)
   5775                {
   5776          
   5777                   // 
   5778                   //  Table -> 0:755, 1:775, 2:795, 3:815, 4:835, 5:855, 6:875, 7:895, 8:915, 9:935, 10:955
   5779                   // Day -> Night   : 1200 -> step 5
   5780                   // 0:1100, 1:1120, 2:1140, 3:1160, 4:1180, 5:1200, 6:1220, 7:1240, 8:1260, 9:1280, 10:1300
   5781          
   5782                   // IBDR: 3100K, 10K FULL-UP
   5783                   //                                                                                                                                  
   5784                   // LUX		     11       10       9        8        7		  6		5          4          3          2           1
   5785                   // 6 LUX  -> 0:930, 1:950, 2:970, 3:990, 4:1010, 5:1030, 6:1050, 7:1070, 8:1090, 9:1110, 10:1130
   5786                   if (u_Data_Convert > (930 + (stCDS.DAY_AND_NIGHT_LEVEL * 20)))
   5787                   {
   5788                      stCDS.NIGHT_CONVERT_CHECK_Cnt++;
   5789          
   5790                      if (stCDS.NIGHT_CONVERT_CHECK_Cnt == stCDS.OFFSET)
   5791                      {
   5792                         stCDS.NIGHT_CONVERT_CHECK_Cnt = 0;
   5793                         stCDS.DAY_AND_NIGHT_CONVERT_FLAG = 0x01;
   5794                         stCDS.DAY_AND_NIGHT_CONVERT_MODE = 0x01;
   5795                      }
   5796                   }
   5797          
   5798                   // 0:500, 1:520, 2:540, 3:560, 4:580, 5:600, 6:620, 7:640, 8:660, 9:680, 10:700
   5799                   // Night -> Day   : 900 -> step 5
   5800                   //                                                                                                                                  
   5801                   // LUX		      11       10       9         8        7	  10	     9         8        7          6           5
   5802                   // 10 LUX  -> 0:850, 1:870, 2:890, 3:910, 4:930, 5:950, 6:970, 7:990, 8:1010, 9:1030, 10:1050
   5803                   else if (u_Data_Convert < (850 + (stCDS.DAY_AND_NIGHT_LEVEL * 20)))
   5804                   {
   5805                      stCDS.DAY_CONVERT_CHECK_Cnt++;
   5806          
   5807                      if (stCDS.DAY_CONVERT_CHECK_Cnt == stCDS.OFFSET)
   5808                      {
   5809                         stCDS.DAY_CONVERT_CHECK_Cnt = 0;
   5810                         stCDS.DAY_AND_NIGHT_CONVERT_FLAG = 0x01;
   5811                         stCDS.DAY_AND_NIGHT_CONVERT_MODE = 0x00;
   5812                      }
   5813                   }
   5814          
   5815                   // 0:755, 1:775, 2:795, 3:815, 4:835, 5:855, 6:875, 7:895, 8:915, 9:935, 10:955
   5816                   if ((stCDS.NIGHT_CONVERT_CHECK_Cnt > 0) && (!(u_Data_Convert > (1100 + (stCDS.DAY_AND_NIGHT_LEVEL * 20)))))
   5817                   {
   5818                      stCDS.NIGHT_CONVERT_CHECK_Cnt = 0;
   5819                   }
   5820                   else if ((stCDS.DAY_CONVERT_CHECK_Cnt > 0) && (!(u_Data_Convert < (800 + (stCDS.DAY_AND_NIGHT_LEVEL * 20)))))
   5821                   {
   5822                      stCDS.DAY_CONVERT_CHECK_Cnt = 0;
   5823                   }
   5824                }
   5825             }
   5826          }
   5827          
   5828          /*******************************************************************************
   5829          * Function Name  : AT24C256C_EEPROM_Write
   5830          *******************************************************************************/
   5831          void AT24C256C_EEPROM_Write(u16 EepAddr, u8 EepData)
   5832          {
   5833             I2C2_Write(AT24C256_ADDR, EepAddr, EepData);
   5834          }
   5835          
   5836          /*******************************************************************************
   5837          * Function Name  : AT24C256C_EEPROM_Read
   5838          *******************************************************************************/
   5839          u8 AT24C256C_EEPROM_Read(u16 EepAddr)
   5840          {
   5841             return I2C2_Read(AT24C256_ADDR, EepAddr);
   5842          }
   5843          
   5844          /*******************************************************************************
   5845          * Function Name  : MDIN_Sprite_Initialization
   5846          *******************************************************************************/
   5847          void MDIN_Sprite_Initialization(u8 u_Layer, u8 u_OnOff)
   5848          {
   5849             u8 u_ID = 0x00;
   5850             u8 u_Rx_Data[50];
   5851          
   5852             switch (u_Layer)
   5853             {
   5854                // Layer 0 : Information
   5855             case MDIN_LAYER_INFORMATION:
   5856          
   5857                stOSD.LAYER_NUM = u_Layer;
   5858          
   5859                u_ID = u_Layer;			// ID
   5860          
   5861                u_Rx_Data[0] = 0x0C;		// X position L
   5862                u_Rx_Data[1] = 0x00;		// X position H
   5863          
   5864                u_Rx_Data[2] = 0x00;		// Y Position L
   5865                u_Rx_Data[3] = 0x00;		// Y Position H
   5866          
   5867                u_Rx_Data[4] = 0xB0;		// Width L : 12 x 100 = 1200, 0xB0
   5868                u_Rx_Data[5] = 0x04;		// Width H : 0x04
   5869          
   5870                u_Rx_Data[6] = 0xD0;		// Height L : 20 x 36 = 720, 0xD0
   5871                u_Rx_Data[7] = 0x02;		// Height H : 0x02
   5872          
   5873                Send_MDIN_Data(MDIN_SPRITE_RECT, 0x09, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   5874                               u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   5875          
   5876                u_ID = u_Layer;			// ID
   5877          
   5878                u_Rx_Data[0] = u_OnOff;	// ON
   5879                u_Rx_Data[1] = 0x00;		// RESERVED
   5880          
   5881                Send_MDIN_Data(MDIN_SPRITE, 0x03, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   5882                               u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   5883          
   5884                break;
   5885          
   5886                // Layer 1 : Information
   5887             case MDIN_LAYER_TARGET:
   5888          
   5889                stOSD.LAYER_NUM = u_Layer;
   5890          
   5891                u_ID = u_Layer;			// ID
   5892          
   5893                u_Rx_Data[0] = 0x0C;		// X position L
   5894                u_Rx_Data[1] = 0x00;		// X position H
   5895          
   5896                u_Rx_Data[2] = 0x00;		// Y Position L
   5897                u_Rx_Data[3] = 0x00;		// Y Position H
   5898          
   5899                u_Rx_Data[4] = 0xB0;		// Width L : 12 x 100 = 1200, 0xB0
   5900                u_Rx_Data[5] = 0x04;		// Width H : 0x04
   5901          
   5902                u_Rx_Data[6] = 0xBC;		// Height L : 20 x 35 = 700, 0xBC
   5903                u_Rx_Data[7] = 0x02;		// Height H : 0x02
   5904          
   5905                Send_MDIN_Data(MDIN_SPRITE_RECT, 0x09, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   5906                               u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   5907          
   5908                u_ID = u_Layer;			// ID
   5909          
   5910                u_Rx_Data[0] = u_OnOff;	// ON
   5911                u_Rx_Data[1] = 0x00;		// RESERVED
   5912          
   5913                Send_MDIN_Data(MDIN_SPRITE, 0x03, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   5914                               u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   5915          
   5916                break;
   5917          
   5918                // Layer 2 : Coordinate
   5919             case MDIN_LAYER_COORDINATE:
   5920          
   5921                stOSD.LAYER_NUM = u_Layer;
   5922          
   5923                u_ID = u_Layer;			// ID
   5924          
   5925                u_Rx_Data[0] = 0x0C;		// X position L
   5926                u_Rx_Data[1] = 0x00;		// X position H
   5927          
   5928                u_Rx_Data[2] = 0xA8;		// Y Position L
   5929                u_Rx_Data[3] = 0x02;		// Y Position H
   5930          
   5931                u_Rx_Data[4] = 0xC0;		// Width L : 12 x 16 = 192, 0xC0
   5932                u_Rx_Data[5] = 0x00;		// Width H : 0x00
   5933          
   5934                u_Rx_Data[6] = 0x14;		// HeightL : 20 x 1 = 20, 0x14
   5935                u_Rx_Data[7] = 0x00;		// HeightL : 0x00
   5936          
   5937                Send_MDIN_Data(MDIN_SPRITE_RECT, 0x09, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   5938                               u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   5939          
   5940                u_ID = u_Layer;			// ID : Main 0
   5941          
   5942                u_Rx_Data[0] = u_OnOff;	// ON
   5943                u_Rx_Data[1] = 0x00;		// RESERVED
   5944          
   5945                Send_MDIN_Data(MDIN_SPRITE, 0x03, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   5946                               u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   5947          
   5948                break;
   5949          
   5950                // Layer 7 : Center Message
   5951             case MDIN_LAYER_CENTER_MSG:
   5952          
   5953                stOSD.LAYER_NUM = u_Layer;
   5954          
   5955                u_ID = u_Layer;			// ID
   5956          
   5957                u_Rx_Data[0] = 0x0C;		// X position L
   5958                u_Rx_Data[1] = 0x00;		// X position H
   5959          
   5960                u_Rx_Data[2] = 0xC8;		// Y Position L
   5961                u_Rx_Data[3] = 0x00;		// Y Position H
   5962          
   5963                u_Rx_Data[4] = 0xB0;		// Width L : 12 x 100 = 1200, 0xB0
   5964                u_Rx_Data[5] = 0x04;		// Width H : 0x04
   5965          
   5966                u_Rx_Data[6] = 0xB4;		// HeightL : 20 x 9 = 180, 0xB4
   5967                u_Rx_Data[7] = 0x00;		// HeightL : 0x00
   5968          
   5969                Send_MDIN_Data(MDIN_SPRITE_RECT, 0x09, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   5970                               u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   5971          
   5972                u_ID = u_Layer;			// ID
   5973          
   5974                u_Rx_Data[0] = u_OnOff;	// ON
   5975                u_Rx_Data[1] = 0x00;		// RESERVED
   5976          
   5977                Send_MDIN_Data(MDIN_SPRITE, 0x03, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   5978                               u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   5979          
   5980                break;
   5981          
   5982             default:
   5983                break;
   5984             }
   5985          
   5986          
   5987          
   5988          }
   5989          
   5990          /*******************************************************************************
   5991          * Function Name  : MDIN_I550_Initialization
   5992          *******************************************************************************/
   5993          void MDIN_I550_Initialization(void)
   5994          {
   5995             u8 u_Port_Check = 0x01;
   5996          
   5997             MDIN_RESET_LOW;
   5998             Delay_ms(20);
   5999          
   6000             MDIN_RESET_HIGH;
   6001             Delay_ms(60);
   6002          
   6003             while (u_Port_Check)
   6004             {
   6005                if (MDIN_I550_INT == 0x01)
   6006                {
   6007                   u_Port_Check = 0x00;
   6008                }
   6009             }
   6010          
   6011             // DELAY TIME
   6012             Delay_ms(100);
   6013          
   6014             // MDIN SETTING
   6015             //Send_MDIN_Data(MDIN_INITIALIZATION, 0x03, 0x00, 0x00, 0x03, MDIN_COMMAND_TIMER_DELAY);
   6016             //Send_MDIN_Data(MDIN_INPUT_RESOLUTION, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, MDIN_COMMAND_TIMER_DELAY);
   6017             //Send_MDIN_Data(MDIN_OUTPUT_RESOLUTION, 0x03, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, MDIN_COMMAND_TIMER_DELAY);
   6018          
   6019             // DELAY TIME
   6020             Delay_ms(100);
   6021          
   6022             // SPRITE SETTING
   6023             //MDIN_Sprite_Initialization(MDIN_LAYER_COORDINATE, bON);
   6024             //Delay_ms(100);
   6025             MDIN_Sprite_Initialization(MDIN_LAYER_CENTER_MSG, bON);
   6026             Delay_ms(100);
   6027          
   6028          }
   6029          
   6030          /*******************************************************************************
   6031          * Function Name  : TW9900_DECODER_RESET_Low
   6032          *******************************************************************************/
   6033          void TW9900_DECODER_RESET_Low(void)
   6034          // Low:Reset
   6035          {
   6036             GPIO_ResetBits(GPIOC, GPIO_Pin_5);
   6037          }
   6038          
   6039          /*******************************************************************************
   6040          * Function Name  : TW9900_DECODER_RESET_Low
   6041          *******************************************************************************/
   6042          void TW9900_DECODER_RESET_High(void)
   6043          // High:Normal
   6044          {
   6045             GPIO_SetBits(GPIOC, GPIO_Pin_5);
   6046          }
   6047          
   6048          /*******************************************************************************
   6049          * TW9900
   6050          *******************************************************************************/
   6051          const char defTW9900Sys[2][112]	=
   6052             {
   6053                //      00    01    02    03    04    05    06    07    08    09    0A    0B    0C    0D    0E    0F	// NTSC
   6054                {
   6055                   0x00, 0x00, 0x40, 0xA0, 0x00, 0x00, 0x00, 0x02, 0x14, 0xF0, 0x11, 0xD0, 0xDC, 0x00, 0x11, 0x00,       //00
   6056                   0xFE, 0x6F, 0x31, 0x80, 0x80, 0x00, 0x00, 0x30, 0x44, 0x58, 0x0A, 0x00, 0x07, 0x7F, 0x08, 0x00,       //01
   6057                   0x50, 0x42, 0xF0, 0xD8, 0xBC, 0xB8, 0x44, 0x2A, 0x00, 0x00, 0x78, 0x44, 0x30, 0x14, 0xA5, 0xE6,       //02
   6058                   0x00, 0x00, 0x00, 0x05, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,       //03
   6059                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x40, 0x00, 0x00,       //04
   6060                   0xA0, 0x22, 0x31, 0x80, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,       //05
   6061                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x24, 0x00, 0x00, 0x13    //06
   6062                },
   6063          
   6064                //      00    01    02    03    04    05    06    07    08    09    0A    0B    0C    0D    0E    0F	// PAL
   6065                {
   6066                   0x00, 0x00, 0x40, 0xA0, 0x00, 0x00, 0x00, 0x12, 0x17, 0x20, 0x0C, 0xD0, 0xDC, 0x00, 0x11, 0x00,       //00
   6067                   0x0C, 0x67, 0x20, 0x7E, 0x7C, 0x00, 0x00, 0x30, 0x44, 0x58, 0x0A, 0x00, 0x07, 0x7F, 0x08, 0x00,       //01
   6068                   0x50, 0x42, 0xF0, 0xD8, 0xBC, 0xB8, 0x44, 0x2A, 0x00, 0x00, 0x78, 0x44, 0x30, 0x14, 0xA5, 0xE6,       //02
   6069                   0x00, 0x00, 0x00, 0x05, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,       //03
   6070                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x50, 0x00, 0x00,       //04
   6071                   0xA0, 0x22, 0x31, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,       //05
   6072                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x24, 0x00, 0x00, 0x13    //06
   6073                }
   6074             };
   6075          
   6076          const char defTW9900Thermal[2][112]	=
   6077             {
   6078                // NTSC
   6079                {
   6080                   //		  00    01    02    03    04    05    06    07    08    09    0A    0B    0C    0D    0E    0F
   6081                   0x00, 0x00, 0x40, 0xA0, 0x00, 0x00, 0x00, 0x02, 0x15, 0xF4, 0x00, 0xE0, 0xDC, 0x00, 0x11, 0x00,
   6082                   0xFE, 0x6F, 0x31, 0x80, 0x80, 0x00, 0x00, 0x30, 0x44, 0x58, 0x0A, 0x00, 0x07, 0x7F, 0x08, 0x00,
   6083                   0x50, 0x42, 0xF0, 0xD8, 0xBC, 0xB8, 0x44, 0x2A, 0x00, 0x00, 0x78, 0x44, 0x30, 0x14, 0xA5, 0xE6,
   6084                   0x00, 0x00, 0x00, 0x05, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   6085                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x40, 0x00, 0x00,
   6086                   0xA0, 0x22, 0x31, 0x80, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   6087                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x24, 0x00, 0x00, 0x13,
   6088                },
   6089          
   6090                // PAL
   6091                {
   6092                   //		  00    01    02    03    04    05    06    07    08    09    0A    0B    0C    0D    0E    0F
   6093                   0x00, 0x00, 0x40, 0xA0, 0x00, 0x00, 0x00, 0x12, 0x17, 0x20, 0x0D, 0xE0, 0xDC, 0x00, 0x11, 0x00,
   6094                   0x0C, 0x67, 0x20, 0x7E, 0x7C, 0x00, 0x00, 0x30, 0x44, 0x58, 0x0A, 0x00, 0x07, 0x7F, 0x08, 0x00,
   6095                   0x50, 0x42, 0xF0, 0xD8, 0xBC, 0xB8, 0x44, 0x2A, 0x00, 0x00, 0x78, 0x44, 0x30, 0x14, 0xA5, 0xE6,
   6096                   0x00, 0x00, 0x00, 0x05, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   6097                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x50, 0x00, 0x00,
   6098                   0xA0, 0x22, 0x31, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   6099                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x24, 0x00, 0x00, 0x13,
   6100                },
   6101             };
   6102          
   6103          /*******************************************************************************
   6104          * Function Name  : TW9900_Initial
   6105          *******************************************************************************/
   6106          void TW9900_Initial(u8 VMode)
   6107          // VMode : NTSC_MODE/PAL_MODE
   6108          {
   6109             u8 i;
   6110          
   6111             TW9900_DECODER_RESET_High();
   6112             Delay_ms(100);
   6113          
   6114             for (i = 2; i < 0x70; i++)
   6115             {
   6116                TW9900_I2C1_ByteWrite(TW9900_ADDR, BYTE_ADDR, i, defTW9900Thermal[VMode - 1][i]);
   6117             }
   6118          }
   6119          
   6120          /*******************************************************************************
   6121          * Function Name  : VIDEO_Initialization
   6122          *******************************************************************************/
   6123          void VIDEO_Initialization(u8 u_Video_Mode)
   6124          {
   6125             TW9900_DECODER_RESET_Low();
   6126             MDIN_RESET_LOW;
   6127             Delay_ms(50);
   6128          
   6129             switch (u_Video_Mode)
   6130             {
   6131             case NTSC_MODE:
   6132                TW9900_Initial(NTSC_MODE);
   6133                break;
   6134          
   6135             case PAL_MODE:
   6136                TW9900_Initial(PAL_MODE);
   6137                break;
   6138          
   6139             default:
   6140                TW9900_Initial(NTSC_MODE);
   6141                break;
   6142             }
   6143             Delay_ms(50);
   6144          
   6145             // 4. MDIN Initial
   6146             Delay_1ms(10);
   6147             MDIN_RESET_HIGH;
   6148             Delay_1ms(1000);
   6149          
   6150             //MDIN_I550_Initialization();
   6151          
   6152          }
   6153          
   6154          /*******************************************************************************
   6155          * Function Name  : Send_Request_Data
   6156          *******************************************************************************/
   6157          void Send_Request_Data(u8 u_Cmd, u8 u_Index)
   6158          {
   6159             u8 u8_Convert_Data[10];
   6160             u16 u16_Convert_Data = 0x0000;
   6161          
   6162             switch (stINFO.MODULE_TYPE)
   6163             {
   6164             case SONY_MODULE:
   6165          
   6166                switch (u_Cmd)
   6167                {
   6168                case SONY_CALL_ZOOM_POSITION:
   6169          
   6170                   u16_Convert_Data = stSONY.ZOOM_CNT;
   6171          
   6172                   u8_Convert_Data[0] = (u8)(u16_Convert_Data >> 8);
   6173                   u8_Convert_Data[1] = (u8)(u16_Convert_Data & 0xFF);
   6174          
   6175                   stUSART1.TX_BUF[0] = IP_SONY_FIRST_BYTE;
   6176                   stUSART1.TX_BUF[1] = IP_SONY_SECOND_BYTE;
   6177                   stUSART1.TX_BUF[2] = 0x05;
   6178          
   6179                   stUSART1.TX_BUF[3] = 0x01;
   6180          
   6181                   stUSART1.TX_BUF[4] = 0xB8;
   6182                   stUSART1.TX_BUF[5] = u8_Convert_Data[0];
   6183                   stUSART1.TX_BUF[6] = u8_Convert_Data[1];
   6184                   stUSART1.TX_BUF[7] = u8_Convert_Data[2];
   6185          
   6186                   stUSART1.TX_BUF[8] = 0x00;
   6187                   stUSART1.TX_BUF[8] = stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5] + stUSART1.TX_BUF[6] + stUSART1.TX_BUF[7];
   6188          
   6189                   stUSART1.TX_BUF[9] = 0xAF;
   6190          
   6191                   stUSART1.TX_CNT = 0;
   6192                   stUSART1.TX_MAX = 10;
   6193          
   6194                   USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   6195                   Delay_1ms(MAIN_COMMAND_TIMER_DELAY);
   6196          
   6197                   break;
   6198          
   6199                case SONY_CALL_FOCUS_POSITION:
   6200          
   6201                   u16_Convert_Data = stSONY.FOCUS_CNT;
   6202          
   6203                   u8_Convert_Data[0] = (u8)(u16_Convert_Data >> 8);
   6204                   u8_Convert_Data[1] = (u8)(u16_Convert_Data & 0xFF);
   6205          
   6206                   stUSART1.TX_BUF[0] = IP_SONY_FIRST_BYTE;
   6207                   stUSART1.TX_BUF[1] = IP_SONY_SECOND_BYTE;
   6208                   stUSART1.TX_BUF[2] = 0x05;
   6209          
   6210                   stUSART1.TX_BUF[3] = 0x01;
   6211          
   6212                   stUSART1.TX_BUF[4] = u_Cmd;
   6213                   stUSART1.TX_BUF[5] = u8_Convert_Data[0];
   6214                   stUSART1.TX_BUF[6] = u8_Convert_Data[1];
   6215                   stUSART1.TX_BUF[7] = u8_Convert_Data[2];
   6216          
   6217                   stUSART1.TX_BUF[8] = 0x00;
   6218                   stUSART1.TX_BUF[8] = stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5] + stUSART1.TX_BUF[6] + stUSART1.TX_BUF[7];
   6219          
   6220                   stUSART1.TX_BUF[9] = 0xAF;
   6221          
   6222                   stUSART1.TX_CNT = 0;
   6223                   stUSART1.TX_MAX = 10;
   6224          
   6225                   USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   6226                   Delay_1ms(MAIN_COMMAND_TIMER_DELAY);
   6227          
   6228                   break;
   6229                }
   6230          
   6231                break;
   6232          
   6233             case TSM_MODULE:
   6234          
   6235                switch (u_Cmd)
   6236                {
   6237                case TSM_CALL_TOTAL_ZOOM_POSITION:
   6238          
   6239                   u16_Convert_Data = stTSM.ZOOM_CNT;
   6240          
   6241                   u8_Convert_Data[0] = (u8)(u16_Convert_Data >> 8);
   6242                   u8_Convert_Data[1] = (u8)(u16_Convert_Data & 0xFF);
   6243          
   6244                   stUSART1.TX_BUF[0] = IP_TSM_FIRST_BYTE;
   6245                   stUSART1.TX_BUF[1] = IP_TSM_SECOND_BYTE;
   6246                   stUSART1.TX_BUF[2] = 0x05;
   6247          
   6248                   stUSART1.TX_BUF[3] = 0x01;
   6249          
   6250                   stUSART1.TX_BUF[4] = u_Cmd;
   6251                   stUSART1.TX_BUF[5] = u8_Convert_Data[0];
   6252                   stUSART1.TX_BUF[6] = u8_Convert_Data[1];
   6253                   stUSART1.TX_BUF[7] = u8_Convert_Data[2];
   6254          
   6255                   stUSART1.TX_BUF[8] = 0x00;
   6256                   stUSART1.TX_BUF[8] = stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5] + stUSART1.TX_BUF[6] + stUSART1.TX_BUF[7];
   6257          
   6258                   stUSART1.TX_BUF[9] = 0xBF;
   6259          
   6260                   stUSART1.TX_CNT = 0;
   6261                   stUSART1.TX_MAX = 10;
   6262          
   6263                   USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   6264                   Delay_1ms(MAIN_COMMAND_TIMER_DELAY);
   6265          
   6266                   break;
   6267          
   6268                case TSM_CALL_FOCUS_POSITION:
   6269          
   6270                   u16_Convert_Data = stTSM.FOCUS_CNT;
   6271          
   6272                   u8_Convert_Data[0] = (u8)(u16_Convert_Data >> 8);
   6273                   u8_Convert_Data[1] = (u8)(u16_Convert_Data & 0xFF);
   6274          
   6275                   stUSART1.TX_BUF[0] = IP_TSM_FIRST_BYTE;
   6276                   stUSART1.TX_BUF[1] = IP_TSM_SECOND_BYTE;
   6277                   stUSART1.TX_BUF[2] = 0x05;
   6278          
   6279                   stUSART1.TX_BUF[3] = 0x01;
   6280          
   6281                   stUSART1.TX_BUF[4] = u_Cmd;
   6282                   stUSART1.TX_BUF[5] = u8_Convert_Data[0];
   6283                   stUSART1.TX_BUF[6] = u8_Convert_Data[1];
   6284                   stUSART1.TX_BUF[7] = u8_Convert_Data[2];
   6285          
   6286                   stUSART1.TX_BUF[8] = 0x00;
   6287                   stUSART1.TX_BUF[8] = stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5] + stUSART1.TX_BUF[6] + stUSART1.TX_BUF[7];
   6288          
   6289                   stUSART1.TX_BUF[9] = 0xBF;
   6290          
   6291                   stUSART1.TX_CNT = 0;
   6292                   stUSART1.TX_MAX = 10;
   6293          
   6294                   USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   6295                   Delay_1ms(MAIN_COMMAND_TIMER_DELAY);
   6296          
   6297                   break;
   6298          
   6299                default:
   6300                   break;
   6301                }
   6302          
   6303                break;
   6304             }
   6305          
   6306          
   6307          }
   6308          
   6309          u8 Data_Test = 0;
   6310          
   6311          /*******************************************************************************
   6312          * Function Name  : Module_Auto_Sync
   6313          *******************************************************************************/
   6314          void Module_Auto_Sync(void)
   6315          {
   6316             UART4_Init(9600);
   6317             Delay_1ms(500);
   6318          
   6319             stUART4.RX_REQUEST_CMD = SONY_POWER_INQ;
   6320             Send_Sony_Data(0x00, 0x00, 0x00, 0x05, SONY_COMMAND_TIMER_DELAY);
   6321             Delay_1ms(SONY_REQUEST_TIMER_DELAY);
   6322             Delay_1ms(500);
   6323          
   6324             UART4_Init(38400);
   6325             Delay_1ms(500);
   6326          
   6327             stUART4.RX_REQUEST_CMD = TSM_CALL_MODULE_STATUS;
   6328             Send_TSM_Data(TSM_CALL_MODULE_STATUS, 0x00, 0x00, 0x00, 0x06, TSM_COMMAND_TIMER_DELAY);
   6329             Delay_1ms(TSM_REQUEST_TIMER_MAX);
   6330             Delay_1ms(500);
   6331          }
   6332          
   6333          /*******************************************************************************
   6334          * Function Name  : EEPROM_Memory_Read
   6335          *******************************************************************************/
   6336          void EEPROM_Memory_Read(void)
   6337          {
   6338             u8 u_EEP_Mark = 0x00;
   6339          
   6340             u_EEP_Mark = AT24C256C_EEPROM_Read(EEP_PROM_MARK);
   6341          
   6342             // =======================================
   6343             // Data Read
   6344             // =======================================
   6345             if (u_EEP_Mark == EEP_HEADER)
   6346             {
   6347                switch (stINFO.MODULE_TYPE)
   6348                {
   6349                case SONY_MODULE:
   6350          
   6351                   // --------------------------------------------------------------------------------------------------//
   6352                   // 1. Color Module Control Command (0xAx)																 //
   6353                   // --------------------------------------------------------------------------------------------------//
   6354          
   6355                   // 1.1.	Set Focus Mode (0x91)
   6356                   stSONY.SET_FOCUS_MODE = AT24C256C_EEPROM_Read(EEP_SET_FOCUS_MODE);
   6357          
   6358                   // 1.2.	Set Auto Focus Mode (0x93)
   6359                   stSONY.SET_AUTO_FOCUS_MODE = AT24C256C_EEPROM_Read(EEP_SET_AUTO_FOCUS_MODE);
   6360          
   6361                   // 1.3.	Manual Focus Mode (0x08)
   6362                   // 1.4.	Manual Focus Direct (0x48)
   6363                   // 1.5.	Manual Zoom Mode (0x07)
   6364                   // 1.6.	Manual Zoom Direct (0x47)
   6365          
   6366                   // 1.7.	Set BLC Mode (0x31)
   6367                   stSONY.SET_BLC_MODE = AT24C256C_EEPROM_Read(EEP_SET_BLC_MODE);
   6368          
   6369                   // 1.8.	Set White Balance Mode (0x33)
   6370                   stSONY.SET_WHITE_BALANCE_MODE = AT24C256C_EEPROM_Read(EEP_SET_WHITE_BALANCE_MODE);
   6371          
   6372                   // 1.9.	Set Defog Mode (0x37)
   6373                   stSONY.SET_DEFOG_MODE = AT24C256C_EEPROM_Read(EEP_SET_DEFOG_MODE);
   6374          
   6375                   // 1.10.	Set Shutter Speed (0x4A)
   6376                   stSONY.SET_SHUTTER_SPEED = AT24C256C_EEPROM_Read(EEP_SET_SHUTTER_SPEED);
   6377          
   6378                   // 1.11.	Set Flicker Mode (0x55)
   6379                   stSONY.SET_FLICKER_MODE = AT24C256C_EEPROM_Read(EEP_SET_FLICKER_MODE);
   6380          
   6381                   // 1.12.	Set Aperture Value (0x59)
   6382                   stSONY.SET_APERTURE_VALUE = AT24C256C_EEPROM_Read(EEP_SET_APERTURE_VALUE);
   6383          
   6384                   // 1.13.	Set Digital Zoom Mode (0x5B)
   6385                   stSONY.SET_DIGITAL_ZOOM_MODE = AT24C256C_EEPROM_Read(EEP_SET_DIGITAL_ZOOM_MODE);
   6386          
   6387                   // 1.14.	Set Day & Night Mode (0x5F)
   6388                   stSONY.SET_DAY_NIGHT_MODE = AT24C256C_EEPROM_Read(EEP_SET_DAY_NIGHT_MODE);
   6389          
   6390                   // 1.15.	Set DSS Mode (0x61)
   6391                   stSONY.SET_DSS_MODE = AT24C256C_EEPROM_Read(EEP_SET_DSS_MODE);
   6392          
   6393                   // 1.16.	Select BLC / WDR (0x85)
   6394                   stSONY.SELECT_BLC_WDR = AT24C256C_EEPROM_Read(EEP_SELECT_BLC_WDR);
   6395          
   6396                   // 1.17.	Set High Resolution (0x87)
   6397                   stSONY.SET_HIGH_RESOLUTION = AT24C256C_EEPROM_Read(EEP_SET_HIGH_RESOLUTION);
   6398          
   6399                   // 1.18.	Set Image Stabilizer (0x89)
   6400                   stSONY.SET_IMAGE_STABILIZER = AT24C256C_EEPROM_Read(EEP_SET_IMAGE_STABILIZER);
   6401          
   6402                   // 1.19.	Set Noise Reduction (0x8B)
   6403                   stSONY.SET_NOISE_REDUCTION = AT24C256C_EEPROM_Read(EEP_SET_NOISE_REDUCTION);
   6404          
   6405                   // ETC.
   6406                   stSONY.SET_NTSC_PAL_MODE = AT24C256C_EEPROM_Read(EEP_SET_NTSC_PAL_MODE);
   6407          
   6408                   stSONY.SET_MANUAL_FOCUS_DATA = (AT24C256C_EEPROM_Read(EEP_MANUAL_FOCUS_DATA) << 8);
   6409                   stSONY.SET_MANUAL_FOCUS_DATA |= AT24C256C_EEPROM_Read(EEP_MANUAL_FOCUS_DATA + 1);
   6410          
   6411                   // --------------------------------------------------------------------------------------------------//
   6412                   // 5. Option Command (0xEx)																			 //
   6413                   // --------------------------------------------------------------------------------------------------//
   6414                   // 5.2. Set Wiper (0x02)
   6415                   stWIPER2.COUNT = AT24C256C_EEPROM_Read(EEP_SET_WIPER_COUNT);
   6416                   stWIPER2.DWELL_TIME = AT24C256C_EEPROM_Read(EEP_SET_WIPER_DWELL_TIME);
   6417          
   6418                   // 5.22. Set Wiper Option (0x22)
   6419                   stWIPER2.OPTION = AT24C256C_EEPROM_Read(EEP_SET_WIPER_OPTION);
   6420                   stWIPER2.SPRITE_TIME = AT24C256C_EEPROM_Read(EEP_SET_WASHER_SPRITE_TIME);
   6421                   stWIPER2.CONTINUOUS_TIME = AT24C256C_EEPROM_Read(EEP_SET_WIPER_CONTINUOUS_TIME);
   6422          
   6423                   break;
   6424          
   6425                case TSM_MODULE:
   6426          
   6427                   // --------------------------------------------------------------------------------------------------//
   6428                   // 2. Thermal Module Control Command (0xBx)																 //
   6429                   // --------------------------------------------------------------------------------------------------//
   6430          
   6431                   // 2.1.4. Shutter Set (0x05)
   6432                   stTSM.SHUTTER_SET = AT24C256C_EEPROM_Read(EEP_SHUTTER_SET);
   6433          
   6434                   // 2.1.15. Digital Zoom Enable (0x1C)
   6435                   stTSM.DIGITAL_ZOOM_ENABLE = AT24C256C_EEPROM_Read(EEP_DIGITAL_ZOOM_ENABLE);
   6436          
   6437                   // 2.1.19. AGC Mode Set (0x26)
   6438                   stTSM.AGC_MODE_SET = AT24C256C_EEPROM_Read(EEP_AGC_MODE_SET);
   6439          
   6440                   // 2.1.20. Color Mode Set (0x27)
   6441                   stTSM.COLOR_MODE_SET = AT24C256C_EEPROM_Read(EEP_COLOR_MODE_SET);
   6442          
   6443                   // 2.1.21. Contrast/Brightness (0x28) (when, AGC OFF)
   6444                   stTSM.CONTRAST_BRIGHTNESS_ENABLE = AT24C256C_EEPROM_Read(EEP_CONTRAST_BRIGHTNESS_ENABLE);
   6445                   stTSM.CONTRAST_BRIGHTNESS_VAL = AT24C256C_EEPROM_Read(EEP_CONTRAST_BRIGHTNESS_VAL);
   6446          
   6447                   // 2.1.22. AGC Center Position Set (0x29)
   6448                   stTSM.AGC_CENTER_POSITION_SET = AT24C256C_EEPROM_Read(EEP_AGC_CENTER_POSITION_SET);
   6449          
   6450                   // 2.1.23. AGC Limit Level Set (0x2A)
   6451                   stTSM.AGC_LIMIT_LEVEL_SET = AT24C256C_EEPROM_Read(EEP_AGC_LIMIT_LEVEL_SET);
   6452          
   6453                   // 2.1.24. AGC ROI (AGC Region of Interest) Set (0x2B)
   6454                   stTSM.AGC_ROI = AT24C256C_EEPROM_Read(EEP_AGC_ROI);
   6455          
   6456                   // 2.1.25. MIDE Level Set (0x2C) (when, Sharpness OFF)
   6457                   stTSM.MIDE_LEVEL_SET = AT24C256C_EEPROM_Read(EEP_MIDE_LEVEL_SET);
   6458          
   6459                   // 2.1.26. Sharpness Level Set (0x2D) (when, MIDE OFF)
   6460                   stTSM.SHARPNESS_LEVEL_SET = AT24C256C_EEPROM_Read(EEP_SHARPNESS_LEVEL_SET);
   6461          
   6462                   // 2.1.27. Detect Mode Set (0x31)
   6463                   // 2.1.28. Area Position Set (0x32)
   6464                   // 2.1.29. Spot Position Set (0x33)
   6465                   // 2.1.30. High Alarm Temperature (0x34)
   6466                   // 2.1.31. Low Alarm Temperature (0x35)
   6467                   // 2.1.32. Select Alarm (0x36)
   6468                   // 2.1.33. Alarm Mode (0x37)
   6469                   // 2.1.34. Temperature OSD (0x38)
   6470                   // 2.1.35. Emissivity Set (0x39)
   6471                   // 2.1.36. Mirror Mode Set (0x44)
   6472                   // 2.1.37. Flip Mode Set (0x45)
   6473          
   6474                   // 2.1.39. Image Color Inverse(White/Black Hot) Set (0x47)
   6475                   stTSM.IMAGE_COLOR_INVERSE_SET = AT24C256C_EEPROM_Read(EEP_IMAGE_COLOR_INVERSE_SET);
   6476          
   6477                   break;
   6478                }
   6479             }
   6480          
   6481             // =======================================
   6482             // Data Write
   6483             // =======================================
   6484             else
   6485             {
   6486                switch (stINFO.MODULE_TYPE)
   6487                {
   6488                case SONY_MODULE:
   6489          
   6490                   // --------------------------------------------------------------------------------------------------//
   6491                   // STATUS																						 	 //
   6492                   // --------------------------------------------------------------------------------------------------//
   6493                   stSONY.SET_NTSC_PAL_MODE = NTSC_MODE;
   6494                   AT24C256C_EEPROM_Write(EEP_SET_NTSC_PAL_MODE, stSONY.SET_NTSC_PAL_MODE);
   6495          
   6496                   // --------------------------------------------------------------------------------------------------//
   6497                   // 1. Color Module Control Command (0xAx)																 //
   6498                   // --------------------------------------------------------------------------------------------------//
   6499          
   6500                   /***************************************************************************************************************************
   6501                   * 1.1.	Set Focus Mode (0x91)
   6502                      - 0x00 : Auto Focus
   6503                      - 0x01 : Manual Focus
   6504                      - 0x02 : One Push Trigger
   6505                   ****************************************************************************************************************************/
   6506                   stSONY.SET_FOCUS_MODE = 0x00;
   6507                   AT24C256C_EEPROM_Write(EEP_SET_FOCUS_MODE, stSONY.SET_FOCUS_MODE);
   6508          
   6509                   /***************************************************************************************************************************
   6510                   * 1.2.	Set Auto Focus Mode (0x93)
   6511                      - 0x00 : Normal 
   6512                      - 0x01 : Zoom Trigger
   6513                   ****************************************************************************************************************************/
   6514                   stSONY.SET_AUTO_FOCUS_MODE = 0x00;
   6515                   AT24C256C_EEPROM_Write(EEP_SET_AUTO_FOCUS_MODE, stSONY.SET_AUTO_FOCUS_MODE);
   6516          
   6517                   // 1.3.	Manual Focus Mode (0x08)
   6518                   // 1.4.	Manual Focus Direct (0x48)
   6519                   // 1.5.	Manual Zoom Mode (0x07)
   6520                   // 1.6.	Manual Zoom Direct (0x47)
   6521          
   6522                   /***************************************************************************************************************************
   6523                   * 1.7.	Set BLC Mode (0x31)
   6524                      - 0x00 : BLC/WDR OFF
   6525                      - 0x01 : BLC ON
   6526                      - 0x10 : WDR ON
   6527                      - 0x11 : BLC/WDR ON
   6528                   ****************************************************************************************************************************/
   6529                   stSONY.SET_BLC_MODE = 0x00;
   6530                   AT24C256C_EEPROM_Write(EEP_SET_BLC_MODE, stSONY.SET_BLC_MODE);
   6531          
   6532                   /***************************************************************************************************************************
   6533                   * 1.8.	Set White Balance Mode (0x33)
   6534                      - 0x00 : Auto white balance Mode (Range : 3000 to 7500K)
   6535                      - 0x01 : In door Mode
   6536                      - 0x02 : Out door Mode
   6537                      - 0x03 : Auto tracing white balance Mode (Range : 2000 to 10000K))
   6538                   ****************************************************************************************************************************/
   6539                   stSONY.SET_WHITE_BALANCE_MODE = 0x00;
   6540                   AT24C256C_EEPROM_Write(EEP_SET_WHITE_BALANCE_MODE, stSONY.SET_WHITE_BALANCE_MODE);
   6541          
   6542                   /***************************************************************************************************************************
   6543                   * 1.9.	Set Defog Mode (0x37)
   6544                      - 0x00 : Defog Off
   6545                      - 0x01 : Defog On
   6546                   ****************************************************************************************************************************/
   6547                   stSONY.SET_DEFOG_MODE = 0x00;
   6548                   AT24C256C_EEPROM_Write(EEP_SET_DEFOG_MODE, stSONY.SET_DEFOG_MODE);
   6549          
   6550                   /***************************************************************************************************************************
   6551                   * 1.10.	Set Shutter Speed (0x4A)
   6552                      - 0x00 : Shutter Speed Auto
   6553                      - 0x00~0x16 (when, DSS On)
   6554                      - 0x00, 0x07~0x16 (when, DSS Off)
   6555                   ****************************************************************************************************************************/
   6556                   stSONY.SET_SHUTTER_SPEED = 0x00;
   6557                   AT24C256C_EEPROM_Write(EEP_SET_SHUTTER_SPEED, stSONY.SET_SHUTTER_SPEED);
   6558          
   6559                   /***************************************************************************************************************************
   6560                   * 1.11.	Set Flicker Mode (0x55)
   6561                      - 0x00 : Flicker OFF
   6562                      - 0x01 : Flicker ON
   6563                   ****************************************************************************************************************************/
   6564                   stSONY.SET_FLICKER_MODE = 0x00;
   6565                   AT24C256C_EEPROM_Write(EEP_SET_FLICKER_MODE, stSONY.SET_FLICKER_MODE);
   6566          
   6567                   /***************************************************************************************************************************
   6568                   * 1.12.	Set Aperture Value (0x59)
   6569                      - 0x00~0x0F (16 Step)
   6570                   ****************************************************************************************************************************/
   6571                   stSONY.SET_APERTURE_VALUE = 0x00;
   6572                   AT24C256C_EEPROM_Write(EEP_SET_APERTURE_VALUE, stSONY.SET_APERTURE_VALUE);
   6573          
   6574                   /***************************************************************************************************************************
   6575                   * 1.13.	Set Digital Zoom Mode (0x5B)
   6576                      - 0x00 : D Zoom OFF
   6577                      - 0x01 : D Zoom ON
   6578                   ****************************************************************************************************************************/
   6579                   stSONY.SET_DIGITAL_ZOOM_MODE = 0x00;
   6580                   AT24C256C_EEPROM_Write(EEP_SET_DIGITAL_ZOOM_MODE, stSONY.SET_DIGITAL_ZOOM_MODE);
   6581          
   6582                   /***************************************************************************************************************************
   6583                   * 1.14.	Set Day & Night Mode (0x5F)
   6584                      - 0x00 : Night Mode
   6585                      - 0x01 : Day Mode 
   6586                      - 0x02 : Auto Mode
   6587                   ****************************************************************************************************************************/
   6588                   stSONY.SET_DAY_NIGHT_MODE = 0x02;
   6589                   AT24C256C_EEPROM_Write(EEP_SET_DAY_NIGHT_MODE, stSONY.SET_DAY_NIGHT_MODE);
   6590          
   6591                   /***************************************************************************************************************************
   6592                   * 1.15.	Set DSS Mode (0x61)
   6593                      - 0x00 : DSS OFF
   6594                      - 0x01 : DSS ON
   6595                   ****************************************************************************************************************************/
   6596                   stSONY.SET_DSS_MODE = 0x00;
   6597                   AT24C256C_EEPROM_Write(EEP_SET_DSS_MODE, stSONY.SET_DSS_MODE);
   6598          
   6599                   /***************************************************************************************************************************
   6600                   * 1.16.	Select BLC / WDR (0x85)
   6601                      - 0x00 : BLC Mode Select
   6602                      - 0x01 : WDR Mode Select
   6603                   ****************************************************************************************************************************/
   6604                   stSONY.SELECT_BLC_WDR = 0x00;
   6605                   AT24C256C_EEPROM_Write(EEP_SELECT_BLC_WDR, stSONY.SELECT_BLC_WDR);
   6606          
   6607                   /***************************************************************************************************************************
   6608                   * 1.17.	Set High Resolution (0x87)
   6609                      - 0x00 : HR Mode OFF
   6610                      - 0x01 : HR Mode On
   6611                   ****************************************************************************************************************************/
   6612                   stSONY.SET_HIGH_RESOLUTION = 0x00;
   6613                   AT24C256C_EEPROM_Write(EEP_SET_HIGH_RESOLUTION, stSONY.SET_HIGH_RESOLUTION);
   6614          
   6615                   /***************************************************************************************************************************
   6616                   * 1.18.	Set Image Stabilizer (0x89)
   6617                      - 0x00 : IS Mode OFF
   6618                      - 0x01 : IS Mode On
   6619                   ****************************************************************************************************************************/
   6620                   stSONY.SET_IMAGE_STABILIZER = 0x00;
   6621                   AT24C256C_EEPROM_Write(EEP_SET_IMAGE_STABILIZER, stSONY.SET_IMAGE_STABILIZER);
   6622          
   6623                   /***************************************************************************************************************************
   6624                   * 1.19.	Set Noise Reduction (0x8B)
   6625                      - 0x00 : NR OFF
   6626                      - 0x01~0x05 : NR ON [Sensitivity]
   6627                   ****************************************************************************************************************************/
   6628                   stSONY.SET_NOISE_REDUCTION = 0x00;
   6629                   AT24C256C_EEPROM_Write(EEP_SET_NOISE_REDUCTION, stSONY.SET_NOISE_REDUCTION);
   6630          
   6631                   // --------------------------------------------------------------------------------------------------//
   6632                   // 5. Option Command (0xEx)																			 //
   6633                   // --------------------------------------------------------------------------------------------------//
   6634                   // 5.2. Set Wiper (0x02)
   6635                   stWIPER2.COUNT = 0x01;
   6636                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_COUNT, stWIPER2.COUNT);
   6637          
   6638                   stWIPER2.DWELL_TIME = 0x00;
   6639                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_DWELL_TIME, stWIPER2.DWELL_TIME);
   6640          
   6641                   // 5.22. Set Wiper Option (0x22)
   6642                   stWIPER2.OPTION = WIPER_NORMAL_MODE;
   6643                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_OPTION, stWIPER2.OPTION);
   6644          
   6645                   stWIPER2.SPRITE_TIME = 0x00;
   6646                   AT24C256C_EEPROM_Write(EEP_SET_WASHER_SPRITE_TIME, stWIPER2.SPRITE_TIME);
   6647          
   6648                   stWIPER2.CONTINUOUS_TIME = 0x00;
   6649                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_CONTINUOUS_TIME, stWIPER2.CONTINUOUS_TIME);
   6650          
   6651                   break;
   6652          
   6653                case TSM_MODULE:
   6654          
   6655                   // --------------------------------------------------------------------------------------------------//
   6656                   // STATUS																							 //
   6657                   // --------------------------------------------------------------------------------------------------//
   6658                   stTSM.SET_NTSC_PAL_MODE = NTSC_MODE;
   6659                   AT24C256C_EEPROM_Write(EEP_SET_NTSC_PAL_MODE, stTSM.SET_NTSC_PAL_MODE);
   6660          
   6661                   // --------------------------------------------------------------------------------------------------//
   6662                   // 2. Thermal Module Control Command (0xBx)																 //
   6663                   // --------------------------------------------------------------------------------------------------//
   6664          
   6665                   /***************************************************************************************************************************
   6666                   * 2.1.4. Shutter Set (0x05)
   6667                      - 0x00 = Shutter Open
   6668                     		   - 0x01 = Shutter Close
   6669                   ****************************************************************************************************************************/
   6670                   stTSM.SHUTTER_SET = 0x00;
   6671                   AT24C256C_EEPROM_Write(EEP_SHUTTER_SET, stTSM.SHUTTER_SET);
   6672          
   6673                   /***************************************************************************************************************************
   6674                   * 2.1.15. Digital Zoom Enable (0x1C)
   6675                      - 0x00 = Shutter Open
   6676                     		   - 0x01 = Shutter Close
   6677                   ****************************************************************************************************************************/
   6678                   stTSM.DIGITAL_ZOOM_ENABLE = 0x00;
   6679                   AT24C256C_EEPROM_Write(EEP_DIGITAL_ZOOM_ENABLE, stTSM.DIGITAL_ZOOM_ENABLE);
   6680          
   6681                   /***************************************************************************************************************************
   6682                   * 2.1.19. AGC Mode Set (0x26)
   6683                      - 0x00 = AGC Mode OFF
   6684                      - 0x01 = AGC Mode
   6685                      - 0x02 = WAGC Mode
   6686                   ****************************************************************************************************************************/
   6687                   stTSM.AGC_MODE_SET = 0x00;
   6688                   AT24C256C_EEPROM_Write(EEP_AGC_MODE_SET, stTSM.AGC_MODE_SET);
   6689          
   6690                   /***************************************************************************************************************************
   6691                   * 2.1.20. Color Mode Set (0x27)
   6692                      - 0x00 = Gray Color Mode
   6693                      - 0x01 = Rainbow Color Mode
   6694                      - 0x02 = Iron Color Mode
   6695                      - 0x03 = Glowbow Color Mode
   6696                      - 0x04 = 2Color Mode
   6697                   ****************************************************************************************************************************/
   6698                   stTSM.COLOR_MODE_SET = 0x00;
   6699                   AT24C256C_EEPROM_Write(EEP_COLOR_MODE_SET, stTSM.COLOR_MODE_SET);
   6700          
   6701                   /***************************************************************************************************************************
   6702                   * 2.1.21. Contrast/Brightness (0x28) (when, AGC OFF)
   6703                      - 0x00:None, 0x01:Contrast, 0x02:Brightnes
   6704                      - [1..255] = GAIN Level (default : 127)
   6705                      - [1..255] = OFFSET Level (default : 127)
   6706                   ****************************************************************************************************************************/
   6707                   stTSM.CONTRAST_BRIGHTNESS_ENABLE = 0x00;
   6708                   AT24C256C_EEPROM_Write(EEP_CONTRAST_BRIGHTNESS_ENABLE, stTSM.CONTRAST_BRIGHTNESS_ENABLE);
   6709          
   6710                   stTSM.CONTRAST_BRIGHTNESS_VAL = 0x7F;
   6711                   AT24C256C_EEPROM_Write(EEP_CONTRAST_BRIGHTNESS_VAL, stTSM.CONTRAST_BRIGHTNESS_VAL);
   6712          
   6713                   /***************************************************************************************************************************
   6714                   * 2.1.22. AGC Center Position Set (0x29)
   6715                      - [25..75%] default 50%
   6716                   ****************************************************************************************************************************/
   6717                   stTSM.AGC_CENTER_POSITION_SET = 50;
   6718                   AT24C256C_EEPROM_Write(EEP_AGC_CENTER_POSITION_SET, stTSM.AGC_CENTER_POSITION_SET);
   6719          
   6720                   /***************************************************************************************************************************
   6721                   * 2.1.23. AGC Limit Level Set (0x2A)
   6722                      - [1..9] = AGC Limit Level
   6723                      - {1=X1, 2=X1.5, 3=X2, 4=X2.5, 5=X3, 6=X5, 7=X9, 8=X15, 9=X30}
   6724                   ****************************************************************************************************************************/
   6725                   stTSM.AGC_LIMIT_LEVEL_SET = 0x04;
   6726                   AT24C256C_EEPROM_Write(EEP_AGC_LIMIT_LEVEL_SET, stTSM.AGC_LIMIT_LEVEL_SET);
   6727          
   6728                   /***************************************************************************************************************************
   6729                   * 2.1.24. AGC ROI (AGC Region of Interest) Set (0x2B)
   6730                      - 0x00 : FULL
   6731                      - 0x01 : CENTER
   6732                      - 0x02 : UNDER
   6733                      - 0x03 : UPPER
   6734                      - 0x04 : LEFT
   6735                      - 0x05 : RIGHT
   6736                   ****************************************************************************************************************************/
   6737                   stTSM.AGC_ROI = 0x01;
   6738                   AT24C256C_EEPROM_Write(EEP_AGC_ROI, stTSM.AGC_ROI);
   6739          
   6740                   /***************************************************************************************************************************
   6741                   * 2.1.25. MIDE Level Set (0x2C) (when, Sharpness OFF)
   6742                      - [0..15] = {0:OFF, 1..15:MIDE Level}
   6743                   ****************************************************************************************************************************/
   6744                   stTSM.MIDE_LEVEL_SET = 0x00;
   6745                   AT24C256C_EEPROM_Write(EEP_MIDE_LEVEL_SET, stTSM.MIDE_LEVEL_SET);
   6746          
   6747                   /***************************************************************************************************************************
   6748                   * 2.1.26. Sharpness Level Set (0x2D) (when, MIDE OFF)
   6749                      - [0..10] = {0:OFF, 1..10:Sharpness Level}
   6750                   ****************************************************************************************************************************/
   6751                   stTSM.SHARPNESS_LEVEL_SET = 0x00;
   6752                   AT24C256C_EEPROM_Write(EEP_SHARPNESS_LEVEL_SET, stTSM.SHARPNESS_LEVEL_SET);
   6753          
   6754                   // 2.1.27. Detect Mode Set (0x31)
   6755                   // 2.1.28. Area Position Set (0x32)
   6756                   // 2.1.29. Spot Position Set (0x33)
   6757                   // 2.1.30. High Alarm Temperature (0x34)
   6758                   // 2.1.31. Low Alarm Temperature (0x35)
   6759                   // 2.1.32. Select Alarm (0x36)
   6760                   // 2.1.33. Alarm Mode (0x37)
   6761                   // 2.1.34. Temperature OSD (0x38)
   6762                   // 2.1.35. Emissivity Set (0x39)
   6763                   // 2.1.36. Mirror Mode Set (0x44)
   6764                   // 2.1.37. Flip Mode Set (0x45)
   6765          
   6766                   /***************************************************************************************************************************
   6767                   * 2.1.39. Image Color Inverse(White/Black Hot) Set (0x47)
   6768                      - 0x00 = Inverse Mode OFF(White Hot)
   6769                      - 0x01 = Inverse Mode ON(Black Hot)
   6770                   ****************************************************************************************************************************/
   6771                   stTSM.IMAGE_COLOR_INVERSE_SET = 0x00;
   6772                   AT24C256C_EEPROM_Write(EEP_IMAGE_COLOR_INVERSE_SET, stTSM.IMAGE_COLOR_INVERSE_SET);
   6773          
   6774                   break;
   6775                }
   6776          
   6777                AT24C256C_EEPROM_Write(EEP_PROM_MARK, EEP_HEADER);
   6778          
   6779             }
   6780          }
   6781          
   6782          /*******************************************************************************
   6783          * IBDR Main Function
   6784          *******************************************************************************/
   6785          int main(void)
   6786          {
   6787             // =======================================
   6788             // Initialization Device
   6789             // =======================================
   6790             Initial_Device();
   6791          
   6792             while (1)
   6793             {
   6794          
   6795          /* LED ON/OFF */
   6796          //	      LED_On_Red();
   6797          //	      Delay_1ms(500);
   6798          //	      LED_Off_Red();
   6799          //	      Delay_1ms(500);
   6800          //		  
   6801          //	      LED_On_Green();
   6802          //	      Delay_1ms(500);
   6803          //	      LED_Off_Green();
   6804          //	      Delay_1ms(500);
   6805          //		  
   6806          //	      LED_On_Yellow();
   6807          //	      Delay_1ms(500);
   6808          //	      LED_Off_Yellow();
   6809          //	      Delay_1ms(500);
   6810          
   6811          
   6812          /* SW + LED ON/OFF */
   6813          //	      User_SW_On_LED_Ren_On();
   6814          
   6815             }
   6816          
   6817          } //End Main
   6818          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  AT24C256C_EEPROM_Read
               8 -> I2C2_Read
       16  AT24C256C_EEPROM_Write
              16 -> I2C2_Write
        0  Auto_Day_And_Night_Control
       56  Before_USART1_Data_Parser
              56 -> GPIO_ResetBits
              56 -> GPIO_SetBits
              56 -> Reponse_Data_Send
              56 -> Send_Light_Data
              56 -> Send_Sony_Data
        8  Bypass_Data_Parser
               8 -> Delay_1ms
               8 -> USART_SendData
        0  CDS_Data_Check
        0  DATA_Request_Handing
        8  EEPROM_Memory_Read
               8 -> AT24C256C_EEPROM_Read
               8 -> AT24C256C_EEPROM_Write
        8  Fan_Heater_Control
               8 -> GPIO_ResetBits
               8 -> GPIO_SetBits
               8 -> Temperature_Convert_Data
        8  LRF_Initialization
               8 -> Send_LRF_Data
        8  MDIN_I550_Initialization
               8 -> Delay_ms
               8 -> GPIO_ReadInputDataBit
               8 -> GPIO_ResetBits
               8 -> GPIO_SetBits
               8 -> MDIN_Sprite_Initialization
      136  MDIN_Sprite_Initialization
             136 -> Send_MDIN_Data
       16  Module_Auto_Sync
              16 -> Delay_1ms
              16 -> Send_Sony_Data
              16 -> Send_TSM_Data
              16 -> UART4_Init
       56  OPTION_Data_Handing
              56 -> AT24C256C_EEPROM_Read
              56 -> AT24C256C_EEPROM_Write
              56 -> Delay_1ms
              56 -> USART_SendData
        8  OSD_Layer_Select
               8 -> MDIN_Sprite_Initialization
       64  PELCO_Data_Handing
              64 -> Send_Pelco_Data
              64 -> Send_Sony_Data
              64 -> Send_TSM_Data
       24  PTZ_Data_Handing
              24 -> Delay_1ms
              24 -> USART_SendData
       16  Reponse_Data_Send
              16 -> USART_SendData
        8  Send_Data_Clear
       16  Send_LRF_Data
              16 -> Delay_1ms
              16 -> USART_SendData
       40  Send_Light_Data
              40 -> Delay_1ms
              40 -> USART_SendData
       40  Send_MDIN_Data
              40 -> Delay_1ms
              40 -> USART_SendData
       32  Send_MDIN_String_Data
              32 -> Delay_1ms
              32 -> USART_SendData
       32  Send_Pelco_Data
              32 -> Delay_1ms
              32 -> USART_SendData
       32  Send_Request_Data
              32 -> Delay_1ms
              32 -> USART_SendData
       24  Send_Sony_Data
              24 -> Delay_1ms
              24 -> USART_SendData
       40  Send_TCM_Data
              40 -> Delay_1ms
              40 -> USART_SendData
       32  Send_TSM_Data
              32 -> Delay_1ms
              32 -> USART_SendData
       32  Send_UART4_Ack
              32 -> Delay_1ms
              32 -> USART_SendData
        8  SetSysClockTo72
               8 -> RCC_DeInit
               8 -> RCC_GetFlagStatus
               8 -> RCC_GetSYSCLKSource
               8 -> RCC_HCLKConfig
               8 -> RCC_HSEConfig
               8 -> RCC_PCLK1Config
               8 -> RCC_PCLK2Config
               8 -> RCC_PLLCmd
               8 -> RCC_PLLConfig
               8 -> RCC_SYSCLKConfig
               8 -> RCC_WaitForHSEStartUp
       48  Sony_Data_Handing
              48 -> AT24C256C_EEPROM_Write
              48 -> Send_Sony_Data
              48 -> USART1_Send_Data
      168  System_Data_Parser
             168 -> Delay_1ms
             168 -> MDIN_I550_Initialization
             168 -> Module_Auto_Sync
             168 -> OPTION_Data_Handing
             168 -> OSD_Layer_Select
             168 -> RCC_APB1PeriphClockCmd
             168 -> Send_MDIN_Data
             168 -> Send_MDIN_String_Data
             168 -> Send_TSM_Data
             168 -> Sony_Data_Handing
             168 -> TCM_Data_Handing
             168 -> TSM_Data_Handing
             168 -> UART4_Init
             168 -> USART_SendData
             168 -> VIDEO_Initialization
             168 -> WWDG_Enable
             168 -> WWDG_SetPrescaler
             168 -> WWDG_SetWindowValue
       88  TCM_Data_Handing
              88 -> Send_TCM_Data
       64  TSM_Data_Handing
              64 -> Delay_1ms
              64 -> Send_TSM_Data
              64 -> USART_SendData
        8  TW9900_DECODER_RESET_High
               8 -> GPIO_SetBits
        8  TW9900_DECODER_RESET_Low
               8 -> GPIO_ResetBits
       16  TW9900_Initial
              16 -> Delay_ms
              16 -> TW9900_DECODER_RESET_High
              16 -> TW9900_I2C1_ByteWrite
        0  Temperature_Boot_Mode
        0  Temperature_Convert_Data
        0  Temperature_Data_Check
       16  UART5_Data_Parser
              16 -> DATA_Request_Handing
              16 -> OPTION_Data_Handing
              16 -> PELCO_Data_Handing
              16 -> PTZ_Data_Handing
              16 -> Sony_Data_Handing
              16 -> TCM_Data_Handing
              16 -> TSM_Data_Handing
      168  USART1_Data_Parser
             168 -> OSD_Layer_Select
             168 -> Send_MDIN_Data
             168 -> Send_MDIN_String_Data
             168 -> Sony_Data_Handing
             168 -> TSM_Data_Handing
       40  USART1_Send_Data
              40 -> Delay_1ms
              40 -> USART_SendData
        8  VIDEO_Initialization
               8 -> Delay_1ms
               8 -> Delay_ms
               8 -> GPIO_ResetBits
               8 -> GPIO_SetBits
               8 -> TW9900_DECODER_RESET_Low
               8 -> TW9900_Initial
        0  Zoom_Data_Sync
       40  Zoom_Light_Auto_Control
              40 -> Send_Light_Data
        8  main
               8 -> Initial_Device


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable14
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
       4  ??DataTable20_7
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable23
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_2
       4  ??DataTable24_3
       4  ??DataTable24_4
       4  ??DataTable24_5
       4  ??DataTable28
       4  ??DataTable29
       4  ??DataTable29_1
       4  ??DataTable36
       4  ??DataTable36_1
       4  ??DataTable38
       4  ??DataTable38_1
       4  ??DataTable38_2
       4  ??DataTable38_3
       4  ??DataTable38_4
       4  ??DataTable38_5
       4  ??DataTable39
       4  ??DataTable39_1
       4  ??DataTable39_10
       4  ??DataTable39_2
       4  ??DataTable39_3
       4  ??DataTable39_4
       4  ??DataTable39_5
       4  ??DataTable39_6
       4  ??DataTable39_7
       4  ??DataTable39_8
       4  ??DataTable39_9
       1  ABB_255_Flag
       1  ABB_Heater_Set
       1  ACTdCount
       1  ACTnCount
       4  ADCConvertedData
       8  ADCConvertedValue
       4  ADC_Value
       1  AFMTimer
       1  AFManual
       1  AFMode
      12  AFMsg
       1  AFactFlag
       4  AFmsTimer
       1  AFocusFlag
       1  AFsTimer
      20  AGCFreezeMsg
       1  AGCGainBias
       1  AGCLevelBias
       1  AGCLimitLevel
       1  AGCMode
      12  AGCMsg
      44  AGCstatusMsg
       1  AIrisFlag
      14  AT24C256C_EEPROM_Read
      20  AT24C256C_EEPROM_Write
      16  AWBModeMsg
       1  AbsFocusFlag
       1  AdBufCnt
       4  AdCDS
       4  AdCDSBuf
       1  AdChkCnt
       4  AdDone
       4  AdDoneCnt
       4  AdFar
       4  AdFarBuf
       4  AdNear
       4  AdNearBuf
       1  AdProCnt
       1  AdjFlag
      24  AgcFMsg
      24  AgcHMsg
      24  AgcLMsg
      24  AgcMMsg
      56  AgcMsg
       1  AgcVal
       4  AlarmCount
       1  AlarmDetect
       4  AlarmDetectMsg
       1  AlarmDisplayFlag
       1  AlarmFlag
       1  AlarmInMode
       1  AlarmMode
       4  AlarmMsg
      16  AlarmSetMsg
      16  AlarmStatusMsg
      84  AllEraseMsg
      92  AllMsg
       4  AlmAct
      56  AlmActMsg
       4  AlmAuxAct
       8  AlmAuxCnt
       1  AlmBlk
       1  AlmBuf
       1  AlmEnable
       1  AlmFlag
      56  AlmInMsg
       4  AlmInput
      64  AlmMMsg
      64  AlmMsg
       1  AlmNo
      56  AlmNoMsg
       1  AlmOSD
      84  AlmOffMsg
      84  AlmOnMsg
       1  AlmRecv
       1  AlmRx
       1  AlmT
       1  AlmTemp
       1  AperVal
      56  AptMsg
      48  AreaMsg
      52  AutoDrMsg
      52  AutoDwMsg
      52  AutoEdMsg
      52  AutoFnMsg
      12  AutoFocusMsg
      68  AutoMsg
       8  AutoPanMsg
      52  AutoSpdMsg
      52  AutoStMsg
     252  Auto_Day_And_Night_Control
       1  Aux1Buf
      80  Aux1OffMsg
      80  Aux1OnMsg
       1  Aux2Buf
      80  Aux2OffMsg
      80  Aux2OnMsg
      56  AuxActMsg
       1  AuxMode
      16  AuxMsg
       8  BackBuf
      48  BaudMsg
       1  BaudRate
       1  Baud_Buffer
      44  BaudrateMsg
    1768  Before_USART1_Data_Parser
      12  BlankMsg
       1  BlcAreaBottom
       1  BlcAreaLeft
       1  BlcAreaMode
       1  BlcAreaRight
       1  BlcAreaSel
       1  BlcAreaTop
       1  BlcEn
       1  BlcEnI
       1  BlcLevel
       1  BlcMode
      20  BlcMode1Msg
      12  BlcModeMsg
      12  BlcModeSMsg
      56  BlcMsg
      60  BlcOffMsg
      60  BlcOnMsg
      56  BlcSetMsg
      20  BlcShortModeMsg
       1  BlcSubCur
       1  BlcSubEn
       1  BlcSubMenu
      24  BlcSubModeMsg
       4  BlkMsg
     102  Bypass_Data_Parser
       8  CDSMsg
       4  CDS_Average_Value
       4  CDS_Buffer_Cnt
     128  CDS_Data_Check
       4  CDS_Day_Check_Cnt
       4  CDS_Night_Check_Cnt
       4  CDS_Total_Value
       4  CDS_convertV
       1  COMMAND_CODE
      20  CRxBuf
       1  CRxReceived
       1  CRxTail
      20  CTxBuf
       1  CTxMax
       1  CTxTail
       1  CURRENT_STATUS
      24  CZoomModeMsg
      20  CZoomOffMsg
      20  CZoomOnMsg
       1  CZoomSet
       1  CamCodeRecv
      48  CamDisMsg
       1  CamID_Buffer
      64  CamIdMsg
       8  CamIdsMsg
      20  CamInitialMsg
       1  CamModuleInfo
      16  CamRxBuf
       1  CamRxCnt
      64  CamSetMsg
      72  CamTestMsg
      20  CamTxBuf
       1  CamType
       8  CamType1Msg
       8  CamType2Msg
      24  CdZoomModeMsg
      20  CdZoomOffMsg
      20  CdZoomOnMsg
       1  CdZoomSet
      36  CelsiMsg
       1  CharLeng
      24  CheckHeater1Msg
      28  CheckHeaterMsg
      36  CheckLockMsg
       1  CheckSum
      36  CheckSyncMsg
       4  CheckTempValue
      28  CheckZoomMsg
       1  Check_Byte
       1  ChkFlag
      68  ChkMsg
      20  ChkOkMsg
      20  ClrMsg
       1  CndFlag
       1  CntReplyAlm
       4  CntSetReq
      36  CodiMsg
       1  CodiRef
       1  ColBaudFlag
       1  ColdCondition
       4  ColdCondition_Check_Time
       1  ColdCondition_Timer_Flag
      16  ColdStart1Msg
      12  ColdStartMsg
       1  Cold_Module_Init_Check
       1  Cold_Start_EnableFlag
       1  ColorBaud
      16  ColorCamMsg
      20  ColorModuleMsg
      56  ColorMsg
       8  ColorTMsg
       4  ColorVal
      16  ColorbaudMsg
       1  CommAcc
       1  CommAccA
       1  CommAccB
      20  CommErrMsg
       1  CommRate
      16  ConfigMsg
      92  ContinuousTimeMsg
       1  ConvertData
       1  DATA1_CODE
       1  DATA2_CODE
       2  DATA_Request_Handing
      36  DN0Msg
      36  DN1Msg
      36  DN2Msg
      72  DNAMsg
      72  DNDMsg
      36  DNLevMsg
       1  DNLevelFlag
       1  DNLevelSet
       1  DNMode
      72  DNNAMsg
      72  DNNMsg
      20  DRSLogoDisplayMsg
       1  DRS_NtPalSet
       1  DRS_RECIVE_COMPLETE
       4  DRS_Zoom_Count
       1  DSSMode
      76  DSSValMsg
       1  DZoom
       1  DZoomCount
      56  DZoomMsg
       1  DZoomPos
       1  Data_Test
       1  DayFlag
       4  DayFlagMsg
       1  DayNightSubMenu
      84  DefaultInitMsg
      60  DefaultMsg
       1  DirectPattFlag
      56  Dis1Msg
       1  DisEn
      36  DisMsg
       8  DisOffMsg
       8  DisOnMsg
       4  DispBuf
      20  DispCode
      56  DnNMsg
       1  DnrMode
      56  DnrMsg
       1  DomeId
      56  DssMsg
      72  DssNAMsg
      72  DssOffMsg
      72  DssOnMsg
       4  DwellMs
       4  DwellSec
    1002  EEPROM_Memory_Read
       1  EXCUTE_CODE
      36  EnMsg
      12  EngErrMsg
      32  EnglishMsg
      16  EpromCheckMsg
      80  EraseMsg
      32  EraseMsgClr
       4  ErrData
      60  ErrMsg
       1  Error_Offset_Check
       1  Error_Repeat_Cnt
      24  ExitMsg
      20  External_Title_Msg
       1  FRZMode
      36  FahreMsg
       1  FailFlag
       1  FanBuf
       1  FanFlag
       8  FanOffMsg
       8  FanOnMsg
       8  FanSetMsg
       1  Fan_Dewell_End_Flag
       1  Fan_Dewell_Flag
       4  Fan_Dwell_Time_ms
       4  Fan_Dwell_Time_sec
     588  Fan_Heater_Control
       1  Fan_Heater_First_Check_Flag
       4  Fan_Heater_First_Check_Time
       1  Fan_Heater_First_On_Flag
       1  Fan_State
      84  FarMsg
      28  FastMsg
       8  FastTMsg
       1  FlagReqAlm
       1  FlagReqSts
      12  FlickerMsg
      64  FlipMsg
      80  FlipOffMsg
      80  FlipOnMsg
      40  FlipStMsg
       1  FlkEn
      56  FlkMsg
      28  FocuFarMsg
      20  FocuNearMsg
       2  FocuPos
       2  FocuPos_SCM
      76  FocusAdjMsg
       1  FocusFlag
       1  FocusMan
      12  FocusModeMsg
       1  FocusModeVal
      88  FocusSSetMsg
      20  FocusSValMsg
       1  FocusSpdVal
       4  FocusStopCount
      12  FourMsg
      40  FreezeAllMsg
      40  FreezeMsg
       1  Freeze_Data
      72  FrzNAMsg
      88  FrzOffMsg
      88  FrzOnMsg
      12  FullAEMsg
       1  GHeaterActFlag
       1  GHeaterBuf
       1  GHeaterDispFlag
       1  GHeaterInter
       1  GHeaterMode
      20  GHeaterOffMsg
       1  GHeaterOffVal
      20  GHeaterOnMsg
       1  GHeaterOnVal
       4  GInterCount
       1  GInterMCount
       1  GInterSCount
       1  GainMode
      32  GainValMsg
      32  GainValMsg1
      16  GlassHeaterMsg
       4  HeatOffMsg
       4  Heater1OnMsg
       4  Heater2OnMsg
       1  HeaterActFlag
      12  HeaterAutoMsg
       1  HeaterFlag
      12  HeaterIntervalMsg
      12  HeaterOffMsg
      12  HeaterOnMsg
      20  HeaterSetMsg
      16  HeaterStatusMsg
       1  Heater_State
      20  HexCode
      24  HighMsg
       1  HitFlag
       1  HlcLevel
       1  HlcMaskColor
      12  HlcModeSMsg
      60  HlcOffMsg
      60  HlcOnMsg
      32  HomeautoMsg
       8  HomeblankMsg
      32  HomepattMsg
      64  HomeposMsg
      32  HomeprstMsg
      32  HomescanMsg
      32  HometourMsg
       1  HrMode
      56  HrMsg
       1  ICRThreshold
       1  ICanTek
      36  IDEHighInfoMsg
      16  IDEModeMsg
       1  IDEModeVal
       1  IDEModeValFlag
      36  IDElowInfoMsg
      16  IRISMsg
       1  IR_Duty_Step
       1  IR_Set_Check
       8  IR_Set_Msg
       1  IR_Test_Mode
       1  ISMode
      56  ISMsg
       1  IdDisp
       1  IdDisp2
      44  IdDispMsg
       1  IdPosBuf
       1  InHeaterDispFlag
       1  InHeaterInter
       1  InHeaterMode
       1  InHeaterOffVal
       1  InHeaterOnVal
       1  InheaterCount_M
       1  InheaterCount_Ms
       1  InheaterCount_S
      64  Init1Msg
      48  Init21Msg
      52  Init2Msg
      56  Init31Msg
      60  Init3Msg
      52  Init41Msg
      48  Init4Msg
      72  Init51Msg
      76  Init5Msg
      60  Init61Msg
      60  Init6Msg
      84  Init71Msg
      84  Init7Msg
      72  InitMsg
       1  InitOpt
      16  InnerHeaterMsg
      20  InnerHeaterOffMsg
      20  InnerHeaterOnMsg
       1  Inner_Heater_State
       4  InterCount
       1  InterMCount
       1  InterSCount
      16  InterTimeMsg
      12  InterValOnePushMsg
       1  InverseMode
      16  InverseModeMsg
      20  InverseOffMsg
      20  InverseOnMsg
      44  IrBrtMsg
       8  IrisAutoMsg
       8  IrisCloseMsg
       1  IrisFlag
      40  IrisLevelMsg
       1  IrisMan
      24  IrisMaxLevelMsg
       1  IrisMaxVal
       1  IrisMode
       1  IrisModeSet
       1  IrisPeakVal
       1  IrisSubMenu
       1  IrisVal
     144  IrisValMsg
       1  Joy_Zoom
       1  JoystickSW
       1  KeyFlag
       1  KeyInputFlag
      42  LRF_Initialization
      64  LangMsg
       1  Language
       4  Led1BlinkTimeMs
       4  Led2BlinkTimeMs
       4  Led3BlinkTimeMs
       1  LedCurFlag
       1  LedFlag
      12  LedOffMsg
      12  LedOnMsg
       1  LedStatus
       4  LeftMsg
      52  LeftTopMsg
      36  LensMsg
       1  LensSetFlag
      12  LensSetMsg
       1  LensVal
      48  LevelMsg
       1  LimFlag
      48  LimitMsg
      24  LoadingMsg
       1  LockEn
      48  LockMsg
       1  LogoEnFlag
       1  LogoModeVal
       8  LogoMsg
      24  LowMsg
      90  MDIN_I550_Initialization
    1250  MDIN_Sprite_Initialization
       1  MODULE_SELECT
      24  MOffMsg
       1  MPVal
      20  MWbBGainMsg
      20  MWbRGainMsg
      24  MainAlmMsg
      48  MainBarMsg
      60  MainCamMsg
      16  MainCameraMsg
       1  MainCur
      60  MainDomMsg
      24  MainExtMsg
      16  MainMsg
      24  MainMsg10
      56  MainMsg2
      52  MainMsg3
      24  MainMsg9
      24  MainPatMsg
      24  MainPreMsg
      64  MainPriMsg
      32  MainScanMsg
      24  MainTitMsg
      16  MainTourMsg
      64  ManMsg
      48  MaskMsg
      28  MediMsg
       1  MenuFlag
       1  MenuKey
       1  Menu_IR_Set
      24  MiddleMsg
       1  MinusFlag
       8  MinuteMsg
       1  MirrorDisp
      56  MirrorMsg
      12  MirrorOffMsg
      12  MirrorOnMsg
       1  Mode
      48  ModeMsg
     118  Module_Auto_Sync
      28  MotorLevH
      24  MotorLevL
      28  MotorLevM
      40  MotorTrqMsg
       1  Motor_FG_Check
       4  Motor_FG_Count
       4  Motor_FG_Save_Buf
       1  Motor_FG_Temp
       4  NAMsg
      16  NCMsg
      16  NOMsg
      24  NTPALMsg
       8  NTSCMsg
       1  NT_PAL_MODE
      16  NameBuf
      20  New_Test_Msg
      56  NextMsg
       1  NightFlag
       4  NightFlagMsg
      12  NineMsg
      12  NoMsg
      36  NoTestMsg
      72  NonData
      36  NonDataClr
      36  NormalMsg
       4  NotAvailableMsg
       1  NtPalMode
       1  NtPalSetFlag
    1066  OPTION_Data_Handing
       1  OSD_Flag
     158  OSD_Layer_Select
       1  OSD_Refresh
      16  OffMsg
       1  OkFlag
       1  OnAlarm
      16  OnMsg
      12  OnePushMsg
       8  OrCode
      16  OsdCamIDMsg
      40  OsdCooMsg
      60  OsdDispMsg
      16  OsdGHeaterMsg
      16  OsdGTempMsg
      16  OsdHeaterMsg
      40  OsdIdMsg
      40  OsdPattMsg
      40  OsdPreMsg
      40  OsdScanMsg
      40  OsdSecMsg
      16  OsdStatusMsg
      40  OsdTourMsg
       8  OsdWiperMsg
       8  PALMsg
      52  PClearMsg
      60  PClrMsg
    1158  PELCO_Data_Handing
      60  PMainMsg
      60  PSaveMsg
      64  PStatusMsg
     144  PTZ_Data_Handing
       4  PanContCnt
       4  PanMsg
      72  PanTestMsg
      16  PanTiltMsg
       1  PassCode
      40  PassMsg
       1  PassWord
      60  PassWordIn1Msg
      80  PassWordIn2Msg
      48  PassWordIn3Msg
      48  PassWordIn4Msg
       4  PassWordIn5Msg
      48  PassWordIn6Msg
      48  PassWordIn7Msg
      52  PassWordIn8Msg
      60  PatClrMsg
      52  PattIdMsg
      52  PattMsg
       8  PattNMsg
      52  PattNoMsg
       1  PattRdyFlag
      52  PattTmMsg
       1  PicFlip
      56  PicFlipMsg
      16  PicFlipOffMsg
      16  PicFlipOnMsg
       1  PinFlag
       1  PreFlag
      44  PreIdMsg
       1  PreIdPosBuf
       1  PreKey
      60  PreMsg
       1  PreNoBuf
      44  PreNoMsg
       1  PreZoomCnt
       1  PrevKey
      60  PrevMsg
      72  PreviMsg
      48  PriActMsg
      28  PriMoveMsg
      48  PriNumMsg
      48  PriStrMsg
      28  PriTLMsg
      12  ProMsg
       8  ProMsg1
       8  ProMsg2
      12  ProMsg3
      16  PromMsg
      36  ProtoMsg
       1  Protocol
       1  RLFlag
       1  RLKey
       1  RS_ZOOM
       1  RUpDay
       1  RUpMonth
       1  RUpYear
      48  RangeMsg
      24  RangeNMsg
      24  RangeWMsg
      84  RdyMarkMsg
      60  ReStartMsg
      64  RecMsg
       1  Recive_Flag
       1  Recover
       1  RecoverF
      20  RecoverTimeSetMsg
       1  RefTemp
      60  RemoteRstMsg
     148  Reponse_Data_Send
      36  ReverseMsg
      52  RightBottomMsg
       4  RightMsg
       1  RlKey
      48  RstMsg
       8  RxBuf
      16  RxBuf1
      12  RxBuf_DRS
      12  RxBuf_SCM
       1  RxCnt
       1  RxCnt_DRS
       1  RxCnt_SCM
       1  RxMaxCnt
       1  RxMaxCnt_DRS
       1  RxPoint
       1  RxStt1
       1  RxStt_BD
       1  RxTemp
       1  SCM_RECIVE_COMPLETE
       8  SClrMsg
       4  SECMsg
       1  SMark
       1  SSDREn
       4  SSDRLevel
       1  SSDRrange
      48  SaveExitMsg
       1  SaveFlag
      24  SaveMsg
      24  SavingMsg
      24  ScheduleTourDwellMsg
      28  ScheduleTourSpeedMsg
      52  SecFnMsg
      52  SecIdMsg
      60  SecMsg
      52  SecNoMsg
      52  SecStMsg
       8  SecondBuf
       1  SecondCnt
      42  Send_Data_Clear
     470  Send_LRF_Data
     150  Send_Light_Data
     836  Send_MDIN_Data
     242  Send_MDIN_String_Data
     148  Send_Pelco_Data
    1004  Send_Request_Data
     400  Send_Sony_Data
     296  Send_TCM_Data
     122  Send_TSM_Data
     326  Send_UART4_Ack
       1  SetFlag
      94  SetSysClockTo72
       1  SetUpFlag
     364  ShuttNTSpdMsg
     364  ShuttPALSpdMsg
      24  ShuttSValMsg
       1  ShutterMode
      40  ShutterModeMsg
       1  ShutterSpd
     132  ShutterSpdMsg
       1  ShutterSpdVal
       1  ShutterSubMenu
      28  SlowMsg
       8  SlowTMsg
    4306  Sony_Data_Handing
       8  Speed
      52  SpeedMsg
      12  SsdrModeSMsg
      60  SsdrOffMsg
      60  SsdrOnMsg
       1  SsnrEn
      16  SsnrFMsg
      16  SsnrHMsg
      16  SsnrLMsg
      16  SsnrMMsg
      56  SsnrMsg
      64  StatusMsg
       4  SubBlcMsg
       1  SubCur
       1  SubFlag
       4  SubWdrMsg
      48  SureMsg
      64  Sys1SetMsg
      60  SysBMsg
      60  SysCMsg
      20  SysColorMsg
      60  SysFMsg
      20  SysModelMsg
      52  SysMsg
      60  SysPMsg
      60  SysRUMsg
      64  SysSetMsg
      60  SysStsMsg
      20  SysThermalMsg
      60  SysUMsg
      16  SystemStartMsg
      16  SystemStatusMsg
    2134  System_Data_Parser
      16  TAGCGainBiasMsg
      16  TAGCLevelBiasMsg
      16  TAGCLimitMsg
      56  TAGCLimitValMsg
      12  TAGCModeMsg
    3194  TCM_Data_Handing
      12  TCamType1Msg
      12  TCamType2Msg
      12  TCamType3Msg
       4  TCdsMsg
      60  TClrMsg
       4  TEMPBuf
       4  TMcount
       1  TModule
       4  TMscount
    2064  TSM_Data_Handing
       4  TScount
      14  TW9900_DECODER_RESET_High
      14  TW9900_DECODER_RESET_Low
      62  TW9900_Initial
      24  TZoomModeMsg
      20  TZoomOffMsg
      20  TZoomOnMsg
       1  TZoomSet
       1  Temp
       4  TempBlankMsg
       1  TempCheckCount
       1  TempCheckFlag
       1  TempCount
       1  TempDispFlag
       1  TempDispVal
       1  TempFlag
       1  TempMonitorting
       8  TempMsg
      12  TempRxBuf
       1  Temp_Count
       1  Temp_Count_S
       4  TemperCnt
       1  TemperFlag
      36  TemperMsg
       1  Temperature
      64  Temperature_Boot_Mode
     930  Temperature_Convert_Data
     164  Temperature_Data_Check
       8  TestData
      40  TestFailMsg
       8  TestMsg
       4  TestOkMsg
      12  TestStartMsg
       1  TestUse
       1  TherBaudFlag
       1  TherBaudSetFlag
       1  ThermalBaud
       1  ThermalBaudset
      16  ThermalCamMsg
      16  ThermalMainCamMsg
      20  ThermalbaudMsg
      16  ThermalbaudsetMsg
       8  ThreeBuf
      20  TiltInitMsg
       8  TiltMsg
       1  TiltRepeat
      72  TiltTestMsg
       4  Time0
       4  Time1ms
       1  Time1ms2
       4  Time1sec
       4  Time50ms
       4  TimeCnt
       1  TimeFlag
       1  TimeLevel
       4  TmCount
       4  Totol_Motor_FG_Count
      60  TourDwellMsg
      36  TourIdMsg
      60  TourMsg
      16  TourNMsg
      52  TourNoMsg
      52  TourPreMsg
      16  TourSetNoMsg
      24  TourSetPrstMsg
      12  TourSetStepMsg
      52  TourStepMsg
      12  TwoMsg
      20  TxBuf
      16  TxBuf1
       1  TxBufCnt1
       1  TxBufCnt_485
       1  TxBufCnt_DRS
       1  TxBufCnt_SCM
      12  TxBuf_485
      12  TxBuf_DRS
       1  TxCnt
       1  TxCnt1
       1  TxCnt_485
       1  TxCnt_DRS
       1  TxMax
       1  TxMaxRef
       1  TxMaxRef_DRS
       1  TxMaxRef_SCM
       1  TxMax_485
       1  TxMax_DRS
       1  TxMax_SCM
      72  TxTestMsg
     226  UART5_Data_Parser
      12  UDateMsg
       8  URxBuf
     776  USART1_Data_Parser
       1  USART1_RECIVE_COMPLETE
      12  USART1_RxBuf
       1  USART1_RxCnt
       1  USART1_RxMaxCnt
     214  USART1_Send_Data
      12  USART1_TempRxBuf
      12  USART3_TxBuf
       1  USART3_TxCnt
       1  UpDownFlag
       1  UpDownKey
      92  VIDEO_Initialization
       8  VerMsg
      72  VibNAMsg
      88  VibOffMsg
      88  VibOnMsg
      24  VideoGainMsg
      48  VideoModeMsg
      36  WB0Msg
      36  WB1Msg
      36  WB2Msg
      36  WB3Msg
      36  WB4Msg
       1  WBMode
      56  WBMsg
       1  WDRnoInc
      48  Wait1Msg
      40  WasherTimeMsg
      16  Washer_Fluid_Msg
       1  Washer_Fluid_Set
       1  Washer_Spray_Flag
       4  Washer_Spray_time
       4  Washer_Spray_time2
       4  Washer_Spray_time2_Delay
      12  Washer_Time_Msg
       4  Washer_Time_Set
       1  Washer_Time_Val
       1  WbBGain
       1  WbRGain
       1  WdrBlcEn
       1  WdrBlcMode
      60  WdrBlcOffMsg
      12  WdrModeSMsg
      56  WdrMsg
      60  WdrOffMsg
      60  WdrOnMsg
      16  WiperActiveMsg
       4  WiperCntMsg
      12  WiperErrorMsg
       4  WiperOnMsg
      20  WiperRepeatOffMsg
      16  WiperRepeatOn2Msg
      16  WiperRepeatOnMsg
      16  WiperSetMsg
      24  WiperSetOffMsg
      24  WiperSetOnMsg
      24  WiperStateMsg
       1  WiperSubMenu
       1  WiperTimelSet
       1  Wiper_Active_1
       4  Wiper_Active_Checktime
       1  Wiper_Active_Cnt
       1  Wiper_Active_Flag
       1  Wiper_Active_Save
       4  Wiper_Add_time
       1  Wiper_Continuous_Delay_Flag
       4  Wiper_Continuous_Delaytime
      16  Wiper_Continuous_Msg
       1  Wiper_Continuous_flag
      12  Wiper_Count_Msg
       1  Wiper_Count_Val
       1  Wiper_Direction_Flag
       1  Wiper_Dwell_Flag
       1  Wiper_Dwell_Time
       1  Wiper_Dwell_Timer_10ms
       1  Wiper_Dwell_Timer_1hour
       1  Wiper_Dwell_Timer_1minute
       1  Wiper_Dwell_Timer_1s
       1  Wiper_Error_Check
       4  Wiper_Error_Check_Time
       4  Wiper_Error_Check_Time_ms
       1  Wiper_Error_Msg
       1  Wiper_Error_Sensor_Check
       1  Wiper_Error_Sensor_Check_Before
       1  Wiper_Error_Status_Flag
       1  Wiper_Manual_Set
       1  Wiper_Origin_Chk
       1  Wiper_Origin_Reset_Chk
       4  Wiper_Repear_delay_time
       1  Wiper_Repeat2_Sensor_Check
       1  Wiper_Repeat_Active_Flag
       1  Wiper_Repeat_Active_Flag2
       4  Wiper_Repeat_Cnt
       1  Wiper_Sens_Count
       1  Wiper_Sens_High
       1  Wiper_Sens_Low
       1  Wiper_Sens_Temp
      12  Wiper_Set_Msg
       1  Wiper_Test_Mode
       4  Wiper_Timer_Chk_Val
       1  Wiper_Timer_Flag
       1  Wiper_Timer_Set
       4  Wiper_Timer_Set_Val
      12  YesMsg
       1  ZCamCodeRecv
      20  ZCamRxBuf
       1  ZCamRxCnt
       2  ZFocuPos
       1  ZOOMDATA_RECIVE_COMPLETE
       1  ZPosRetryCount
       4  ZPosWaitTime
       1  ZPreZoomCnt
      20  ZTxBuf
       1  ZTxCnt
       1  ZTxMax
       1  ZTxMaxRef
       1  ZZoomCnt
       1  ZZoomLed
       2  ZZoomPos
       1  ZZoomTCnt
       8  ZoomBothMsg
       1  ZoomChkCnt
       1  ZoomCnt
       4  ZoomData
       1  ZoomFlag
       1  ZoomInFlag
       1  ZoomLed
      16  ZoomModeMsg
       1  ZoomModeSet
      64  ZoomMsg
       8  ZoomNAMsg
       1  ZoomOutFlag
       2  ZoomPos
       1  ZoomPosCheckCount
       2  ZoomPos_SCM
       1  ZoomRef
       1  ZoomReferanceSpeed
      76  ZoomSSetMsg
      20  ZoomSValMsg
      20  ZoomSetMsg
       1  ZoomSpd
       1  ZoomSpdVal
      16  ZoomSpeedMsg
      16  ZoomStatusMsg
       4  ZoomStopCount
      52  ZoomSyncData19m
      52  ZoomSyncData35m
      52  ZoomSyncData75m
       8  ZoomSyncMsg
       1  ZoomTCnt
       4  ZoomVal
       4  ZoomVal_SCM
    1110  Zoom_Data_Sync
     180  Zoom_Light_Auto_Control
       1  Ztxsendflag
       4  convertV
       4  convertV_Buffer
       4  convertV_Buffer1
     224  defTW9900Sys
     224  defTW9900Thermal
      32  g_Po_Data
       1  inHeaterBuf
      20  inHeaterOffMsg
      20  inHeaterOnMsg
       4  intFlag
       4  inter
       8  main
       1  minusFlag
       4  msCount
       4  msIdleCnt
      12  ntpalsetMsg
      32  pSTR
       1  rxTest2
       1  rxTest3
       1  tx_watch_count
       1  txsendflag
       1  txsendflag_DRS
       1  txsendflag_SCM

 
  1 062 bytes in section .bss
    199 bytes in section .data
 18 192 bytes in section .rodata
 28 008 bytes in section .text
 
 28 008 bytes of CODE  memory
 18 192 bytes of CONST memory
  1 261 bytes of DATA  memory

Errors: none
Warnings: 15
