###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     13/Jul/2022  18:47:22 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\src\main.c        #
#    Command line =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\src\main.c -D     #
#                    USE_STDPERIPH_DRIVER -D STM32F10x_HD -D USE_FULL_ASSERT  #
#                    -lcN C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_ #
#                    M32\Debug\List\ -lb C:\Users\TTT\Desktop\zz.STDFW\00.Stu #
#                    dy\project\IAR_M32\Debug\List\ -o                        #
#                    C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_M32\D #
#                    ebug\Obj\ --no_cse --no_unroll --no_inline               #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\I #
#                    AR_M32\..\..\inc\ -I C:\Users\TTT\Desktop\zz.STDFW\00.St #
#                    udy\project\IAR_M32\..\..\Libraries\CMSIS\CM3\DeviceSupp #
#                    ort\ST\STM32F10x\ -I C:\Users\TTT\Desktop\zz.STDFW\00.St #
#                    udy\project\IAR_M32\..\..\Libraries\STM32F10x_StdPeriph_ #
#                    Driver\inc\ -I "C:\Program Files (x86)\IAR               #
#                    Systems\Embedded Workbench 6.0\arm\inc\c\" -On -I        #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_M32\D #
#                    ebug\List\main.lst                                       #
#    Object file  =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_M32\D #
#                    ebug\Obj\main.o                                          #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\TTT\Desktop\zz.STDFW\00.Study\src\main.c
      1          /*=================================================================================
      2          Project Name 		:	TPV HD Type - TILT BOARD (HD IP THERMOGRAPHY PTZ CAMERA)
      3          Author			:	phs@tbtsys.com
      4          ==================================================================================
      5          
      6          ---------------------------------------------------------------------------------
      7          CPU					: 	STM32F103RCT
      8          ---------------------------------------------------------------------------------
      9          Z:LQFP144 	(R:LQFP64, V:LQFP100)
     10          E:512KB 		(B:128KB, C:256KB, F:768KB, G:1024KB)
     11          T:LQFP		(H:UFBGA, Y:WLCSP)
     12          7:-40~105'C	(6:-40~85'C)
     13          ---------------------------------------------------------------------------------
     14          CPU Infomation 	:  ARM 32-bit Cortex-M3 CPU, 120MHz max
     15          Package			: 	LQFP144(20x20mm)
     16          ---------------------------------------------------------------------------------
     17          Clock			: 	4~26MHz Crystal oscillator
     18          	Internal 16MHz RC(factory-trimmed)
     19          	32kHz oscillator for RTC with calibration
     20          	Internal 32kHz RC with calibration
     21          ---------------------------------------------------------------------------------
     22          Program Memory		: 	1MBytes Flash Memory
     23          Data Memory			: 	128KBytes(112+16) + 4KBytes SRAM(BackUp)
     24          OTP Memory			: 	512 Bytes
     25          ---------------------------------------------------------------------------------
     26          Timer				: 10-General, 2-Advanced, 2-Basic, IWDG, WWDG
     27          RTC					: Yes
     28          I2C					: 3
     29          USART				: 4
     30          UART				: 2
     31          USB OTG FS			: Yes (full speed)
     32          USB OTG HS			: Yes (High Speed)
     33          CAN					: 2
     34          Camera Interface		: No
     35          GPIO				: 114
     36          SDIO				: Yes
     37          12-bit ADC			: 3 * 24Channel
     38          12-bit DAC			: 2
     39          Max CPU Frequency	: 120MHz
     40          Operation Volatage		: 1.8V ~ 3.6V
     41          ADC					: 3*12bit up to 24Channel
     42          DAC					: 2*12bit
     43          SPI					: 3 SPIs
     44          ---------------------------------------------------------------------------------
     45          //===============================================================================*/
     46          
     47          /* ==========================================
     48          	Clock Speed Compute
     49          // ==========================================
     50          Clock : 16Mhz 
     51          int Clock : 80Mhz
     52           
     53          Xtal=16Mhz
     54          SysFreq=80Mhz
     55          Desired Baud Rate = 2400 / 38400
     56          ----------2400----------------------------
     57          UxBRG = ((16000000/2400)/16)-1 
     58                = 415.667
     59          Calculated Baud Rate = 16000000/(16(416+1))
     60                               = 2403
     61                               = 0.1%
     62          ----------38400----------------------------                      
     63          UxBRG = ((16000000/38400)/16)-1 
     64                = 25.042
     65          Calculated Baud Rate = 16000000/(16(25+1))
     66                               = 38461.5
     67                               = 0.16%
     68          --------------------------------------------------------*/
     69          
     70          /*******************************************************************************
     71          * INCLUDE
     72          *******************************************************************************/
     73          #include "main.h"
     74          #include "Common.h"
     75          #include <stdio.h>
     76          #include "stm32f10x.h"
     77          #include "sysclk.h"
     78          #include "systickdelay.h"
     79          #include "stm32f10x_it.h"
     80          
     81          
     82          
     83          
     84          
     85          /*******************************************************************************
     86          * Function : Send_Sony_Data
     87          *******************************************************************************/
     88          void Send_Sony_Data(u8 u_Cmd, u8 u_Data1, u8 u_Data2, u8 u_Leng, u8 u_Timer)
     89          {
     90             switch (u_Leng)
     91             {
     92             case 0x05:
     93          
     94                stUART4.TX_BUF[0] = 0x81;
     95                stUART4.TX_BUF[1] = 0x09;
     96                stUART4.TX_BUF[2] = 0x04;
     97                stUART4.TX_BUF[3] = u_Cmd;
     98                stUART4.TX_BUF[4] = 0xFF;
     99          
    100                stUART4.TX_CNT = 0;
    101                stUART4.TX_MAX = u_Leng;
    102          
    103                break;
    104          
    105             case 0x06:
    106          
    107                stUART4.TX_BUF[0] = 0x81;
    108                stUART4.TX_BUF[1] = 0x01;
    109                stUART4.TX_BUF[2] = 0x04;
    110                stUART4.TX_BUF[3] = u_Cmd;
    111                stUART4.TX_BUF[4] = u_Data1;
    112                stUART4.TX_BUF[5] = 0xFF;
    113          
    114                stUART4.TX_CNT = 0;
    115                stUART4.TX_MAX = u_Leng;
    116          
    117                break;
    118          
    119             case 0x08:
    120          
    121                stUART4.TX_BUF[0] = 0x81;
    122                stUART4.TX_BUF[1] = 0x01;
    123                stUART4.TX_BUF[2] = 0x04;
    124                stUART4.TX_BUF[3] = 0x24;
    125                stUART4.TX_BUF[4] = u_Cmd;
    126                stUART4.TX_BUF[5] = u_Data1;
    127                stUART4.TX_BUF[6] = u_Data2;
    128                stUART4.TX_BUF[7] = 0xFF;
    129          
    130                stUART4.TX_CNT = 0;
    131                stUART4.TX_MAX = u_Leng;
    132          
    133                break;
    134          
    135             case 0x09:
    136          
    137                stUART4.TX_BUF[0] = 0x81;
    138                stUART4.TX_BUF[1] = 0x01;
    139                stUART4.TX_BUF[2] = 0x04;
    140                stUART4.TX_BUF[3] = u_Cmd;
    141                stUART4.TX_BUF[4] = (u_Data1 >> 4) & 0x0F;
    142                stUART4.TX_BUF[5] = u_Data1 & 0x0F;
    143                stUART4.TX_BUF[6] = (u_Data2 >> 4) & 0x0F;
    144                stUART4.TX_BUF[7] = u_Data2 & 0x0F;
    145                stUART4.TX_BUF[8] = 0xFF;
    146          
    147          
    148                stUART4.TX_CNT = 0;
    149                stUART4.TX_MAX = u_Leng;
    150          
    151             case 0xFF:
    152          
    153                stUART4.TX_CNT = 0;
    154                stUART4.TX_MAX = u_Leng;
    155          
    156                break;
    157          
    158                break;
    159          
    160             default:
    161                break;
    162             }
    163          
    164             USART_SendData(UART4, stUART4.TX_BUF[stUART4.TX_CNT++]);
    165             Delay_1ms(u_Timer);
    166          }
    167          
    168          /*******************************************************************************
    169          * Function : Send_LRF_Data
    170          *******************************************************************************/
    171          void Send_LRF_Data(u8 u_Cmd, u16 u_Timer)
    172          {
    173             switch (u_Cmd)
    174             {
    175             case LRF_INIT:
    176          
    177                //ID1
    178                stUSART2.TX_BUF[0] = 0x49;	// I
    179                stUSART2.TX_BUF[1] = 0x44;	// D
    180                stUSART2.TX_BUF[2] = 0x31;	// 1
    181                stUSART2.TX_BUF[3] = 0x0D;	// CR
    182          
    183                stUSART2.TX_CNT = 0;
    184                stUSART2.TX_MAX = 0x04;
    185          
    186                USART_SendData(USART2, stUSART2.TX_BUF[stUSART2.TX_CNT++]);
    187                Delay_1ms(u_Timer);
    188          
    189                break;
    190          
    191             case LRF_MAX_TIME:
    192          
    193                // MT 3 (500ms)
    194                stUSART2.TX_BUF[0] = 0x4D;	// M
    195                stUSART2.TX_BUF[1] = 0x54;	// T
    196                stUSART2.TX_BUF[2] = 0x20;	// SP
    197                stUSART2.TX_BUF[3] = 0x33;	// 3
    198                stUSART2.TX_BUF[4] = 0x0D;	// CR
    199          
    200                stUSART2.TX_CNT = 0;
    201                stUSART2.TX_MAX = 0x05;
    202          
    203                USART_SendData(USART2, stUSART2.TX_BUF[stUSART2.TX_CNT++]);
    204                Delay_1ms(u_Timer);
    205          
    206                break;
    207          
    208             case LRF_LIMIT:
    209          
    210                // MW 1 5000
    211                stUSART2.TX_BUF[0] = 0x4D;	// M
    212                stUSART2.TX_BUF[1] = 0x57;	// W
    213                stUSART2.TX_BUF[2] = 0x20;	// SP
    214                stUSART2.TX_BUF[3] = 0x31;	// 1
    215                stUSART2.TX_BUF[4] = 0x20;	// SP
    216                stUSART2.TX_BUF[5] = 0x35;	// 5
    217                stUSART2.TX_BUF[6] = 0x30;	// 0
    218                stUSART2.TX_BUF[7] = 0x30;	// 0
    219                stUSART2.TX_BUF[8] = 0x30;	// 0
    220                stUSART2.TX_BUF[9] = 0x0D;	// CR
    221          
    222                stUSART2.TX_CNT = 0;
    223                stUSART2.TX_MAX = 0x0A;
    224          
    225                USART_SendData(USART2, stUSART2.TX_BUF[stUSART2.TX_CNT++]);
    226                Delay_1ms(u_Timer);
    227          
    228                break;
    229          
    230             case LRF_CALL_DATA:
    231          
    232                // dm1 1
    233                stUSART2.TX_BUF[0] = 0x64;	// d
    234                stUSART2.TX_BUF[1] = 0x6D;	// m
    235                stUSART2.TX_BUF[2] = 0x31;	// 1
    236                stUSART2.TX_BUF[3] = 0x20;	// SP
    237                stUSART2.TX_BUF[4] = 0x31;	// 1
    238                stUSART2.TX_BUF[5] = 0x0D;	// CR
    239          
    240                stUSART2.TX_CNT = 0;
    241                stUSART2.TX_MAX = 0x06;
    242          
    243                USART_SendData(USART2, stUSART2.TX_BUF[stUSART2.TX_CNT++]);
    244                Delay_1ms(u_Timer);
    245          
    246                break;
    247          
    248             }
    249          }
    250          
    251          /*******************************************************************************
    252          * Function : Send_MDIN_String_Data
    253          *******************************************************************************/
    254          void Send_MDIN_String_Data(u16 u_Cmd, u8 u_Leng, u8 u_Timer)
    255          {
    256             u8 i, i_Max = 0x00;
    257             u8 u_Checksum = 0x00;
    258             u8 u_Rx_Data[50];
    259          
    260             stUSART2.TX_BUF[0] = 0xA0;
    261             stUSART2.TX_BUF[1] = 0x60;
    262             stUSART2.TX_BUF[2] = (u8)(u_Cmd & 0xFF);
    263             stUSART2.TX_BUF[3] = (u8)(u_Cmd >> 8);
    264             stUSART2.TX_BUF[4] = u_Leng - 2;
    265          
    266             i_Max = u_Leng + 3;
    267          
    268             for (i = 5; i < i_Max; i++)
    269             {
    270                stUSART2.TX_BUF[i] = stSYS.RX_BUF[0][i + 1];
    271             }
    272          
    273             for (i = 2; i < i_Max; i++)
    274             {
    275                u_Checksum += stUSART2.TX_BUF[i];
    276             }
    277          
    278             stUSART2.TX_BUF[i_Max] = 0x00;
    279             stUSART2.TX_BUF[i_Max] = (u8)(u_Checksum);
    280             stUSART2.TX_BUF[i_Max + 1] = 0x5F;
    281          
    282             stUSART2.TX_CNT = 0;
    283             stUSART2.TX_MAX = u_Leng + 0x05;
    284          
    285             USART_SendData(USART2, stUSART2.TX_BUF[stUSART2.TX_CNT++]);
    286             Delay_1ms(u_Timer);
    287          }
    288          
    289          /*******************************************************************************
    290          * Function : Send_MDIN_Data
    291          *******************************************************************************/
    292          void Send_MDIN_Data(u16 u_Cmd, u8 u_Leng, u8 u_Data1, u8 u_Data2, u8 u_Data3, u8 u_Data4, u8 u_Data5, u8 u_Data6, u8 u_Data7,
    293                              u8 u_Data8, u8 u_Data9, u8 u_Data10, u8 u_Data11, u8 u_Data12, u8 u_Data13, u8 u_Data14, u8 u_Data15, u8 u_Data16, u8 u_Data17, u8 u_Data18, u8 u_Timer)
    294          {
    295             u8 i = 0, u_Sum_Data = 0x00;
    296          
    297             switch (u_Leng)
    298             {
    299             case 0x03:
    300          
    301                stUSART2.TX_BUF[0] = 0xA0;
    302                stUSART2.TX_BUF[1] = 0x60;
    303                stUSART2.TX_BUF[2] = (u8)(u_Cmd & 0xFF);
    304                stUSART2.TX_BUF[3] = (u8)(u_Cmd >> 8);
    305                stUSART2.TX_BUF[4] = u_Leng;
    306                stUSART2.TX_BUF[5] = u_Data1;
    307                stUSART2.TX_BUF[6] = u_Data2;
    308                stUSART2.TX_BUF[7] = u_Data3;
    309                stUSART2.TX_BUF[8] = (u8)(stUSART2.TX_BUF[2] + stUSART2.TX_BUF[3] + stUSART2.TX_BUF[4] + stUSART2.TX_BUF[5] + stUSART2.TX_BUF[6] + stUSART2.TX_BUF[7]);
    310                stUSART2.TX_BUF[9] = 0x5F;
    311          
    312                stUSART2.TX_CNT = 0;
    313                stUSART2.TX_MAX = u_Leng + 0x07;
    314          
    315                USART_SendData(USART2, stUSART2.TX_BUF[stUSART2.TX_CNT++]);
    316                Delay_1ms(u_Timer);
    317          
    318                break;
    319          
    320             case 0x09:
    321          
    322                stUSART2.TX_BUF[0] = 0xA0;
    323                stUSART2.TX_BUF[1] = 0x60;
    324                stUSART2.TX_BUF[2] = (u8)(u_Cmd & 0xFF);
    325                stUSART2.TX_BUF[3] = (u8)(u_Cmd >> 8);
    326                stUSART2.TX_BUF[4] = u_Leng;
    327          
    328                stUSART2.TX_BUF[5] = u_Data1;		// ID
    329                stUSART2.TX_BUF[6] = u_Data2;		// COLUMN
    330                stUSART2.TX_BUF[7] = u_Data3;		// ROW
    331          
    332                stUSART2.TX_BUF[8] = u_Data4;
    333                stUSART2.TX_BUF[9] = u_Data5;
    334                stUSART2.TX_BUF[10] = u_Data6;
    335                stUSART2.TX_BUF[11] = u_Data7;
    336                stUSART2.TX_BUF[12] = u_Data8;
    337                stUSART2.TX_BUF[13] = u_Data9;
    338          
    339                stUSART2.TX_BUF[14] = 0x00;
    340          
    341                for (i = 2; i < 14; i++)
    342                {
    343                   u_Sum_Data = (u8)(u_Sum_Data + stUSART2.TX_BUF[i]);
    344                }
    345          
    346                stUSART2.TX_BUF[14] = u_Sum_Data;
    347          
    348                stUSART2.TX_BUF[15] = 0x5F;
    349          
    350                stUSART2.TX_CNT = 0;
    351                stUSART2.TX_MAX = u_Leng + 0x07;
    352          
    353                USART_SendData(USART2, stUSART2.TX_BUF[stUSART2.TX_CNT++]);
    354                Delay_1ms(u_Timer);
    355          
    356                break;
    357          
    358             case 0x12:
    359          
    360                stUSART2.TX_BUF[0] = 0xA0;
    361                stUSART2.TX_BUF[1] = 0x60;
    362                stUSART2.TX_BUF[2] = (u8)(u_Cmd & 0xFF);
    363                stUSART2.TX_BUF[3] = (u8)(u_Cmd >> 8);
    364                stUSART2.TX_BUF[4] = u_Leng;
    365          
    366                stUSART2.TX_BUF[5] = u_Data1;		// ID
    367                stUSART2.TX_BUF[6] = u_Data2;		// COLUMN
    368                stUSART2.TX_BUF[7] = u_Data3;		// ROW
    369          
    370                stUSART2.TX_BUF[8] = u_Data4;		// +
    371                stUSART2.TX_BUF[9] = u_Data5;		// 0
    372                stUSART2.TX_BUF[10] = u_Data6;		// 0
    373                stUSART2.TX_BUF[11] = u_Data7;		// 0
    374                stUSART2.TX_BUF[12] = u_Data8;		// .
    375                stUSART2.TX_BUF[13] = u_Data9;		// 0
    376                stUSART2.TX_BUF[14] = u_Data10;		// 0
    377                stUSART2.TX_BUF[15] = u_Data11;		// NULL
    378                stUSART2.TX_BUF[16] = u_Data12;		// -
    379                stUSART2.TX_BUF[17] = u_Data13;		// 0
    380                stUSART2.TX_BUF[18] = u_Data14;		// 0
    381                stUSART2.TX_BUF[19] = u_Data15;		// 0
    382                stUSART2.TX_BUF[20] = u_Data16;		// .
    383                stUSART2.TX_BUF[21] = u_Data17;		// 0
    384                stUSART2.TX_BUF[22] = u_Data18;		// 0
    385          
    386                stUSART2.TX_BUF[23] = 0x00;
    387          
    388                for (i = 2; i < 23; i++)
    389                {
    390                   u_Sum_Data = (u8)(u_Sum_Data + stUSART2.TX_BUF[i]);
    391                }
    392          
    393                stUSART2.TX_BUF[23] = u_Sum_Data;
    394          
    395                stUSART2.TX_BUF[24] = 0x5F;
    396          
    397                stUSART2.TX_CNT = 0;
    398                stUSART2.TX_MAX = u_Leng + 0x07;
    399          
    400                USART_SendData(USART2, stUSART2.TX_BUF[stUSART2.TX_CNT++]);
    401                Delay_1ms(u_Timer);
    402          
    403                break;
    404          
    405             default:
    406                break;
    407             }
    408          
    409          }
    410          
    411          /*******************************************************************************
    412          * Function : LRF_Initialization
    413          *******************************************************************************/
    414          void LRF_Initialization(void)
    415          {
    416             Send_LRF_Data(LRF_INIT, LRF_TRANS_DELAY);
    417             Send_LRF_Data(LRF_MAX_TIME, LRF_TRANS_DELAY);
    418             Send_LRF_Data(LRF_LIMIT, LRF_TRANS_DELAY);
    419             //Send_LRF_Data(LRF_CALL_DATA, LRF_TRANS_DELAY);
    420          
    421             stLRF.INIT_ACTIVE = 0x00;
    422          
    423             // TEST
    424             //stLRF.CONTINUOUS_FLAG = 0x01;
    425          }
    426          
    427          /*******************************************************************************
    428          * Function : Reponse_Data_Send
    429          *******************************************************************************/
    430          void Reponse_Data_Send(u8 Comm, u8 R1_data, u8 R2_data)
    431          {
    432             stUSART1.TX_BUF[0] = 0xCA;
    433             stUSART1.TX_BUF[1] = 0xAC;
    434             stUSART1.TX_BUF[2] = Comm;
    435             stUSART1.TX_BUF[3] = R1_data;
    436             stUSART1.TX_BUF[4] = R2_data;
    437             stUSART1.TX_BUF[5] = 0x00;
    438             stUSART1.TX_BUF[5] = stUSART1.TX_BUF[2] + stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4];
    439          
    440             stUSART1.TX_CNT = 0;
    441             stUSART1.TX_MAX = 6;
    442          
    443             USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
    444          }
    445          
    446          /*******************************************************************************
    447          * Function : Send_COLOR_TILT_Data
    448          *******************************************************************************/
    449          void Send_Light_Data(u8 u_Cmd, u8 u_Sign, u8 u_Data1, u8 u_Data2, u8 u_Data3, u8 u_Data4, u8 u_Leng, u8 u_Timer)
    450          {
    451             stUSART2.TX_BUF[0] = 0x24;
    452             stUSART2.TX_BUF[1] = u_Cmd;
    453             stUSART2.TX_BUF[2] = 0x31;
    454             stUSART2.TX_BUF[3] = u_Sign;
    455             stUSART2.TX_BUF[4] = u_Data1;
    456             stUSART2.TX_BUF[5] = u_Data2;
    457             stUSART2.TX_BUF[6] = u_Data3;
    458             stUSART2.TX_BUF[7] = u_Data4;
    459             stUSART2.TX_BUF[8] = 0x23;
    460          
    461             stUSART2.TX_CNT = 0;
    462             stUSART2.TX_MAX = u_Leng;
    463          
    464             USART_SendData(USART2, stUSART2.TX_BUF[stUSART2.TX_CNT++]);
    465             Delay_1ms(u_Timer);
    466          }
    467          
    468          /*******************************************************************************
    469          * Function : Send_TSM_Data
    470          *******************************************************************************/
    471          void Send_TSM_Data(u8 u_Cmd, u8 u_Data1, u8 u_Data2, u8 u_Data3, u8 u_Leng, u8 u_Timer)
    472          {
    473             stUART4.TX_BUF[0] = 0xA0;
    474             stUART4.TX_BUF[1] = u_Cmd;
    475             stUART4.TX_BUF[2] = u_Data1;
    476             stUART4.TX_BUF[3] = u_Data2;
    477             stUART4.TX_BUF[4] = u_Data3;
    478             stUART4.TX_BUF[5] = 0xAF;
    479          
    480             stUART4.TX_CNT = 0;
    481             stUART4.TX_MAX = u_Leng;
    482          
    483             USART_SendData(UART4, stUART4.TX_BUF[stUART4.TX_CNT++]);
    484             Delay_1ms(u_Timer);
    485          }
    486          
    487          /*******************************************************************************
    488          * Function : Send_TCM_Data
    489          *******************************************************************************/
    490          void Send_TCM_Data(u8 u_Cmd, u8 u_Data1, u8 u_Data2, u8 u_Data3, u8 u_Data4, u8 u_Data5, u8 u_Data6, u8 u_Data7, u8 u_Data8, u8 u_Data9, u8 u_Leng, u8 u_Timer)
    491          {
    492             switch (u_Leng)
    493             {
    494             case 0x06:
    495          
    496                stUART4.TX_BUF[0] = 0xA0;
    497                stUART4.TX_BUF[1] = u_Cmd;
    498                stUART4.TX_BUF[2] = u_Data1;
    499                stUART4.TX_BUF[3] = u_Data2;
    500                stUART4.TX_BUF[4] = u_Data3;
    501                stUART4.TX_BUF[5] = 0xAF;
    502          
    503                stUART4.TX_CNT = 0;
    504                stUART4.TX_MAX = u_Leng;
    505          
    506                break;
    507          
    508             case 0x08:
    509          
    510                stUART4.TX_BUF[0] = 0xA0;
    511                stUART4.TX_BUF[1] = u_Cmd;
    512                stUART4.TX_BUF[2] = u_Data1;
    513                stUART4.TX_BUF[3] = u_Data2;
    514                stUART4.TX_BUF[4] = u_Data3;
    515                stUART4.TX_BUF[5] = u_Data4;
    516                stUART4.TX_BUF[6] = u_Data5;
    517                stUART4.TX_BUF[7] = 0xAF;
    518          
    519                stUART4.TX_CNT = 0;
    520                stUART4.TX_MAX = u_Leng;
    521          
    522                break;
    523          
    524             case 0x0C:
    525          
    526                stUART4.TX_BUF[0] = 0xA0;
    527                stUART4.TX_BUF[1] = u_Cmd;
    528                stUART4.TX_BUF[2] = u_Data1;
    529                stUART4.TX_BUF[3] = u_Data2;
    530                stUART4.TX_BUF[4] = u_Data3;
    531                stUART4.TX_BUF[5] = u_Data4;
    532                stUART4.TX_BUF[6] = u_Data5;
    533                stUART4.TX_BUF[3] = u_Data6;
    534                stUART4.TX_BUF[4] = u_Data7;
    535                stUART4.TX_BUF[5] = u_Data8;
    536                stUART4.TX_BUF[6] = u_Data9;
    537                stUART4.TX_BUF[7] = 0xAF;
    538          
    539                stUART4.TX_CNT = 0;
    540                stUART4.TX_MAX = u_Leng;
    541          
    542                break;
    543          
    544             }
    545          
    546             USART_SendData(UART4, stUART4.TX_BUF[stUART4.TX_CNT++]);
    547             Delay_1ms(u_Timer);
    548          
    549          }
    550          
    551          /*******************************************************************************
    552          * Function : Send_USART1_Ack
    553          *******************************************************************************/
    554          void Send_UART4_Ack(u8 u_Index, u8 u_Leng, u8 u_Address, u8 u_Cmd, u8 u_Data, u8 u_timer)
    555          {
    556             u8 u_Checksum = 0x00;
    557          
    558             switch (u_Leng)
    559             {
    560             case 0x02:
    561          
    562                stUART4.TX_BUF[0] = IP_BOARD_SYNC_BYTE;
    563                stUART4.TX_BUF[1] = IP_BOARD_SYNC_AND_BYTE;
    564          
    565                stUART4.TX_BUF[2] = u_Index;
    566                stUART4.TX_BUF[3] = u_Leng;
    567                stUART4.TX_BUF[4] = u_Address;
    568                stUART4.TX_BUF[5] = u_Cmd;
    569          
    570                u_Checksum = stUART4.TX_BUF[4] + stUART4.TX_BUF[5];
    571          
    572                stUART4.TX_BUF[6] = u_Checksum;
    573          
    574                switch (u_Index)
    575                {
    576                case IP_SONY_FIRST_BYTE:
    577                   stUART4.TX_BUF[7] = 0xAF;
    578                   break;
    579          
    580                case IP_TSM_FIRST_BYTE:
    581                   stUART4.TX_BUF[7] = 0xBF;
    582                   break;
    583          
    584                case IP_OPTION_FIRST_BYTE:
    585                   stUART4.TX_BUF[7] = 0xEF;
    586                   break;
    587                }
    588          
    589                stUART4.TX_MAX = u_Leng + 6;
    590                stUART4.TX_CNT = 0x00;
    591          
    592                USART_SendData(UART4, stUART4.TX_BUF[stUART4.TX_CNT++]);
    593                Delay_1ms(u_timer);
    594          
    595                break;
    596          
    597             case 0x03:
    598          
    599                stUART4.TX_BUF[0] = IP_BOARD_SYNC_BYTE;
    600                stUART4.TX_BUF[1] = IP_BOARD_SYNC_AND_BYTE;
    601          
    602                stUART4.TX_BUF[2] = u_Index;
    603                stUART4.TX_BUF[3] = u_Leng;
    604                stUART4.TX_BUF[4] = u_Address;
    605                stUART4.TX_BUF[5] = u_Cmd;
    606                stUART4.TX_BUF[6] = u_Data;
    607          
    608                u_Checksum = stUART4.TX_BUF[4] + stUART4.TX_BUF[5];
    609          
    610                stUART4.TX_BUF[7] = u_Checksum;
    611          
    612                switch (u_Index)
    613                {
    614                case IP_SONY_FIRST_BYTE:
    615                   stUART4.TX_BUF[8] = 0xAF;
    616                   break;
    617          
    618                case IP_TSM_FIRST_BYTE:
    619                   stUART4.TX_BUF[8] = 0xBF;
    620                   break;
    621          
    622                case IP_OPTION_FIRST_BYTE:
    623                   stUART4.TX_BUF[8] = 0xEF;
    624                   break;
    625                }
    626          
    627                stUART4.TX_MAX = u_Leng + 6;
    628                stUART4.TX_CNT = 0x00;
    629          
    630                USART_SendData(UART4, stUART4.TX_BUF[stUART4.TX_CNT++]);
    631                Delay_1ms(u_timer);
    632          
    633                break;
    634             }
    635          }
    636          
    637          /*******************************************************************************
    638          * Function : Send_Pelco_Data
    639          *******************************************************************************/
    640          void Send_Pelco_Data(u8 u_Comm1, u8 u_Comm2, u8 u_Data1, u8 u_Data2, u8 u_Leng, u8 u_Timer)
    641          {
    642             stUSART1.TX_BUF[0] = 0xFF;
    643             stUSART1.TX_BUF[1] = 0x01;
    644             stUSART1.TX_BUF[2] = u_Comm1;
    645             stUSART1.TX_BUF[3] = u_Comm2;
    646             stUSART1.TX_BUF[4] = u_Data1;
    647             stUSART1.TX_BUF[5] = u_Data2;
    648             stUSART1.TX_BUF[6] = stUSART1.TX_BUF[1] + stUSART1.TX_BUF[2] + stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5];
    649          
    650             stUSART1.TX_CNT = 0;
    651             stUSART1.TX_MAX = u_Leng;
    652          
    653             USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
    654             Delay_1ms(u_Timer);
    655          }
    656          
    657          /*******************************************************************************
    658          * Function Name  : USART1_Data_Parser
    659          *******************************************************************************/
    660          void Bypass_Data_Parser(void)
    661          {
    662             u8 i = 0;
    663          
    664             /*******************************************************************************************
    665             * Data Format
    666             						BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]
    667             1) General Command		0x81		0x01		0x04		CMD			DATA1		0xFF
    668             2) Inquiry Command		0x81		0x09		0x04		CMD			0xFF
    669             3) Address Set			0x88		0x30		0x01		0xFF
    670             4) IF_Clear(Broadcast)		0x88		0x01		0x00		0x01		0xFF
    671             5) IF_Clear (For x)			0x8x		0x01		0x00		0x01		0xFF
    672             6) Command Cancel		0x8x		0x2y		0xFF
    673             *******************************************************************************************/
    674             if (stUSART1.RX_BYPASS == 0x01)
    675             {
    676                stUSART1.RX_BYPASS = 0x00;
    677          
    678                stUART5.TX_CNT = 0;
    679                stUART5.TX_MAX = stUSART1.RX_BYPASS_CNT;
    680          
    681                for (i = 0; i < stUART5.TX_MAX; i++)
    682                {
    683                   stUART5.TX_BUF[i] = stUSART1.RX_BUF[i];
    684                }
    685          
    686                USART_SendData(UART5, stUART5.TX_BUF[stUART5.TX_CNT++]);
    687                Delay_1ms(SONY_COMMAND_TIMER_DELAY);
    688             }
    689          }
    690          
    691          /*******************************************************************************
    692          * Function : Send_Data_Clear
    693          *******************************************************************************/
    694          void Send_Data_Clear(u8 u_sync, u8 u_Leng)
    695          {
    696             u8 i, i_Max = u_Leng + 5;
    697          
    698             for (i = 0; i < u_Leng; i++)
    699             {
    700                switch (u_sync)
    701                {
    702                case USART1_INDEX:
    703          
    704                   stUSART1.RX_BUF[i] = 0x00;
    705          
    706                   break;
    707                }
    708             }
    709          }
    710          
    711          /*******************************************************************************
    712          * Function : USART1_Send_Data
    713          *******************************************************************************/
    714          void USART1_Send_Data(u8 u_sync, u8 u_Comm, u8 u_Data1, u8 u_Data2, u8 u_Data3, u8 u_Leng)
    715          {
    716             u8 i, i_Max = u_Leng + 3;
    717             u8 u_Checksum = 0x00;
    718          
    719             switch (u_sync)
    720             {
    721             case IP_SONY_FIRST_BYTE:
    722          
    723                stUSART1.TX_BUF[0] = IP_SONY_FIRST_BYTE;
    724                stUSART1.TX_BUF[1] = IP_SONY_SECOND_BYTE;
    725                stUSART1.TX_BUF[u_Leng + 4] = 0xAF;
    726          
    727                break;
    728             }
    729          
    730             stUSART1.TX_BUF[2] = u_Leng;
    731             stUSART1.TX_BUF[3] = 0x01;
    732          
    733             switch (u_Leng)
    734             {
    735             case 0x05:
    736          
    737                stUSART1.TX_BUF[4] = u_Comm;
    738                stUSART1.TX_BUF[5] = u_Data1;
    739                stUSART1.TX_BUF[6] = u_Data2;
    740                stUSART1.TX_BUF[7] = u_Data3;
    741          
    742                break;
    743             }
    744          
    745             stUSART1.TX_BUF[i_Max] = 0x00;
    746          
    747             for (i = 3; i < i_Max; i++)
    748             {
    749                u_Checksum += stUSART1.TX_BUF[i];
    750             }
    751          
    752             stUSART1.TX_BUF[i_Max] = u_Checksum;
    753          
    754             stUSART1.TX_CNT = 0;
    755             stUSART1.TX_MAX = u_Leng + 5;
    756          
    757             USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
    758             Delay_1ms(MAIN_COMMAND_TIMER_DELAY);
    759          }
    760          
    761          /***************************************************************************************************************************
    762          * Function : Sony_Data_Handing
    763          * Protocol Version : 0.1 (2016.04.11)
    764          * Data Architecture :
    765          BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]		BYTE[..]		BYTE(n)[LENGTH+4]	BYTE(n+1)[LENGTH+4]
    766          0xA0		0x0A		LENGTH		ADDR		COMM		DATA		...			CS					0xAF
    767          ****************************************************************************************************************************/
    768          void Sony_Data_Handing(u8 u_Port, u8 u_Comm, u8 u_Leng)
    769          {
    770             u8 u_Cmd = 0x00, u_Data_Check = 0x00;	// Camera Command
    771             u8 u_Data[5];
    772             u16 u16_Convert_Data = 0x0000;
    773          
    774             switch (u_Port)
    775             {
    776             case SYSTEM_INDEX:
    777          
    778                u_Cmd = stSYS.RX_BUF[0][5];
    779                u_Data[0] = stSYS.RX_BUF[0][6];
    780                u_Data[1] = stSYS.RX_BUF[0][7];
    781          
    782                break;
    783          
    784             case USART1_INDEX:
    785          
    786                u_Cmd = stUSART1.RX_BUF[4];
    787                u_Data[0] = stUSART1.RX_BUF[5];
    788                u_Data[1] = stUSART1.RX_BUF[6];
    789          
    790                break;
    791          
    792             case USART5_INDEX:
    793          
    794                u_Cmd = stUART5.RX_BUF[4];
    795                u_Data[0] = stUART5.RX_BUF[5];
    796                u_Data[1] = stUART5.RX_BUF[6];
    797          
    798                break;
    799          
    800             default:
    801                break;
    802             }
    803          
    804             switch (u_Comm)
    805             {
    806                // 1.1.	Set Focus Mode (0x91)
    807             case SONY_SET_FOCUS_MODE:
    808          
    809                stSONY.SET_FOCUS_MODE = u_Data[1];
    810          
    811                AT24C256C_EEPROM_Write(EEP_SET_FOCUS_MODE, stSONY.SET_FOCUS_MODE);
    812          
    813                u_Data[0] = 0x00;
    814                u_Data[1] = 0x00;
    815          
    816                switch (stSONY.SET_FOCUS_MODE)
    817                {
    818                   // Auto Focus
    819                case 0x00:
    820          
    821                   switch (stSONY.SET_AUTO_FOCUS_MODE)
    822                   {
    823                   case 0x00:
    824          
    825                      // Normal
    826                      u_Cmd = 0x57;
    827                      u_Data[0] = 0x00;
    828          
    829                      Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    830          
    831                      u_Cmd = 0x38;
    832                      u_Data[0] = 0x02;
    833          
    834                      Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    835          
    836                      break;
    837          
    838                   case 0x01:
    839          
    840                      // Zoom Trigger
    841                      u_Cmd = 0x57;
    842                      u_Data[0] = 0x02;
    843          
    844                      Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    845          
    846                      u_Cmd = 0x38;
    847                      u_Data[0] = 0x02;
    848          
    849                      Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    850          
    851                      break;
    852          
    853                   default:
    854                      break;
    855                   }
    856          
    857                   break;
    858          
    859                   // Manual Focus
    860                case 0x01:
    861          
    862                   u_Cmd = 0x38;
    863                   u_Data[0] = 0x03;
    864          
    865                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    866          
    867                   u_Cmd = SONY_MANUAL_FOCUS_DIRECT;
    868                   u_Data[0] = (u8)(stSONY.SET_MANUAL_FOCUS_DATA >> 8);
    869                   u_Data[1] = (u8)(stSONY.SET_MANUAL_FOCUS_DATA & 0xFF);
    870          
    871                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x09, SONY_COMMAND_TIMER_DELAY);
    872          
    873                   break;
    874          
    875                   // One Push Trigger
    876                case 0x02:
    877          
    878                   u_Cmd = 0x38;
    879                   u_Data[0] = 0x03;
    880          
    881                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    882          
    883                   u_Cmd = 0x18;
    884                   u_Data[0] = 0x01;
    885          
    886                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    887          
    888                   break;
    889          
    890                default:
    891                   break;
    892                }
    893          
    894                break;
    895          
    896                // 1.2.	Set Auto Focus Mode (0x93)
    897             case SONY_SET_AUTO_FOCUS_MODE:
    898          
    899                // Command & Data Convert
    900                u_Cmd = 0x57;
    901          
    902                stSONY.SET_AUTO_FOCUS_MODE = u_Data[1];
    903          
    904                AT24C256C_EEPROM_Write(EEP_SET_AUTO_FOCUS_MODE, stSONY.SET_AUTO_FOCUS_MODE);
    905          
    906                u_Data[0] = 0x00;
    907                u_Data[1] = 0x00;
    908          
    909                switch (stSONY.SET_AUTO_FOCUS_MODE)
    910                {
    911                   // Normal
    912                case 0x00:
    913                   u_Data[0] = 0x00;
    914                   break;
    915          
    916                   // Zoom Trigger
    917                case 0x01:
    918                   u_Data[0] = 0x02;
    919                   break;
    920          
    921                default:
    922                   break;
    923                }
    924          
    925                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    926          
    927                break;
    928          
    929                // 1.3.	Manual Focus (0x08)
    930             case SONY_MANUAL_FOCUS:
    931          
    932                u_Data_Check = stSONY.SET_FOCUS_MODE;
    933          
    934                switch (u_Data_Check)
    935                {
    936                case 0x01:
    937                case 0x02:
    938                   stSONY.SET_MANUAL_FOCUS_MODE = u_Data[1];
    939                   break;
    940          
    941                default:
    942          
    943                   u_Data_Check = 0xFF;
    944          
    945                   break;
    946                }
    947          
    948                u_Data[0] = 0x00;
    949                u_Data[1] = 0x00;
    950          
    951                if (u_Data_Check == 0xFF)
    952                   break;
    953          
    954                switch (stSONY.SET_MANUAL_FOCUS_MODE)
    955                {
    956                   // Stop
    957                case 0x00:
    958          
    959                   u_Cmd = 0x08;
    960                   u_Data[0] = 0x00;
    961                   stSONY.FOCUS_STATUS = STOP;
    962          
    963                   break;
    964          
    965                   // Focus Far
    966                case 0x01:
    967          
    968                   if (stSONY.SET_FOCUS_MODE == 0x02)
    969                   {
    970                      u_Cmd = 0x38;
    971                      u_Data[0] = 0x03;
    972                      Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    973                   }
    974          
    975                   u_Cmd = 0x08;
    976                   u_Data[0] = 0x24;
    977                   stSONY.FOCUS_STATUS = ACTIVE;
    978                   stSONY.DIV_TRIGGER_NON_FOCUS = 0x01;
    979          
    980                   break;
    981          
    982                   // Focus Near
    983                case 0x02:
    984          
    985                   if (stSONY.SET_FOCUS_MODE == 0x02)
    986                   {
    987                      u_Cmd = 0x38;
    988                      u_Data[0] = 0x03;
    989                      Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    990                   }
    991          
    992                   u_Cmd = 0x08;
    993                   u_Data[0] = 0x34;
    994                   stSONY.FOCUS_STATUS = ACTIVE;
    995                   stSONY.DIV_TRIGGER_NON_FOCUS = 0x01;
    996          
    997                   break;
    998          
    999                default:
   1000                   break;
   1001                }
   1002          
   1003                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1004          
   1005                break;
   1006          
   1007                // 1.4.	Manual IRIS Mode (0x0B)
   1008             case SONY_MANUAL_IRIS:
   1009          
   1010                stSONY.SET_MANUAL_IRIS_MODE = u_Data[1];
   1011          
   1012                u_Data[0] = 0x00;
   1013                u_Data[1] = 0x00;
   1014          
   1015                switch (stSONY.SET_MANUAL_IRIS_MODE)
   1016                {
   1017                   // Stop
   1018                case 0x00:
   1019                   u_Cmd = 0x39;
   1020                   u_Data[0] = 0x03;
   1021                   stSONY.CIRIS_STATUS = STOP;
   1022                   stSONY.CIRIS_MODE_FLAG = 0x01;
   1023                   break;
   1024          
   1025                   // Iris Open
   1026                case 0x01:
   1027                   u_Cmd = 0x0B;
   1028                   u_Data[0] = 0x02;
   1029                   stSONY.CIRIS_STATUS = ACTIVE;
   1030                   stSONY.CIRIS_MODE_FLAG = 0x01;
   1031                   break;
   1032          
   1033                   // Iris Close
   1034                case 0x02:
   1035                   u_Cmd = 0x0B;
   1036                   u_Data[0] = 0x03;
   1037                   stSONY.CIRIS_STATUS = ACTIVE;
   1038                   stSONY.CIRIS_MODE_FLAG = 0x01;
   1039                   break;
   1040          
   1041                default:
   1042                   break;
   1043                }
   1044          
   1045                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1046          
   1047                break;
   1048          
   1049                // 1.4.	Manual Focus Direct (0x48)
   1050             case SONY_MANUAL_FOCUS_DIRECT:
   1051          
   1052                u_Data_Check = stSONY.SET_FOCUS_MODE;
   1053          
   1054                if (u_Data_Check != 0x01)
   1055                   break;
   1056          
   1057                u_Cmd = SONY_MANUAL_FOCUS_DIRECT;
   1058          
   1059                stSONY.SET_MANUAL_FOCUS_DATA = 0x0000;
   1060                stSONY.SET_MANUAL_FOCUS_DATA = u_Data[0] << 8;
   1061                stSONY.SET_MANUAL_FOCUS_DATA |= u_Data[1];
   1062          
   1063                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x09, SONY_COMMAND_TIMER_DELAY);
   1064          
   1065                AT24C256C_EEPROM_Write(EEP_MANUAL_FOCUS_DATA, u_Data[0]);
   1066                AT24C256C_EEPROM_Write(EEP_MANUAL_FOCUS_DATA + 1, u_Data[1]);
   1067          
   1068                break;
   1069          
   1070                // 1.5.	Manual Zoom (0x07)
   1071             case SONY_MANUAL_ZOOM:
   1072          
   1073                stSONY.SET_MANUAL_ZOOM_MODE = u_Data[1];
   1074          
   1075                u_Data[0] = 0x00;
   1076                u_Data[1] = 0x00;
   1077          
   1078                u_Cmd = 0x07;
   1079          
   1080                switch (stSONY.SET_MANUAL_ZOOM_MODE)
   1081                {
   1082                   // Stop
   1083                case 0x00:
   1084                   stSONY.ZOOM_STATUS = STOP;
   1085                   u_Data[0] = 0x00;
   1086                   break;
   1087          
   1088                   // Tele
   1089                case 0x01:
   1090                   stSONY.ZOOM_STATUS = ACTIVE;
   1091                   u_Data[0] = 0x27;
   1092                   break;
   1093          
   1094                   // Wide
   1095                case 0x02:
   1096                   stSONY.ZOOM_STATUS = ACTIVE;
   1097                   u_Data[0] = 0x37;
   1098                   break;
   1099          
   1100                default:
   1101                   break;
   1102                }
   1103          
   1104                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1105          
   1106                break;
   1107          
   1108                // 1.6.	Manual Focus Direct (0x48)
   1109             case SONY_MANUAL_ZOOM_DIRECT:
   1110          
   1111                u_Cmd = SONY_MANUAL_ZOOM_DIRECT;
   1112          
   1113                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x09, SONY_COMMAND_TIMER_DELAY);
   1114          
   1115                break;
   1116          
   1117                // 1.7.	Set BLC Mode (0x31)
   1118             case SONY_SET_BLC_MODE:
   1119          
   1120                stSONY.SET_BLC_MODE = u_Data[1];
   1121          
   1122                AT24C256C_EEPROM_Write(EEP_SET_BLC_MODE, stSONY.SET_BLC_MODE);
   1123          
   1124                u_Data[0] = 0x00;
   1125                u_Data[1] = 0x00;
   1126          
   1127                switch (stSONY.SET_BLC_MODE)
   1128                {
   1129                   // BLC/WDR OFF
   1130                case 0x00:
   1131          
   1132                   u_Cmd = 0x3D;
   1133                   u_Data[0] = 0x03;
   1134                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1135          
   1136                   u_Cmd = 0x33;
   1137                   u_Data[0] = 0x03;
   1138                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1139          
   1140                   break;
   1141          
   1142                   // BLC ON
   1143                case 0x01:
   1144          
   1145                   u_Cmd = 0x3D;
   1146                   u_Data[0] = 0x03;
   1147                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1148          
   1149                   u_Cmd = 0x33;
   1150                   u_Data[0] = 0x02;
   1151                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1152          
   1153                   break;
   1154          
   1155                   // WDR ON
   1156                case 0x10:
   1157          
   1158                   u_Cmd = 0x3D;
   1159                   u_Data[0] = 0x02;
   1160                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1161          
   1162                   u_Cmd = 0x33;
   1163                   u_Data[0] = 0x03;
   1164                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1165          
   1166                   break;
   1167          
   1168                   // BLC/WDR ON
   1169                case 0x11:
   1170          
   1171                   u_Cmd = 0x3D;
   1172                   u_Data[0] = 0x02;
   1173                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1174          
   1175                   u_Cmd = 0x33;
   1176                   u_Data[0] = 0x02;
   1177                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1178          
   1179                   break;
   1180          
   1181                default:
   1182                   break;
   1183                }
   1184          
   1185                break;
   1186          
   1187                // 1.8.	Set White Balance Mode (0x33)
   1188             case SONY_SET_WHITE_BALANCE_MODE:
   1189          
   1190                // Command & Data Convert
   1191                u_Cmd = 0x35;
   1192          
   1193                stSONY.SET_WHITE_BALANCE_MODE = u_Data[1];
   1194          
   1195                AT24C256C_EEPROM_Write(EEP_SET_WHITE_BALANCE_MODE, stSONY.SET_WHITE_BALANCE_MODE);
   1196          
   1197                u_Data[0] = 0x00;
   1198                u_Data[1] = 0x00;
   1199          
   1200                switch (stSONY.SET_WHITE_BALANCE_MODE)
   1201                {
   1202                   // Auto white balance Mode (Range : 3000 to 7500K)
   1203                case 0x00:
   1204                   u_Data[0] = 0x00;
   1205                   break;
   1206          
   1207                   // In door Mode
   1208                case 0x01:
   1209                   u_Data[0] = 0x01;
   1210                   break;
   1211          
   1212                   // Out door Mode
   1213                case 0x02:
   1214                   u_Data[0] = 0x02;
   1215                   break;
   1216          
   1217                   // Auto tracing white balance Mode (Range : 2000 to 10000K)
   1218                case 0x03:
   1219                   u_Data[0] = 0x04;
   1220                   break;
   1221          
   1222                default:
   1223                   break;
   1224                }
   1225          
   1226                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1227          
   1228                break;
   1229          
   1230                // 1.9.	Set Defog Mode (0x37)
   1231             case SONY_SET_DEFOG_MODE:
   1232          
   1233                stSONY.SET_DEFOG_MODE = u_Data[1];
   1234          
   1235                AT24C256C_EEPROM_Write(EEP_SET_DEFOG_MODE, stSONY.SET_DEFOG_MODE);
   1236          
   1237                u_Data[0] = 0x00;
   1238                u_Data[1] = 0x00;
   1239          
   1240                switch (stSONY.SET_DEFOG_MODE)
   1241                {
   1242                   // Defog Off
   1243                case 0x00:
   1244                   u_Data[0] = 0x03;
   1245                   break;
   1246          
   1247                   // Defog On
   1248                case 0x01:
   1249                   u_Data[0] = 0x02;
   1250                   break;
   1251          
   1252                   //  0x01   Defog On
   1253                default:
   1254                   u_Data[0] = 0x02;
   1255                   stSONY.SET_DEFOG_MODE = 0x02;
   1256                   break;
   1257                }
   1258          
   1259                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x07, SONY_COMMAND_TIMER_DELAY);
   1260          
   1261                break;
   1262          
   1263                // 1.10.	Set Shutter Speed (0x4A)
   1264             case SONY_SET_SHUTTER_SPEED:
   1265          
   1266                u_Data_Check = u_Data[1];
   1267          
   1268                if (u_Data_Check > 0x16)
   1269                   break;
   1270          
   1271                stSONY.SET_SHUTTER_SPEED = u_Data[1];
   1272          
   1273                AT24C256C_EEPROM_Write(EEP_SET_SHUTTER_SPEED, stSONY.SET_SHUTTER_SPEED);
   1274          
   1275                u_Data[0] = 0x00;
   1276                u_Data[1] = 0x00;
   1277          
   1278                if (stSONY.SET_SHUTTER_SPEED == 0x00)
   1279                {
   1280                   if (stSONY.SET_FLICKER_MODE)
   1281                   {
   1282                      // Flicker On   Flicker Off
   1283                      stSONY.SET_FLICKER_MODE = 0x00;
   1284          
   1285                      u_Cmd = 0x39;
   1286                      u_Data[0] = 0x00;
   1287          
   1288                      Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1289                   }
   1290          
   1291                   u_Cmd = 0x4A;
   1292                   u_Data[0] = 0x00;
   1293                   u_Data[1] = 0x06;
   1294          
   1295                   // when, NTSC:1/30, PAL:1/25
   1296                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x09, SONY_COMMAND_TIMER_DELAY);
   1297          
   1298                   u_Cmd = 0x39;
   1299                   u_Data[0] = 0x00;
   1300          
   1301                   // Full-Auto Mode
   1302                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1303          
   1304                   stSONY.SET_SHUTTER_SPEED = 0x00;
   1305                }
   1306                else
   1307                {
   1308                   if (stSONY.SET_DSS_MODE)
   1309                   {
   1310                      if (stSONY.SET_SHUTTER_SPEED <= 0x16)
   1311                      {
   1312                         if (stINFO.NTSC_PAL_STATUS == NTSC_MODE)
   1313                         {
   1314                            if (stSONY.SET_SHUTTER_SPEED == 0x09)
   1315                            {
   1316                               stSONY.SET_FLICKER_MODE = 0x01;
   1317          
   1318                               // Shutter Priority Mode
   1319                               u_Cmd = 0x39;
   1320                               u_Data[0] = 0x0A;
   1321                               Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1322                            }
   1323                            else
   1324                            {
   1325                               stSONY.SET_FLICKER_MODE = 0x00;
   1326          
   1327                               u_Cmd = 0x39;
   1328                               u_Data[0] = 0x00;
   1329          
   1330                               // Full-Auto Mode
   1331                               Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1332                            }
   1333                         }
   1334                         else if (stINFO.NTSC_PAL_STATUS == PAL_MODE)
   1335                         {
   1336                            if (stSONY.SET_SHUTTER_SPEED == 0x08)
   1337                            {
   1338                               stSONY.SET_FLICKER_MODE = 0x01;
   1339          
   1340                               // Shutter Priority Mode
   1341                               u_Cmd = 0x39;
   1342                               u_Data[0] = 0x0A;
   1343                               Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1344                            }
   1345                            else
   1346                            {
   1347                               stSONY.SET_FLICKER_MODE = 0x00;
   1348          
   1349                               u_Cmd = 0x39;
   1350                               u_Data[0] = 0x00;
   1351          
   1352                               // Full-Auto Mode
   1353                               Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1354                            }
   1355                         }
   1356          
   1357                         // Shutter Priority Mode
   1358                         u_Cmd = 0x39;
   1359                         u_Data[0] = 0x0A;
   1360                         Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1361          
   1362                         // Shutter Speed Setting
   1363                         u_Cmd = 0x4A;
   1364                         u_Data[0] = 0x00;
   1365                         u_Data[1] = stSONY.SET_SHUTTER_SPEED - 1;
   1366                         Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x09, SONY_COMMAND_TIMER_DELAY);
   1367          
   1368                      }
   1369                   }
   1370                   else
   1371                   {
   1372                      if ((stSONY.SET_SHUTTER_SPEED <= 0x16) && (stSONY.SET_SHUTTER_SPEED > 0x05))
   1373                      {
   1374                         if (stINFO.NTSC_PAL_STATUS == NTSC_MODE)
   1375                         {
   1376                            if (stSONY.SET_SHUTTER_SPEED == 0x09)
   1377                            {
   1378                               stSONY.SET_FLICKER_MODE = 0x01;
   1379          
   1380                               // Shutter Priority Mode
   1381                               u_Cmd = 0x39;
   1382                               u_Data[0] = 0x0A;
   1383                               Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1384                            }
   1385                            else
   1386                            {
   1387                               stSONY.SET_FLICKER_MODE = 0x00;
   1388          
   1389                               u_Cmd = 0x39;
   1390                               u_Data[0] = 0x00;
   1391          
   1392                               // Full-Auto Mode
   1393                               Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1394                            }
   1395                         }
   1396                         else if (stINFO.NTSC_PAL_STATUS == PAL_MODE)
   1397                         {
   1398                            if (stSONY.SET_SHUTTER_SPEED == 0x08)
   1399                            {
   1400                               stSONY.SET_FLICKER_MODE = 0x01;
   1401          
   1402                               // Shutter Priority Mode
   1403                               u_Cmd = 0x39;
   1404                               u_Data[0] = 0x0A;
   1405                               Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1406                            }
   1407                            else
   1408                            {
   1409                               stSONY.SET_FLICKER_MODE = 0x00;
   1410          
   1411                               u_Cmd = 0x39;
   1412                               u_Data[0] = 0x00;
   1413          
   1414                               // Full-Auto Mode
   1415                               Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1416                            }
   1417                         }
   1418          
   1419                         // Shutter Priority Mode
   1420                         u_Cmd = 0x39;
   1421                         u_Data[0] = 0x0A;
   1422                         Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1423          
   1424                         u_Cmd = 0x4A;
   1425                         u_Data[0] = 0x00;
   1426                         u_Data[1] = stSONY.SET_SHUTTER_SPEED - 1;
   1427          
   1428                         // when, NTSC:1/30, PAL:1/25
   1429                         Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x09, SONY_COMMAND_TIMER_DELAY);
   1430                      }
   1431                   }
   1432                }
   1433                break;
   1434          
   1435                // 1.11.	Set Flicker Mode (0x55)
   1436             case SONY_SET_FLICKER_MODE:
   1437          
   1438                stSONY.SET_FLICKER_MODE = u_Data[1];
   1439          
   1440                AT24C256C_EEPROM_Write(EEP_SET_FLICKER_MODE, stSONY.SET_FLICKER_MODE);
   1441          
   1442                u_Data[0] = 0x00;
   1443                u_Data[1] = 0x00;
   1444          
   1445                switch (stSONY.SET_FLICKER_MODE)
   1446                {
   1447                   // Flicker Off = Full-Auto Mode
   1448                case 0x00:
   1449          
   1450                   u_Cmd = 0x39;
   1451                   u_Data[0] = 0x00;
   1452                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);	// Full-Auto Mode
   1453          
   1454                   stSONY.SET_SHUTTER_SPEED = 0x00;
   1455          
   1456                   break;
   1457          
   1458                   // Flicker On = Shutter Priority Mode
   1459                case 0x01:
   1460          
   1461                   u_Cmd = 0x39;
   1462                   u_Data[0] = 0x0A;
   1463                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);	// Shutter Priority Mode
   1464          
   1465                   u_Cmd = 0x4A;
   1466          
   1467                   if (stINFO.NTSC_PAL_STATUS == NTSC_MODE)
   1468                   {
   1469                      u_Data[0] = 0x00;
   1470                      u_Data[1] = 0x08;	// 1/100s
   1471                      stSONY.SET_SHUTTER_SPEED = 0x0A;
   1472                   }
   1473                   else if (stINFO.NTSC_PAL_STATUS == PAL_MODE)
   1474                   {
   1475                      u_Data[0] = 0x00;
   1476                      u_Data[1] = 0x09;	// 1/120s
   1477                      stSONY.SET_SHUTTER_SPEED = 0x09;
   1478                   }
   1479          
   1480                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x09, SONY_COMMAND_TIMER_DELAY);	// Full-Auto Mode
   1481          
   1482                   break;
   1483                }
   1484          
   1485                break;
   1486          
   1487                // 1.12.	Set Aperture Value (0x59)
   1488             case SONY_SET_APERTURE_VALUE:
   1489          
   1490                u_Data_Check = u_Data[1];
   1491          
   1492                if (u_Data_Check > 0x0F)
   1493                   break;
   1494          
   1495                stSONY.SET_APERTURE_VALUE = u_Data[1];
   1496          
   1497                AT24C256C_EEPROM_Write(EEP_SET_APERTURE_VALUE, stSONY.SET_APERTURE_VALUE);
   1498          
   1499                u_Cmd = 0x42;
   1500                u_Data[0] = 0x00;
   1501                u_Data[1] = stSONY.SET_APERTURE_VALUE;
   1502          
   1503                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x09, SONY_COMMAND_TIMER_DELAY);
   1504          
   1505                break;
   1506          
   1507                // 1.13.	Set Digital Zoom Mode (0x5B)
   1508             case SONY_SET_DIGITAL_ZOOM_MODE:
   1509          
   1510                stSONY.SET_DIGITAL_ZOOM_MODE = u_Data[1];
   1511          
   1512                AT24C256C_EEPROM_Write(EEP_SET_DIGITAL_ZOOM_MODE, stSONY.SET_DIGITAL_ZOOM_MODE);
   1513          
   1514                u_Data[0] = 0x00;
   1515                u_Data[1] = 0x00;
   1516          
   1517                switch (stSONY.SET_DIGITAL_ZOOM_MODE)
   1518                {
   1519                   // Digital Zoom Mode Off
   1520                case 0x00:
   1521          
   1522                   u_Cmd = 0x06;
   1523                   u_Data[0] = 0x03;
   1524                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);	// Shutter Priority Mode
   1525          
   1526                   break;
   1527          
   1528                   // Digital Zoom Mode On
   1529                case 0x01:
   1530          
   1531                   u_Cmd = 0x06;
   1532                   u_Data[0] = 0x02;
   1533                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);	// Shutter Priority Mode
   1534          
   1535                   break;
   1536          
   1537                default:
   1538          
   1539                   // 0x01     Digital Zoom Mode On
   1540                   u_Cmd = 0x06;
   1541                   u_Data[0] = 0x02;
   1542                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);	// Shutter Priority Mode
   1543          
   1544                   stSONY.SET_DIGITAL_ZOOM_MODE = 0x01;
   1545          
   1546                   break;
   1547          
   1548                }
   1549          
   1550                break;
   1551          
   1552                // 1.14.	Set Day & Night Mode (0x5F)
   1553             case SONY_SET_DAY_NIGHT_MODE:
   1554          
   1555                stSONY.SET_DAY_NIGHT_MODE = u_Data[1];
   1556          
   1557                AT24C256C_EEPROM_Write(EEP_SET_DAY_NIGHT_MODE, stSONY.SET_DAY_NIGHT_MODE);
   1558          
   1559                u_Data[0] = 0x00;
   1560                u_Data[1] = 0x00;
   1561          
   1562                switch (stSONY.SET_DAY_NIGHT_MODE)
   1563                {
   1564                   // Night Mode
   1565                case 0x00:
   1566          
   1567                   // Auto Mode Off
   1568                   u_Cmd = 0x51;
   1569                   u_Data[0] = 0x03;
   1570                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1571          
   1572                   // Night Mode
   1573                   u_Cmd = 0x01;
   1574                   u_Data[0] = 0x02;
   1575                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1576          
   1577                   break;
   1578          
   1579                   // Day Mode
   1580                case 0x01:
   1581          
   1582                   // Auto Mode Off
   1583                   u_Cmd = 0x51;
   1584                   u_Data[0] = 0x03;
   1585                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1586          
   1587                   // Day Mode
   1588                   u_Cmd = 0x01;
   1589                   u_Data[0] = 0x03;
   1590                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1591          
   1592                   break;
   1593          
   1594                   // Auto Mode
   1595                case 0x02:
   1596          
   1597                   // Auto Mode On
   1598                   u_Cmd = 0x51;
   1599                   u_Data[0] = 0x02;
   1600                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1601          
   1602                   break;
   1603                }
   1604          
   1605                break;
   1606          
   1607                // 1.15.	Set DSS Mode (0x61)
   1608             case SONY_SET_DSS_MODE:
   1609          
   1610                stSONY.SET_DSS_MODE = u_Data[1];
   1611          
   1612                AT24C256C_EEPROM_Write(EEP_SET_DSS_MODE, stSONY.SET_DSS_MODE);
   1613          
   1614                u_Data[0] = 0x00;
   1615                u_Data[1] = 0x00;
   1616          
   1617                switch (stSONY.SET_DSS_MODE)
   1618                {
   1619                   // DSS OFF
   1620                case 0x00:
   1621          
   1622                   // DSS OFF
   1623                   u_Cmd = 0x5A;
   1624                   u_Data[0] = 0x03;
   1625                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1626          
   1627                   if (stSONY.SET_SHUTTER_SPEED < 0x07)
   1628                   {
   1629                      // Full-Auto Mode
   1630                      u_Cmd = 0x39;
   1631                      u_Data[0] = 0x00;
   1632                      Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1633          
   1634                      stSONY.SET_SHUTTER_SPEED = 0x00;
   1635                   }
   1636          
   1637                   break;
   1638          
   1639                   // DSS ON
   1640                case 0x01:
   1641          
   1642                   u_Cmd = 0x5A;
   1643                   u_Data[0] = 0x02;
   1644                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1645          
   1646                   break;
   1647          
   1648                default:
   1649                   break;
   1650                }
   1651          
   1652                break;
   1653          
   1654                // 1.16.	Select BLC / WDR (0x85)
   1655             case SONY_SELECT_BLC_WDR:
   1656          
   1657                stSONY.SELECT_BLC_WDR = u_Data[1];
   1658          
   1659                AT24C256C_EEPROM_Write(EEP_SELECT_BLC_WDR, stSONY.SELECT_BLC_WDR);
   1660          
   1661                u_Data[0] = 0x00;
   1662                u_Data[1] = 0x00;
   1663          
   1664                //  .
   1665                switch (stSONY.SELECT_BLC_WDR)
   1666                {
   1667                case 0x00:
   1668                   break;
   1669          
   1670                case 0x01:
   1671                   break;
   1672          
   1673                default:
   1674                   break;
   1675                }
   1676          
   1677                break;
   1678          
   1679                // 1.17.	Set High Resolution (0x87)
   1680             case SONY_SET_HIGH_RESOLUTION:
   1681          
   1682                stSONY.SET_HIGH_RESOLUTION = u_Data[1];
   1683          
   1684                AT24C256C_EEPROM_Write(EEP_SET_HIGH_RESOLUTION, stSONY.SET_HIGH_RESOLUTION);
   1685          
   1686                u_Data[0] = 0x00;
   1687                u_Data[1] = 0x00;
   1688          
   1689                switch (stSONY.SET_HIGH_RESOLUTION)
   1690                {
   1691                   // HR Mode Off
   1692                case 0x00:
   1693          
   1694                   u_Cmd = 0x52;
   1695                   u_Data[0] = 0x03;
   1696                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1697          
   1698                   break;
   1699          
   1700                   // HR Mode On
   1701                case 0x01:
   1702          
   1703                   u_Cmd = 0x52;
   1704                   u_Data[0] = 0x02;
   1705                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1706          
   1707                   break;
   1708          
   1709                default:
   1710                   break;
   1711                }
   1712          
   1713                break;
   1714          
   1715                // 1.18.	Set Image Stabilizer (0x89)
   1716             case SONY_SET_IMAGE_STABILIZER:
   1717          
   1718                stSONY.SET_IMAGE_STABILIZER = u_Data[1];
   1719          
   1720                AT24C256C_EEPROM_Write(EEP_SET_IMAGE_STABILIZER, stSONY.SET_IMAGE_STABILIZER);
   1721          
   1722                u_Data[0] = 0x00;
   1723                u_Data[1] = 0x00;
   1724          
   1725                switch (stSONY.SET_IMAGE_STABILIZER)
   1726                {
   1727                   // Image Stabilizer Off
   1728                case 0x00:
   1729          
   1730                   u_Cmd = 0x34;
   1731                   u_Data[0] = 0x03;
   1732                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1733          
   1734                   break;
   1735          
   1736                   // Image Stabilizer On
   1737                case 0x01:
   1738          
   1739                   u_Cmd = 0x34;
   1740                   u_Data[0] = 0x02;
   1741                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1742          
   1743                   break;
   1744          
   1745                default:
   1746                   break;
   1747                }
   1748          
   1749                break;
   1750          
   1751                // 1.19.	Set Noise Reduction (0x8B)
   1752             case SONY_SET_NOISE_REDUCTION:
   1753          
   1754                u_Data_Check = u_Data[1];
   1755          
   1756                if (u_Data_Check > 0x05)
   1757                   break;
   1758          
   1759                stSONY.SET_NOISE_REDUCTION = u_Data[1];
   1760          
   1761                AT24C256C_EEPROM_Write(EEP_SET_NOISE_REDUCTION, stSONY.SET_NOISE_REDUCTION);
   1762          
   1763                u_Data[0] = 0x00;
   1764                u_Data[1] = 0x00;
   1765          
   1766                switch (stSONY.SET_NOISE_REDUCTION)
   1767                {
   1768                   // Noise Reduction Off
   1769                case 0x00:
   1770          
   1771                   u_Cmd = 0x53;
   1772                   u_Data[0] = 0x00;
   1773                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1774          
   1775                   break;
   1776          
   1777                   // Image Stabilizer On [Sensitivity] (Lv.1 ~ Lv.5)
   1778                case 0x01:
   1779                case 0x02:
   1780                case 0x03:
   1781                case 0x04:
   1782                case 0x05:
   1783          
   1784                   u_Cmd = 0x53;
   1785                   u_Data[0] = stSONY.SET_NOISE_REDUCTION;
   1786                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1787          
   1788                   break;
   1789          
   1790                default:
   1791                   break;
   1792                }
   1793          
   1794                break;
   1795          
   1796                // 1.20.	Set Color Module (0xF0) -      
   1797             case SONY_SET_COLOR_MODULE:
   1798                break;
   1799          
   1800                // Set NTSC/PAL Mode (0x72)
   1801             case SONY_SET_NTSC_PAL_MODE:
   1802          
   1803                u_Data_Check = u_Data[1];
   1804          
   1805                stSONY.SET_NTSC_PAL_MODE = u_Data[1];
   1806          
   1807                AT24C256C_EEPROM_Write(EEP_SET_NTSC_PAL_MODE, stSONY.SET_NTSC_PAL_MODE);
   1808          
   1809                u_Data[0] = 0x00;
   1810                u_Data[1] = 0x00;
   1811          
   1812                u_Cmd = SONY_SET_NTSC_PAL_MODE;
   1813                u_Data[0] = 0x00;
   1814          
   1815                switch (stSONY.SET_NTSC_PAL_MODE)
   1816                {
   1817                   // NTSC MODE
   1818                case 0x01:
   1819                   u_Data[1] = 0x07;
   1820                   break;
   1821          
   1822                   // PAL MODE
   1823                case 0x02:
   1824                   u_Data[1] = 0x08;
   1825                   break;
   1826          
   1827                default:
   1828                   break;
   1829                }
   1830          
   1831                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x08, SONY_COMMAND_TIMER_DELAY);
   1832          
   1833                break;
   1834          
   1835                // Call Zoom Position (0xB8 : 0xFF - 0x47)
   1836             case 0xB8:
   1837          
   1838                switch (u_Port)
   1839                {
   1840                case USART1_INDEX:
   1841          
   1842                   u_Cmd = SONY_CALL_ZOOM_POSITION;
   1843          
   1844                   u16_Convert_Data = stSONY.ZOOM_CNT;
   1845                   u_Data[0] = (u8)(u16_Convert_Data >> 8);
   1846                   u_Data[1] = (u8)(u16_Convert_Data & 0xFF);
   1847                   u_Leng = 0x05;
   1848          
   1849                   stUSART1.TX_READY = 0x01;
   1850          
   1851                   break;
   1852          
   1853                default:
   1854                   break;
   1855                }
   1856          
   1857                break;
   1858          
   1859             default:
   1860                break;
   1861          
   1862             }
   1863          
   1864             // Send MAIN Command & Data Trans
   1865             if (stUSART1.TX_READY)
   1866             {
   1867                USART1_Send_Data(IP_SONY_FIRST_BYTE, u_Cmd, u_Data[0], u_Data[1], u_Data[2], u_Leng);
   1868          
   1869                stUSART1.TX_READY = 0;
   1870          
   1871                //Send_Data_Clear(USART1_INDEX, u_Leng);
   1872             }
   1873          
   1874             // Send SONY Command & Data Trans
   1875             if (stUART4.TX_READY)
   1876             {
   1877                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], u_Leng, TSM_COMMAND_TIMER_DELAY);
   1878          
   1879                if (!stUART4.TX_REQUEST)
   1880                   stUART4.TX_ACK = 0x01;
   1881          
   1882                stUART4.TX_READY = 0;
   1883          
   1884                //Send_Data_Clear(USART1_INDEX, u_Leng);
   1885             }
   1886          
   1887             // Send Ack Trans
   1888             if (stUART4.TX_ACK)
   1889             {
   1890                stUART4.TX_ACK = 0;
   1891             }
   1892          
   1893          }
   1894          
   1895          /***************************************************************************************************************************
   1896          * Function : TSM_Data_Handing
   1897          * Protocol Version : 0.1 (2016.04.11)
   1898          * Data Architecture :
   1899          BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]		BYTE[..]		BYTE(n)[LENGTH+4]	BYTE(n+1)[LENGTH+4]
   1900          0xB0		0x0B		LENGTH		ADDR		COMM		DATA		...			CS					0xBF
   1901          ****************************************************************************************************************************/
   1902          void TSM_Data_Handing(u8 u_Port, u8 u_Comm, u8 u_Leng)
   1903          {
   1904             u8 u_Cmd = 0x00;	// Camera Command
   1905             u8 u_Data1 = 0x00, u_Data2 = 0x00, u_Data3 = 0x00;
   1906             u8 u_Response_Data = 0x00;
   1907          
   1908             u8 u8_Convert_Data[10];
   1909             u16 u16_Convert_Data = 0x0000;
   1910          
   1911             switch (u_Port)
   1912             {
   1913             case SYSTEM_INDEX:
   1914          
   1915                u_Cmd = stSYS.RX_BUF[0][5];
   1916                u_Data1 = stSYS.RX_BUF[0][6];
   1917                u_Data2 = stSYS.RX_BUF[0][7];
   1918                u_Data3 = stSYS.RX_BUF[0][8];
   1919          
   1920                break;
   1921          
   1922             case USART1_INDEX:
   1923          
   1924                u_Cmd = stUSART1.RX_BUF[4];
   1925                u_Data1 = stUSART1.RX_BUF[5];
   1926                u_Data2 = stUSART1.RX_BUF[6];
   1927                u_Data3 = stUSART1.RX_BUF[7];
   1928          
   1929                break;
   1930          
   1931             case USART5_INDEX:
   1932          
   1933                u_Cmd = stUART5.RX_BUF[4];
   1934                u_Data1 = stUART5.RX_BUF[5];
   1935                u_Data2 = stUART5.RX_BUF[6];
   1936                u_Data3 = stUART5.RX_BUF[7];
   1937          
   1938                break;
   1939          
   1940             default:
   1941                break;
   1942             }
   1943          
   1944             switch (u_Comm)
   1945             {
   1946                // 2.1.1. Initialize (0x01)
   1947             case TSM_INITIALIZE:
   1948                stUART4.TX_READY = 0x01;
   1949                break;
   1950          
   1951                // 2.1.2. Rebooting (0x02)
   1952             case TSM_REBOOTING:
   1953                stUART4.TX_READY = 0x01;
   1954                break;
   1955          
   1956                // 2.1.3. Save Setting (0x04)
   1957             case TSM_SAVE_SETTING:
   1958                stUART4.TX_READY = 0x01;
   1959                break;
   1960          
   1961                // 2.1.4. Shutter Set (0x05)
   1962             case TSM_SHUTTER_SET:
   1963                stUART4.TX_READY = 0x01;
   1964                break;
   1965          
   1966                // 2.1.5. Digital Zoom Start (0x11)
   1967             case TSM_DIGITAL_ZOOM_START:
   1968                stUART4.TX_READY = 0x01;
   1969                break;
   1970          
   1971                // 2.1.6. Digital Zoom Stop (0x10)
   1972             case TSM_DIGITAL_ZOOM_STOP:
   1973                stUART4.TX_READY = 0x01;
   1974                break;
   1975          
   1976                // 2.1.7. Digital Zoom Direct (0x12)
   1977             case TSM_DIGITAL_ZOOM_DIRECT:
   1978                stUART4.TX_READY = 0x01;
   1979                break;
   1980          
   1981                // 2.1.8. Optical Zoom Start (0x13)
   1982             case TSM_OPTICAL_ZOOM_START:
   1983                stUART4.TX_READY = 0x01;
   1984                break;
   1985          
   1986                // 2.1.9. Optical Zoom Stop (0x14)
   1987             case TSM_OPTICAL_ZOOM_STOP:
   1988                stUART4.TX_READY = 0x01;
   1989                break;
   1990          
   1991                // 2.1.10. Optical Zoom Direct (0x15)
   1992             case TSM_OPTICAL_ZOOM_DIRECT:
   1993                stUART4.TX_READY = 0x01;
   1994                break;
   1995          
   1996                // 2.1.11. Focus Start (0x16)
   1997             case TSM_FOCUS_START:
   1998                stUART4.TX_READY = 0x01;
   1999                //stPTZ.TFOCUS_STATUS = FOCUS_ACTIVE;
   2000                break;
   2001          
   2002                // 2.1.12. Focus Stop (0x17)
   2003             case TSM_FOCUS_STOP:
   2004                stUART4.TX_READY = 0x01;
   2005                stTSM.FOCUS_CHECK_FLAG = 0x01;
   2006                //stPTZ.TFOCUS_STATUS = FOCUS_STOP;
   2007                break;
   2008          
   2009                // 2.1.13. Focus Direct (0x18)
   2010             case TSM_FOCUS_DIRECT:
   2011                stUART4.TX_READY = 0x01;
   2012                break;
   2013          
   2014                // 2.1.14. Auto Focus Set (0x19)
   2015             case TSM_AUTO_FOCUS_SET:
   2016                stUART4.TX_READY = 0x01;
   2017                break;
   2018          
   2019                // 2.1.15. Digital Zoom Enable (0x1C)
   2020             case TSM_DIZITAL_ZOOM_ENABLE:
   2021          
   2022                // IP ERROR DATA CONVERT
   2023                switch (u_Data3)
   2024                {
   2025                case 0x01:
   2026                   u_Data3 = 0x80;
   2027                   break;
   2028                }
   2029                stUART4.TX_READY = 0x01;
   2030                break;
   2031          
   2032                // 2.1.16. Total Zoom Start (0x20)
   2033             case TSM_TOTAL_ZOOM_START:
   2034          
   2035                switch (stINFO.THERMAL_MODEL)
   2036                {
   2037                case TSM_72:
   2038                case TSM_1M:
   2039          
   2040          #if(1)
   2041          
   2042                   switch (stINFO.THERMAL_LENS)
   2043                   {
   2044                   case 0x01:
   2045                      u_Cmd = TSM_TOTAL_ZOOM_START;
   2046                      u_Data2 = 0x07;
   2047                      break;
   2048          
   2049                   default:
   2050                      u_Cmd = TSM_TOTAL_ZOOM_START;
   2051                      break;
   2052                   }
   2053          #else
   2054                   switch (stINFO.THERMAL_LENS)
   2055                   {
   2056                   case 0x01:
   2057                      u_Cmd = TSM_TOTAL_ZOOM_START;
   2058                      u_Data2 = 0x07;
   2059                      break;
   2060          
   2061                   default:
   2062                      u_Cmd = TSM_DIGITAL_ZOOM_START;
   2063                      break;
   2064                   }
   2065          #endif
   2066          
   2067                   break;
   2068          
   2069                default:
   2070                   break;
   2071                }
   2072          
   2073                stUART4.TX_READY = 0x01;
   2074                //stPTZ.TZOOM_STATUS = ZOOM_ACTIVE;
   2075                break;
   2076          
   2077                // 2.1.17. Total Zoom Stop (0x21)
   2078             case TSM_TOTAL_ZOOM_STOP:
   2079                stUART4.TX_READY = 0x01;
   2080                stTSM.ZOOM_CHECK_FLAG = 0x01;
   2081                break;
   2082          
   2083                // 2.1.18. Total Zoom Direct (0x22)
   2084             case TSM_TOTAL_ZOOM_DIRECT:
   2085                stUART4.TX_READY = 0x01;
   2086                break;
   2087          
   2088                // 2.1.19. Total Zoom Stop (0x23)
   2089             case TSM_TOTAL_ZOOM_STOP_SUB:
   2090                stUART4.TX_READY = 0x01;
   2091                stTSM.ZOOM_CHECK_FLAG = 0x01;
   2092                break;
   2093          
   2094                // 2.1.20. AGC Mode Set (0x26)
   2095             case TSM_AGC_MODE_SET:
   2096                stUART4.TX_READY = 0x01;
   2097                break;
   2098          
   2099                // 2.1.21. Color Mode Set (0x27)
   2100             case TSM_COLOR_MODE_SET:
   2101                stUART4.TX_READY = 0x01;
   2102                break;
   2103          
   2104                // 2.1.22. Contrast/Brightness (0x28) (when, AGC OFF)
   2105             case TSM_CONTRAST_BRIGHTNESS:
   2106                stUART4.TX_READY = 0x01;
   2107                break;
   2108          
   2109                // 2.1.23. AGC Center Position Set (0x29)
   2110             case TSM_AGC_CENTER_POSITION_SET:
   2111                stUART4.TX_READY = 0x01;
   2112                break;
   2113          
   2114                // 2.1.24. AGC Limit Level Set (0x2A)
   2115             case TSM_AGC_LIMIT_LEVEL_SET:
   2116                stUART4.TX_READY = 0x01;
   2117                break;
   2118          
   2119                // 2.1.25. AGC ROI (AGC Region of Interest) Set (0x2B)
   2120             case TSM_AGC_ROI_SET:
   2121                stUART4.TX_READY = 0x01;
   2122                break;
   2123          
   2124                // 2.1.26. MIDE Level Set (0x2C) (when, Sharpness OFF)
   2125             case TSM_MIDE_LEVEL_SET:
   2126                stUART4.TX_READY = 0x01;
   2127                break;
   2128          
   2129                // 2.1.27. Sharpness Level Set (0x2D) (when, MIDE OFF)
   2130             case TSM_SHARPNESS_LEVEL_SET:
   2131                stUART4.TX_READY = 0x01;
   2132                break;
   2133          
   2134                // 2.1.28. Detect Mode Set (0x31)
   2135             case TSM_DETECT_MODE_SET:
   2136                stUART4.TX_READY = 0x01;
   2137                break;
   2138          
   2139                // 2.1.29. Area Position Set (0x32)
   2140             case TSM_AREA_POSITION_SET:
   2141                stUART4.TX_READY = 0x01;
   2142                break;
   2143          
   2144                // 2.1.30. Spot Position Set (0x33)
   2145             case TSM_SPOT_POSITION_SET:
   2146                stUART4.TX_READY = 0x01;
   2147                break;
   2148          
   2149                // 2.1.31. High Alarm Temperature (0x34)
   2150             case TSM_HIGH_ALARM_TEMPERATURE:
   2151                stUART4.TX_READY = 0x01;
   2152                break;
   2153          
   2154                // 2.1.32. Low Alarm Temperature (0x35)
   2155             case TSM_LOW_ALARM_TEMPERATURE:
   2156                stUART4.TX_READY = 0x01;
   2157                break;
   2158          
   2159                // 2.1.33. Select Alarm (0x36)
   2160             case TSM_SELECT_ALARM:
   2161                stUART4.TX_READY = 0x01;
   2162                break;
   2163          
   2164                // 2.1.34. Alarm Mode (0x37)
   2165             case TSM_ALARM_MODE:
   2166                stUART4.TX_READY = 0x01;
   2167                break;
   2168          
   2169                // 2.1.35. Temperature OSD (0x38)
   2170             case TSM_TEMPERATURE_OSD:
   2171                stUART4.TX_READY = 0x01;
   2172                break;
   2173          
   2174                // 2.1.36. Emissivity Set (0x39)
   2175             case TSM_EMISSIVITY_SET:
   2176                stUART4.TX_READY = 0x01;
   2177                break;
   2178          
   2179                // 2.1.37. Mirror / Flip Mode Set (0x43)
   2180             case TSM_MIRROR_FLIP_MODE_SET:
   2181                stUART4.TX_READY = 0x01;
   2182                break;
   2183          
   2184                // 2.1.38. Mirror Mode Set (0x44)
   2185             case TSM_MIRROR_MODE_SET:
   2186                stUART4.TX_READY = 0x01;
   2187                break;
   2188          
   2189                // 2.1.39. Flip Mode Set (0x45)
   2190             case TSM_FLIP_MODE_SET:
   2191                stUART4.TX_READY = 0x01;
   2192                break;
   2193          
   2194                // 2.1.40. Image Freeze Set (0x46)
   2195             case TSM_IMAGE_FREEZE_SET:
   2196                stUART4.TX_READY = 0x01;
   2197                break;
   2198          
   2199                // 2.1.41. Image Color Inverse(White/Black Hot) Set (0x47)
   2200             case TSM_IMAGE_COLOR_INVERSE:
   2201                stUART4.TX_READY = 0x01;
   2202                break;
   2203          
   2204                // 2.1.42. External Communication Option Set (0x55)
   2205             case TSM_EXTERNAL_OPTION_SET:
   2206                stUART4.TX_READY = 0x01;
   2207                break;
   2208          
   2209                // 2.1.43. Calibration Execute (0x65)
   2210             case TSM_CALIBRATION_EXECUTE:
   2211                stUART4.TX_READY = 0x01;
   2212                break;
   2213          
   2214                // 2.1.44. Calibration Option Set (0x66)
   2215             case TSM_CALIBRATION_OPTION_SET:
   2216                stUART4.TX_READY = 0x01;
   2217                break;
   2218          
   2219                // 2.1.45. OSD All Off (0x76)
   2220             case TSM_OSD_ALL_OFF:
   2221                stUART4.TX_READY = 0x01;
   2222                break;
   2223          
   2224                // 2.1.46. Temperature Mode Set (0x77)
   2225             case TSM_TEMPERATURE_MODE_SET:
   2226                stUART4.TX_READY = 0x01;
   2227                break;
   2228          
   2229                // 2.1.47. Temperature Range Set (0x78) - Not Used
   2230             case TSM_TEMPERATURE_RANGE_SET:
   2231                break;
   2232          
   2233                // 2.1.48. Video Mode Set (0x79)
   2234             case TSM_VIDEO_MODE_SET:
   2235                stUART4.TX_READY = 0x01;
   2236                break;
   2237          
   2238                // 2.1.49. OSD MENU Key Control (0xA0)
   2239             case TSM_OSD_MENU_KEY_CONTROL:
   2240                stUART4.TX_READY = 0x01;
   2241                break;
   2242          
   2243                // 2.1.50. Call Module Status (0x30)
   2244             case TSM_CALL_MODULE_STATUS:
   2245                stUART4.TX_READY = 0x01;
   2246                stUART4.TX_REQUEST = 0x01;
   2247                break;
   2248          
   2249                // 2.1.51. Call Alarm Status (0x3A)
   2250             case TSM_CALL_ALARM_STATUS:
   2251                stUART4.TX_READY = 0x01;
   2252                stUART4.TX_REQUEST = 0x01;
   2253                break;
   2254          
   2255                // 2.1.52. Call Spot Temperature (0x3B)
   2256             case TSM_CALL_SPOT_TEMPERATURE:
   2257                stUART4.TX_READY = 0x01;
   2258                stUART4.TX_REQUEST = 0x01;
   2259                break;
   2260          
   2261                // 2.1.53. Call Area Temperature (0x3C)
   2262             case TSM_CALL_AREA_TEMPERATURE:
   2263                stUART4.TX_READY = 0x01;
   2264                stUART4.TX_REQUEST = 0x01;
   2265                break;
   2266          
   2267                // 2.1.54. Call Center Temperature (0x3D)
   2268             case TSM_CALL_CENTER_TEMPERATURE:
   2269                stUART4.TX_READY = 0x01;
   2270                stUART4.TX_REQUEST = 0x01;
   2271                break;
   2272          
   2273                // 2.1.55. Call Full Temperature (0x3E)
   2274             case TSM_CALL_FULL_TEMPERATURE:
   2275                stUART4.TX_READY = 0x01;
   2276                stUART4.TX_REQUEST = 0x01;
   2277                break;
   2278          
   2279                // 2.1.56. Call External Communication (0x71)
   2280             case TSM_CALL_EXTERNAL_COMMUNICATION:
   2281                stUART4.TX_READY = 0x01;
   2282                stUART4.TX_REQUEST = 0x01;
   2283                break;
   2284          
   2285                // 2.1.57. Call Camera Information (0x80)
   2286             case TSM_CALL_CAMERA_INFORMATION:
   2287                stUART4.TX_READY = 0x01;
   2288                stUART4.TX_REQUEST = 0x01;
   2289                break;
   2290          
   2291                // 2.1.58. Call Firmware Version (0x81)
   2292             case TSM_CALL_FIRMWARE_VERSION:
   2293                stUART4.TX_READY = 0x01;
   2294                stUART4.TX_REQUEST = 0x01;
   2295                break;
   2296          
   2297                // 2.1.59. Call Digital Zoom Position (0x82)
   2298             case TSM_CALL_DIGITAL_ZOOM_POSITION:
   2299                stUART4.TX_READY = 0x01;
   2300                stUART4.TX_REQUEST = 0x01;
   2301                break;
   2302          
   2303                // 2.1.60. Call Optical Zoom Position (0x83)
   2304             case TSM_CALL_OPTICAL_ZOOM_POSITION:
   2305                stUART4.TX_READY = 0x01;
   2306                stUART4.TX_REQUEST = 0x01;
   2307                break;
   2308          
   2309                // 2.1.61. Call Focus Position (0x84)
   2310             case TSM_CALL_FOCUS_POSITION:
   2311                stUART4.TX_READY = 0x01;
   2312                stUART4.TX_REQUEST = 0x01;
   2313                break;
   2314          
   2315                // 2.1.62. Call Total Zoom Position (0x85)
   2316             case TSM_CALL_TOTAL_ZOOM_POSITION:
   2317                stUART4.TX_READY = 0x01;
   2318                stUART4.TX_REQUEST = 0x01;
   2319          
   2320                stTSM.ZOOM_CHECK_FLAG = 0x01;
   2321                break;
   2322          
   2323                // 2.1.63. Call Temperature Mode (0x86)
   2324             case TSM_CALL_TEMPERATURE_MODE:
   2325                stUART4.TX_READY = 0x01;
   2326                stUART4.TX_REQUEST = 0x01;
   2327                break;
   2328          
   2329                // 2.1.64. Call All Temperature (0x87)
   2330             case TSM_CALL_ALL_TEMPERATURE:
   2331                stUART4.TX_READY = 0x01;
   2332                stUART4.TX_REQUEST = 0x01;
   2333          
   2334                // BackUp Data
   2335                stTSM.TEMPERATURE_READ_FLAG = u_Data1;		//     
   2336          
   2337                u16_Convert_Data = (u_Data2 << 8);		//      P2
   2338                u16_Convert_Data |= u_Data3;			//      P3
   2339                stTSM.TEMPERATURE_READ_TIME = u16_Convert_Data;
   2340                break;
   2341          
   2342                // 2.1.65. Call Auto AF (0x88)
   2343             case TSM_CALL_AUTO_AF:
   2344                stUART4.TX_READY = 0x01;
   2345                stUART4.TX_REQUEST = 0x01;
   2346                break;
   2347          
   2348                // Call Focus Position (0x94)
   2349             case TSM_CALL_FOCUS_POSITION_SUB:
   2350          
   2351                u16_Convert_Data = stTSM.FOCUS_CNT;
   2352          
   2353                u8_Convert_Data[0] = (u8)(u16_Convert_Data >> 8);
   2354                u8_Convert_Data[1] = (u8)(u16_Convert_Data & 0xFF);
   2355          
   2356                stUSART1.TX_BUF[0] = IP_TSM_FIRST_BYTE;
   2357                stUSART1.TX_BUF[1] = IP_TSM_SECOND_BYTE;
   2358                stUSART1.TX_BUF[2] = 0x05;
   2359          
   2360                stUSART1.TX_BUF[3] = 0x01;
   2361          
   2362                stUSART1.TX_BUF[4] = TSM_CALL_FOCUS_POSITION_SUB;
   2363                stUSART1.TX_BUF[5] = u8_Convert_Data[0];
   2364                stUSART1.TX_BUF[6] = u8_Convert_Data[1];
   2365                stUSART1.TX_BUF[7] = u8_Convert_Data[2];
   2366          
   2367                stUSART1.TX_BUF[8] = 0x00;
   2368                stUSART1.TX_BUF[8] = stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5] + stUSART1.TX_BUF[6] + stUSART1.TX_BUF[7];
   2369          
   2370                stUSART1.TX_BUF[9] = 0xBF;
   2371          
   2372                stUSART1.TX_CNT = 0;
   2373                stUSART1.TX_MAX = 10;
   2374          
   2375                USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   2376                Delay_1ms(MAIN_COMMAND_TIMER_DELAY);
   2377          
   2378                break;
   2379          
   2380                // Call Total Zoom Position (0x95)
   2381             case TSM_CALL_TOTAL_ZOOM_POSITION_SUB:
   2382          
   2383                u16_Convert_Data = stTSM.ZOOM_CNT;
   2384          
   2385                u8_Convert_Data[0] = (u8)(u16_Convert_Data >> 8);
   2386                u8_Convert_Data[1] = (u8)(u16_Convert_Data & 0xFF);
   2387          
   2388                stUSART1.TX_BUF[0] = IP_TSM_FIRST_BYTE;
   2389                stUSART1.TX_BUF[1] = IP_TSM_SECOND_BYTE;
   2390                stUSART1.TX_BUF[2] = 0x05;
   2391          
   2392                stUSART1.TX_BUF[3] = 0x01;
   2393          
   2394                stUSART1.TX_BUF[4] = TSM_CALL_TOTAL_ZOOM_POSITION_SUB;
   2395                stUSART1.TX_BUF[5] = u8_Convert_Data[0];
   2396                stUSART1.TX_BUF[6] = u8_Convert_Data[1];
   2397                stUSART1.TX_BUF[7] = u8_Convert_Data[2];
   2398          
   2399                stUSART1.TX_BUF[8] = 0x00;
   2400                stUSART1.TX_BUF[8] = stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5] + stUSART1.TX_BUF[6] + stUSART1.TX_BUF[7];
   2401          
   2402                stUSART1.TX_BUF[9] = 0xBF;
   2403          
   2404                stUSART1.TX_CNT = 0;
   2405                stUSART1.TX_MAX = 10;
   2406          
   2407                USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   2408                Delay_1ms(MAIN_COMMAND_TIMER_DELAY);
   2409          
   2410                break;
   2411          
   2412                // 2.1.66. Call Product Identification (0xF0)
   2413             case TSM_CALL_PRODUCT_IDENTIFICATION:
   2414                stUART4.TX_READY = 0x01;
   2415                stUART4.TX_REQUEST = 0x01;
   2416                break;
   2417          
   2418                // 2.1.67. Module Mode Set (0xF1)
   2419             case TSM_MODULE_MODE_SET:
   2420                stUART4.TX_READY = 0x01;
   2421                stUART4.TX_REQUEST = 0x01;
   2422                break;
   2423          
   2424                // 2.1.68. Auto AF Set (0xF2)
   2425             case TSM_AUTO_AF_SET:
   2426                stUART4.TX_READY = 0x01;
   2427                stUART4.TX_REQUEST = 0x01;
   2428                break;
   2429          
   2430                // 2.1.69. Set Thermal Module (0xF3)
   2431             case TSM_SET_THERMAL_MODULE:
   2432                stUART4.TX_READY = 0x01;
   2433                break;
   2434          
   2435             default:
   2436                stUART4.TX_READY = 0x01;
   2437                break;
   2438          
   2439             }
   2440          
   2441             stUART4.TX_CMD = u_Cmd;
   2442             stUART4.TX_PARAMETER1 = u_Data1;
   2443             stUART4.TX_PARAMETER2 = u_Data2;
   2444             stUART4.TX_PARAMETER3 = u_Data3;
   2445          
   2446             // Send TSM Command & Data Trans
   2447             if (stUART4.TX_READY)
   2448             {
   2449                Send_TSM_Data(u_Cmd, u_Data1, u_Data2, u_Data3, 0x06, TSM_COMMAND_TIMER_DELAY);
   2450          
   2451                if (stTSM.ZOOM_CHECK_FLAG == 0x01)
   2452                {
   2453                   stTSM.ZOOM_CHECK_FLAG = 0x00;
   2454                   stUART4.RX_REQUEST_CMD = TSM_CALL_TOTAL_ZOOM_POSITION;
   2455                   Send_TSM_Data(TSM_CALL_TOTAL_ZOOM_POSITION, 0x00, 0x00, 0x00, 0x06, TSM_COMMAND_TIMER_DELAY);
   2456                }
   2457          
   2458                if (stTSM.FOCUS_CHECK_FLAG == 0x01)
   2459                {
   2460                   stTSM.FOCUS_CHECK_FLAG = 0x00;
   2461                   stUART4.RX_REQUEST_CMD = TSM_CALL_FOCUS_POSITION;
   2462                   Send_TSM_Data(TSM_CALL_FOCUS_POSITION, 0x00, 0x00, 0x00, 0x06, TSM_COMMAND_TIMER_DELAY);
   2463                }
   2464          
   2465                if (!stUART4.TX_REQUEST)
   2466                   stUART4.TX_ACK = 0x01;
   2467          
   2468                stUART4.TX_READY = 0;
   2469          
   2470                //Send_Data_Clear(u_Leng);
   2471             }
   2472          
   2473             // Send Ack Trans
   2474             if (stUART4.TX_ACK)
   2475             {
   2476                //Send_UART4_Ack(0xB0, 0x03, 0x01, u_Comm, u_Response_Data, 5);
   2477          
   2478                stUART4.TX_ACK = 0;
   2479             }
   2480          }
   2481          
   2482          /***************************************************************************************************************************
   2483          * Function : TCM_Data_Handing
   2484          * Protocol Version : 2.12 (2017.05.16)
   2485          * Data Architecture :
   2486          BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]		BYTE[..]		BYTE(n)[LENGTH+4]	BYTE(n+1)[LENGTH+4]
   2487          0xB0		0x0B		LENGTH		ADDR		COMM		DATA		...			CS					0xBF
   2488          ****************************************************************************************************************************/
   2489          void TCM_Data_Handing(u8 u_Port, u8 u_Comm, u8 u_Leng)
   2490          {
   2491             u8 u_Cmd = 0x00, u_Length = 0x06;
   2492             u8 u_Data1 = 0x00, u_Data2 = 0x00, u_Data3 = 0x00, u_Data4 = 0x00, u_Data5 = 0x00;
   2493             u8 u_Data6 = 0x00, u_Data7 = 0x00, u_Data8 = 0x00, u_Data9 = 0x00;
   2494             u8 u_Response_Data = 0x00;
   2495          
   2496             u8 u8_Convert_Data[10];
   2497             u16 u16_Convert_Data = 0x0000;
   2498          
   2499             switch (u_Port)
   2500             {
   2501             case SYSTEM_INDEX:
   2502          
   2503                u_Cmd = stSYS.RX_BUF[0][5];
   2504                u_Data1 = stSYS.RX_BUF[0][6];
   2505                u_Data2 = stSYS.RX_BUF[0][7];
   2506                u_Data3 = stSYS.RX_BUF[0][8];
   2507          
   2508                u_Data4 = stSYS.RX_BUF[0][9];
   2509                u_Data5 = stSYS.RX_BUF[0][10];
   2510                u_Data6 = stSYS.RX_BUF[0][11];
   2511          
   2512                u_Data7 = stSYS.RX_BUF[0][12];
   2513                u_Data8 = stSYS.RX_BUF[0][13];
   2514                u_Data9 = stSYS.RX_BUF[0][14];
   2515          
   2516                break;
   2517          
   2518             case USART1_INDEX:
   2519          
   2520                u_Cmd = stUSART1.RX_BUF[4];
   2521                u_Data1 = stUSART1.RX_BUF[5];
   2522                u_Data2 = stUSART1.RX_BUF[6];
   2523                u_Data3 = stUSART1.RX_BUF[7];
   2524          
   2525                u_Data4 = stUSART1.RX_BUF[8];
   2526                u_Data5 = stUSART1.RX_BUF[9];
   2527                u_Data6 = stUSART1.RX_BUF[10];
   2528          
   2529                u_Data7 = stUSART1.RX_BUF[11];
   2530                u_Data8 = stUSART1.RX_BUF[12];
   2531                u_Data9 = stUSART1.RX_BUF[13];
   2532          
   2533                break;
   2534          
   2535             case USART5_INDEX:
   2536          
   2537                u_Cmd = stUART5.RX_BUF[4];
   2538                u_Data1 = stUART5.RX_BUF[5];
   2539                u_Data2 = stUART5.RX_BUF[6];
   2540                u_Data3 = stUART5.RX_BUF[7];
   2541          
   2542                u_Data4 = stUART5.RX_BUF[8];
   2543                u_Data5 = stUART5.RX_BUF[9];
   2544                u_Data6 = stUART5.RX_BUF[10];
   2545          
   2546                u_Data7 = stUSART1.RX_BUF[11];
   2547                u_Data8 = stUSART1.RX_BUF[12];
   2548                u_Data9 = stUSART1.RX_BUF[13];
   2549          
   2550                break;
   2551          
   2552             default:
   2553                break;
   2554             }
   2555          
   2556             switch (u_Comm)
   2557             {
   2558                // 2.3.1. Camera Initialize (0x01)
   2559             case TCM_INITIALIZE:
   2560                stUART4.TX_READY = 0x01;
   2561                break;
   2562          
   2563                // 2.3.2. Rebooting (0x02)
   2564             case TCM_REBOOTING:
   2565                stUART4.TX_READY = 0x01;
   2566                break;
   2567          
   2568                // 2.3.3. Save Current Setting Option (0x04)
   2569             case TCM_SAVE_CURRENT_SETTING_OPTION:
   2570                stUART4.TX_READY = 0x01;
   2571                break;
   2572          
   2573                // 2.3.4. Zoom/Focus Stop (Digital Zoom, Optical Zoom, Focus) (0x10)
   2574             case TCM_ZOOM_FOCUS_STOP:
   2575                stUART4.TX_READY = 0x01;
   2576                break;
   2577          
   2578                // 2.3.5. Digital Zoom Start (0x11)
   2579             case TCM_DIGITAL_ZOOM_START:
   2580                stUART4.TX_READY = 0x01;
   2581                break;
   2582          
   2583                // 2.3.6. Digital Zoom Direct (0x12)
   2584             case TCM_DIGITAL_ZOOM_DIRECT:
   2585                stUART4.TX_READY = 0x01;
   2586                break;
   2587          
   2588                // 2.3.7. Optical Zoom Direct (0x13)
   2589             case TCM_OPTICAL_ZOOM_DIRECT:
   2590                u_Length = 0x08;
   2591                stUART4.TX_READY = 0x01;
   2592                break;
   2593          
   2594                // 2.3.8. Optical Zoom Start (0x14)
   2595             case TCM_OPTICAL_ZOOM_START:
   2596                stUART4.TX_READY = 0x01;
   2597                break;
   2598          
   2599                // 2.3.9. Save FOV (0x15)
   2600             case TCM_SAVE_FOV:
   2601                stUART4.TX_READY = 0x01;
   2602                break;
   2603          
   2604                // 2.3.10. Move FOV (0x16)
   2605             case TCM_MOVE_FOV:
   2606                u_Cmd = 0x18;
   2607                stUART4.TX_READY = 0x01;
   2608                break;
   2609          
   2610                // 2.3.10.1 Focus Stop Sub (0x17)
   2611             case TCM_FOCUS_STOP_SUB:
   2612                u_Cmd = 0xA2;
   2613                stUART4.TX_READY = 0x01;
   2614                break;
   2615          
   2616                // 2.3.13. Focus Start (0x18)
   2617             case TCM_FOCUS_START:
   2618                stUART4.TX_READY = 0x01;
   2619                break;
   2620          
   2621                // IP  PTZ Convert Data
   2622             case CVT_AF_EXCUTE:
   2623                u_Cmd = TCM_AF_EXECUTE;
   2624                stUART4.TX_READY = 0x01;
   2625                break;
   2626          
   2627                // 2.3.14. Integral Time Set (0x1A)
   2628             case TCM_INTEGRAL_TIME_SET:
   2629                stUART4.TX_READY = 0x01;
   2630                break;
   2631          
   2632                // 2.3.15. Digital Zoom Enable Set (0x1C)
   2633             case TCM_DIGITAL_ZOOM_ENABLE_SET:
   2634                stUART4.TX_READY = 0x01;
   2635                break;
   2636          
   2637                // 2.3.29. Total Zoom Start (0x20)
   2638             case TCM_TOTAL_ZOOM_START:
   2639                u_Data2 = 0x07;
   2640                stUART4.TX_READY = 0x01;
   2641                break;
   2642          
   2643                // 2.3.16. AGC Type Set (GAIN, OFFSET) (0x21)
   2644             case TCM_AGC_TYPE_SET:
   2645                u_Length = 0x08;
   2646                stUART4.TX_READY = 0x01;
   2647                break;
   2648          
   2649                // 2.3.28. Total Zoom Direct (0x22)
   2650             case TCM_TOTAL_ZOOM_DIRECT:
   2651                stUART4.TX_READY = 0x01;
   2652                break;
   2653          
   2654                // 2.3.28.1. Total Zoom Stop Sub (0x23)
   2655             case TCM_TOTAL_ZOOM_STOP_SUB:
   2656                stUART4.TX_READY = 0x01;
   2657                break;
   2658          
   2659                // 2.3.17. AGC Mode Set (0x26)
   2660             case TCM_AGC_MODE_SET:
   2661          
   2662                switch (u_Port)
   2663                {
   2664                case SYSTEM_INDEX:
   2665                   stUART4.TX_READY = 0x01;
   2666                   break;
   2667          
   2668                case USART1_INDEX:
   2669                   stUART4.TX_READY = 0x01;
   2670                   break;
   2671          
   2672                case USART5_INDEX:
   2673          
   2674                   switch (u_Data1)
   2675                   {
   2676                   case 0x00:
   2677                      Send_TCM_Data(TCM_AGC_TYPE_SET, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, TCM_COMMAND_TIMER_DELAY);
   2678                      stTCM.AGC_TYPE_SET = 0x00;
   2679                      break;
   2680          
   2681                   case 0x01:
   2682                      if (stTCM.AGC_TYPE_SET == 0x00)
   2683                         Send_TCM_Data(TCM_AGC_TYPE_SET, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, TCM_COMMAND_TIMER_DELAY);
   2684                      Send_TCM_Data(TCM_AGC_MODE_SET, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, TCM_COMMAND_TIMER_DELAY);
   2685                      stTCM.AGC_TYPE_SET = 0x01;
   2686                      break;
   2687          
   2688                   case 0x02:
   2689                      if (stTCM.AGC_TYPE_SET == 0x00)
   2690                         Send_TCM_Data(TCM_AGC_TYPE_SET, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, TCM_COMMAND_TIMER_DELAY);
   2691                      Send_TCM_Data(TCM_AGC_MODE_SET, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, TCM_COMMAND_TIMER_DELAY);
   2692                      stTCM.AGC_TYPE_SET = 0x02;
   2693                      break;
   2694          
   2695                   default:
   2696                      break;
   2697                   }
   2698          
   2699                   break;
   2700                }
   2701          
   2702                break;
   2703          
   2704                // 2.3.18. Color Mode Set (0x27)
   2705             case TCM_COLOR_MODE_SET:
   2706                stUART4.TX_READY = 0x01;
   2707                break;
   2708          
   2709                // 2.3.19. AGC Center Position Set (0x29)
   2710             case TCM_AGC_CENTER_POSITION_SET:
   2711                stUART4.TX_READY = 0x01;
   2712                break;
   2713          
   2714                // 2.3.20. AGC Limit Level Set (0x2A)
   2715             case TCM_AGC_LIMIT_LEVEL_SET:
   2716                stUART4.TX_READY = 0x01;
   2717                break;
   2718          
   2719                // 2.3.21. AGC ROI (Region of Interest) Set (0x2B)
   2720             case TCM_AGC_ROI_SET:
   2721                stUART4.TX_READY = 0x01;
   2722                break;
   2723          
   2724                // 2.3.22. MIDE Level Set (0x2C)
   2725             case TCM_MIDE_LEVEL_SET:
   2726                stUART4.TX_READY = 0x01;
   2727                break;
   2728          
   2729                // 2.3.23. SHARPNESS Level Set (0x2D)
   2730             case TCM_SHARPNESS_LEVEL_SET:
   2731                stUART4.TX_READY = 0x01;
   2732                break;
   2733          
   2734                // 2.3.24. AF ROI (Region of Interest) Set (0x2E)
   2735             case TCM_AF_ROI_SET:
   2736                stUART4.TX_READY = 0x01;
   2737                break;
   2738          
   2739                // 2.3.25. AF Mark Set (0x2F)
   2740             case TCM_AF_MARK_SET:
   2741                stUART4.TX_READY = 0x01;
   2742                break;
   2743          
   2744                // 2.3.26. AGC Smooth (0x31)
   2745             case TCM_AGC_SMOOTH:
   2746                stUART4.TX_READY = 0x01;
   2747                break;
   2748          
   2749                // 2.3.27. AF Execute (0x32)
   2750             case TCM_AF_EXECUTE:
   2751                stUART4.TX_READY = 0x01;
   2752                break;
   2753          
   2754                // 2.3.11. Save FOV EX (0x35)
   2755             case TCM_SAVE_FOV_EX:
   2756                stUART4.TX_READY = 0x01;
   2757                break;
   2758          
   2759                // 2.3.12. Move FOV EX (0x36)
   2760             case TCM_MOVE_FOV_EX:
   2761                stUART4.TX_READY = 0x01;
   2762                break;
   2763          
   2764                // 2.3.30. Calibration Shutter Use (0x40)
   2765             case TCM_CALIBRATION_SHUTTER_USE:
   2766                stUART4.TX_READY = 0x01;
   2767                break;
   2768          
   2769                // 2.3.31. Shutter Set (0x41)
   2770             case TCM_SHUTTER_SET:
   2771                stUART4.TX_READY = 0x01;
   2772                break;
   2773          
   2774                // 2.3.32. AF Mode Set (0x42)
   2775             case TCM_AF_MODE_SET:
   2776                stUART4.TX_READY = 0x01;
   2777                break;
   2778          
   2779                // 2.3.33. Mirror/Flip Mode (0x43)
   2780             case TCM_MIRROR_FLIP_MODE:
   2781          
   2782                // P3 : Status Enable : TCM .
   2783                u_Data3 = 0x00;
   2784          
   2785                stUART4.TX_READY = 0x01;
   2786                break;
   2787          
   2788                // 2.3.34. Mirror Mode Set (0x44)
   2789             case TCM_MIRROR_MODE_SET:
   2790                stUART4.TX_READY = 0x01;
   2791                break;
   2792          
   2793                // 2.3.35. Flip Mode Set (0x45)
   2794             case TCM_FLIP_MODE_SET:
   2795                stUART4.TX_READY = 0x01;
   2796                break;
   2797          
   2798                // 2.3.36. Image Freeze Set (0x46)
   2799             case TCM_IMAGE_FREEZE_SET:
   2800                stUART4.TX_READY = 0x01;
   2801                break;
   2802          
   2803                // 2.3.37. Image Color Inverse (White/Black Hot) Set (0x47)
   2804             case TCM_IMAGE_COLOR_INVERSE:
   2805                stUART4.TX_READY = 0x01;
   2806                break;
   2807          
   2808                // 2.3.38. External Communication Option Set (0x55)
   2809             case TCM_EXTERNAL_COMMUNICATION_OPTION:
   2810                stUART4.TX_READY = 0x01;
   2811                break;
   2812          
   2813                // 2.3.39. Calibration Execute (0x65)
   2814             case TCM_CALIBRATION_EXECUTE:
   2815                stUART4.TX_READY = 0x01;
   2816                break;
   2817          
   2818                // 2.3.40. Calibration Option Set (0x66)
   2819             case TCM_CALIBRATION_OPTION_SET:
   2820                stUART4.TX_READY = 0x01;
   2821                break;
   2822          
   2823                // 2.3.41. Video Mode Set (0x79)
   2824             case TCM_VIDEO_MODE_SET:
   2825                stUART4.TX_READY = 0x01;
   2826                break;
   2827          
   2828                // 2.3.42. OSD MENU Key Control (0xA0)
   2829             case TCM_OSD_MENU_KEY_CONTROL:
   2830                stUART4.TX_READY = 0x01;
   2831                break;
   2832          
   2833                // 2.3.43. ZOOM Stop (0xA1)
   2834             case TCM_ZOOM_STOP:
   2835                stUART4.TX_READY = 0x01;
   2836                break;
   2837          
   2838                // 2.3.44. FOCUS Stop (0xA2)
   2839             case TCM_FOCUS_STOP:
   2840                stUART4.TX_READY = 0x01;
   2841                break;
   2842          
   2843                // 2.3.45. ZOOM Direct (0xA3)
   2844             case TCM_ZOOM_DIRECT:
   2845                stUART4.TX_READY = 0x01;
   2846                break;
   2847          
   2848                // 2.3.46. FOCUS Direct (0xA4)
   2849             case TCM_FOCUS_DIRECT:
   2850                stUART4.TX_READY = 0x01;
   2851                break;
   2852          
   2853                // 2.3.47. OSD Information Print (0xA5)
   2854             case TCM_OSD_INFORMATION_PRINT:
   2855                stUART4.TX_READY = 0x01;
   2856                break;
   2857          
   2858                // 2.3.48. Zoom Focus Speed Set (0xA6)
   2859             case TCM_ZOOM_FOCUS_SPEED_SET:
   2860                stUART4.TX_READY = 0x01;
   2861                break;
   2862          
   2863                // 2.3.49. FOV All Initialize (0xA7)
   2864             case TCM_FOV_ALL_INITIALIZE:
   2865                stUART4.TX_READY = 0x01;
   2866                break;
   2867          
   2868                // 2.3.50. EEPROM Save (0xA8)
   2869             case TCM_EEPROM_SAVE:
   2870                stUART4.TX_READY = 0x01;
   2871                break;
   2872          
   2873                // 2.3.51. NUC Execute (0xF1)
   2874             case TCM_NUC_EXECUTE:
   2875                stUART4.TX_READY = 0x01;
   2876                break;
   2877          
   2878                // 2.3.52. Spot for BPR Set (0xF2)
   2879             case TCM_SPOT_FOR_BPR_SET:
   2880                stUART4.TX_READY = 0x01;
   2881                break;
   2882          
   2883                // 2.3.53. Move Spot (0xF3)
   2884             case TCM_MOVE_SPOT:
   2885                stUART4.TX_READY = 0x01;
   2886                break;
   2887          
   2888                // 2.3.54. Active BPR (0xF4)
   2889             case TCM_ACTIVE_BPR:
   2890                stUART4.TX_READY = 0x01;
   2891                break;
   2892          
   2893                // 2.3.55. Active BPR (0x95)
   2894             case TCM_SET_FRAME_RATE:
   2895                stUART4.TX_READY = 0x01;
   2896                break;
   2897          
   2898                // 2.3.56. Set Integral Time (0x96)
   2899             case TCM_SET_INTEGRAL_TIME:
   2900                stUART4.TX_READY = 0x01;
   2901                break;
   2902          
   2903                // 2.3.57. Operation Parameter Save (0x98)
   2904             case TCM_OPERATION_PARAMETER_SAVE:
   2905                stUART4.TX_READY = 0x01;
   2906                break;
   2907          
   2908             case TCM_DNR_MODE_SET:
   2909                stUART4.TX_READY = 0x01;
   2910                break;
   2911          
   2912             case TCM_DIS_MODE_SET:
   2913                stUART4.TX_READY = 0x01;
   2914                break;
   2915          
   2916                // 2.3.I.1. Module Status Inquiry (0x30)
   2917             case TCM_MODULE_STATUS_INQ:
   2918                stUART4.TX_READY = 0x01;
   2919                stUART4.TX_REQUEST = 0x01;
   2920                break;
   2921          
   2922                // 2.3.I.2. Camera Information Inquiry (0x80)
   2923             case TCM_CAMERA_INFORMATION_INQ:
   2924                stUART4.TX_READY = 0x01;
   2925                stUART4.TX_REQUEST = 0x01;
   2926                break;
   2927          
   2928                // 2.3.I.3. Digital Zoom Position Inquiry (0x82)
   2929             case TCM_DIGITAL_ZOOM_POSITION_INQ:
   2930                stUART4.TX_READY = 0x01;
   2931                stUART4.TX_REQUEST = 0x01;
   2932                break;
   2933          
   2934                // 2.3.I.4. AGC Mode Inquiry (0xB0)
   2935             case TCM_AGC_MODE_INQ:
   2936                stUART4.TX_READY = 0x01;
   2937                stUART4.TX_REQUEST = 0x01;
   2938                break;
   2939          
   2940                // 2.3.I.5. CONTRAST/BRIGHTNESS Level Inquiry (0xB1)
   2941             case TCM_CON_BRI_LEVEL_INQ:
   2942                stUART4.TX_READY = 0x01;
   2943                stUART4.TX_REQUEST = 0x01;
   2944                break;
   2945          
   2946                // 2.3.I.6. AGC Limit Level Inquiry (0xB2)
   2947             case TCM_AGC_LIMIT_LEVEL_INQ:
   2948                stUART4.TX_READY = 0x01;
   2949                stUART4.TX_REQUEST = 0x01;
   2950                break;
   2951          
   2952                // 2.3.I.7. AGC Center Position Inquiry (0xB3)
   2953             case TCM_AGC_CENTER_POSITION_INQ:
   2954                stUART4.TX_READY = 0x01;
   2955                stUART4.TX_REQUEST = 0x01;
   2956                break;
   2957          
   2958                // 2.3.I.8. MIDE Level Inquiry (0xB4)
   2959             case TCM_MIDE_LEVEL_INQ:
   2960                stUART4.TX_READY = 0x01;
   2961                stUART4.TX_REQUEST = 0x01;
   2962                break;
   2963          
   2964                // 2.3.I.9. SHARPNESS Level Inquiry (0xB5)
   2965             case TCM_SHARPNESS_LEVEL_INQ:
   2966                stUART4.TX_READY = 0x01;
   2967                stUART4.TX_REQUEST = 0x01;
   2968                break;
   2969          
   2970                // 2.3.I.10. Color Mode Inquiry (0xB6)
   2971             case TCM_COLOR_MODE_INQ:
   2972                stUART4.TX_READY = 0x01;
   2973                stUART4.TX_REQUEST = 0x01;
   2974                break;
   2975          
   2976                // 2.3.I.11. Mirror Mode Inquiry (0xB7)
   2977             case TCM_MIRROR_MODE_INQ:
   2978                stUART4.TX_READY = 0x01;
   2979                stUART4.TX_REQUEST = 0x01;
   2980                break;
   2981          
   2982                // 2.3.I.12. Flip Mode Inquiry (0xB8)
   2983             case TCM_FLIP_MODE_INQ:
   2984                stUART4.TX_READY = 0x01;
   2985                stUART4.TX_REQUEST = 0x01;
   2986                break;
   2987          
   2988                // 2.3.I.13. Image Freeze Inquiry (0xB9)
   2989             case TCM_IMAGE_FREEZE_INQ:
   2990                stUART4.TX_READY = 0x01;
   2991                stUART4.TX_REQUEST = 0x01;
   2992                break;
   2993          
   2994                // 2.3.I.14. Image Color Inverse (White/Black Hot) Inquiry (0xBA)
   2995             case TCM_IMAGE_COLOR_INVERSE_INQ:
   2996                stUART4.TX_READY = 0x01;
   2997                stUART4.TX_REQUEST = 0x01;
   2998                break;
   2999          
   3000                // 2.3.I.15. Digital Zoom Set Inquiry (0xBB)
   3001             case TCM_DIGITAL_ZOOM_SET_INQ:
   3002                stUART4.TX_READY = 0x01;
   3003                stUART4.TX_REQUEST = 0x01;
   3004                break;
   3005          
   3006                // 2.3.I.16. Video Mode Inquiry (0xBC)
   3007             case TCM_VIDEO_MODE_INQ:
   3008                stUART4.TX_READY = 0x01;
   3009                stUART4.TX_REQUEST = 0x01;
   3010                break;
   3011          
   3012                // 2.3.I.17. Calibration Option Inquiry (0xBD)
   3013             case TCM_CALIBRATION_OPTION_INQ:
   3014                stUART4.TX_READY = 0x01;
   3015                stUART4.TX_REQUEST = 0x01;
   3016                break;
   3017          
   3018                // 2.3.I.18. External Communication Option Inquiry (0xBE)
   3019             case TCM_EXTERNAL_COMMUNICATION_INQ:
   3020                stUART4.TX_READY = 0x01;
   3021                stUART4.TX_REQUEST = 0x01;
   3022                break;
   3023          
   3024                // 2.3.I.19. Focus Position Inquiry (0xBF)
   3025             case TCM_FOCUS_POSITION_INQ:
   3026                stUART4.TX_READY = 0x01;
   3027                stUART4.TX_REQUEST = 0x01;
   3028                break;
   3029          
   3030          
   3031                // 2.3.I.20. Integral Time Inquiry (0xC0)
   3032             case TCM_INTEGRAL_TIME_INQ:
   3033                stUART4.TX_READY = 0x01;
   3034                stUART4.TX_REQUEST = 0x01;
   3035                break;
   3036          
   3037                // 2.3.I.21. AF ROI (Region of Interest) Inquiry (0xC1)
   3038             case TCM_AF_ROI_INQ:
   3039                stUART4.TX_READY = 0x01;
   3040                stUART4.TX_REQUEST = 0x01;
   3041                break;
   3042          
   3043                // 2.3.I.22. AGC Type Inquiry (GAIN, OFFSET) (0xC2)
   3044             case TCM_AGC_TYPE_INQ:
   3045                stUART4.TX_READY = 0x01;
   3046                stUART4.TX_REQUEST = 0x01;
   3047                break;
   3048          
   3049                // 2.3.I.23. AGC Smooth Inquiry (0xC3)
   3050             case TCM_AGC_SMOOTH_INQ:
   3051                stUART4.TX_READY = 0x01;
   3052                stUART4.TX_REQUEST = 0x01;
   3053                break;
   3054          
   3055                // 2.3.I.24. Optical Zoom & Focus Position Inquiry (0xC4)
   3056             case TCM_OPTICAL_ZOOM_FOCUS_POS_INQ:
   3057                stUART4.TX_READY = 0x01;
   3058                stUART4.TX_REQUEST = 0x01;
   3059                break;
   3060          
   3061                // 2.3.I.25. Zoom & Focus Speed Inquiry (0xC5)
   3062             case TCM_ZOOM_FOCUS_SPEED_INQ:
   3063                stUART4.TX_READY = 0x01;
   3064                stUART4.TX_REQUEST = 0x01;
   3065                break;
   3066          
   3067                // 2.3.I.26. AF Mark Inquiry (0xC6)
   3068             case TCM_AF_MARK_INQ:
   3069                stUART4.TX_READY = 0x01;
   3070                stUART4.TX_REQUEST = 0x01;
   3071                break;
   3072          
   3073                // 2.3.I.27. Shutter Set Inquiry (0xC7)
   3074             case TCM_SHUTTER_SET_INQ:
   3075                stUART4.TX_READY = 0x01;
   3076                stUART4.TX_REQUEST = 0x01;
   3077                break;
   3078          
   3079                // 2.3.I.28. AF Mode Inquiry (0xC8)
   3080             case TCM_AF_MODE_INQ:
   3081                stUART4.TX_READY = 0x01;
   3082                stUART4.TX_REQUEST = 0x01;
   3083                break;
   3084          
   3085                // 2.3.I.29. AGC ROI Inquiry (0xC9)
   3086             case TCM_AGC_ROI_INQ:
   3087                stUART4.TX_READY = 0x01;
   3088                stUART4.TX_REQUEST = 0x01;
   3089                break;
   3090          
   3091                // 2.3.I.30. Cooler Runtime Inquiry (0xCA)
   3092             case TCM_COOLER_RUNTIME_INQ:
   3093                stUART4.TX_READY = 0x01;
   3094                stUART4.TX_REQUEST = 0x01;
   3095                break;
   3096          
   3097                // 2.3.I.31. ZOOM POS Inquiry (0xCB)
   3098             case TCM_ZOOM_POS_INQ:
   3099                stUART4.TX_READY = 0x01;
   3100                stUART4.TX_REQUEST = 0x01;
   3101                break;
   3102          
   3103                // 2.3.I.32. Power Cycle Inquiry (0xCE)
   3104             case TCM_POWER_CYCLE_INQ:
   3105                stUART4.TX_READY = 0x01;
   3106                stUART4.TX_REQUEST = 0x01;
   3107                break;
   3108          
   3109                // 2.3.I.33. Get Temperature (0xD0)
   3110             case TCM_GET_TEMPERATURE_INQ:
   3111                stUART4.TX_READY = 0x01;
   3112                stUART4.TX_REQUEST = 0x01;
   3113                break;
   3114          
   3115                // 2.3.I.34. Shutter Use Calibration (0xD1)
   3116             case TCM_CALIBRATION_METHOD_INQ:
   3117                stUART4.TX_READY = 0x01;
   3118                stUART4.TX_REQUEST = 0x01;
   3119                break;
   3120          
   3121                // 2.3.I.35. LENS Information Inquiry (0xD2)
   3122             case TCM_LENS_INFORMATION_INQ:
   3123                stUART4.TX_READY = 0x01;
   3124                stUART4.TX_REQUEST = 0x01;
   3125                break;
   3126          
   3127                // 2.3.I.36.  Total Zoom Position Inquiry (0xD5)
   3128             case TCM_TOTAL_ZOOM_POSITION_INQ:
   3129                stUART4.TX_READY = 0x01;
   3130                stUART4.RX_REQUEST_CMD = TCM_TOTAL_ZOOM_POSITION_INQ;
   3131                break;
   3132          
   3133                // 2.3.I.37. MY ID Inquiry (0xF0)
   3134             case TCM_MY_ID_INQ:
   3135                stUART4.TX_READY = 0x01;
   3136                stUART4.TX_REQUEST = 0x01;
   3137                break;
   3138          
   3139                // 2.3.I.38. Get F/W Update (0xFA)
   3140             case TCM_GET_FW_UPDATE_INQ:
   3141                stUART4.TX_READY = 0x01;
   3142                stUART4.TX_REQUEST = 0x01;
   3143                break;
   3144          
   3145                // 2.3.I.38. Get FPGA Version (0xF8)
   3146             case TCM_GET_FPGA_VERSION:
   3147                stUART4.TX_READY = 0x01;
   3148                stUART4.TX_REQUEST = 0x01;
   3149                break;
   3150          
   3151                // Get ENGINE Version (0xF9)
   3152             case TCM_GET_ENGINE_VERSION:
   3153                stUART4.TX_READY = 0x01;
   3154                stUART4.TX_REQUEST = 0x01;
   3155                break;
   3156          
   3157             default:
   3158                stUART4.TX_READY = 0x01;
   3159                break;
   3160             }
   3161          
   3162             stUART4.TX_CMD = u_Cmd;
   3163             stUART4.TX_PARAMETER1 = u_Data1;
   3164             stUART4.TX_PARAMETER2 = u_Data2;
   3165             stUART4.TX_PARAMETER3 = u_Data3;
   3166             stUART4.TX_PARAMETER4 = u_Data4;
   3167             stUART4.TX_PARAMETER5 = u_Data5;
   3168             stUART4.TX_PARAMETER6 = u_Data6;
   3169             stUART4.TX_PARAMETER7 = u_Data7;
   3170             stUART4.TX_PARAMETER8 = u_Data8;
   3171             stUART4.TX_PARAMETER9 = u_Data9;
   3172          
   3173             // Send TSM Command & Data Trans
   3174             if (stUART4.TX_READY)
   3175             {
   3176                switch (u_Length)
   3177                {
   3178                case 0x06:
   3179                   Send_TCM_Data(u_Cmd, u_Data1, u_Data2, u_Data3, u_Data4, u_Data5, u_Data6, u_Data7, u_Data8, u_Data9, 0x06, TCM_COMMAND_TIMER_DELAY);
   3180                   break;
   3181          
   3182                case 0x08:
   3183                   Send_TCM_Data(u_Cmd, u_Data1, u_Data2, u_Data3, u_Data4, u_Data5, u_Data6, u_Data7, u_Data8, u_Data9, 0x08, TCM_COMMAND_TIMER_DELAY);
   3184                   break;
   3185          
   3186                case 0x0C:
   3187                   Send_TCM_Data(u_Cmd, u_Data1, u_Data2, u_Data3, u_Data4, u_Data5, u_Data6, u_Data7, u_Data8, u_Data9, 0x0C, TCM_COMMAND_TIMER_DELAY);
   3188                   break;
   3189                }
   3190          
   3191                if (stTSM.ZOOM_CHECK_FLAG == 0x01)
   3192                {
   3193                   stTSM.ZOOM_CHECK_FLAG = 0x00;
   3194                   stUART4.RX_REQUEST_CMD = TCM_TOTAL_ZOOM_POSITION_INQ;
   3195                   Send_TCM_Data(TCM_TOTAL_ZOOM_POSITION_INQ, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, TCM_COMMAND_TIMER_DELAY);
   3196                }
   3197          
   3198                if (stTSM.FOCUS_CHECK_FLAG == 0x01)
   3199                {
   3200                   stTSM.FOCUS_CHECK_FLAG = 0x00;
   3201                   stUART4.RX_REQUEST_CMD = TCM_FOCUS_POSITION_INQ;
   3202                   Send_TCM_Data(TCM_FOCUS_POSITION_INQ, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, TCM_COMMAND_TIMER_DELAY);
   3203                }
   3204          
   3205                if (!stUART4.TX_REQUEST)
   3206                   stUART4.TX_ACK = 0x01;
   3207          
   3208                stUART4.TX_READY = 0;
   3209          
   3210                //Send_Data_Clear(u_Leng);
   3211             }
   3212          
   3213             // Send Ack Trans
   3214             if (stUART4.TX_ACK)
   3215             {
   3216                //Send_UART4_Ack(0xB0, 0x03, 0x01, u_Comm, u_Response_Data, 5);
   3217          
   3218                stUART4.TX_ACK = 0;
   3219             }
   3220          }
   3221          
   3222          /***************************************************************************************************************************
   3223          * Function : PTZ_Data_Handing
   3224          * Protocol Version : 0.1 (2016.04.11)
   3225          * Data Architecture :
   3226          BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]		BYTE[..]		BYTE(n)[LENGTH+4]	BYTE(n+1)[LENGTH+4]
   3227          0xC0		0x0C		LENGTH		ADDR		COMM		DATA		...			CS					0xCF
   3228          ****************************************************************************************************************************/
   3229          void PTZ_Data_Handing(u8 u_Comm, u8 u_Leng)
   3230          {
   3231             u8 i = 0, i_Max = u_Leng + 5;
   3232          
   3233             switch (u_Comm)
   3234             {
   3235                // 3.10. Set Preset & Temperature Option (0x10)
   3236             case PTZ_SET_PRESET_TEMPERATURE_OPTION:
   3237          
   3238                stUSART1.TX_READY = 0x01;
   3239          
   3240                break;
   3241          
   3242                // 3.11. Set Preset Index & Name (0x11)
   3243             case PTZ_SET_PRESET_AND_INDEX_NAME:
   3244          
   3245                stUSART1.TX_READY = 0x01;
   3246          
   3247                break;
   3248          
   3249                // 3.F1. PTZ Remote Reset (0xF1)
   3250             case PTZ_REMOTE_RESET:
   3251          
   3252                stUSART1.TX_READY = 0x01;
   3253          
   3254                break;
   3255             }
   3256          
   3257          
   3258             // Send USART1 Command & Data Trans
   3259             if (stUSART1.TX_READY)
   3260             {
   3261                for (i = 0; i < i_Max; i++)
   3262                {
   3263                   stUSART1.TX_BUF[i] = stUART5.RX_BUF[i];
   3264                }
   3265          
   3266                stUSART1.TX_CNT = 0;
   3267                stUSART1.TX_MAX = i_Max;
   3268          
   3269                USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   3270                Delay_1ms(MAIN_COMMAND_TIMER_DELAY);
   3271          
   3272                stUSART1.TX_READY = 0x00;
   3273          
   3274             }
   3275          }
   3276          
   3277          /***************************************************************************************************************************
   3278          * Function : DATA_Request_Handing
   3279          * Protocol Version : 0.1 (2016.04.11)
   3280          * Data Architecture :
   3281          BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]		BYTE[..]		BYTE(n)[LENGTH+4]	BYTE(n+1)[LENGTH+4]
   3282          0xD0		0x0D		LENGTH		ADDR		COMM		DATA		...			CS					0xDF
   3283          ****************************************************************************************************************************/
   3284          void DATA_Request_Handing(u8 u_Comm, u8 u_Leng)
   3285          {}
   3286          
   3287          /***************************************************************************************************************************
   3288          * Function : OPTION_Data_Handing
   3289          * Protocol Version : 0.1 (2016.04.11)
   3290          * Data Architecture :
   3291          BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]		BYTE[..]		BYTE(n)[LENGTH+4]	BYTE(n+1)[LENGTH+4]
   3292          0xE0		0x0E		LENGTH		ADDR		COMM		DATA		...			CS					0xEF
   3293          ****************************************************************************************************************************/
   3294          void OPTION_Data_Handing(u8 u_Port, u8 u_Comm, u8 u_Leng)
   3295          {
   3296             u8 i = 0, i_Max = u_Leng + 5;
   3297          
   3298             u8 u_Cmd = 0x00;	// Camera Command
   3299             u8 u_Data1 = 0x00, u_Data2 = 0x00, u_Data3 = 0x00, u_Data4 = 0x00, u_Data5 = 0x00;
   3300             u8 u_Response_Data = 0x00;
   3301          
   3302             u8 u8_Convert_Data[10];
   3303             u16 u16_Convert_Data = 0x0000;
   3304          
   3305             switch (u_Port)
   3306             {
   3307             case SYSTEM_INDEX:
   3308          
   3309                u_Cmd = stSYS.RX_BUF[0][5];
   3310                u_Data1 = stSYS.RX_BUF[0][6];
   3311                u_Data2 = stSYS.RX_BUF[0][7];
   3312                u_Data3 = stSYS.RX_BUF[0][8];
   3313          
   3314                break;
   3315          
   3316             case USART1_INDEX:
   3317          
   3318                u_Cmd = stUSART1.RX_BUF[4];
   3319                u_Data1 = stUSART1.RX_BUF[5];
   3320                u_Data2 = stUSART1.RX_BUF[6];
   3321                u_Data3 = stUSART1.RX_BUF[7];
   3322          
   3323                break;
   3324          
   3325             case USART5_INDEX:
   3326          
   3327                u_Cmd = stUART5.RX_BUF[4];
   3328                u_Data1 = stUART5.RX_BUF[5];
   3329                u_Data2 = stUART5.RX_BUF[6];
   3330                u_Data3 = stUART5.RX_BUF[7];
   3331                u_Data4 = stUART5.RX_BUF[8];
   3332                u_Data5 = stUART5.RX_BUF[9];
   3333          
   3334                break;
   3335          
   3336             default:
   3337                break;
   3338             }
   3339          
   3340             switch (u_Comm)
   3341             {
   3342             case OPTION_SET_ETHERNET_INIT:
   3343          
   3344                stUSART1.TX_READY = 0x01;
   3345          
   3346                break;
   3347          
   3348             case OPTION_SET_WIPER:
   3349          
   3350                switch (stDIP.MODE2)
   3351                {
   3352                case 0x00:
   3353          
   3354                   if ((u_Data2 == 0x00) || (u_Data2 > 0x0F))
   3355                      break;
   3356          
   3357                   stWIPER2.OPTION = u_Data1;
   3358                   stWIPER2.COUNT = u_Data2;
   3359                   stWIPER2.DWELL_TIME = u_Data3;
   3360          
   3361                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_OPTION, stWIPER2.OPTION);
   3362                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_COUNT, stWIPER2.COUNT);
   3363                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_DWELL_TIME, stWIPER2.DWELL_TIME);
   3364          
   3365                   break;
   3366          
   3367                case 0x01:
   3368          
   3369                   if ((u_Data2 == 0x00) || (u_Data2 > 0x0F))
   3370                      break;
   3371          
   3372                   stWIPER2.OPTION = u_Data1;
   3373                   stWIPER2.COUNT = u_Data2;
   3374                   stWIPER2.DWELL_TIME = u_Data3;
   3375          
   3376                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_OPTION, u_Data1);
   3377                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_COUNT, u_Data2);
   3378                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_DWELL_TIME, u_Data3);
   3379          
   3380                   break;
   3381          
   3382                default:
   3383                   break;
   3384                }
   3385          
   3386          
   3387          
   3388                break;
   3389          
   3390             case OPTION_STOP_WIPER:
   3391          
   3392                switch (stDIP.MODE2)
   3393                {
   3394                case 0x00:
   3395          
   3396                   switch (u_Data1)
   3397                   {
   3398                   case 0x00:
   3399                      stWIPER2.STOP_MODE = WIPER_STOP_ORIGIN;
   3400                      break;
   3401          
   3402                   case 0x01:
   3403                      stWIPER2.STOP_MODE = WIPER_STOP_EMERGENCY;
   3404                      break;
   3405                   }
   3406          
   3407                   if (stWIPER2.DWELL_TIMER_FLAG)
   3408                      stWIPER2.DWELL_TIMER_FLAG = 0x00;
   3409                   if (stWIPER2.CONTINUOUS_FLAG == 0x01)
   3410                   {
   3411                      stWIPER2.CONTINUOUS_FLAG = 0x00;
   3412                   }
   3413          
   3414                   break;
   3415          
   3416                case 0x01:
   3417          
   3418                   stWIPER1.ACTIVE_COUNT = 0;
   3419                   stWIPER1.DWELL_TIME = 0;
   3420          
   3421                   break;
   3422          
   3423                default:
   3424                   break;
   3425                }
   3426          
   3427                break;
   3428          
   3429             case OPTION_RUN_WIPER:
   3430          
   3431                switch (stDIP.MODE2)
   3432                {
   3433                case 0x00:
   3434          
   3435                   stWIPER2.OPTION = u_Data1;
   3436          
   3437                   stWIPER2.COUNT = AT24C256C_EEPROM_Read(EEP_SET_WIPER_COUNT);
   3438                   stWIPER2.DWELL_TIME = AT24C256C_EEPROM_Read(EEP_SET_WIPER_DWELL_TIME);
   3439                   stWIPER2.SPRITE_TIME = AT24C256C_EEPROM_Read(EEP_SET_WASHER_SPRITE_TIME);
   3440                   stWIPER2.CONTINUOUS_TIME = AT24C256C_EEPROM_Read(EEP_SET_WIPER_CONTINUOUS_TIME);
   3441          
   3442                   switch (stWIPER2.OPTION)
   3443                   {
   3444                   case WIPER_NORMAL_MODE:
   3445          
   3446                      stWIPER2.COUNT = AT24C256C_EEPROM_Read(EEP_SET_WIPER_COUNT);
   3447                      if (stWIPER2.COUNT >= 0x0F)
   3448                         break;
   3449          
   3450                      stWIPER2.DWELL_TIME = AT24C256C_EEPROM_Read(EEP_SET_WIPER_DWELL_TIME);
   3451          
   3452                      stWIPER2.DWELL_TIME_DATA = stWIPER2.DWELL_TIME;
   3453                      stWIPER2.FLAG = 0x01;
   3454          
   3455                      stWIPER2.STOP_MODE = WIPER_STOP_READY;
   3456                      stWIPER2.STEP = WIPER_READY;
   3457          
   3458                      break;
   3459          
   3460                   case WIPER_SPRITE_MODE:
   3461                      break;
   3462          
   3463                   case WIPER_CONTINUOUS_MODE:
   3464          
   3465                      stWIPER2.COUNT = AT24C256C_EEPROM_Read(EEP_SET_WIPER_COUNT);
   3466                      if (stWIPER2.COUNT < 0x0F)
   3467                         break;
   3468          
   3469                      stWIPER2.DWELL_TIME = AT24C256C_EEPROM_Read(EEP_SET_WIPER_DWELL_TIME);
   3470          
   3471                      stWIPER2.DWELL_TIME_DATA = stWIPER2.DWELL_TIME;
   3472                      stWIPER2.FLAG = 0x01;
   3473          
   3474                      stWIPER2.STOP_MODE = WIPER_STOP_READY;
   3475                      stWIPER2.STEP = WIPER_READY;
   3476          
   3477                      if (stWIPER2.COUNT >= 0x0F)
   3478                      {
   3479                         stWIPER2.CONTINUOUS_FLAG = 0x01;
   3480                         stWIPER2.CONTINUOUS_ms = 0;
   3481                         stWIPER2.CONTINUOUS_s = 0;
   3482                      }
   3483          
   3484                      break;
   3485          
   3486                   default:
   3487                      break;
   3488                   }
   3489          
   3490                   break;
   3491          
   3492                case 0x01:
   3493          
   3494                   stWIPER1.ACTIVE_COUNT = AT24C256C_EEPROM_Read(EEP_SET_WIPER_COUNT);
   3495                   stWIPER1.DWELL_TIME = AT24C256C_EEPROM_Read(EEP_SET_WIPER_DWELL_TIME);
   3496          
   3497                   break;
   3498          
   3499                default:
   3500                   break;
   3501                }
   3502          
   3503          
   3504          
   3505                break;
   3506          
   3507                // 5.22. Set Wiper Option (0x22)
   3508             case OPTION_SET_WIPER_OPTION:
   3509          
   3510                if ((u_Data2 == 0x00) || (u_Data2 > 0x0F))
   3511                   break;
   3512          
   3513                stWIPER2.OPTION = u_Data1;
   3514                stWIPER2.COUNT = u_Data2;
   3515                stWIPER2.DWELL_TIME = u_Data3;
   3516                stWIPER2.SPRITE_TIME = u_Data4;
   3517                stWIPER2.CONTINUOUS_TIME = u_Data5;
   3518          
   3519                AT24C256C_EEPROM_Write(EEP_SET_WIPER_OPTION, stWIPER2.OPTION);
   3520                AT24C256C_EEPROM_Write(EEP_SET_WIPER_COUNT, stWIPER2.COUNT);
   3521                AT24C256C_EEPROM_Write(EEP_SET_WIPER_DWELL_TIME, stWIPER2.DWELL_TIME);
   3522                AT24C256C_EEPROM_Write(EEP_SET_WASHER_SPRITE_TIME, stWIPER2.SPRITE_TIME);
   3523          
   3524                if (stWIPER2.CONTINUOUS_TIME != 0xFF)
   3525                {
   3526                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_CONTINUOUS_TIME, stWIPER2.CONTINUOUS_TIME);
   3527                }
   3528          
   3529                break;
   3530          
   3531             default:
   3532                break;
   3533             }
   3534          
   3535             // Send USART1 Command & Data Trans
   3536             if (stUSART1.TX_READY)
   3537             {
   3538                for (i = 0; i < i_Max; i++)
   3539                {
   3540                   stUSART1.TX_BUF[i] = stUART5.RX_BUF[i];
   3541                }
   3542          
   3543                stUSART1.TX_CNT = 0;
   3544                stUSART1.TX_MAX = i_Max;
   3545          
   3546                USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   3547                Delay_1ms(MAIN_COMMAND_TIMER_DELAY);
   3548          
   3549                stUSART1.TX_READY = 0x00;
   3550          
   3551             }
   3552          }
   3553          
   3554          /****************************************************************************************************
   3555          * Define : PELCO_Data_Handing
   3556          * Protocol Version : 0.1 (2016.04.11)
   3557          * Data Architecture :
   3558          BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]		BYTE5[6]
   3559          0xFF			ADDR		COMM1		COMM2		DATA1		DATA2		CS		
   3560          *****************************************************************************************************/
   3561          void PELCO_Data_Handing(u8 u_Comm_High, u8 u_Comm_Low, u8 u_Data_High, u8 u_Data_Low)
   3562          {
   3563             u8 u_Cmd = 0x00, u_Data1 = 0x00, u_Data2 = 0x00, u_Data3 = 0x00;
   3564             u8 u_MCmd = 0x00, u_MData1 = 0x00, u_MData2 = 0x00, u_MData3 = 0x00;
   3565             u16 u_Pelco_Comm = 0x0000;
   3566          
   3567             u_Pelco_Comm = (u_Comm_High << 8) | u_Comm_Low;
   3568             u_Data1 = u_Data_High;
   3569             u_Data2 = u_Data_Low;
   3570          
   3571             switch (u_Pelco_Comm)
   3572             {
   3573                // Move Stop Command
   3574             case PELCO_MOVE_STOP:
   3575          
   3576                stUSART1.TX_READY = 0x01;
   3577          
   3578                switch (stINFO.MODULE_TYPE)
   3579                {
   3580                case SONY_MODULE:
   3581          
   3582                   if (stSONY.ZOOM_STATUS == ACTIVE)
   3583                   {
   3584                      u_MCmd = SONY_MANUAL_ZOOM;
   3585          
   3586                      stSONY.ZOOM_STATUS = STOP;
   3587                      stSONY.ZOOM_CHECK_FLAG = 0x01;
   3588                   }
   3589          
   3590                   if (stSONY.FOCUS_STATUS == ACTIVE)
   3591                   {
   3592                      u_MCmd = SONY_MANUAL_FOCUS;
   3593          
   3594                      stSONY.FOCUS_STATUS = STOP;
   3595                      stSONY.FOCUS_CHECK_FLAG = 0x01;
   3596                   }
   3597          
   3598          
   3599                   break;
   3600          
   3601                case TSM_MODULE:
   3602          
   3603                   if (stTSM.ZOOM_STATUS == ACTIVE)
   3604                   {
   3605                      u_MCmd = TCM_TOTAL_ZOOM_STOP_SUB;
   3606          
   3607                      stTSM.ZOOM_STATUS = STOP;
   3608                      stTSM.ZOOM_CHECK_FLAG = 0x01;
   3609                   }
   3610          
   3611                   if (stTSM.FOCUS_STATUS == ACTIVE)
   3612                   {
   3613                      u_MCmd = TCM_FOCUS_STOP_SUB;
   3614          
   3615                      stTSM.FOCUS_STATUS = STOP;
   3616                      stTSM.FOCUS_CHECK_FLAG = 0x01;
   3617                   }
   3618          
   3619                   break;
   3620          
   3621                default:
   3622                   break;
   3623          
   3624                }
   3625          
   3626                stUART4.TX_READY = 0x01;
   3627          
   3628                break;
   3629          
   3630                // Move Right Command
   3631             case PELCO_MOVE_RIGHT:
   3632                stUSART1.TX_READY = 0x01;
   3633                break;
   3634          
   3635                // Move Left Command
   3636             case PELCO_MOVE_LEFT:
   3637                stUSART1.TX_READY = 0x01;
   3638                break;
   3639          
   3640                // Move Up Command
   3641             case PELCO_MOVE_UP:
   3642                stUSART1.TX_READY = 0x01;
   3643                break;
   3644          
   3645                // Move Down Command
   3646             case PELCO_MOVE_DOWN:
   3647                stUSART1.TX_READY = 0x01;
   3648                break;
   3649          
   3650                // Move Right-Up Command
   3651             case PELCO_MOVE_RIGHT_UP:
   3652                stUSART1.TX_READY = 0x01;
   3653                break;
   3654          
   3655                // Move Left-Up Command
   3656             case PELCO_MOVE_LEFT_UP:
   3657                stUSART1.TX_READY = 0x01;
   3658                break;
   3659          
   3660                // Move Right-Down Command
   3661             case PELCO_MOVE_RIGHT_DOWN:
   3662                stUSART1.TX_READY = 0x01;
   3663                break;
   3664          
   3665                // Move Left-Down Command
   3666             case PELCO_MOVE_LEFT_DOWN:
   3667                stUSART1.TX_READY = 0x01;
   3668                break;
   3669          
   3670                // Zoom-Tele Command
   3671             case PELCO_ZOOM_TELE:
   3672          
   3673                switch (stINFO.MODULE_TYPE)
   3674                {
   3675                case SONY_MODULE:
   3676          
   3677                   u_MCmd = SONY_MANUAL_ZOOM;
   3678                   u_MData1 = 0x27;
   3679          
   3680                   stSONY.ZOOM_STATUS = ACTIVE;
   3681          
   3682                   break;
   3683          
   3684                case TSM_MODULE:
   3685          
   3686                   u_MCmd = TCM_TOTAL_ZOOM_START;
   3687                   u_MData1 = 0x00;
   3688                   u_MData2 = 0x09;
   3689          
   3690                   stTSM.ZOOM_STATUS = ACTIVE;
   3691          
   3692                   break;
   3693          
   3694                default:
   3695                   break;
   3696                }
   3697          
   3698                stUART4.TX_READY = 0x01;
   3699          
   3700                break;
   3701          
   3702                // Zoom-Wide Command
   3703             case PELCO_ZOOM_WIDE:
   3704          
   3705                switch (stINFO.MODULE_TYPE)
   3706                {
   3707                case SONY_MODULE:
   3708          
   3709                   u_MCmd = SONY_MANUAL_ZOOM;
   3710                   u_MData1 = 0x37;
   3711          
   3712                   stSONY.ZOOM_STATUS = ACTIVE;
   3713          
   3714                   break;
   3715          
   3716                case TSM_MODULE:
   3717          
   3718                   u_MCmd = TCM_TOTAL_ZOOM_START;
   3719                   u_MData1 = 0x01;
   3720                   u_MData2 = 0x09;
   3721          
   3722                   stTSM.ZOOM_STATUS = ACTIVE;
   3723          
   3724                   break;
   3725          
   3726                default:
   3727                   break;
   3728                }
   3729          
   3730                stUART4.TX_READY = 0x01;
   3731          
   3732                break;
   3733          
   3734                // Focus-Far Command
   3735             case PELCO_FOCUS_FAR:
   3736          
   3737                switch (stINFO.MODULE_TYPE)
   3738                {
   3739                case SONY_MODULE:
   3740          
   3741                   u_MCmd = SONY_MANUAL_FOCUS;
   3742                   u_MData1 = 0x24;
   3743          
   3744                   stSONY.FOCUS_STATUS = ACTIVE;
   3745          
   3746                   break;
   3747          
   3748                case TSM_MODULE:
   3749          
   3750                   u_MCmd = TSM_FOCUS_START;
   3751                   u_MData1 = 0x00;
   3752                   u_MData2 = 0x03;
   3753          
   3754                   stTSM.FOCUS_STATUS = ACTIVE;
   3755          
   3756                   break;
   3757          
   3758                default:
   3759                   break;
   3760                }
   3761          
   3762                stUART4.TX_READY = 0x01;
   3763          
   3764                break;
   3765          
   3766                // Focus-Near Command
   3767             case PELCO_FOCUS_NEAR:
   3768          
   3769                switch (stINFO.MODULE_TYPE)
   3770                {
   3771                case SONY_MODULE:
   3772          
   3773                   u_MCmd = SONY_MANUAL_FOCUS;
   3774                   u_MData1 = 0x34;
   3775          
   3776                   stSONY.FOCUS_STATUS = ACTIVE;
   3777          
   3778                   break;
   3779          
   3780                case TSM_MODULE:
   3781          
   3782                   u_MCmd = TSM_FOCUS_START;
   3783                   u_MData1 = 0x01;
   3784                   u_MData2 = 0x03;
   3785          
   3786                   stTSM.FOCUS_STATUS = ACTIVE;
   3787          
   3788                   break;
   3789          
   3790                default:
   3791                   break;
   3792                }
   3793          
   3794                stUART4.TX_READY = 0x01;
   3795          
   3796                break;
   3797          
   3798                // 5.2. Set Preset (0x03)
   3799             case PELCO_SET_PRESET:
   3800                stUSART1.TX_READY = 0x01;
   3801                break;
   3802          
   3803                // 5.3. Clear Preset (0x05)
   3804             case PELCO_CLEAR_PRESET:
   3805                stUSART1.TX_READY = 0x01;
   3806                break;
   3807          
   3808                // 5.4. Call Preset (0x07)
   3809             case PELCO_CALL_PRESET:
   3810                stUSART1.TX_READY = 0x01;
   3811                break;
   3812          
   3813                // 5.5. Set Zone(Scan) Start (0x11)
   3814             case PELCO_SET_ZONE_START:
   3815                stUSART1.TX_READY = 0x01;
   3816                break;
   3817          
   3818                // 5.6. Set Zone(Scan) End (0x13)
   3819             case PELCO_SET_ZONE_END:
   3820                stUSART1.TX_READY = 0x01;
   3821                break;
   3822          
   3823                // 5.7. Zone(Scan) On (0x1B)
   3824             case PELCO_ZONE_ON:
   3825                stUSART1.TX_READY = 0x01;
   3826                break;
   3827          
   3828                // 5.8. Zone(Scan) Off (0x1D)
   3829             case PELCO_ZONE_OFF:
   3830                stUSART1.TX_READY = 0x01;
   3831                break;
   3832          
   3833                // 5.12. Set Zero Position (0x49)
   3834             case PELCO_SET_ZERO:
   3835                stUSART1.TX_READY = 0x01;
   3836                break;
   3837             }
   3838          
   3839             // Send TSM Command & Data Trans
   3840             if (stUART4.TX_READY)
   3841             {
   3842                stUART4.TX_CMD = u_MCmd;
   3843                stUART4.TX_PARAMETER1 = u_MData1;
   3844                stUART4.TX_PARAMETER2 = u_MData2;
   3845                stUART4.TX_PARAMETER3 = u_MData3;
   3846          
   3847                switch (stINFO.MODULE_TYPE)
   3848                {
   3849                case SONY_MODULE:
   3850          
   3851                   Send_Sony_Data(u_MCmd, u_MData1, u_MData2, 0x06, SONY_COMMAND_TIMER_DELAY);
   3852          
   3853                   if (stSONY.ZOOM_CHECK_FLAG == 0x01)
   3854                   {
   3855                      stSONY.ZOOM_CHECK_FLAG = 0x00;
   3856                      stUART4.RX_REQUEST_CMD = SONY_CALL_ZOOM_POSITION;
   3857                      Send_Sony_Data(SONY_CALL_ZOOM_POSITION, 0x00, 0x00, 0x05, SONY_COMMAND_TIMER_DELAY);
   3858                   }
   3859          
   3860                   if (stSONY.FOCUS_CHECK_FLAG == 0x01)
   3861                   {
   3862                      stSONY.FOCUS_CHECK_FLAG = 0x00;
   3863                      stUART4.RX_REQUEST_CMD = SONY_CALL_FOCUS_POSITION;
   3864                      Send_Sony_Data(SONY_CALL_FOCUS_POSITION, 0x00, 0x00, 0x05, SONY_COMMAND_TIMER_DELAY);
   3865                   }
   3866          
   3867                   break;
   3868          
   3869                case TSM_MODULE:
   3870          
   3871                   Send_TSM_Data(u_MCmd, u_MData1, u_MData2, u_MData3, 0x06, TSM_COMMAND_TIMER_DELAY);
   3872          
   3873                   if (stTSM.ZOOM_CHECK_FLAG == 0x01)
   3874                   {
   3875                      stTSM.ZOOM_CHECK_FLAG = 0x00;
   3876                      stUART4.RX_REQUEST_CMD = TSM_CALL_TOTAL_ZOOM_POSITION;
   3877                      Send_TSM_Data(TSM_CALL_TOTAL_ZOOM_POSITION, 0x00, 0x00, 0x00, 0x06, TSM_COMMAND_TIMER_DELAY);
   3878                   }
   3879          
   3880                   if (stTSM.FOCUS_CHECK_FLAG == 0x01)
   3881                   {
   3882                      stTSM.FOCUS_CHECK_FLAG = 0x00;
   3883                      stUART4.RX_REQUEST_CMD = TSM_CALL_FOCUS_POSITION;
   3884                      Send_TSM_Data(TSM_CALL_FOCUS_POSITION, 0x00, 0x00, 0x00, 0x06, TSM_COMMAND_TIMER_DELAY);
   3885                   }
   3886          
   3887                   break;
   3888          
   3889                default:
   3890                   stUSART1.TX_READY = 0x01;
   3891                   break;
   3892                }
   3893          
   3894                stUART4.TX_READY = 0;
   3895          
   3896                //Send_Data_Clear(u_Leng);
   3897             }
   3898          
   3899             // Send USART1 Command & Data Trans
   3900             if (stUSART1.TX_READY)
   3901             {
   3902                stUSART1.TX_CMD = u_Cmd;
   3903                stUSART1.TX_PARAMETER1 = u_Data1;
   3904                stUSART1.TX_PARAMETER2 = u_Data2;
   3905          
   3906                Send_Pelco_Data(u_Comm_High, u_Comm_Low, u_Data1, u_Data2, 0x07, MAIN_COMMAND_TIMER_DELAY);
   3907          
   3908                if (!stUSART1.TX_REQUEST)
   3909                   stUSART1.TX_ACK = 0x01;
   3910          
   3911                stUSART1.TX_READY = 0x00;
   3912          
   3913                //Send_Data_Clear(u_Leng);
   3914             }
   3915          
   3916          }
   3917          
   3918          /*******************************************************************************
   3919          * Function Name  : OSD_Layer_Select
   3920          *******************************************************************************/
   3921          void OSD_Layer_Select(u8 u_Num)
   3922          {
   3923             switch (u_Num)
   3924             {
   3925             case MDIN_LAYER_INFORMATION:
   3926          
   3927                // ALL OFF
   3928                MDIN_Sprite_Initialization(MDIN_LAYER_COORDINATE, bOFF);
   3929                MDIN_Sprite_Initialization(MDIN_LAYER_CENTER_MSG, bOFF);
   3930                MDIN_Sprite_Initialization(MDIN_LAYER_TARGET, bOFF);
   3931          
   3932                // INFORMATION ON
   3933                MDIN_Sprite_Initialization(MDIN_LAYER_INFORMATION, bON);
   3934          
   3935                break;
   3936          
   3937             case MDIN_LAYER_TARGET:
   3938          
   3939                // ALL OFF
   3940                MDIN_Sprite_Initialization(MDIN_LAYER_COORDINATE, bOFF);
   3941                MDIN_Sprite_Initialization(MDIN_LAYER_CENTER_MSG, bOFF);
   3942                MDIN_Sprite_Initialization(MDIN_LAYER_INFORMATION, bOFF);
   3943          
   3944                // CENTER ON
   3945                MDIN_Sprite_Initialization(MDIN_LAYER_TARGET, bON);
   3946          
   3947                break;
   3948          
   3949             case MDIN_LAYER_CENTER_MSG:
   3950          
   3951                // ALL OFF
   3952                MDIN_Sprite_Initialization(MDIN_LAYER_INFORMATION, bOFF);
   3953                MDIN_Sprite_Initialization(MDIN_LAYER_COORDINATE, bOFF);
   3954                MDIN_Sprite_Initialization(MDIN_LAYER_TARGET, bOFF);
   3955          
   3956                // CENTER ON
   3957                MDIN_Sprite_Initialization(MDIN_LAYER_CENTER_MSG, bON);
   3958          
   3959                break;
   3960          
   3961             case MDIN_LAYER_COORDINATE:
   3962             default:
   3963          
   3964                // ALL OFF
   3965                MDIN_Sprite_Initialization(MDIN_LAYER_INFORMATION, bOFF);
   3966                MDIN_Sprite_Initialization(MDIN_LAYER_CENTER_MSG, bOFF);
   3967                MDIN_Sprite_Initialization(MDIN_LAYER_TARGET, bOFF);
   3968          
   3969                // COORDINATE ON
   3970                MDIN_Sprite_Initialization(MDIN_LAYER_COORDINATE, bON);
   3971          
   3972                break;
   3973             }
   3974          }
   3975          
   3976          /*******************************************************************************
   3977          * Function Name  : UART5_Data_Parser
   3978          *******************************************************************************/
   3979          void UART5_Data_Parser(void)
   3980          {
   3981             u8 u_buf[10];
   3982          
   3983             u_buf[0] = stUART5.RX_BUF[0];	// stUART5.RX_BUF[0] : Protocol Check
   3984             u_buf[2] = stUART5.RX_BUF[2];	// stUART5.RX_BUF[2] : Length Check (when, TBT Protocol), Command High Byte Check (when, PELCO Protocol)
   3985             u_buf[3] = stUART5.RX_BUF[3];	// stUART5.RX_BUF[3] : Command Low Byte Check (when, PELCO Protocol)
   3986             u_buf[4] = stUART5.RX_BUF[4];	// stUART5.RX_BUF[4] : Command Check (when, TBT Protocol), Data High Byte Check (when, PELCO Protocol)
   3987             u_buf[5] = stUART5.RX_BUF[5];	// stUART5.RX_BUF[5] : Data Low Byte Check (when, PELCO Protocol)
   3988          
   3989             /*******************************************************************************
   3990             * Status :   
   3991             *******************************************************************************/ 
   3992             //    (Sync Byte Check)
   3993             switch (u_buf[0])
   3994             {
   3995             case IP_SONY_FIRST_BYTE:
   3996          
   3997                //  
   3998                Sony_Data_Handing(USART5_INDEX, u_buf[4], u_buf[2]);	// Command Check, Length Check
   3999          
   4000                break;
   4001          
   4002             case IP_TSM_FIRST_BYTE:
   4003          
   4004                //  
   4005                switch (stINFO.THERMAL_MODEL)
   4006                {
   4007                case TSM_72:
   4008                case TSM_72T:
   4009                case TSM_1M:
   4010                case TSM_1MT:
   4011                   TSM_Data_Handing(USART5_INDEX, u_buf[4], u_buf[2]);		// Command Check, Length Check
   4012                   break;
   4013          
   4014                case TCM_640:
   4015                   TCM_Data_Handing(USART5_INDEX, u_buf[4], u_buf[2]);		// Command Check, Length Check
   4016                   break;
   4017                }
   4018          
   4019                break;
   4020          
   4021             case IP_TCM_FIRST_BYTE:
   4022          
   4023                //  
   4024                //TCM_Data_Handing(u_buf[4], u_buf[2]);	// Command Check, Length Check
   4025          
   4026                break;
   4027          
   4028             case IP_PTZ_FIRST_BYTE:
   4029          
   4030                //  
   4031                PTZ_Data_Handing(u_buf[4], u_buf[2]);		// Command Check, Length Check
   4032          
   4033                break;
   4034          
   4035             case IP_DATA_FIRST_BYTE:
   4036          
   4037                //  
   4038                DATA_Request_Handing(u_buf[4], u_buf[2]);	// Command Check, Length Check
   4039                break;
   4040          
   4041             case IP_OPTION_FIRST_BYTE:
   4042          
   4043                //  
   4044                OPTION_Data_Handing(USART5_INDEX, u_buf[4], u_buf[2]);	// Command Check, Length Check
   4045                break;
   4046          
   4047             case IP_PELCO_CHK_BYTE:
   4048          
   4049                //  
   4050                PELCO_Data_Handing(u_buf[2], u_buf[3], u_buf[4], u_buf[5]);	// Command Check, Data Check
   4051          
   4052                break;
   4053          
   4054             default:
   4055                break;
   4056             }
   4057          }
   4058          
   4059          u8 g_Po_Data[30];
   4060          
   4061          /*******************************************************************************
   4062          * Function Name  : System_Data_Parser
   4063          *******************************************************************************/
   4064          void System_Data_Parser(void)
   4065          {
   4066             u8 i = 0, i_Max = 0x00;
   4067             u8 u_Sync_Byte = 0x00;
   4068             u8 u_Cmd = 0x00, u_Leng = 0x00;
   4069             u8 u_ID = 0x00, u_Position_x = 0x00, u_Position_y = 0x00;
   4070             u8 u_Rx_Data[50];
   4071          
   4072             u8 u_PT_PAN_SIGN = 0x00, u_PT_TILT_SIGN = 0x00;
   4073             u16 u_PT_PAN_INT = 0x0000, u_PT_PAN_DECIMAL = 0x0000;
   4074             u16 u_PT_TILT_INT = 0x0000, u_PT_TILT_DECIMAL = 0x0000;
   4075          
   4076             u8 u8_Convert_Data = 0x00;
   4077             u16 u16_Convert_Data = 0x0000;
   4078          
   4079             u_Sync_Byte = stSYS.RX_BUF[0][1];
   4080          
   4081             u_Cmd = stSYS.RX_BUF[0][5];
   4082             u_Leng = stSYS.RX_BUF[0][3];
   4083             i_Max = u_Leng + 5;
   4084          
   4085             for (i = 6; i < i_Max; i++)
   4086             {
   4087                u_Rx_Data[i - 6] = stSYS.RX_BUF[0][i];
   4088                g_Po_Data[i - 6] = u_Rx_Data[i - 6];
   4089             }
   4090          
   4091             switch (u_Sync_Byte)
   4092             {
   4093             case TILT_FIRST_BYTE:
   4094          
   4095                switch (u_Cmd)
   4096                {
   4097                case MDIN_OSD_CLEAR:
   4098          
   4099                   if (stOSD.LAYER_NUM != stSYS.RX_BUF[0][6])
   4100                   {
   4101                      stOSD.LAYER_NUM = stSYS.RX_BUF[0][6];
   4102          
   4103                      OSD_Layer_Select(stOSD.LAYER_NUM);
   4104                   }
   4105          
   4106                   Send_MDIN_String_Data(MDIN_SPRITE_CLEAR, u_Leng, MDIN_COMMAND_TIMER_DELAY);
   4107          
   4108                   break;
   4109          
   4110                case MDIN_OSD_DATA:
   4111          
   4112                   if (stOSD.LAYER_NUM != stSYS.RX_BUF[0][6])
   4113                   {
   4114                      stOSD.LAYER_NUM = stSYS.RX_BUF[0][6];
   4115          
   4116                      OSD_Layer_Select(stOSD.LAYER_NUM);
   4117                   }
   4118          
   4119                   Send_MDIN_String_Data(MDIN_SPRITE_STRING, u_Leng, MDIN_COMMAND_TIMER_DELAY);
   4120          
   4121                   break;
   4122          
   4123                case MDIN_COORDINATE_DATA:
   4124          
   4125                   if (stOSD.LAYER_NUM != MDIN_LAYER_COORDINATE)
   4126                   {
   4127                      stOSD.LAYER_NUM = MDIN_LAYER_COORDINATE;
   4128          
   4129                      OSD_Layer_Select(stOSD.LAYER_NUM);
   4130                   }
   4131          
   4132                   u_PT_PAN_INT = (u_Rx_Data[1] << 4);
   4133                   u_PT_PAN_INT |= (u_Rx_Data[2]);
   4134          
   4135                   u_PT_PAN_DECIMAL = (u_Rx_Data[3] << 4);
   4136                   u_PT_PAN_DECIMAL |= (u_Rx_Data[4]);
   4137          
   4138                   switch (u_Rx_Data[5])
   4139                   {
   4140                   case 0x00:
   4141                      u_PT_TILT_SIGN = 0x00;	// NULL
   4142                      break;
   4143          
   4144                   case 0x01:
   4145                      u_PT_TILT_SIGN = 0x2D;	// -
   4146                      break;
   4147          
   4148                   default:
   4149                      break;
   4150                   }
   4151          
   4152                   u_PT_TILT_INT = (u_Rx_Data[6] << 4);
   4153                   u_PT_TILT_INT |= (u_Rx_Data[7]);
   4154                   u_PT_TILT_DECIMAL = (u_Rx_Data[8] << 4);
   4155                   u_PT_TILT_DECIMAL |= (u_Rx_Data[9]);
   4156          
   4157                   /*
   4158                   u_ID = MDIN_LAYER_CENTER_MSG;				// ID
   4159                   u_Rx_Data[0] = 0x00;		// ON
   4160                   u_Rx_Data[1] = 0x00;		// RESERVED
   4161          
   4162                   Send_MDIN_Data(MDIN_FREEZE, 0x03, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   4163                   				u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   4164                   */
   4165          
   4166                   u_ID = MDIN_LAYER_COORDINATE;										// ID : Main 0
   4167                   u_Position_x = 0x01;								// COLUMN : 1
   4168                   u_Position_y = 0x00;								// ROW : 0
   4169          
   4170                   u_Rx_Data[0] = 0x00;								// NULL
   4171                   u_Rx_Data[1] = (u_PT_PAN_INT / 100) + 0x30;			// 1
   4172                   u_Rx_Data[2] = ((u_PT_PAN_INT % 100) / 10) + 0x30;	// 8
   4173                   u_Rx_Data[3] = (u_PT_PAN_INT % 10) + 0x30;			// 0
   4174                   u_Rx_Data[4] = 0x2E;								// .
   4175                   u8_Convert_Data = (u_PT_PAN_DECIMAL / 10) + 0x30;
   4176                   u_Rx_Data[5] = u8_Convert_Data;					// 0
   4177                   u8_Convert_Data = (u_PT_PAN_DECIMAL % 10) + 0x30;
   4178                   u_Rx_Data[6] = u8_Convert_Data;					// 0
   4179                   u_Rx_Data[7] = 0x00;								// NULL
   4180                   u_Rx_Data[8] = u_PT_TILT_SIGN;					// NULL / -
   4181                   u_Rx_Data[9] = (u_PT_TILT_INT / 100) + 0x30;		// 1
   4182                   u_Rx_Data[10] = ((u_PT_TILT_INT % 100) / 10) + 0x30;	// 8
   4183                   u_Rx_Data[11] = (u_PT_TILT_INT % 10) + 0x30;		// 0
   4184                   u_Rx_Data[12] = 0x2E;								// .
   4185                   u8_Convert_Data = (u_PT_TILT_DECIMAL / 10) + 0x30;
   4186                   u_Rx_Data[13] = u8_Convert_Data;					// 0
   4187                   u8_Convert_Data = (u_PT_TILT_DECIMAL % 10) + 0x30;
   4188                   u_Rx_Data[14] = u8_Convert_Data;					// 0
   4189          
   4190                   Send_MDIN_Data(MDIN_SPRITE_STRING, 0x12, u_ID, u_Position_x, u_Position_y, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7],
   4191                                  u_Rx_Data[8], u_Rx_Data[9], u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], MDIN_COMMAND_TIMER_DELAY);
   4192          
   4193                   break;
   4194          
   4195                case MDIN_BYPASS_DATA:
   4196          
   4197                   u16_Convert_Data = u_Rx_Data[0];
   4198                   u16_Convert_Data |= (u_Rx_Data[1] << 8);
   4199          
   4200                   Send_MDIN_Data(u16_Convert_Data, u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9], u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13],
   4201                                  u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], u_Rx_Data[17], u_Rx_Data[18], u_Rx_Data[19], u_Rx_Data[20], MDIN_COMMAND_TIMER_DELAY);
   4202                   break;
   4203          
   4204                case TILT_BOOT_STATUS:
   4205          
   4206                   u_Cmd = TILT_BOOT_STATUS;
   4207                   u_Leng = 0x04;
   4208                   u_ID = MDIN_LAYER_CENTER_MSG;
   4209          
   4210                   stUSART1.TX_BUF[0] = TILT_FIRST_BYTE;
   4211                   stUSART1.TX_BUF[1] = TILT_SECOND_BYTE;
   4212                   stUSART1.TX_BUF[2] = u_Leng;
   4213                   stUSART1.TX_BUF[3] = u_ID;
   4214                   stUSART1.TX_BUF[4] = u_Cmd;
   4215                   stUSART1.TX_BUF[5] = ACTIVE;
   4216                   stUSART1.TX_BUF[6] = 0x00;
   4217          
   4218                   stUSART1.TX_BUF[7] = 0x00;
   4219                   stUSART1.TX_BUF[7] = stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5] + stUSART1.TX_BUF[6];
   4220          
   4221                   stUSART1.TX_BUF[8] = 0xCF;
   4222          
   4223                   stUSART1.TX_CNT = 0;
   4224                   stUSART1.TX_MAX = u_Leng + 5;
   4225          
   4226                   USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   4227          
   4228                   break;
   4229          
   4230                case TILT_RESET:
   4231          
   4232                   RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE);
   4233                   WWDG_SetPrescaler(WWDG_Prescaler_8);
   4234                   WWDG_SetWindowValue(80);
   4235                   WWDG_Enable(127);
   4236          
   4237                   break;
   4238          
   4239                case TILT_MDIN_RESET:
   4240          
   4241                   stINFO.BOOT_FLAG = 0x01;
   4242          
   4243                   while (stINFO.BOOT_FLAG)
   4244                   {
   4245                      Module_Auto_Sync();
   4246          
   4247                      if (stINFO.MODULE_TYPE != INDEX_NON)
   4248                         stINFO.BOOT_FLAG = 0x00;
   4249                   }
   4250          
   4251                   switch (stINFO.MODULE_TYPE)
   4252                   {
   4253                   case SONY_MODULE:
   4254          
   4255                      UART4_Init(9600);
   4256                      Delay_1ms(200);
   4257          
   4258                      break;
   4259          
   4260                   case TSM_MODULE:
   4261          
   4262                      UART4_Init(38400);
   4263          
   4264                      VIDEO_Initialization(PAL_MODE);
   4265                      Delay_1ms(200);
   4266                      MDIN_I550_Initialization();
   4267          
   4268                      stUART4.RX_REQUEST_CMD = TSM_CALL_PRODUCT_IDENTIFICATION;
   4269                      Send_TSM_Data(TSM_CALL_PRODUCT_IDENTIFICATION, 0x00, 0x00, 0x00, 0x06, TSM_COMMAND_TIMER_DELAY);
   4270                      Delay_1ms(TSM_REQUEST_TIMER_MAX);
   4271          
   4272                      stUART4.RX_REQUEST_CMD = TSM_CALL_CAMERA_INFORMATION;
   4273                      Send_TSM_Data(TSM_CALL_CAMERA_INFORMATION, 0x00, 0x00, 0x00, 0x06, TSM_COMMAND_TIMER_DELAY);
   4274                      Delay_1ms(TSM_REQUEST_TIMER_MAX);
   4275          
   4276                      stUART4.RX_REQUEST_CMD = TSM_CALL_FIRMWARE_VERSION;
   4277                      Send_TSM_Data(TSM_CALL_FIRMWARE_VERSION, 0x00, 0x00, 0x00, 0x06, TSM_COMMAND_TIMER_DELAY);
   4278                      Delay_1ms(TSM_REQUEST_TIMER_MAX);
   4279          
   4280                      break;
   4281          
   4282                   default:
   4283          
   4284                      UART4_Init(38400);
   4285          
   4286                      VIDEO_Initialization(PAL_MODE);
   4287                      Delay_1ms(200);
   4288                      MDIN_I550_Initialization();
   4289                      Delay_1ms(200);
   4290          
   4291                      Send_MDIN_Data(MDIN_OUTPUT_PATTERN, 0x03, 0x0D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, MDIN_COMMAND_TIMER_DELAY);
   4292                      Send_MDIN_Data(MDIN_OUTPUT_PATTERN, 0x03, 0x0D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, MDIN_COMMAND_TIMER_DELAY);
   4293                      Send_MDIN_Data(MDIN_OUTPUT_PATTERN, 0x03, 0x0D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, MDIN_COMMAND_TIMER_DELAY);
   4294          
   4295                      break;
   4296          
   4297                   }
   4298          
   4299                   break;
   4300          
   4301                case CALL_INFORMATION:
   4302          
   4303                   u_Cmd = CALL_INFORMATION;
   4304                   u_Leng = 0x0E;
   4305                   u_ID = 0x01;
   4306          
   4307                   stUSART1.TX_BUF[0] = TILT_FIRST_BYTE;
   4308                   stUSART1.TX_BUF[1] = TILT_SECOND_BYTE;
   4309                   stUSART1.TX_BUF[2] = u_Leng;
   4310                   stUSART1.TX_BUF[3] = u_ID;
   4311                   stUSART1.TX_BUF[4] = u_Cmd;
   4312          
   4313                   stUSART1.TX_BUF[5] = Version_High;
   4314                   stUSART1.TX_BUF[6] = Version_Low;
   4315          
   4316                   stUSART1.TX_BUF[7] = Upgrade_Year_Month;
   4317                   stUSART1.TX_BUF[8] = Upgrade_Day;
   4318          
   4319                   stUSART1.TX_BUF[9] = stINFO.MODULE_TYPE;
   4320          
   4321                   switch (stINFO.MODULE_TYPE)
   4322                   {
   4323                   case SONY_MODULE:
   4324          
   4325                      stUSART1.TX_BUF[10] = 0x00;
   4326                      stUSART1.TX_BUF[11] = 0x00;
   4327                      stUSART1.TX_BUF[12] = 0x00;
   4328                      stUSART1.TX_BUF[13] = 0x00;
   4329                      stUSART1.TX_BUF[14] = 0x00;
   4330                      stUSART1.TX_BUF[15] = 0x00;
   4331                      stUSART1.TX_BUF[16] = 0x00;
   4332          
   4333                      break;
   4334          
   4335                   case TSM_MODULE:
   4336          
   4337                      stUSART1.TX_BUF[10] = stINFO.THERMAL_MODEL;
   4338                      stUSART1.TX_BUF[11] = stINFO.THERMAL_LENS;
   4339                      stUSART1.TX_BUF[12] = stINFO.THERMAL_VER_HIGH;
   4340                      stUSART1.TX_BUF[13] = stINFO.THERMAL_VER_LOW;
   4341                      stUSART1.TX_BUF[14] = stINFO.THERMAL_DAY;
   4342                      stUSART1.TX_BUF[15] = stINFO.THERMAL_MONTH;
   4343                      stUSART1.TX_BUF[16] = stINFO.THERMAL_YEAR;
   4344          
   4345                      break;
   4346          
   4347                   default:
   4348                      break;
   4349                   }
   4350          
   4351                   stUSART1.TX_BUF[17] = 0x00;
   4352                   stUSART1.TX_BUF[17] = stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5] + stUSART1.TX_BUF[6];
   4353          
   4354                   stUSART1.TX_BUF[18] = 0xCF;
   4355          
   4356                   stUSART1.TX_CNT = 0;
   4357                   stUSART1.TX_MAX = u_Leng + 5;
   4358          
   4359                   USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   4360          
   4361                   break;
   4362          
   4363                default:
   4364                   break;
   4365                }
   4366          
   4367                break;
   4368          
   4369             case IP_SONY_FIRST_BYTE:
   4370          
   4371                Sony_Data_Handing(SYSTEM_INDEX, u_Cmd, u_Leng);		// Command Check, Length Check
   4372          
   4373                break;
   4374          
   4375             case IP_TSM_FIRST_BYTE:
   4376          
   4377                //  
   4378                switch (stINFO.THERMAL_MODEL)
   4379                {
   4380                case TSM_72:
   4381                case TSM_72T:
   4382                case TSM_1M:
   4383                case TSM_1MT:
   4384                   TSM_Data_Handing(SYSTEM_INDEX, u_Cmd, u_Leng);		// Command Check, Length Check
   4385                   break;
   4386          
   4387                case TCM_640:
   4388                   TCM_Data_Handing(SYSTEM_INDEX, u_Cmd, u_Leng);		// Command Check, Length Check
   4389                   break;
   4390                }
   4391          
   4392                break;
   4393          
   4394             case IP_OPTION_FIRST_BYTE:
   4395                OPTION_Data_Handing(SYSTEM_INDEX, u_Cmd, u_Leng);		// Command Check, Length Check
   4396                break;
   4397          
   4398             default:
   4399                break;
   4400             }
   4401          }
   4402          
   4403          /*******************************************************************************
   4404          * Function Name  : USART1_Data_Parser
   4405          *******************************************************************************/
   4406          void USART1_Data_Parser(void)
   4407          {
   4408             u8 i = 0, i_Max = 0x00;
   4409             u8 u_Cmd = 0x00, u_Leng = 0x00;
   4410             u8 u_ID = 0x00, u_Position_x = 0x00, u_Position_y = 0x00;
   4411             u8 u_Rx_Data[50];
   4412          
   4413             u8 u_PT_PAN_SIGN = 0x00, u_PT_TILT_SIGN = 0x00;
   4414             u16 u_PT_PAN_INT = 0x0000, u_PT_PAN_DECIMAL = 0x0000;
   4415             u16 u_PT_TILT_INT = 0x0000, u_PT_TILT_DECIMAL = 0x0000;
   4416          
   4417             u8 u8_Convert_Data = 0x00;
   4418             u16 u16_Convert_Data = 0x0000;
   4419          
   4420             u_Cmd = stUSART1.RX_BUF[4];
   4421             u_Leng = stUSART1.RX_BUF[2];
   4422             i_Max = u_Leng + 4;
   4423          
   4424             for (i = 5; i < i_Max; i++)
   4425             {
   4426                u_Rx_Data[i - 5] = stUSART1.RX_BUF[i];
   4427             }
   4428          
   4429             switch (stUSART1.RX_BUF[0])
   4430             {
   4431             case TILT_FIRST_BYTE:
   4432          
   4433                switch (u_Cmd)
   4434                {
   4435                case MDIN_OSD_CLEAR:
   4436          
   4437                   if (stOSD.LAYER_NUM != stUSART2.TX_BUF[5])
   4438                   {
   4439                      stOSD.LAYER_NUM = stUSART2.TX_BUF[5];
   4440          
   4441                      OSD_Layer_Select(stOSD.LAYER_NUM);
   4442                   }
   4443          
   4444                   Send_MDIN_String_Data(MDIN_SPRITE_CLEAR, u_Leng, MDIN_COMMAND_TIMER_DELAY);
   4445          
   4446                   break;
   4447          
   4448                case MDIN_OSD_DATA:
   4449          
   4450                   if (stOSD.LAYER_NUM != stUSART2.TX_BUF[5])
   4451                   {
   4452                      stOSD.LAYER_NUM = stUSART2.TX_BUF[5];
   4453          
   4454                      OSD_Layer_Select(stOSD.LAYER_NUM);
   4455                   }
   4456          
   4457                   Send_MDIN_String_Data(MDIN_SPRITE_STRING, u_Leng, MDIN_COMMAND_TIMER_DELAY);
   4458          
   4459                   break;
   4460          
   4461                case MDIN_COORDINATE_DATA:
   4462          
   4463                   if (stOSD.LAYER_NUM != MDIN_LAYER_COORDINATE)
   4464                   {
   4465                      stOSD.LAYER_NUM = MDIN_LAYER_COORDINATE;
   4466          
   4467                      OSD_Layer_Select(stOSD.LAYER_NUM);
   4468                   }
   4469          
   4470                   u_PT_PAN_INT = (u_Rx_Data[1] << 4);
   4471                   u_PT_PAN_INT |= (u_Rx_Data[2]);
   4472          
   4473                   u_PT_PAN_DECIMAL = (u_Rx_Data[3] << 4);
   4474                   u_PT_PAN_DECIMAL |= (u_Rx_Data[4]);
   4475          
   4476                   switch (u_Rx_Data[5])
   4477                   {
   4478                   case 0x00:
   4479                      u_PT_TILT_SIGN = 0x00;	// NULL
   4480                      break;
   4481          
   4482                   case 0x01:
   4483                      u_PT_TILT_SIGN = 0x2D;	// -
   4484                      break;
   4485          
   4486                   default:
   4487                      break;
   4488                   }
   4489          
   4490                   u_PT_TILT_INT = (u_Rx_Data[6] << 4);
   4491                   u_PT_TILT_INT |= (u_Rx_Data[7]);
   4492                   u_PT_TILT_DECIMAL = (u_Rx_Data[8] << 4);
   4493                   u_PT_TILT_DECIMAL |= (u_Rx_Data[9]);
   4494          
   4495                   /*
   4496                   u_ID = MDIN_LAYER_CENTER_MSG;				// ID : Main 0
   4497                   u_Rx_Data[0] = 0x00;		// ON
   4498                   u_Rx_Data[1] = 0x00;		// RESERVED
   4499          
   4500                   Send_MDIN_Data(MDIN_FREEZE, 0x03, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   4501                   				u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   4502                   */
   4503          
   4504                   u_ID = MDIN_LAYER_COORDINATE;					// ID
   4505                   u_Position_x = 0x01;								// COLUMN : 1
   4506                   u_Position_y = 0x00;								// ROW : 0
   4507          
   4508                   u_Rx_Data[0] = 0x00;								// NULL
   4509                   u_Rx_Data[1] = (u_PT_PAN_INT / 100) + 0x30;			// 1
   4510                   u_Rx_Data[2] = ((u_PT_PAN_INT % 100) / 10) + 0x30;	// 8
   4511                   u_Rx_Data[3] = (u_PT_PAN_INT % 10) + 0x30;			// 0
   4512                   u_Rx_Data[4] = 0x2E;								// .
   4513                   u8_Convert_Data = (u_PT_PAN_DECIMAL / 10) + 0x30;
   4514                   u_Rx_Data[5] = u8_Convert_Data;					// 0
   4515                   u8_Convert_Data = (u_PT_PAN_DECIMAL % 10) + 0x30;
   4516                   u_Rx_Data[6] = u8_Convert_Data;					// 0
   4517                   u_Rx_Data[7] = 0x00;								// NULL
   4518                   u_Rx_Data[8] = u_PT_TILT_SIGN;					// NULL / -
   4519                   u_Rx_Data[9] = (u_PT_TILT_INT / 100) + 0x30;		// 1
   4520                   u_Rx_Data[10] = ((u_PT_TILT_INT % 100) / 10) + 0x30;	// 8
   4521                   u_Rx_Data[11] = (u_PT_TILT_INT % 10) + 0x30;		// 0
   4522                   u_Rx_Data[12] = 0x2E;								// .
   4523                   u8_Convert_Data = (u_PT_TILT_DECIMAL / 10) + 0x30;
   4524                   u_Rx_Data[13] = u8_Convert_Data;					// 0
   4525                   u8_Convert_Data = (u_PT_TILT_DECIMAL % 10) + 0x30;
   4526                   u_Rx_Data[14] = u8_Convert_Data;					// 0
   4527          
   4528                   Send_MDIN_Data(MDIN_SPRITE_STRING, 0x12, u_ID, u_Position_x, u_Position_y, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7],
   4529                                  u_Rx_Data[8], u_Rx_Data[9], u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], MDIN_COMMAND_TIMER_DELAY);
   4530          
   4531                   break;
   4532          
   4533                default:
   4534                   break;
   4535                }
   4536          
   4537                break;
   4538          
   4539             case IP_SONY_FIRST_BYTE:
   4540          
   4541                Sony_Data_Handing(USART1_INDEX, u_Cmd, u_Leng);		// Command Check, Length Check
   4542          
   4543                break;
   4544          
   4545             case IP_TSM_FIRST_BYTE:
   4546          
   4547                //  
   4548                switch (stINFO.THERMAL_MODEL)
   4549                {
   4550                case TSM_72:
   4551                case TSM_72T:
   4552                case TSM_1M:
   4553                case TSM_1MT:
   4554                   TSM_Data_Handing(USART1_INDEX, u_Cmd, u_Leng);		// Command Check, Length Check
   4555                   break;
   4556          
   4557                case TCM_640:
   4558                   //TCM_Data_Handing(u_buf[4], u_buf[2]);		// Command Check, Length Check
   4559                   break;
   4560                }
   4561          
   4562                break;
   4563          
   4564             default:
   4565                break;
   4566             }
   4567          }
   4568          
   4569          /*******************************************************************************
   4570          * Function Name  : Before_USART1_Data_Parser
   4571          *******************************************************************************/
   4572          void Before_USART1_Data_Parser(void)
   4573          {
   4574             /*******************************************************************************
   4575             * Data Format
   4576             BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]
   4577             0xCA		0xAC		CMD			DATA1(P1)	DATA2(P2)	CS
   4578             *******************************************************************************/
   4579             u8 u_Cmd = 0x00, u_Rx_Data1 = 0x00, u_Rx_Data2 = 0x00;
   4580             u8 u_Tx_Data1 = 0x00, u_Tx_Data2 = 0x00, u_Tx_Data3 = 0x00, u_Tx_Data4 = 0x00;
   4581             u16 u_Convert_Data = 0x0000;
   4582          
   4583             if (stUSART1.RX_PARITY == 0x01)
   4584             {
   4585                stUSART1.RX_PARITY = 0x00;
   4586                u_Cmd = stUSART1.RX_BUF[2];
   4587                u_Rx_Data1 = stUSART1.RX_BUF[3];
   4588                u_Rx_Data2 = stUSART1.RX_BUF[4];
   4589          
   4590                switch (u_Cmd)
   4591                {
   4592                   /*******************************************************************************
   4593                   * Command : 0x02
   4594                   * Mode : Set Wiper
   4595                   BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]
   4596                   0xCA		0xAC		0x02		P1			P2			CS
   4597                   - P1 : Count - 0x01 ~ 0x0E (1~14), 0x0F : Continuous Active
   4598                   - P2 : Dwell Time (s) - 0x00 ~ 0x3B (0~59)
   4599                   *******************************************************************************/ 
   4600                   // 5.2. Set Wiper (0x02)
   4601                case SET_WIPER:
   4602          
   4603                   stWIPER2.COUNT = u_Rx_Data1;
   4604                   stWIPER2.DWELL_TIME_DATA = u_Rx_Data2;
   4605                   stWIPER2.FLAG = 0x01;
   4606          
   4607                   stWIPER2.STOP_MODE = WIPER_STOP_READY;
   4608                   stWIPER2.STEP = WIPER_READY;
   4609          
   4610                   if (stWIPER2.COUNT >= 0x0F)
   4611                   {
   4612                      stWIPER2.CONTINUOUS_FLAG = 0x01;
   4613                      stWIPER2.CONTINUOUS_ms = 0;
   4614                      stWIPER2.CONTINUOUS_s = 0;
   4615                   }
   4616          
   4617                   break;
   4618          
   4619                   /*******************************************************************************
   4620                   * Command : 0x03
   4621                   * Mode : Stop Wiper
   4622                   BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]
   4623                   0xCA		0xAC		0x03		P1			0x00			CS
   4624                   - P1 : 
   4625                   0x00 : Origin Stop
   4626                   0x01 : Emergency Stop 
   4627                   *******************************************************************************/ 
   4628                   // 5.3. Stop Wiper (0x03)
   4629                case STOP_WIPER:
   4630          
   4631                   switch (u_Rx_Data1)
   4632                   {
   4633                   case 0x00:
   4634                      stWIPER2.STOP_MODE = WIPER_STOP_ORIGIN;
   4635                      break;
   4636          
   4637                   case 0x01:
   4638                      stWIPER2.STOP_MODE = WIPER_STOP_EMERGENCY;
   4639                      break;
   4640                   }
   4641          
   4642                   if (stWIPER2.DWELL_TIMER_FLAG)
   4643                      stWIPER2.DWELL_TIMER_FLAG = 0x00;
   4644                   if (stWIPER2.CONTINUOUS_FLAG == 0x01)
   4645                   {
   4646                      stWIPER2.CONTINUOUS_FLAG = 0x00;
   4647                   }
   4648          
   4649                   break;
   4650          
   4651                   // 5.5. Set LRF (0x05)
   4652                case SET_LRF:
   4653          
   4654                   switch (u_Rx_Data2)
   4655                   {
   4656                   case 0x00:
   4657                      break;
   4658          
   4659                   default:
   4660          
   4661                      stLRF.CONTINUOUS_TIME_MAX = u_Rx_Data2 * 50;
   4662          
   4663                      break;
   4664                   }
   4665          
   4666                   switch (u_Rx_Data1)
   4667                   {
   4668                   case 0x01:
   4669          
   4670                      stLRF.CONTINUOUS_FLAG = 0x01;
   4671          
   4672                      break;
   4673          
   4674                   default:
   4675          
   4676                      stLRF.CONTINUOUS_FLAG = 0x00;
   4677          
   4678                      break;
   4679                   }
   4680          
   4681                   break;
   4682          
   4683          
   4684                   /*******************************************************************************
   4685                   * Command : 0x07
   4686                   * Mode : Light On/Off [0x00:Off, 0x01:On]
   4687                   BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]
   4688                   0xCA		0xAC		0x07		P1			0x00		CS
   4689                   - P1 :
   4690                   0x00 : Light Off
   4691                   0x01 : Light On
   4692                   *******************************************************************************/ 
   4693                   // 5.7. Set Light On/Off (0x07)
   4694                case SET_LIGHT:
   4695          
   4696                   switch (u_Rx_Data1)
   4697                   {
   4698                   case 0x00:
   4699          
   4700                      EXTERNAL_LIGHT_PORT_OFF;
   4701                      stLIGHT.EXTERNAL_STATUS = LIGHT_OFF;
   4702          
   4703                      break;
   4704          
   4705                   case 0x01:
   4706          
   4707                      EXTERNAL_LIGHT_PORT_ON;
   4708                      stLIGHT.EXTERNAL_STATUS = LIGHT_ON;
   4709          
   4710                      break;
   4711          
   4712                   default:
   4713                      break;
   4714                   }
   4715          
   4716                   break;
   4717          
   4718                   // 5.8. Set Zoom-Light On/Off (0x08)
   4719                case SET_ZOOM_LIGHT:
   4720          
   4721                   switch (u_Rx_Data1)
   4722                   {
   4723                   case 0x00:
   4724          
   4725                      // Zoom Light Off
   4726                      Send_Light_Data(ZOOM_LIGHT_ENABLE, 0x30, 0x30, 0x30, 0x30, 0x30, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4727                      stLIGHT.ZOOM_STATUS = LIGHT_OFF;
   4728          
   4729                      break;
   4730          
   4731                   case 0x01:
   4732          
   4733                      // Zoom Light On
   4734                      Send_Light_Data(ZOOM_LIGHT_ENABLE, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4735                      stLIGHT.ZOOM_STATUS = LIGHT_ON;
   4736          
   4737                      break;
   4738          
   4739                   default:
   4740                      break;
   4741                   }
   4742          
   4743                   break;
   4744          
   4745                   // 5.9. Set Zoom-Light Direct Position (0x09)
   4746                case SET_ZOOM_LIGHT_DIRECT_POSITION:
   4747          
   4748                   u_Convert_Data = (u_Rx_Data1 << 8);
   4749                   u_Convert_Data |= u_Rx_Data2;
   4750          
   4751                   u_Tx_Data1 = (u_Convert_Data / 1000) & 0xFF;
   4752                   if (u_Tx_Data1 >= 9)
   4753                      u_Tx_Data1 = 9;
   4754                   u_Tx_Data1 = u_Tx_Data1 + 0x30;
   4755          
   4756                   u_Convert_Data = u_Convert_Data % 1000;
   4757                   u_Tx_Data2 = (u_Convert_Data / 100) & 0xFF;
   4758                   u_Tx_Data2 = u_Tx_Data2 + 0x30;
   4759          
   4760                   u_Convert_Data = u_Convert_Data % 100;
   4761                   u_Tx_Data3 = (u_Convert_Data / 10) & 0xFF;
   4762                   u_Tx_Data3 = u_Tx_Data3 + 0x30;
   4763          
   4764                   u_Tx_Data4 = (u_Convert_Data % 10) & 0xFF;
   4765                   u_Tx_Data4 = u_Tx_Data4 + 0x30;
   4766          
   4767                   Send_Light_Data(ZOOM_LIGHT_DIRECT, 0x2B, u_Tx_Data1, u_Tx_Data2, u_Tx_Data3, u_Tx_Data4, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4768          
   4769                   break;
   4770          
   4771                   // 5.A. (Special CMD) Call Zoom-Light Data (0x0A)
   4772                case CALL_ZOOM_LIGHT_DATA:
   4773          
   4774                   Send_Light_Data(CALL_ZOOM_LIGHT_POSITION, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4775          
   4776                   break;
   4777          
   4778                   // 5.B. (Special CMD) Set Zoom-Light Manual Control (0x0B)
   4779                case SET_ZOOM_LIGHT_MANUAL_CONTROL:
   4780          
   4781                   switch (u_Rx_Data1)
   4782                   {
   4783                   case 0x00:
   4784          
   4785                      stLIGHT.DIRECTION = CMD_ZOOM_LIGHT_WIDE;
   4786                      u_Tx_Data1 = 0x30;
   4787          
   4788                      u_Tx_Data2 = u_Rx_Data2 / 100;
   4789                      u_Tx_Data2 = u_Tx_Data2 + 0x30;
   4790          
   4791                      u_Rx_Data2 = u_Rx_Data2 % 100;
   4792                      u_Tx_Data3 = u_Rx_Data2 / 10;
   4793                      u_Tx_Data3 = u_Tx_Data3 + 0x30;
   4794          
   4795                      u_Tx_Data4 = u_Rx_Data2 % 10;
   4796                      u_Tx_Data4 = u_Tx_Data4 + 0x30;
   4797          
   4798                      Send_Light_Data(ZOOM_LIGHT_STEP, CMD_ZOOM_LIGHT_WIDE, u_Tx_Data1, u_Tx_Data2, u_Tx_Data3, u_Tx_Data4, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4799          
   4800                      break;
   4801          
   4802                   case 0x01:
   4803          
   4804                      stLIGHT.DIRECTION = CMD_ZOOM_LIGHT_TELE;
   4805          
   4806                      u_Tx_Data1 = 0x30;
   4807          
   4808                      u_Tx_Data2 = u_Rx_Data2 / 100;
   4809                      u_Tx_Data2 = u_Tx_Data2 + 0x30;
   4810          
   4811                      u_Rx_Data2 = u_Rx_Data2 % 100;
   4812                      u_Tx_Data3 = u_Rx_Data2 / 10;
   4813                      u_Tx_Data3 = u_Tx_Data3 + 0x30;
   4814          
   4815                      u_Tx_Data4 = u_Rx_Data2 % 10;
   4816                      u_Tx_Data4 = u_Tx_Data4 + 0x30;
   4817          
   4818                      Send_Light_Data(ZOOM_LIGHT_STEP, CMD_ZOOM_LIGHT_TELE, u_Tx_Data1, u_Tx_Data2, u_Tx_Data3, u_Tx_Data4, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4819          
   4820                      break;
   4821          
   4822                   default:
   4823                      break;
   4824                   }
   4825          
   4826                   break;
   4827          
   4828                   // 5.C. (Special CMD) Initialization Zoom-Light (0x0C)
   4829                case INITIALIZATION_ZOOM_LIGHT:
   4830          
   4831                   Send_Light_Data(ZOOM_LIGHT_INITIALIZATION, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4832          
   4833                   break;
   4834          
   4835                   // 5.10. LRF Initialization (0x10)
   4836                case LRF_INITIALIZATION:
   4837          
   4838                   // =======================================
   4839                   // Set LRF Initialization Flag
   4840                   // =======================================
   4841                   stLRF.INIT_FLAG = 0x01;
   4842          
   4843                   break;
   4844          
   4845                   // 5.18. Set Dual Light On/Off (0x18)
   4846                case OPTION_SET_EXTERNAL_IR_MODE:
   4847          
   4848                   switch (u_Rx_Data1)
   4849                   {
   4850                   case 0x00:
   4851          
   4852                      stCDS.IR_AUTO_ENABLE = 0x01;
   4853          
   4854                      switch (stCDS.DAY_AND_NIGHT_STATUS)
   4855                      {
   4856                         // Day Mode
   4857                      case 0x00:
   4858          
   4859                         EXTERNAL_LIGHT_PORT_OFF;
   4860                         stLIGHT.EXTERNAL_STATUS = LIGHT_OFF;
   4861          
   4862                         // Zoom Light Off
   4863                         Send_Light_Data(ZOOM_LIGHT_ENABLE, 0x30, 0x30, 0x30, 0x30, 0x30, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4864                         stLIGHT.ZOOM_STATUS = LIGHT_OFF;
   4865          
   4866                         break;
   4867          
   4868                         // Night Mode
   4869                      case 0x01:
   4870          
   4871                         EXTERNAL_LIGHT_PORT_ON;
   4872                         stLIGHT.EXTERNAL_STATUS = LIGHT_ON;
   4873          
   4874                         // Zoom Light On
   4875                         Send_Light_Data(ZOOM_LIGHT_ENABLE, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4876                         stLIGHT.ZOOM_STATUS = LIGHT_ON;
   4877          
   4878                         break;
   4879                      }
   4880          
   4881                      break;
   4882          
   4883                   case 0x01:
   4884          
   4885                      stCDS.IR_AUTO_ENABLE = 0x00;
   4886          
   4887                      EXTERNAL_LIGHT_PORT_ON;
   4888                      stLIGHT.EXTERNAL_STATUS = LIGHT_ON;
   4889          
   4890                      // Zoom Light On
   4891                      Send_Light_Data(ZOOM_LIGHT_ENABLE, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4892                      stLIGHT.ZOOM_STATUS = LIGHT_ON;
   4893          
   4894                      break;
   4895          
   4896                   case 0x02:
   4897          
   4898                      stCDS.IR_AUTO_ENABLE = 0x00;
   4899          
   4900                      EXTERNAL_LIGHT_PORT_OFF;
   4901                      stLIGHT.EXTERNAL_STATUS = LIGHT_OFF;
   4902          
   4903                      // Zoom Light Off
   4904                      Send_Light_Data(ZOOM_LIGHT_ENABLE, 0x30, 0x30, 0x30, 0x30, 0x30, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4905                      stLIGHT.ZOOM_STATUS = LIGHT_OFF;
   4906          
   4907                      break;
   4908          
   4909                   default:
   4910                      break;
   4911                   }
   4912          
   4913                   break;
   4914          
   4915                   // 5.19. Set External IR Change Lux (0x19)
   4916                case OPTION_SET_EXTERNAL_IR_CHANGE_LUX:
   4917          
   4918                   stCDS.LUX = u_Rx_Data1;
   4919          
   4920                   switch (stCDS.LUX)
   4921                   {
   4922                      // -5
   4923                   case 0x75:
   4924                      stCDS.DAY_AND_NIGHT_LEVEL = 10;
   4925                      break;
   4926          
   4927                      // -4
   4928                   case 0x77:
   4929                      stCDS.DAY_AND_NIGHT_LEVEL = 9;
   4930                      break;
   4931          
   4932                      // -3
   4933                   case 0x79:
   4934                      stCDS.DAY_AND_NIGHT_LEVEL = 8;
   4935                      break;
   4936          
   4937                      // -2
   4938                   case 0x7B:
   4939                      stCDS.DAY_AND_NIGHT_LEVEL = 7;
   4940                      break;
   4941          
   4942                      // -1
   4943                   case 0x7D:
   4944                      stCDS.DAY_AND_NIGHT_LEVEL = 6;
   4945                      break;
   4946          
   4947                      // Default
   4948                   case 0x7F:
   4949                      stCDS.DAY_AND_NIGHT_LEVEL = 5;
   4950                      break;
   4951          
   4952                      // +1
   4953                   case 0x81:
   4954                      stCDS.DAY_AND_NIGHT_LEVEL = 4;
   4955                      break;
   4956          
   4957                      // +2
   4958                   case 0x83:
   4959                      stCDS.DAY_AND_NIGHT_LEVEL = 3;
   4960                      break;
   4961          
   4962                      // +3
   4963                   case 0x85:
   4964                      stCDS.DAY_AND_NIGHT_LEVEL = 2;
   4965                      break;
   4966          
   4967                      // +4
   4968                   case 0x87:
   4969                      stCDS.DAY_AND_NIGHT_LEVEL = 1;
   4970                      break;
   4971          
   4972                      // +5
   4973                   case 0x89:
   4974                      stCDS.DAY_AND_NIGHT_LEVEL = 0;
   4975                      break;
   4976                   }
   4977          
   4978                   break;
   4979          
   4980                   // 5.20. Set External IR Offset (0x20)
   4981                case OPTION_SET_EXTERNAL_IR_OFFSET:
   4982          
   4983                   stCDS.OFFSET = u_Rx_Data1 * 1000;
   4984          
   4985                   break;
   4986          
   4987                   // 5.21. Set Wiper Continuous Time (0x21)
   4988                case OPTION_SET_WIPER_CONTINUOUS_TIME:
   4989          
   4990                   stWIPER2.CONTINUOUS_TIME = u_Rx_Data1;
   4991          
   4992                   break;
   4993          
   4994                   // 5.90. Call Version Data (0x90)
   4995                case CALL_VERSION:
   4996          
   4997                   Reponse_Data_Send(CALL_VERSION, Version_High, Version_Low);
   4998          
   4999                   break;
   5000          
   5001                   // 5.91. Call Update Data (0x91)
   5002                case CALL_UPGRADE_DATE:
   5003          
   5004                   Reponse_Data_Send(CALL_UPGRADE_DATE, Upgrade_Year_Month, Upgrade_Day);
   5005          
   5006                   break;
   5007          
   5008                   // 5.A0. CDS - Day & Night (Auto Mode) (0xA0)
   5009                case DAY_AND_NIGHT_AUTO_MODE:
   5010          
   5011                   switch (u_Rx_Data1)
   5012                   {
   5013                      // Night Mode
   5014                   case 0x00:
   5015          
   5016                      stCDS.DAY_AND_NIGHT_AUTO_ENABLE = 0x00;
   5017                      stCDS.DAY_AND_NIGHT_STATUS = 0x01;
   5018          
   5019                      // Auto Mode Off
   5020                      Send_Sony_Data(0x51, 0x03, 0x00, 0x06, SONY_COMMAND_TIMER_DELAY);
   5021          
   5022                      // Night Mode
   5023                      Send_Sony_Data(0x01, 0x02, 0x00, 0x06, SONY_COMMAND_TIMER_DELAY);
   5024          
   5025                      EXTERNAL_LIGHT_PORT_ON;
   5026                      stLIGHT.EXTERNAL_STATUS = LIGHT_ON;
   5027          
   5028                      // Zoom Light On
   5029                      Send_Light_Data(ZOOM_LIGHT_ENABLE, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   5030                      stLIGHT.ZOOM_STATUS = LIGHT_ON;
   5031          
   5032                      break;
   5033          
   5034                      // Day Mode
   5035                   case 0x01:
   5036          
   5037                      stCDS.DAY_AND_NIGHT_AUTO_ENABLE = 0x00;
   5038                      stCDS.DAY_AND_NIGHT_STATUS = 0x00;
   5039          
   5040                      // Auto Mode Off
   5041                      Send_Sony_Data(0x51, 0x03, 0x00, 0x06, SONY_COMMAND_TIMER_DELAY);
   5042          
   5043                      // Day Mode
   5044                      Send_Sony_Data(0x01, 0x03, 0x00, 0x06, SONY_COMMAND_TIMER_DELAY);
   5045          
   5046                      EXTERNAL_LIGHT_PORT_OFF;
   5047                      stLIGHT.EXTERNAL_STATUS = LIGHT_OFF;
   5048          
   5049                      // Zoom Light Off
   5050                      Send_Light_Data(ZOOM_LIGHT_ENABLE, 0x30, 0x30, 0x30, 0x30, 0x30, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   5051                      stLIGHT.ZOOM_STATUS = LIGHT_OFF;
   5052          
   5053                      break;
   5054          
   5055                      // Auto Mode
   5056                   case 0x02:
   5057          
   5058                      // Auto Mode Off
   5059                      Send_Sony_Data(0x51, 0x02, 0x00, 0x06, SONY_COMMAND_TIMER_DELAY);
   5060          
   5061                      stCDS.DAY_AND_NIGHT_AUTO_ENABLE = 0x01;
   5062          
   5063                      break;
   5064                   }
   5065          
   5066                   break;
   5067          
   5068                   // TEST_ZOOM_DATA
   5069                case TEST_ZOOM_DATA:
   5070          
   5071                   Send_Sony_Data(0x07, 0x27, 0x00, 0x06, SONY_COMMAND_TIMER_DELAY);
   5072          
   5073                   stTEST.TIMER_FLAG = 0x01;
   5074          
   5075                   break;
   5076          
   5077                default:
   5078                   break;
   5079                }
   5080             }
   5081          }
   5082          
   5083          /*******************************************************************************
   5084          * Function Name  : Zoom_Data_Sync
   5085          /=============================================================/
   5086          Step		Light-Zoom(DEC)	Light-Zoom(HEX)	Sony-Zoom(DEC)	Sony-Zoom(HEX)
   5087          0		1036			0x040B			0				0x0000
   5088          1		1000			0x03E8			550				0x0226
   5089          2		964				0x03C4			1096			0x0448
   5090          3		929				0x03A0			1642			0x066A
   5091          4		893				0x037D			2188			0x088C
   5092          5		857				0x0359			2734			0x0AAE
   5093          6		822				0x0335			3280			0x0CD0
   5094          7		786				0x0311			3826			0x0EF2
   5095          8		750				0x02EE			4372			0x1114
   5096          9		714				0x02CA			4918			0x1336
   5097          10		679				0x02A6			5464			0x1558
   5098          11		643				0x0282			6010			0x177A
   5099          12		607				0x025F			6556			0x199C
   5100          13		572				0x023B			7102			0x1BBE
   5101          14		536				0x0217			7648			0x1DE0
   5102          15		500				0x01F4			8194			0x2002
   5103          16		464				0x01D0			8740			0x2224
   5104          17		429				0x01AC			9286			0x2446
   5105          18		393				0x0188			9832			0x2668
   5106          19		357				0x0165			10378			0x288A
   5107          20		321				0x0141			10924			0x2AAC
   5108          21		286				0x011D			11470			0x2CCE
   5109          22		250				0x00FA			12016			0x2EF0
   5110          23		214				0x00D6			12562			0x3112
   5111          24		179				0x00B2			13108			0x3334
   5112          25		143				0x008E			13654			0x3556
   5113          26		107				0x006B			14200			0x3778
   5114          27		71				0x0047			14746			0x399A
   5115          28		36				0x0023			15292			0x3BBC
   5116          29		0				0x0000			15838			0x3DDE
   5117          30										16384			0x4000
   5118          *******************************************************************************/
   5119          void Zoom_Data_Sync(void)
   5120          {
   5121             // STEP 0 - HEX : 0x0000 ~ 0x0226 (DEC : 0 ~ 550)
   5122             if (stSONY.ZOOM_POSITION < 0x0225)
   5123             {
   5124                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_0;
   5125             }
   5126             // STEP 1 - HEX : 0x0226 ~ 0x0448 (DEC : 550 ~ 1096)
   5127             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_0) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_1))
   5128             {
   5129                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_1;
   5130             }
   5131             // STEP 2 - HEX : 0x0448 ~ 0x066A (DEC : 1096 ~ 1642)
   5132             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_1) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_2))
   5133             {
   5134                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_2;
   5135             }
   5136             // STEP 3 - HEX : 0x066A ~ 0x088C (DEC : 1642 ~ 2188)
   5137             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_2) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_3))
   5138             {
   5139                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_3;
   5140             }
   5141             // STEP 4 - HEX : 0x088C ~ 0x0AAE (DEC : 2188 ~ 2734)
   5142             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_3) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_4))
   5143             {
   5144                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_4;
   5145             }
   5146             // STEP 5 - HEX : 0x0AAE ~ 0x0CD0 (DEC : 2734 ~ 3280)
   5147             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_4) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_5))
   5148             {
   5149                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_5;
   5150             }
   5151             // STEP 6 - HEX : 0x0CD0 ~ 0x0EF2 (DEC : 3280 ~ 3826)
   5152             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_5) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_6))
   5153             {
   5154                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_6;
   5155             }
   5156             // STEP 7 - HEX : 0x0EF2 ~ 0x1114 (DEC : 3826 ~ 4372)
   5157             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_6) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_7))
   5158             {
   5159                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_7;
   5160             }
   5161             // STEP 8 - HEX : 0x1114 ~ 0x1336 (DEC : 4372 ~ 4918)
   5162             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_7) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_8))
   5163             {
   5164                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_8;
   5165             }
   5166             // STEP 9 - HEX : 0x1336 ~ 0x1558 (DEC : 4918 ~ 5464)
   5167             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_8) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_9))
   5168             {
   5169                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_9;
   5170             }
   5171             // STEP 10 - HEX : 0x1558 ~ 0x177A (DEC : 5464 ~ 6010)
   5172             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_9) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_10))
   5173             {
   5174                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_10;
   5175             }
   5176             // STEP 11 - HEX : 0x177A ~ 0x199C (DEC : 6010 ~ 6556)
   5177             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_10) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_11))
   5178             {
   5179                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_11;
   5180             }
   5181             // STEP 12 - HEX : 0x199C ~ 0x1BBE (DEC : 6556 ~ 7102)
   5182             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_11) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_12))
   5183             {
   5184                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_12;
   5185             }
   5186             // STEP 13 - HEX : 0x1BBE ~ 0x1DE0 (DEC : 7102 ~ 7648)
   5187             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_12) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_13))
   5188             {
   5189                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_13;
   5190             }
   5191             // STEP 14 - HEX : 0x1DE0 ~ 0x2002 (DEC : 7648 ~ 8194)
   5192             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_13) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_14))
   5193             {
   5194                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_14;
   5195             }
   5196             // STEP 15 - HEX : 0x2002 ~ 0x2224 (DEC : 8194 ~ 8740)
   5197             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_14) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_15))
   5198             {
   5199                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_15;
   5200             }
   5201             // STEP 16 - HEX : 0x2224 ~ 0x2446 (DEC : 8740 ~ 9286)
   5202             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_15) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_16))
   5203             {
   5204                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_16;
   5205             }
   5206             // STEP 17 - HEX : 0x2446 ~ 0x2668 (DEC : 9286 ~ 9832)
   5207             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_16) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_17))
   5208             {
   5209                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_17;
   5210             }
   5211             // STEP 18 - HEX : 0x2668 ~ 0x288A (DEC : 9832 ~ 10378)
   5212             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_17) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_18))
   5213             {
   5214                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_18;
   5215             }
   5216             // STEP 19 - HEX : 0x288A ~ 0x2AAC (DEC : 10378 ~ 10924)
   5217             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_18) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_19))
   5218             {
   5219                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_19;
   5220             }
   5221             // STEP 20 - HEX : 0x2AAC ~ 0x2CCE (DEC : 10924 ~ 11470)
   5222             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_19) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_20))
   5223             {
   5224                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_20;
   5225             }
   5226             // STEP 21 - HEX : 0x2CCE ~ 0x2EF0 (DEC : 11470 ~ 12016)
   5227             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_20) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_21))
   5228             {
   5229                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_21;
   5230             }
   5231             // STEP 22 - HEX : 0x2EF0 ~ 0x3112 (DEC : 12016 ~ 12562)
   5232             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_21) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_22))
   5233             {
   5234                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_22;
   5235             }
   5236             // STEP 23 - HEX : 0x3112 ~ 0x3334 (DEC : 12562 ~ 13108)
   5237             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_22) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_23))
   5238             {
   5239                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_23;
   5240             }
   5241             // STEP 24 - HEX : 0x3334 ~ 0x3556 (DEC : 13108 ~ 13654)
   5242             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_23) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_24))
   5243             {
   5244                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_24;
   5245             }
   5246             // STEP 25 - HEX : 0x3556 ~ 0x3778 (DEC : 13654 ~ 14200)
   5247             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_24) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_25))
   5248             {
   5249                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_25;
   5250             }
   5251             // STEP 26 - HEX : 0x3778 ~ 0x399A (DEC : 14200 ~ 14746)
   5252             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_25) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_26))
   5253             {
   5254                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_26;
   5255             }
   5256             // STEP 27 - HEX : 0x399A ~ 0x3BBC (DEC : 14746 ~ 15292)
   5257             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_26) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_27))
   5258             {
   5259                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_27;
   5260             }
   5261             // STEP 28 - HEX : 0x3BBC ~ 0x3DDE (DEC : 15292 ~ 15838)
   5262             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_27) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_28))
   5263             {
   5264                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_28;
   5265             }
   5266             // STEP 29 - HEX : 0x3DDE ~ 0x4000 (DEC : 15838 ~ 16384)
   5267             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_28) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_29))
   5268             {
   5269                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_29;
   5270             }
   5271          }
   5272          
   5273          /*******************************************************************************
   5274          * Function Name  : Temperature_Convert_Data
   5275          :  ADC  
   5276          *******************************************************************************/
   5277          u16 Temperature_Convert_Data(u8 u_Celsius_Data)
   5278          {
   5279             u16 u_ADC_Data;
   5280          
   5281             switch (u_Celsius_Data)
   5282             {
   5283             case 0:     		//-30'
   5284                u_ADC_Data = 2875;
   5285                break;
   5286             case 1:
   5287                u_ADC_Data = 2857;
   5288                break;
   5289             case 2:
   5290                u_ADC_Data = 2838;
   5291                break;
   5292             case 3:
   5293                u_ADC_Data = 2819;
   5294                break;
   5295             case 4:
   5296                u_ADC_Data = 2799;
   5297                break;
   5298             case 5:    		//-15'
   5299                u_ADC_Data = 2779;
   5300                break;
   5301             case 6:
   5302                u_ADC_Data = 2758;
   5303                break;
   5304             case 7:
   5305                u_ADC_Data = 2737;
   5306                break;
   5307             case 8:
   5308                u_ADC_Data = 2715;
   5309                break;
   5310             case 9:
   5311                u_ADC_Data = 2693;
   5312                break;
   5313             case 10:    		//-10'
   5314                u_ADC_Data = 2670;
   5315                break;
   5316             case 11:
   5317                u_ADC_Data = 2647;
   5318                break;
   5319             case 12:
   5320                u_ADC_Data = 2623;
   5321                break;
   5322             case 13:
   5323                u_ADC_Data = 2598;
   5324                break;
   5325             case 14:
   5326                u_ADC_Data = 2574;
   5327                break;
   5328             case 15:    		//-5'
   5329                u_ADC_Data = 2548;
   5330                break;
   5331             case 16:
   5332                u_ADC_Data = 2522;
   5333                break;
   5334             case 17:
   5335                u_ADC_Data = 2496;
   5336                break;
   5337             case 18:
   5338                u_ADC_Data = 2469;
   5339                break;
   5340             case 19:
   5341                u_ADC_Data = 2442;
   5342                break;
   5343             case 20:    		//0'
   5344                u_ADC_Data = 2414;
   5345                break;
   5346             case 21:
   5347                u_ADC_Data = 2386;
   5348                break;
   5349             case 22:
   5350                u_ADC_Data = 2358;
   5351                break;
   5352             case 23:
   5353                u_ADC_Data = 2329;
   5354                break;
   5355             case 24:
   5356                u_ADC_Data = 2300;
   5357                break;
   5358             case 25:    		//5'
   5359                u_ADC_Data = 2271;
   5360                break;
   5361             case 26:
   5362                u_ADC_Data = 2241;
   5363                break;
   5364             case 27:
   5365                u_ADC_Data = 2211;
   5366                break;
   5367             case 28:
   5368                u_ADC_Data = 2181;
   5369                break;
   5370             case 29:
   5371                u_ADC_Data = 2150;
   5372                break;
   5373             case 30:    		//10'
   5374                u_ADC_Data = 2119;
   5375                break;
   5376             case 31:
   5377                u_ADC_Data = 2088;
   5378                break;
   5379             case 32:
   5380                u_ADC_Data = 2057;
   5381                break;
   5382             case 33:
   5383                u_ADC_Data = 2026;
   5384                break;
   5385             case 34:
   5386                u_ADC_Data = 1995;
   5387                break;
   5388             case 35:
   5389                u_ADC_Data = 1963;
   5390                break;
   5391             case 36:
   5392                u_ADC_Data = 1932;
   5393                break;
   5394             case 37:
   5395                u_ADC_Data = 1900;
   5396                break;
   5397             case 38:
   5398                u_ADC_Data = 1869;
   5399                break;
   5400             case 39:
   5401                u_ADC_Data = 1837;
   5402                break;
   5403             case 40:    		//20'
   5404                u_ADC_Data = 1806;
   5405                break;
   5406             case 41:
   5407                u_ADC_Data = 1774;
   5408                break;
   5409             case 42:
   5410                u_ADC_Data = 1743;
   5411                break;
   5412             case 43:
   5413                u_ADC_Data = 1712;
   5414                break;
   5415             case 44:
   5416                u_ADC_Data = 1680;
   5417                break;
   5418             case 45:    		//25'
   5419                u_ADC_Data = 1650;
   5420                break;
   5421             case 46:
   5422                u_ADC_Data = 1619;
   5423                break;
   5424             case 47:
   5425                u_ADC_Data = 1588;
   5426                break;
   5427             case 48:
   5428                u_ADC_Data = 1558;
   5429                break;
   5430             case 49:
   5431                u_ADC_Data = 1527;
   5432                break;
   5433             case 50:    		//30'
   5434                u_ADC_Data = 1497;
   5435                break;
   5436             case 51:
   5437                u_ADC_Data = 1468;
   5438                break;
   5439             case 52:
   5440                u_ADC_Data = 1438;
   5441                break;
   5442             case 53:
   5443                u_ADC_Data = 1409;
   5444                break;
   5445             case 54:
   5446                u_ADC_Data = 1380;
   5447                break;
   5448             case 55:
   5449                u_ADC_Data = 1352;
   5450                break;
   5451             case 56:
   5452                u_ADC_Data = 1324;
   5453                break;
   5454             case 57:
   5455                u_ADC_Data = 1296;
   5456                break;
   5457             case 58:
   5458                u_ADC_Data = 1268;
   5459                break;
   5460             case 59:
   5461                u_ADC_Data = 1241;
   5462                break;
   5463             case 60:    		// 40'
   5464                u_ADC_Data = 1214;
   5465                break;
   5466             case 61:    		// 41'
   5467                u_ADC_Data = 1188;
   5468                break;
   5469             case 62:    		// 42'
   5470                u_ADC_Data = 1162;
   5471                break;
   5472             case 63:    		// 43'
   5473                u_ADC_Data = 1136;
   5474                break;
   5475             case 64:    		// 44'
   5476                u_ADC_Data = 1111;
   5477                break;
   5478             case 65:    		// 45'
   5479                u_ADC_Data = 1087;
   5480                break;
   5481             case 66:    		// 46'
   5482                u_ADC_Data = 1062;
   5483                break;
   5484             case 67:    		// 47'
   5485                u_ADC_Data = 1038;
   5486                break;
   5487             case 68:    		// 48'
   5488                u_ADC_Data = 1015;
   5489                break;
   5490             case 69:    		// 49'
   5491                u_ADC_Data = 992;
   5492                break;
   5493             case 70:    		// 50'
   5494                u_ADC_Data = 969;
   5495                break;
   5496             }
   5497             return u_ADC_Data;
   5498          }
   5499          
   5500          /*******************************************************************************
   5501          * Function Name  : Temperature_Data_Check
   5502          *******************************************************************************/
   5503          void Temperature_Data_Check(void)
   5504          {
   5505             if (stTEMP.ENABLE)
   5506             {
   5507                stTEMP.DATA_CHECK_1ms++;
   5508                stTEMP.TOTAL_VALUE_1ms = stTEMP.TOTAL_VALUE_1ms + ((stADC.DMA1_ADC_VALUE[0] * 3300) / 4096);
   5509          
   5510                if (stTEMP.DATA_CHECK_1ms >= TEMP_CHECK_DATA_COUNT_1ms)
   5511                {
   5512                   stTEMP.DATA_CHECK_1ms = 0;
   5513          
   5514                   stTEMP.DATA_CHECK_10ms++;
   5515                   stTEMP.TOTAL_VALUE_10ms = stTEMP.TOTAL_VALUE_10ms + (stTEMP.TOTAL_VALUE_1ms / TEMP_CHECK_DATA_COUNT_1ms);
   5516                   stTEMP.TOTAL_VALUE_1ms = 0;
   5517          
   5518                   if (stTEMP.DATA_CHECK_10ms >= TEMP_CHECK_DATA_COUNT_10ms)
   5519                   {
   5520                      stTEMP.DATA_CHECK_10ms = 0;
   5521          
   5522                      stTEMP.AVERAGE_DATA = stTEMP.TOTAL_VALUE_10ms / TEMP_CHECK_DATA_COUNT_10ms;
   5523                      stTEMP.TOTAL_VALUE_10ms = 0;
   5524                   }
   5525                }
   5526             }
   5527          }
   5528          
   5529          /*******************************************************************************
   5530          * Function Name  : CDS_Data_Check
   5531          *******************************************************************************/
   5532          void CDS_Data_Check(void)
   5533          {
   5534             if (stCDS.ENABLE)
   5535             {
   5536                stCDS.DATA_CHECK_1ms++;
   5537                stCDS.TOTAL_VALUE_1ms = stCDS.TOTAL_VALUE_1ms + ((stADC.DMA1_ADC_VALUE[1] * 3300) / 4096);
   5538          
   5539                if (stCDS.DATA_CHECK_1ms >= TEMP_CHECK_DATA_COUNT_1ms)
   5540                {
   5541                   stCDS.DATA_CHECK_1ms = 0;
   5542          
   5543                   stCDS.DATA_CHECK_10ms++;
   5544                   stCDS.TOTAL_VALUE_10ms = stCDS.TOTAL_VALUE_10ms + (stCDS.TOTAL_VALUE_1ms / TEMP_CHECK_DATA_COUNT_1ms);
   5545                   stCDS.TOTAL_VALUE_1ms = 0;
   5546          
   5547                   if (stCDS.DATA_CHECK_10ms >= TEMP_CHECK_DATA_COUNT_10ms)
   5548                   {
   5549                      stCDS.DATA_CHECK_10ms = 0;
   5550          
   5551                      stCDS.AVERAGE_DATA = stCDS.TOTAL_VALUE_10ms / TEMP_CHECK_DATA_COUNT_10ms;
   5552                      stCDS.TOTAL_VALUE_10ms = 0;
   5553                   }
   5554                }
   5555             }
   5556          }
   5557          
   5558          /*******************************************************************************
   5559          * Function Name  : Temperature_Boot_Mode
   5560          *******************************************************************************/
   5561          void Temperature_Boot_Mode(void)
   5562          {
   5563             if (stTEMP.STARTING_MODE_TIMER_FLAG)
   5564             {
   5565                stTEMP.STARTING_MODE_TIMER_ms++;
   5566          
   5567                if (stTEMP.STARTING_MODE_TIMER_ms >= TEMP_BOOT_START_TIME)
   5568                {
   5569                   stTEMP.STARTING_MODE_TIMER_ms = 0;
   5570          
   5571                   stTEMP.STARTING_MODE_TIMER_FLAG = 0x00;
   5572                   stTEMP.STARTING_MODE_COMPLETE = 0x01;
   5573                }
   5574             }
   5575          }
   5576          
   5577          /*******************************************************************************
   5578          * Function Name  : Zoom_Light_Auto_Control
   5579          *******************************************************************************/
   5580          void Zoom_Light_Auto_Control(void)
   5581          {
   5582             u8 u_Tx_Data1 = 0x00, u_Tx_Data2 = 0x00, u_Tx_Data3 = 0x00, u_Tx_Data4 = 0x00;
   5583             u16 u_Convert_Data = 0x0000;
   5584          
   5585             if (stLIGHT.POSITION_STATUS != stLIGHT.POSITION_DATA)
   5586             {
   5587                u_Convert_Data = stLIGHT.POSITION_DATA;
   5588          
   5589                if (u_Convert_Data >= 1035)
   5590                   u_Convert_Data = 1035;
   5591          
   5592                u_Tx_Data1 = (u_Convert_Data / 1000) & 0xFF;
   5593                if (u_Tx_Data1 >= 9)
   5594                   u_Tx_Data1 = 9;
   5595                u_Tx_Data1 = u_Tx_Data1 + 0x30;
   5596          
   5597                u_Convert_Data = u_Convert_Data % 1000;
   5598                u_Tx_Data2 = (u_Convert_Data / 100) & 0xFF;
   5599                u_Tx_Data2 = u_Tx_Data2 + 0x30;
   5600          
   5601                u_Convert_Data = u_Convert_Data % 100;
   5602                u_Tx_Data3 = (u_Convert_Data / 10) & 0xFF;
   5603                u_Tx_Data3 = u_Tx_Data3 + 0x30;
   5604          
   5605                u_Tx_Data4 = (u_Convert_Data % 10) & 0xFF;
   5606                u_Tx_Data4 = u_Tx_Data4 + 0x30;
   5607          
   5608                Send_Light_Data(ZOOM_LIGHT_DIRECT, 0x2B, u_Tx_Data1, u_Tx_Data2, u_Tx_Data3, u_Tx_Data4, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   5609          
   5610                stLIGHT.POSITION_STATUS = stLIGHT.POSITION_DATA;
   5611             }
   5612          }
   5613          
   5614          /*******************************************************************************
   5615          * Function Name  : Fan_Heater_Control
   5616          *******************************************************************************/
   5617          void Fan_Heater_Control(u8 u_Mode)
   5618          {
   5619             switch (u_Mode)
   5620             {
   5621             case DISABLE_MODE:
   5622                break;
   5623          
   5624             case BOOT_MODE:
   5625          
   5626                if (stTEMP.STARTING_MODE_ENABLE == 0x00)
   5627                {
   5628                   Heater_ON;
   5629                   Fan_ON;
   5630          
   5631                   stTEMP.STARTING_MODE_ENABLE = 0x01;
   5632                   stTEMP.STARTING_MODE_TIMER_FLAG = 0x01;
   5633                }
   5634                else
   5635                {
   5636                   if (stTEMP.STARTING_MODE_COMPLETE == 0x01)
   5637                   {
   5638                      Heater_OFF;
   5639                      Fan_OFF;
   5640          
   5641                      stTEMP.STARTING_MODE_COMPLETE = 0x00;
   5642                      stTEMP.STARTING_MODE = 0x01;
   5643                      stTEMP.ENABLE = 0x01;
   5644                   }
   5645                }
   5646          
   5647                break;
   5648          
   5649             case NORMAL_MODE:
   5650          
   5651                // FAN 30   
   5652                if (stFAN.FAN_DWELL_FLAG)
   5653                {
   5654                   Fan_OFF;
   5655                   stFAN.STATUS = bOFF;
   5656          
   5657                   stFAN.FAN_DWELL_FLAG = 0x00;
   5658                   stFAN.FAN_DWELL_END_FLAG = 0x00;
   5659          
   5660                   stFAN.FAN_DWELL_TIMER_ms = 0;
   5661                   stFAN.FAN_DWELL_TIMER_s = 0;
   5662                }
   5663          
   5664                /*******************************************************************************
   5665                * FAN  
   5666                 50(969)  : FAN ON
   5667                 40(1214)  & 50(969)    : 
   5668                 40(1214)  : FAN OFF
   5669                 IR LED ON  : FAN ON
   5670                 LRF ON  : FAN ON
   5671          
   5672          
   5673                * HEATER  
   5674                 -10(1806)  : HEATER ON
   5675                 0(1497)  : HEATER OFF
   5676          
   5677                * stFAN.FAN_DWELL_FLAG = 1  FAN 30  . (  FAN ON     FLAG  .)
   5678                * stFAN.FAN_DWELL_FLAG = 0  FAN .
   5679                *******************************************************************************/
   5680          
   5681                if (stFAN.FAN_DWELL_FLAG == 0x01)
   5682                {
   5683                   //  -10(2670)  : HEATER ON
   5684                   if (stTEMP.AVERAGE_DATA >= Temperature_Convert_Data(TEMP_COMPARE_VALUE - 10))
   5685                   {
   5686                      Heater_ON;
   5687                      stHEATER.STATUS = bON;
   5688                   }
   5689          
   5690                   //  0(2414)  : HEATER OFF
   5691                   else if (stTEMP.AVERAGE_DATA < Temperature_Convert_Data(TEMP_COMPARE_VALUE + 0))
   5692                   {
   5693                      Heater_OFF;
   5694                      stHEATER.STATUS = bOFF;
   5695                   }
   5696                }
   5697                else
   5698                {
   5699                   //  50(969)  : FAN ON
   5700                   if (stTEMP.AVERAGE_DATA < Temperature_Convert_Data(TEMP_COMPARE_VALUE + 50))
   5701                   {
   5702                      Fan_ON;
   5703                      stFAN.STATUS = bON;
   5704                   }
   5705          
   5706                   //  40(1214)  & 50(969)    : 
   5707                   else if ((stTEMP.AVERAGE_DATA < Temperature_Convert_Data(TEMP_COMPARE_VALUE + 40)) && (stTEMP.AVERAGE_DATA >= Temperature_Convert_Data(TEMP_COMPARE_VALUE + 50)))
   5708                   {
   5709                      if (stFAN.STATUS == bOFF)
   5710                      {
   5711                         if ((stLIGHT.ZOOM_STATUS == LIGHT_OFF) && (stLRF.CONTINUOUS_FLAG == 0x00))
   5712                         {
   5713                            Fan_OFF;
   5714                            stFAN.STATUS = bOFF;
   5715                         }
   5716                      }
   5717                      else
   5718                      {
   5719                         Fan_ON;
   5720                         stFAN.STATUS = bON;
   5721                      }
   5722                   }
   5723          
   5724                   //  40(1214)  : FAN OFF
   5725                   else if (stTEMP.AVERAGE_DATA >= Temperature_Convert_Data(TEMP_COMPARE_VALUE + 40))
   5726                   {
   5727                      //  -10(1806)  : HEATER ON
   5728                      if (stTEMP.AVERAGE_DATA >= Temperature_Convert_Data(TEMP_COMPARE_VALUE - 10))
   5729                      {
   5730                         Heater_ON;
   5731                         stHEATER.STATUS = bON;
   5732          
   5733                         if (stFAN.STATUS == bOFF)
   5734                         {
   5735                            Fan_ON;
   5736                            stFAN.STATUS = bON;
   5737                         }
   5738                      }
   5739          
   5740                      //  0(1497)  : HEATER OFF
   5741                      else if (stTEMP.AVERAGE_DATA < Temperature_Convert_Data(TEMP_COMPARE_VALUE + 0))
   5742                      {
   5743                         Heater_OFF;
   5744                         stHEATER.STATUS = bOFF;
   5745          
   5746                         if (stFAN.STATUS == bON)
   5747                         {
   5748                            if ((stLIGHT.ZOOM_STATUS == LIGHT_OFF) && (stLRF.CONTINUOUS_FLAG == 0x00))
   5749                               stFAN.FAN_DWELL_FLAG = 0x01;
   5750                         }
   5751                      }
   5752                   }
   5753          
   5754                   break;
   5755          
   5756                default:
   5757                   break;
   5758                }
   5759             }
   5760          }
   5761          
   5762          /*******************************************************************************
   5763          * Function Name  : Auto_Day_And_Night_Control
   5764          *******************************************************************************/ 
   5765          /* TNS 3.3V Table ()
   5766          ==========================================================
   5767          Lux           7     10    15   20   25   30   40   50
   5768          ----------------------------------------------------------
   5769          ADCValue1    875   547   358  277  240  206  166  140 
   5770          ==========================================================*/
   5771          void Auto_Day_And_Night_Control(void)
   5772          {
   5773             u16 u_Data_Convert = 0;
   5774          
   5775             if (stCDS.ENABLE)
   5776             {
   5777                u_Data_Convert = stCDS.AVERAGE_DATA;
   5778          
   5779                if (stCDS.DAY_AND_NIGHT_AUTO_ENABLE)
   5780                {
   5781          
   5782                   // 
   5783                   //  Table -> 0:755, 1:775, 2:795, 3:815, 4:835, 5:855, 6:875, 7:895, 8:915, 9:935, 10:955
   5784                   // Day -> Night   : 1200 -> step 5
   5785                   // 0:1100, 1:1120, 2:1140, 3:1160, 4:1180, 5:1200, 6:1220, 7:1240, 8:1260, 9:1280, 10:1300
   5786          
   5787                   // IBDR: 3100K, 10K FULL-UP
   5788                   //                                                                                                                                  
   5789                   // LUX		     11       10       9        8        7		  6		5          4          3          2           1
   5790                   // 6 LUX  -> 0:930, 1:950, 2:970, 3:990, 4:1010, 5:1030, 6:1050, 7:1070, 8:1090, 9:1110, 10:1130
   5791                   if (u_Data_Convert > (930 + (stCDS.DAY_AND_NIGHT_LEVEL * 20)))
   5792                   {
   5793                      stCDS.NIGHT_CONVERT_CHECK_Cnt++;
   5794          
   5795                      if (stCDS.NIGHT_CONVERT_CHECK_Cnt == stCDS.OFFSET)
   5796                      {
   5797                         stCDS.NIGHT_CONVERT_CHECK_Cnt = 0;
   5798                         stCDS.DAY_AND_NIGHT_CONVERT_FLAG = 0x01;
   5799                         stCDS.DAY_AND_NIGHT_CONVERT_MODE = 0x01;
   5800                      }
   5801                   }
   5802          
   5803                   // 0:500, 1:520, 2:540, 3:560, 4:580, 5:600, 6:620, 7:640, 8:660, 9:680, 10:700
   5804                   // Night -> Day   : 900 -> step 5
   5805                   //                                                                                                                                  
   5806                   // LUX		      11       10       9         8        7	  10	     9         8        7          6           5
   5807                   // 10 LUX  -> 0:850, 1:870, 2:890, 3:910, 4:930, 5:950, 6:970, 7:990, 8:1010, 9:1030, 10:1050
   5808                   else if (u_Data_Convert < (850 + (stCDS.DAY_AND_NIGHT_LEVEL * 20)))
   5809                   {
   5810                      stCDS.DAY_CONVERT_CHECK_Cnt++;
   5811          
   5812                      if (stCDS.DAY_CONVERT_CHECK_Cnt == stCDS.OFFSET)
   5813                      {
   5814                         stCDS.DAY_CONVERT_CHECK_Cnt = 0;
   5815                         stCDS.DAY_AND_NIGHT_CONVERT_FLAG = 0x01;
   5816                         stCDS.DAY_AND_NIGHT_CONVERT_MODE = 0x00;
   5817                      }
   5818                   }
   5819          
   5820                   // 0:755, 1:775, 2:795, 3:815, 4:835, 5:855, 6:875, 7:895, 8:915, 9:935, 10:955
   5821                   if ((stCDS.NIGHT_CONVERT_CHECK_Cnt > 0) && (!(u_Data_Convert > (1100 + (stCDS.DAY_AND_NIGHT_LEVEL * 20)))))
   5822                   {
   5823                      stCDS.NIGHT_CONVERT_CHECK_Cnt = 0;
   5824                   }
   5825                   else if ((stCDS.DAY_CONVERT_CHECK_Cnt > 0) && (!(u_Data_Convert < (800 + (stCDS.DAY_AND_NIGHT_LEVEL * 20)))))
   5826                   {
   5827                      stCDS.DAY_CONVERT_CHECK_Cnt = 0;
   5828                   }
   5829                }
   5830             }
   5831          }
   5832          
   5833          /*******************************************************************************
   5834          * Function Name  : AT24C256C_EEPROM_Write
   5835          *******************************************************************************/
   5836          void AT24C256C_EEPROM_Write(u16 EepAddr, u8 EepData)
   5837          {
   5838             I2C2_Write(AT24C256_ADDR, EepAddr, EepData);
   5839          }
   5840          
   5841          /*******************************************************************************
   5842          * Function Name  : AT24C256C_EEPROM_Read
   5843          *******************************************************************************/
   5844          u8 AT24C256C_EEPROM_Read(u16 EepAddr)
   5845          {
   5846             return I2C2_Read(AT24C256_ADDR, EepAddr);
   5847          }
   5848          
   5849          /*******************************************************************************
   5850          * Function Name  : MDIN_Sprite_Initialization
   5851          *******************************************************************************/
   5852          void MDIN_Sprite_Initialization(u8 u_Layer, u8 u_OnOff)
   5853          {
   5854             u8 u_ID = 0x00;
   5855             u8 u_Rx_Data[50];
   5856          
   5857             switch (u_Layer)
   5858             {
   5859                // Layer 0 : Information
   5860             case MDIN_LAYER_INFORMATION:
   5861          
   5862                stOSD.LAYER_NUM = u_Layer;
   5863          
   5864                u_ID = u_Layer;			// ID
   5865          
   5866                u_Rx_Data[0] = 0x0C;		// X position L
   5867                u_Rx_Data[1] = 0x00;		// X position H
   5868          
   5869                u_Rx_Data[2] = 0x00;		// Y Position L
   5870                u_Rx_Data[3] = 0x00;		// Y Position H
   5871          
   5872                u_Rx_Data[4] = 0xB0;		// Width L : 12 x 100 = 1200, 0xB0
   5873                u_Rx_Data[5] = 0x04;		// Width H : 0x04
   5874          
   5875                u_Rx_Data[6] = 0xD0;		// Height L : 20 x 36 = 720, 0xD0
   5876                u_Rx_Data[7] = 0x02;		// Height H : 0x02
   5877          
   5878                Send_MDIN_Data(MDIN_SPRITE_RECT, 0x09, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   5879                               u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   5880          
   5881                u_ID = u_Layer;			// ID
   5882          
   5883                u_Rx_Data[0] = u_OnOff;	// ON
   5884                u_Rx_Data[1] = 0x00;		// RESERVED
   5885          
   5886                Send_MDIN_Data(MDIN_SPRITE, 0x03, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   5887                               u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   5888          
   5889                break;
   5890          
   5891                // Layer 1 : Information
   5892             case MDIN_LAYER_TARGET:
   5893          
   5894                stOSD.LAYER_NUM = u_Layer;
   5895          
   5896                u_ID = u_Layer;			// ID
   5897          
   5898                u_Rx_Data[0] = 0x0C;		// X position L
   5899                u_Rx_Data[1] = 0x00;		// X position H
   5900          
   5901                u_Rx_Data[2] = 0x00;		// Y Position L
   5902                u_Rx_Data[3] = 0x00;		// Y Position H
   5903          
   5904                u_Rx_Data[4] = 0xB0;		// Width L : 12 x 100 = 1200, 0xB0
   5905                u_Rx_Data[5] = 0x04;		// Width H : 0x04
   5906          
   5907                u_Rx_Data[6] = 0xBC;		// Height L : 20 x 35 = 700, 0xBC
   5908                u_Rx_Data[7] = 0x02;		// Height H : 0x02
   5909          
   5910                Send_MDIN_Data(MDIN_SPRITE_RECT, 0x09, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   5911                               u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   5912          
   5913                u_ID = u_Layer;			// ID
   5914          
   5915                u_Rx_Data[0] = u_OnOff;	// ON
   5916                u_Rx_Data[1] = 0x00;		// RESERVED
   5917          
   5918                Send_MDIN_Data(MDIN_SPRITE, 0x03, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   5919                               u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   5920          
   5921                break;
   5922          
   5923                // Layer 2 : Coordinate
   5924             case MDIN_LAYER_COORDINATE:
   5925          
   5926                stOSD.LAYER_NUM = u_Layer;
   5927          
   5928                u_ID = u_Layer;			// ID
   5929          
   5930                u_Rx_Data[0] = 0x0C;		// X position L
   5931                u_Rx_Data[1] = 0x00;		// X position H
   5932          
   5933                u_Rx_Data[2] = 0xA8;		// Y Position L
   5934                u_Rx_Data[3] = 0x02;		// Y Position H
   5935          
   5936                u_Rx_Data[4] = 0xC0;		// Width L : 12 x 16 = 192, 0xC0
   5937                u_Rx_Data[5] = 0x00;		// Width H : 0x00
   5938          
   5939                u_Rx_Data[6] = 0x14;		// HeightL : 20 x 1 = 20, 0x14
   5940                u_Rx_Data[7] = 0x00;		// HeightL : 0x00
   5941          
   5942                Send_MDIN_Data(MDIN_SPRITE_RECT, 0x09, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   5943                               u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   5944          
   5945                u_ID = u_Layer;			// ID : Main 0
   5946          
   5947                u_Rx_Data[0] = u_OnOff;	// ON
   5948                u_Rx_Data[1] = 0x00;		// RESERVED
   5949          
   5950                Send_MDIN_Data(MDIN_SPRITE, 0x03, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   5951                               u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   5952          
   5953                break;
   5954          
   5955                // Layer 7 : Center Message
   5956             case MDIN_LAYER_CENTER_MSG:
   5957          
   5958                stOSD.LAYER_NUM = u_Layer;
   5959          
   5960                u_ID = u_Layer;			// ID
   5961          
   5962                u_Rx_Data[0] = 0x0C;		// X position L
   5963                u_Rx_Data[1] = 0x00;		// X position H
   5964          
   5965                u_Rx_Data[2] = 0xC8;		// Y Position L
   5966                u_Rx_Data[3] = 0x00;		// Y Position H
   5967          
   5968                u_Rx_Data[4] = 0xB0;		// Width L : 12 x 100 = 1200, 0xB0
   5969                u_Rx_Data[5] = 0x04;		// Width H : 0x04
   5970          
   5971                u_Rx_Data[6] = 0xB4;		// HeightL : 20 x 9 = 180, 0xB4
   5972                u_Rx_Data[7] = 0x00;		// HeightL : 0x00
   5973          
   5974                Send_MDIN_Data(MDIN_SPRITE_RECT, 0x09, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   5975                               u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   5976          
   5977                u_ID = u_Layer;			// ID
   5978          
   5979                u_Rx_Data[0] = u_OnOff;	// ON
   5980                u_Rx_Data[1] = 0x00;		// RESERVED
   5981          
   5982                Send_MDIN_Data(MDIN_SPRITE, 0x03, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   5983                               u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   5984          
   5985                break;
   5986          
   5987             default:
   5988                break;
   5989             }
   5990          
   5991          
   5992          
   5993          }
   5994          
   5995          /*******************************************************************************
   5996          * Function Name  : MDIN_I550_Initialization
   5997          *******************************************************************************/
   5998          void MDIN_I550_Initialization(void)
   5999          {
   6000             u8 u_Port_Check = 0x01;
   6001          
   6002             MDIN_RESET_LOW;
   6003             Delay_ms(20);
   6004          
   6005             MDIN_RESET_HIGH;
   6006             Delay_ms(60);
   6007          
   6008             while (u_Port_Check)
   6009             {
   6010                if (MDIN_I550_INT == 0x01)
   6011                {
   6012                   u_Port_Check = 0x00;
   6013                }
   6014             }
   6015          
   6016             // DELAY TIME
   6017             Delay_ms(100);
   6018          
   6019             // MDIN SETTING
   6020             //Send_MDIN_Data(MDIN_INITIALIZATION, 0x03, 0x00, 0x00, 0x03, MDIN_COMMAND_TIMER_DELAY);
   6021             //Send_MDIN_Data(MDIN_INPUT_RESOLUTION, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, MDIN_COMMAND_TIMER_DELAY);
   6022             //Send_MDIN_Data(MDIN_OUTPUT_RESOLUTION, 0x03, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, MDIN_COMMAND_TIMER_DELAY);
   6023          
   6024             // DELAY TIME
   6025             Delay_ms(100);
   6026          
   6027             // SPRITE SETTING
   6028             //MDIN_Sprite_Initialization(MDIN_LAYER_COORDINATE, bON);
   6029             //Delay_ms(100);
   6030             MDIN_Sprite_Initialization(MDIN_LAYER_CENTER_MSG, bON);
   6031             Delay_ms(100);
   6032          
   6033          }
   6034          
   6035          /*******************************************************************************
   6036          * Function Name  : TW9900_DECODER_RESET_Low
   6037          *******************************************************************************/
   6038          void TW9900_DECODER_RESET_Low(void)
   6039          // Low:Reset
   6040          {
   6041             GPIO_ResetBits(GPIOC, GPIO_Pin_5);
   6042          }
   6043          
   6044          /*******************************************************************************
   6045          * Function Name  : TW9900_DECODER_RESET_Low
   6046          *******************************************************************************/
   6047          void TW9900_DECODER_RESET_High(void)
   6048          // High:Normal
   6049          {
   6050             GPIO_SetBits(GPIOC, GPIO_Pin_5);
   6051          }
   6052          
   6053          /*******************************************************************************
   6054          * TW9900
   6055          *******************************************************************************/
   6056          const char defTW9900Sys[2][112]	=
   6057             {
   6058                //      00    01    02    03    04    05    06    07    08    09    0A    0B    0C    0D    0E    0F	// NTSC
   6059                {
   6060                   0x00, 0x00, 0x40, 0xA0, 0x00, 0x00, 0x00, 0x02, 0x14, 0xF0, 0x11, 0xD0, 0xDC, 0x00, 0x11, 0x00,       //00
   6061                   0xFE, 0x6F, 0x31, 0x80, 0x80, 0x00, 0x00, 0x30, 0x44, 0x58, 0x0A, 0x00, 0x07, 0x7F, 0x08, 0x00,       //01
   6062                   0x50, 0x42, 0xF0, 0xD8, 0xBC, 0xB8, 0x44, 0x2A, 0x00, 0x00, 0x78, 0x44, 0x30, 0x14, 0xA5, 0xE6,       //02
   6063                   0x00, 0x00, 0x00, 0x05, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,       //03
   6064                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x40, 0x00, 0x00,       //04
   6065                   0xA0, 0x22, 0x31, 0x80, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,       //05
   6066                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x24, 0x00, 0x00, 0x13    //06
   6067                },
   6068          
   6069                //      00    01    02    03    04    05    06    07    08    09    0A    0B    0C    0D    0E    0F	// PAL
   6070                {
   6071                   0x00, 0x00, 0x40, 0xA0, 0x00, 0x00, 0x00, 0x12, 0x17, 0x20, 0x0C, 0xD0, 0xDC, 0x00, 0x11, 0x00,       //00
   6072                   0x0C, 0x67, 0x20, 0x7E, 0x7C, 0x00, 0x00, 0x30, 0x44, 0x58, 0x0A, 0x00, 0x07, 0x7F, 0x08, 0x00,       //01
   6073                   0x50, 0x42, 0xF0, 0xD8, 0xBC, 0xB8, 0x44, 0x2A, 0x00, 0x00, 0x78, 0x44, 0x30, 0x14, 0xA5, 0xE6,       //02
   6074                   0x00, 0x00, 0x00, 0x05, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,       //03
   6075                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x50, 0x00, 0x00,       //04
   6076                   0xA0, 0x22, 0x31, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,       //05
   6077                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x24, 0x00, 0x00, 0x13    //06
   6078                }
   6079             };
   6080          
   6081          const char defTW9900Thermal[2][112]	=
   6082             {
   6083                // NTSC
   6084                {
   6085                   //		  00    01    02    03    04    05    06    07    08    09    0A    0B    0C    0D    0E    0F
   6086                   0x00, 0x00, 0x40, 0xA0, 0x00, 0x00, 0x00, 0x02, 0x15, 0xF4, 0x00, 0xE0, 0xDC, 0x00, 0x11, 0x00,
   6087                   0xFE, 0x6F, 0x31, 0x80, 0x80, 0x00, 0x00, 0x30, 0x44, 0x58, 0x0A, 0x00, 0x07, 0x7F, 0x08, 0x00,
   6088                   0x50, 0x42, 0xF0, 0xD8, 0xBC, 0xB8, 0x44, 0x2A, 0x00, 0x00, 0x78, 0x44, 0x30, 0x14, 0xA5, 0xE6,
   6089                   0x00, 0x00, 0x00, 0x05, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   6090                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x40, 0x00, 0x00,
   6091                   0xA0, 0x22, 0x31, 0x80, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   6092                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x24, 0x00, 0x00, 0x13,
   6093                },
   6094          
   6095                // PAL
   6096                {
   6097                   //		  00    01    02    03    04    05    06    07    08    09    0A    0B    0C    0D    0E    0F
   6098                   0x00, 0x00, 0x40, 0xA0, 0x00, 0x00, 0x00, 0x12, 0x17, 0x20, 0x0D, 0xE0, 0xDC, 0x00, 0x11, 0x00,
   6099                   0x0C, 0x67, 0x20, 0x7E, 0x7C, 0x00, 0x00, 0x30, 0x44, 0x58, 0x0A, 0x00, 0x07, 0x7F, 0x08, 0x00,
   6100                   0x50, 0x42, 0xF0, 0xD8, 0xBC, 0xB8, 0x44, 0x2A, 0x00, 0x00, 0x78, 0x44, 0x30, 0x14, 0xA5, 0xE6,
   6101                   0x00, 0x00, 0x00, 0x05, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   6102                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x50, 0x00, 0x00,
   6103                   0xA0, 0x22, 0x31, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   6104                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x24, 0x00, 0x00, 0x13,
   6105                },
   6106             };
   6107          
   6108          /*******************************************************************************
   6109          * Function Name  : TW9900_Initial
   6110          *******************************************************************************/
   6111          void TW9900_Initial(u8 VMode)
   6112          // VMode : NTSC_MODE/PAL_MODE
   6113          {
   6114             u8 i;
   6115          
   6116             TW9900_DECODER_RESET_High();
   6117             Delay_ms(100);
   6118          
   6119             for (i = 2; i < 0x70; i++)
   6120             {
   6121                TW9900_I2C1_ByteWrite(TW9900_ADDR, BYTE_ADDR, i, defTW9900Thermal[VMode - 1][i]);
   6122             }
   6123          }
   6124          
   6125          /*******************************************************************************
   6126          * Function Name  : VIDEO_Initialization
   6127          *******************************************************************************/
   6128          void VIDEO_Initialization(u8 u_Video_Mode)
   6129          {
   6130             TW9900_DECODER_RESET_Low();
   6131             MDIN_RESET_LOW;
   6132             Delay_ms(50);
   6133          
   6134             switch (u_Video_Mode)
   6135             {
   6136             case NTSC_MODE:
   6137                TW9900_Initial(NTSC_MODE);
   6138                break;
   6139          
   6140             case PAL_MODE:
   6141                TW9900_Initial(PAL_MODE);
   6142                break;
   6143          
   6144             default:
   6145                TW9900_Initial(NTSC_MODE);
   6146                break;
   6147             }
   6148             Delay_ms(50);
   6149          
   6150             // 4. MDIN Initial
   6151             Delay_1ms(10);
   6152             MDIN_RESET_HIGH;
   6153             Delay_1ms(1000);
   6154          
   6155             //MDIN_I550_Initialization();
   6156          
   6157          }
   6158          
   6159          /*******************************************************************************
   6160          * Function Name  : Send_Request_Data
   6161          *******************************************************************************/
   6162          void Send_Request_Data(u8 u_Cmd, u8 u_Index)
   6163          {
   6164             u8 u8_Convert_Data[10];
   6165             u16 u16_Convert_Data = 0x0000;
   6166          
   6167             switch (stINFO.MODULE_TYPE)
   6168             {
   6169             case SONY_MODULE:
   6170          
   6171                switch (u_Cmd)
   6172                {
   6173                case SONY_CALL_ZOOM_POSITION:
   6174          
   6175                   u16_Convert_Data = stSONY.ZOOM_CNT;
   6176          
   6177                   u8_Convert_Data[0] = (u8)(u16_Convert_Data >> 8);
   6178                   u8_Convert_Data[1] = (u8)(u16_Convert_Data & 0xFF);
   6179          
   6180                   stUSART1.TX_BUF[0] = IP_SONY_FIRST_BYTE;
   6181                   stUSART1.TX_BUF[1] = IP_SONY_SECOND_BYTE;
   6182                   stUSART1.TX_BUF[2] = 0x05;
   6183          
   6184                   stUSART1.TX_BUF[3] = 0x01;
   6185          
   6186                   stUSART1.TX_BUF[4] = 0xB8;
   6187                   stUSART1.TX_BUF[5] = u8_Convert_Data[0];
   6188                   stUSART1.TX_BUF[6] = u8_Convert_Data[1];
   6189                   stUSART1.TX_BUF[7] = u8_Convert_Data[2];
   6190          
   6191                   stUSART1.TX_BUF[8] = 0x00;
   6192                   stUSART1.TX_BUF[8] = stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5] + stUSART1.TX_BUF[6] + stUSART1.TX_BUF[7];
   6193          
   6194                   stUSART1.TX_BUF[9] = 0xAF;
   6195          
   6196                   stUSART1.TX_CNT = 0;
   6197                   stUSART1.TX_MAX = 10;
   6198          
   6199                   USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   6200                   Delay_1ms(MAIN_COMMAND_TIMER_DELAY);
   6201          
   6202                   break;
   6203          
   6204                case SONY_CALL_FOCUS_POSITION:
   6205          
   6206                   u16_Convert_Data = stSONY.FOCUS_CNT;
   6207          
   6208                   u8_Convert_Data[0] = (u8)(u16_Convert_Data >> 8);
   6209                   u8_Convert_Data[1] = (u8)(u16_Convert_Data & 0xFF);
   6210          
   6211                   stUSART1.TX_BUF[0] = IP_SONY_FIRST_BYTE;
   6212                   stUSART1.TX_BUF[1] = IP_SONY_SECOND_BYTE;
   6213                   stUSART1.TX_BUF[2] = 0x05;
   6214          
   6215                   stUSART1.TX_BUF[3] = 0x01;
   6216          
   6217                   stUSART1.TX_BUF[4] = u_Cmd;
   6218                   stUSART1.TX_BUF[5] = u8_Convert_Data[0];
   6219                   stUSART1.TX_BUF[6] = u8_Convert_Data[1];
   6220                   stUSART1.TX_BUF[7] = u8_Convert_Data[2];
   6221          
   6222                   stUSART1.TX_BUF[8] = 0x00;
   6223                   stUSART1.TX_BUF[8] = stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5] + stUSART1.TX_BUF[6] + stUSART1.TX_BUF[7];
   6224          
   6225                   stUSART1.TX_BUF[9] = 0xAF;
   6226          
   6227                   stUSART1.TX_CNT = 0;
   6228                   stUSART1.TX_MAX = 10;
   6229          
   6230                   USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   6231                   Delay_1ms(MAIN_COMMAND_TIMER_DELAY);
   6232          
   6233                   break;
   6234                }
   6235          
   6236                break;
   6237          
   6238             case TSM_MODULE:
   6239          
   6240                switch (u_Cmd)
   6241                {
   6242                case TSM_CALL_TOTAL_ZOOM_POSITION:
   6243          
   6244                   u16_Convert_Data = stTSM.ZOOM_CNT;
   6245          
   6246                   u8_Convert_Data[0] = (u8)(u16_Convert_Data >> 8);
   6247                   u8_Convert_Data[1] = (u8)(u16_Convert_Data & 0xFF);
   6248          
   6249                   stUSART1.TX_BUF[0] = IP_TSM_FIRST_BYTE;
   6250                   stUSART1.TX_BUF[1] = IP_TSM_SECOND_BYTE;
   6251                   stUSART1.TX_BUF[2] = 0x05;
   6252          
   6253                   stUSART1.TX_BUF[3] = 0x01;
   6254          
   6255                   stUSART1.TX_BUF[4] = u_Cmd;
   6256                   stUSART1.TX_BUF[5] = u8_Convert_Data[0];
   6257                   stUSART1.TX_BUF[6] = u8_Convert_Data[1];
   6258                   stUSART1.TX_BUF[7] = u8_Convert_Data[2];
   6259          
   6260                   stUSART1.TX_BUF[8] = 0x00;
   6261                   stUSART1.TX_BUF[8] = stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5] + stUSART1.TX_BUF[6] + stUSART1.TX_BUF[7];
   6262          
   6263                   stUSART1.TX_BUF[9] = 0xBF;
   6264          
   6265                   stUSART1.TX_CNT = 0;
   6266                   stUSART1.TX_MAX = 10;
   6267          
   6268                   USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   6269                   Delay_1ms(MAIN_COMMAND_TIMER_DELAY);
   6270          
   6271                   break;
   6272          
   6273                case TSM_CALL_FOCUS_POSITION:
   6274          
   6275                   u16_Convert_Data = stTSM.FOCUS_CNT;
   6276          
   6277                   u8_Convert_Data[0] = (u8)(u16_Convert_Data >> 8);
   6278                   u8_Convert_Data[1] = (u8)(u16_Convert_Data & 0xFF);
   6279          
   6280                   stUSART1.TX_BUF[0] = IP_TSM_FIRST_BYTE;
   6281                   stUSART1.TX_BUF[1] = IP_TSM_SECOND_BYTE;
   6282                   stUSART1.TX_BUF[2] = 0x05;
   6283          
   6284                   stUSART1.TX_BUF[3] = 0x01;
   6285          
   6286                   stUSART1.TX_BUF[4] = u_Cmd;
   6287                   stUSART1.TX_BUF[5] = u8_Convert_Data[0];
   6288                   stUSART1.TX_BUF[6] = u8_Convert_Data[1];
   6289                   stUSART1.TX_BUF[7] = u8_Convert_Data[2];
   6290          
   6291                   stUSART1.TX_BUF[8] = 0x00;
   6292                   stUSART1.TX_BUF[8] = stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5] + stUSART1.TX_BUF[6] + stUSART1.TX_BUF[7];
   6293          
   6294                   stUSART1.TX_BUF[9] = 0xBF;
   6295          
   6296                   stUSART1.TX_CNT = 0;
   6297                   stUSART1.TX_MAX = 10;
   6298          
   6299                   USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   6300                   Delay_1ms(MAIN_COMMAND_TIMER_DELAY);
   6301          
   6302                   break;
   6303          
   6304                default:
   6305                   break;
   6306                }
   6307          
   6308                break;
   6309             }
   6310          
   6311          
   6312          }
   6313          
   6314          u8 Data_Test = 0;
   6315          
   6316          /*******************************************************************************
   6317          * Function Name  : Module_Auto_Sync
   6318          *******************************************************************************/
   6319          void Module_Auto_Sync(void)
   6320          {
   6321             UART4_Init(9600);
   6322             Delay_1ms(500);
   6323          
   6324             stUART4.RX_REQUEST_CMD = SONY_POWER_INQ;
   6325             Send_Sony_Data(0x00, 0x00, 0x00, 0x05, SONY_COMMAND_TIMER_DELAY);
   6326             Delay_1ms(SONY_REQUEST_TIMER_DELAY);
   6327             Delay_1ms(500);
   6328          
   6329             UART4_Init(38400);
   6330             Delay_1ms(500);
   6331          
   6332             stUART4.RX_REQUEST_CMD = TSM_CALL_MODULE_STATUS;
   6333             Send_TSM_Data(TSM_CALL_MODULE_STATUS, 0x00, 0x00, 0x00, 0x06, TSM_COMMAND_TIMER_DELAY);
   6334             Delay_1ms(TSM_REQUEST_TIMER_MAX);
   6335             Delay_1ms(500);
   6336          }
   6337          
   6338          /*******************************************************************************
   6339          * Function Name  : EEPROM_Memory_Read
   6340          *******************************************************************************/
   6341          void EEPROM_Memory_Read(void)
   6342          {
   6343             u8 u_EEP_Mark = 0x00;
   6344          
   6345             u_EEP_Mark = AT24C256C_EEPROM_Read(EEP_PROM_MARK);
   6346          
   6347             // =======================================
   6348             // Data Read
   6349             // =======================================
   6350             if (u_EEP_Mark == EEP_HEADER)
   6351             {
   6352                switch (stINFO.MODULE_TYPE)
   6353                {
   6354                case SONY_MODULE:
   6355          
   6356                   // --------------------------------------------------------------------------------------------------//
   6357                   // 1. Color Module Control Command (0xAx)																 //
   6358                   // --------------------------------------------------------------------------------------------------//
   6359          
   6360                   // 1.1.	Set Focus Mode (0x91)
   6361                   stSONY.SET_FOCUS_MODE = AT24C256C_EEPROM_Read(EEP_SET_FOCUS_MODE);
   6362          
   6363                   // 1.2.	Set Auto Focus Mode (0x93)
   6364                   stSONY.SET_AUTO_FOCUS_MODE = AT24C256C_EEPROM_Read(EEP_SET_AUTO_FOCUS_MODE);
   6365          
   6366                   // 1.3.	Manual Focus Mode (0x08)
   6367                   // 1.4.	Manual Focus Direct (0x48)
   6368                   // 1.5.	Manual Zoom Mode (0x07)
   6369                   // 1.6.	Manual Zoom Direct (0x47)
   6370          
   6371                   // 1.7.	Set BLC Mode (0x31)
   6372                   stSONY.SET_BLC_MODE = AT24C256C_EEPROM_Read(EEP_SET_BLC_MODE);
   6373          
   6374                   // 1.8.	Set White Balance Mode (0x33)
   6375                   stSONY.SET_WHITE_BALANCE_MODE = AT24C256C_EEPROM_Read(EEP_SET_WHITE_BALANCE_MODE);
   6376          
   6377                   // 1.9.	Set Defog Mode (0x37)
   6378                   stSONY.SET_DEFOG_MODE = AT24C256C_EEPROM_Read(EEP_SET_DEFOG_MODE);
   6379          
   6380                   // 1.10.	Set Shutter Speed (0x4A)
   6381                   stSONY.SET_SHUTTER_SPEED = AT24C256C_EEPROM_Read(EEP_SET_SHUTTER_SPEED);
   6382          
   6383                   // 1.11.	Set Flicker Mode (0x55)
   6384                   stSONY.SET_FLICKER_MODE = AT24C256C_EEPROM_Read(EEP_SET_FLICKER_MODE);
   6385          
   6386                   // 1.12.	Set Aperture Value (0x59)
   6387                   stSONY.SET_APERTURE_VALUE = AT24C256C_EEPROM_Read(EEP_SET_APERTURE_VALUE);
   6388          
   6389                   // 1.13.	Set Digital Zoom Mode (0x5B)
   6390                   stSONY.SET_DIGITAL_ZOOM_MODE = AT24C256C_EEPROM_Read(EEP_SET_DIGITAL_ZOOM_MODE);
   6391          
   6392                   // 1.14.	Set Day & Night Mode (0x5F)
   6393                   stSONY.SET_DAY_NIGHT_MODE = AT24C256C_EEPROM_Read(EEP_SET_DAY_NIGHT_MODE);
   6394          
   6395                   // 1.15.	Set DSS Mode (0x61)
   6396                   stSONY.SET_DSS_MODE = AT24C256C_EEPROM_Read(EEP_SET_DSS_MODE);
   6397          
   6398                   // 1.16.	Select BLC / WDR (0x85)
   6399                   stSONY.SELECT_BLC_WDR = AT24C256C_EEPROM_Read(EEP_SELECT_BLC_WDR);
   6400          
   6401                   // 1.17.	Set High Resolution (0x87)
   6402                   stSONY.SET_HIGH_RESOLUTION = AT24C256C_EEPROM_Read(EEP_SET_HIGH_RESOLUTION);
   6403          
   6404                   // 1.18.	Set Image Stabilizer (0x89)
   6405                   stSONY.SET_IMAGE_STABILIZER = AT24C256C_EEPROM_Read(EEP_SET_IMAGE_STABILIZER);
   6406          
   6407                   // 1.19.	Set Noise Reduction (0x8B)
   6408                   stSONY.SET_NOISE_REDUCTION = AT24C256C_EEPROM_Read(EEP_SET_NOISE_REDUCTION);
   6409          
   6410                   // ETC.
   6411                   stSONY.SET_NTSC_PAL_MODE = AT24C256C_EEPROM_Read(EEP_SET_NTSC_PAL_MODE);
   6412          
   6413                   stSONY.SET_MANUAL_FOCUS_DATA = (AT24C256C_EEPROM_Read(EEP_MANUAL_FOCUS_DATA) << 8);
   6414                   stSONY.SET_MANUAL_FOCUS_DATA |= AT24C256C_EEPROM_Read(EEP_MANUAL_FOCUS_DATA + 1);
   6415          
   6416                   // --------------------------------------------------------------------------------------------------//
   6417                   // 5. Option Command (0xEx)																			 //
   6418                   // --------------------------------------------------------------------------------------------------//
   6419                   // 5.2. Set Wiper (0x02)
   6420                   stWIPER2.COUNT = AT24C256C_EEPROM_Read(EEP_SET_WIPER_COUNT);
   6421                   stWIPER2.DWELL_TIME = AT24C256C_EEPROM_Read(EEP_SET_WIPER_DWELL_TIME);
   6422          
   6423                   // 5.22. Set Wiper Option (0x22)
   6424                   stWIPER2.OPTION = AT24C256C_EEPROM_Read(EEP_SET_WIPER_OPTION);
   6425                   stWIPER2.SPRITE_TIME = AT24C256C_EEPROM_Read(EEP_SET_WASHER_SPRITE_TIME);
   6426                   stWIPER2.CONTINUOUS_TIME = AT24C256C_EEPROM_Read(EEP_SET_WIPER_CONTINUOUS_TIME);
   6427          
   6428                   break;
   6429          
   6430                case TSM_MODULE:
   6431          
   6432                   // --------------------------------------------------------------------------------------------------//
   6433                   // 2. Thermal Module Control Command (0xBx)																 //
   6434                   // --------------------------------------------------------------------------------------------------//
   6435          
   6436                   // 2.1.4. Shutter Set (0x05)
   6437                   stTSM.SHUTTER_SET = AT24C256C_EEPROM_Read(EEP_SHUTTER_SET);
   6438          
   6439                   // 2.1.15. Digital Zoom Enable (0x1C)
   6440                   stTSM.DIGITAL_ZOOM_ENABLE = AT24C256C_EEPROM_Read(EEP_DIGITAL_ZOOM_ENABLE);
   6441          
   6442                   // 2.1.19. AGC Mode Set (0x26)
   6443                   stTSM.AGC_MODE_SET = AT24C256C_EEPROM_Read(EEP_AGC_MODE_SET);
   6444          
   6445                   // 2.1.20. Color Mode Set (0x27)
   6446                   stTSM.COLOR_MODE_SET = AT24C256C_EEPROM_Read(EEP_COLOR_MODE_SET);
   6447          
   6448                   // 2.1.21. Contrast/Brightness (0x28) (when, AGC OFF)
   6449                   stTSM.CONTRAST_BRIGHTNESS_ENABLE = AT24C256C_EEPROM_Read(EEP_CONTRAST_BRIGHTNESS_ENABLE);
   6450                   stTSM.CONTRAST_BRIGHTNESS_VAL = AT24C256C_EEPROM_Read(EEP_CONTRAST_BRIGHTNESS_VAL);
   6451          
   6452                   // 2.1.22. AGC Center Position Set (0x29)
   6453                   stTSM.AGC_CENTER_POSITION_SET = AT24C256C_EEPROM_Read(EEP_AGC_CENTER_POSITION_SET);
   6454          
   6455                   // 2.1.23. AGC Limit Level Set (0x2A)
   6456                   stTSM.AGC_LIMIT_LEVEL_SET = AT24C256C_EEPROM_Read(EEP_AGC_LIMIT_LEVEL_SET);
   6457          
   6458                   // 2.1.24. AGC ROI (AGC Region of Interest) Set (0x2B)
   6459                   stTSM.AGC_ROI = AT24C256C_EEPROM_Read(EEP_AGC_ROI);
   6460          
   6461                   // 2.1.25. MIDE Level Set (0x2C) (when, Sharpness OFF)
   6462                   stTSM.MIDE_LEVEL_SET = AT24C256C_EEPROM_Read(EEP_MIDE_LEVEL_SET);
   6463          
   6464                   // 2.1.26. Sharpness Level Set (0x2D) (when, MIDE OFF)
   6465                   stTSM.SHARPNESS_LEVEL_SET = AT24C256C_EEPROM_Read(EEP_SHARPNESS_LEVEL_SET);
   6466          
   6467                   // 2.1.27. Detect Mode Set (0x31)
   6468                   // 2.1.28. Area Position Set (0x32)
   6469                   // 2.1.29. Spot Position Set (0x33)
   6470                   // 2.1.30. High Alarm Temperature (0x34)
   6471                   // 2.1.31. Low Alarm Temperature (0x35)
   6472                   // 2.1.32. Select Alarm (0x36)
   6473                   // 2.1.33. Alarm Mode (0x37)
   6474                   // 2.1.34. Temperature OSD (0x38)
   6475                   // 2.1.35. Emissivity Set (0x39)
   6476                   // 2.1.36. Mirror Mode Set (0x44)
   6477                   // 2.1.37. Flip Mode Set (0x45)
   6478          
   6479                   // 2.1.39. Image Color Inverse(White/Black Hot) Set (0x47)
   6480                   stTSM.IMAGE_COLOR_INVERSE_SET = AT24C256C_EEPROM_Read(EEP_IMAGE_COLOR_INVERSE_SET);
   6481          
   6482                   break;
   6483                }
   6484             }
   6485          
   6486             // =======================================
   6487             // Data Write
   6488             // =======================================
   6489             else
   6490             {
   6491                switch (stINFO.MODULE_TYPE)
   6492                {
   6493                case SONY_MODULE:
   6494          
   6495                   // --------------------------------------------------------------------------------------------------//
   6496                   // STATUS																						 	 //
   6497                   // --------------------------------------------------------------------------------------------------//
   6498                   stSONY.SET_NTSC_PAL_MODE = NTSC_MODE;
   6499                   AT24C256C_EEPROM_Write(EEP_SET_NTSC_PAL_MODE, stSONY.SET_NTSC_PAL_MODE);
   6500          
   6501                   // --------------------------------------------------------------------------------------------------//
   6502                   // 1. Color Module Control Command (0xAx)																 //
   6503                   // --------------------------------------------------------------------------------------------------//
   6504          
   6505                   /***************************************************************************************************************************
   6506                   * 1.1.	Set Focus Mode (0x91)
   6507                      - 0x00 : Auto Focus
   6508                      - 0x01 : Manual Focus
   6509                      - 0x02 : One Push Trigger
   6510                   ****************************************************************************************************************************/
   6511                   stSONY.SET_FOCUS_MODE = 0x00;
   6512                   AT24C256C_EEPROM_Write(EEP_SET_FOCUS_MODE, stSONY.SET_FOCUS_MODE);
   6513          
   6514                   /***************************************************************************************************************************
   6515                   * 1.2.	Set Auto Focus Mode (0x93)
   6516                      - 0x00 : Normal 
   6517                      - 0x01 : Zoom Trigger
   6518                   ****************************************************************************************************************************/
   6519                   stSONY.SET_AUTO_FOCUS_MODE = 0x00;
   6520                   AT24C256C_EEPROM_Write(EEP_SET_AUTO_FOCUS_MODE, stSONY.SET_AUTO_FOCUS_MODE);
   6521          
   6522                   // 1.3.	Manual Focus Mode (0x08)
   6523                   // 1.4.	Manual Focus Direct (0x48)
   6524                   // 1.5.	Manual Zoom Mode (0x07)
   6525                   // 1.6.	Manual Zoom Direct (0x47)
   6526          
   6527                   /***************************************************************************************************************************
   6528                   * 1.7.	Set BLC Mode (0x31)
   6529                      - 0x00 : BLC/WDR OFF
   6530                      - 0x01 : BLC ON
   6531                      - 0x10 : WDR ON
   6532                      - 0x11 : BLC/WDR ON
   6533                   ****************************************************************************************************************************/
   6534                   stSONY.SET_BLC_MODE = 0x00;
   6535                   AT24C256C_EEPROM_Write(EEP_SET_BLC_MODE, stSONY.SET_BLC_MODE);
   6536          
   6537                   /***************************************************************************************************************************
   6538                   * 1.8.	Set White Balance Mode (0x33)
   6539                      - 0x00 : Auto white balance Mode (Range : 3000 to 7500K)
   6540                      - 0x01 : In door Mode
   6541                      - 0x02 : Out door Mode
   6542                      - 0x03 : Auto tracing white balance Mode (Range : 2000 to 10000K))
   6543                   ****************************************************************************************************************************/
   6544                   stSONY.SET_WHITE_BALANCE_MODE = 0x00;
   6545                   AT24C256C_EEPROM_Write(EEP_SET_WHITE_BALANCE_MODE, stSONY.SET_WHITE_BALANCE_MODE);
   6546          
   6547                   /***************************************************************************************************************************
   6548                   * 1.9.	Set Defog Mode (0x37)
   6549                      - 0x00 : Defog Off
   6550                      - 0x01 : Defog On
   6551                   ****************************************************************************************************************************/
   6552                   stSONY.SET_DEFOG_MODE = 0x00;
   6553                   AT24C256C_EEPROM_Write(EEP_SET_DEFOG_MODE, stSONY.SET_DEFOG_MODE);
   6554          
   6555                   /***************************************************************************************************************************
   6556                   * 1.10.	Set Shutter Speed (0x4A)
   6557                      - 0x00 : Shutter Speed Auto
   6558                      - 0x00~0x16 (when, DSS On)
   6559                      - 0x00, 0x07~0x16 (when, DSS Off)
   6560                   ****************************************************************************************************************************/
   6561                   stSONY.SET_SHUTTER_SPEED = 0x00;
   6562                   AT24C256C_EEPROM_Write(EEP_SET_SHUTTER_SPEED, stSONY.SET_SHUTTER_SPEED);
   6563          
   6564                   /***************************************************************************************************************************
   6565                   * 1.11.	Set Flicker Mode (0x55)
   6566                      - 0x00 : Flicker OFF
   6567                      - 0x01 : Flicker ON
   6568                   ****************************************************************************************************************************/
   6569                   stSONY.SET_FLICKER_MODE = 0x00;
   6570                   AT24C256C_EEPROM_Write(EEP_SET_FLICKER_MODE, stSONY.SET_FLICKER_MODE);
   6571          
   6572                   /***************************************************************************************************************************
   6573                   * 1.12.	Set Aperture Value (0x59)
   6574                      - 0x00~0x0F (16 Step)
   6575                   ****************************************************************************************************************************/
   6576                   stSONY.SET_APERTURE_VALUE = 0x00;
   6577                   AT24C256C_EEPROM_Write(EEP_SET_APERTURE_VALUE, stSONY.SET_APERTURE_VALUE);
   6578          
   6579                   /***************************************************************************************************************************
   6580                   * 1.13.	Set Digital Zoom Mode (0x5B)
   6581                      - 0x00 : D Zoom OFF
   6582                      - 0x01 : D Zoom ON
   6583                   ****************************************************************************************************************************/
   6584                   stSONY.SET_DIGITAL_ZOOM_MODE = 0x00;
   6585                   AT24C256C_EEPROM_Write(EEP_SET_DIGITAL_ZOOM_MODE, stSONY.SET_DIGITAL_ZOOM_MODE);
   6586          
   6587                   /***************************************************************************************************************************
   6588                   * 1.14.	Set Day & Night Mode (0x5F)
   6589                      - 0x00 : Night Mode
   6590                      - 0x01 : Day Mode 
   6591                      - 0x02 : Auto Mode
   6592                   ****************************************************************************************************************************/
   6593                   stSONY.SET_DAY_NIGHT_MODE = 0x02;
   6594                   AT24C256C_EEPROM_Write(EEP_SET_DAY_NIGHT_MODE, stSONY.SET_DAY_NIGHT_MODE);
   6595          
   6596                   /***************************************************************************************************************************
   6597                   * 1.15.	Set DSS Mode (0x61)
   6598                      - 0x00 : DSS OFF
   6599                      - 0x01 : DSS ON
   6600                   ****************************************************************************************************************************/
   6601                   stSONY.SET_DSS_MODE = 0x00;
   6602                   AT24C256C_EEPROM_Write(EEP_SET_DSS_MODE, stSONY.SET_DSS_MODE);
   6603          
   6604                   /***************************************************************************************************************************
   6605                   * 1.16.	Select BLC / WDR (0x85)
   6606                      - 0x00 : BLC Mode Select
   6607                      - 0x01 : WDR Mode Select
   6608                   ****************************************************************************************************************************/
   6609                   stSONY.SELECT_BLC_WDR = 0x00;
   6610                   AT24C256C_EEPROM_Write(EEP_SELECT_BLC_WDR, stSONY.SELECT_BLC_WDR);
   6611          
   6612                   /***************************************************************************************************************************
   6613                   * 1.17.	Set High Resolution (0x87)
   6614                      - 0x00 : HR Mode OFF
   6615                      - 0x01 : HR Mode On
   6616                   ****************************************************************************************************************************/
   6617                   stSONY.SET_HIGH_RESOLUTION = 0x00;
   6618                   AT24C256C_EEPROM_Write(EEP_SET_HIGH_RESOLUTION, stSONY.SET_HIGH_RESOLUTION);
   6619          
   6620                   /***************************************************************************************************************************
   6621                   * 1.18.	Set Image Stabilizer (0x89)
   6622                      - 0x00 : IS Mode OFF
   6623                      - 0x01 : IS Mode On
   6624                   ****************************************************************************************************************************/
   6625                   stSONY.SET_IMAGE_STABILIZER = 0x00;
   6626                   AT24C256C_EEPROM_Write(EEP_SET_IMAGE_STABILIZER, stSONY.SET_IMAGE_STABILIZER);
   6627          
   6628                   /***************************************************************************************************************************
   6629                   * 1.19.	Set Noise Reduction (0x8B)
   6630                      - 0x00 : NR OFF
   6631                      - 0x01~0x05 : NR ON [Sensitivity]
   6632                   ****************************************************************************************************************************/
   6633                   stSONY.SET_NOISE_REDUCTION = 0x00;
   6634                   AT24C256C_EEPROM_Write(EEP_SET_NOISE_REDUCTION, stSONY.SET_NOISE_REDUCTION);
   6635          
   6636                   // --------------------------------------------------------------------------------------------------//
   6637                   // 5. Option Command (0xEx)																			 //
   6638                   // --------------------------------------------------------------------------------------------------//
   6639                   // 5.2. Set Wiper (0x02)
   6640                   stWIPER2.COUNT = 0x01;
   6641                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_COUNT, stWIPER2.COUNT);
   6642          
   6643                   stWIPER2.DWELL_TIME = 0x00;
   6644                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_DWELL_TIME, stWIPER2.DWELL_TIME);
   6645          
   6646                   // 5.22. Set Wiper Option (0x22)
   6647                   stWIPER2.OPTION = WIPER_NORMAL_MODE;
   6648                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_OPTION, stWIPER2.OPTION);
   6649          
   6650                   stWIPER2.SPRITE_TIME = 0x00;
   6651                   AT24C256C_EEPROM_Write(EEP_SET_WASHER_SPRITE_TIME, stWIPER2.SPRITE_TIME);
   6652          
   6653                   stWIPER2.CONTINUOUS_TIME = 0x00;
   6654                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_CONTINUOUS_TIME, stWIPER2.CONTINUOUS_TIME);
   6655          
   6656                   break;
   6657          
   6658                case TSM_MODULE:
   6659          
   6660                   // --------------------------------------------------------------------------------------------------//
   6661                   // STATUS																							 //
   6662                   // --------------------------------------------------------------------------------------------------//
   6663                   stTSM.SET_NTSC_PAL_MODE = NTSC_MODE;
   6664                   AT24C256C_EEPROM_Write(EEP_SET_NTSC_PAL_MODE, stTSM.SET_NTSC_PAL_MODE);
   6665          
   6666                   // --------------------------------------------------------------------------------------------------//
   6667                   // 2. Thermal Module Control Command (0xBx)																 //
   6668                   // --------------------------------------------------------------------------------------------------//
   6669          
   6670                   /***************************************************************************************************************************
   6671                   * 2.1.4. Shutter Set (0x05)
   6672                      - 0x00 = Shutter Open
   6673                     		   - 0x01 = Shutter Close
   6674                   ****************************************************************************************************************************/
   6675                   stTSM.SHUTTER_SET = 0x00;
   6676                   AT24C256C_EEPROM_Write(EEP_SHUTTER_SET, stTSM.SHUTTER_SET);
   6677          
   6678                   /***************************************************************************************************************************
   6679                   * 2.1.15. Digital Zoom Enable (0x1C)
   6680                      - 0x00 = Shutter Open
   6681                     		   - 0x01 = Shutter Close
   6682                   ****************************************************************************************************************************/
   6683                   stTSM.DIGITAL_ZOOM_ENABLE = 0x00;
   6684                   AT24C256C_EEPROM_Write(EEP_DIGITAL_ZOOM_ENABLE, stTSM.DIGITAL_ZOOM_ENABLE);
   6685          
   6686                   /***************************************************************************************************************************
   6687                   * 2.1.19. AGC Mode Set (0x26)
   6688                      - 0x00 = AGC Mode OFF
   6689                      - 0x01 = AGC Mode
   6690                      - 0x02 = WAGC Mode
   6691                   ****************************************************************************************************************************/
   6692                   stTSM.AGC_MODE_SET = 0x00;
   6693                   AT24C256C_EEPROM_Write(EEP_AGC_MODE_SET, stTSM.AGC_MODE_SET);
   6694          
   6695                   /***************************************************************************************************************************
   6696                   * 2.1.20. Color Mode Set (0x27)
   6697                      - 0x00 = Gray Color Mode
   6698                      - 0x01 = Rainbow Color Mode
   6699                      - 0x02 = Iron Color Mode
   6700                      - 0x03 = Glowbow Color Mode
   6701                      - 0x04 = 2Color Mode
   6702                   ****************************************************************************************************************************/
   6703                   stTSM.COLOR_MODE_SET = 0x00;
   6704                   AT24C256C_EEPROM_Write(EEP_COLOR_MODE_SET, stTSM.COLOR_MODE_SET);
   6705          
   6706                   /***************************************************************************************************************************
   6707                   * 2.1.21. Contrast/Brightness (0x28) (when, AGC OFF)
   6708                      - 0x00:None, 0x01:Contrast, 0x02:Brightnes
   6709                      - [1..255] = GAIN Level (default : 127)
   6710                      - [1..255] = OFFSET Level (default : 127)
   6711                   ****************************************************************************************************************************/
   6712                   stTSM.CONTRAST_BRIGHTNESS_ENABLE = 0x00;
   6713                   AT24C256C_EEPROM_Write(EEP_CONTRAST_BRIGHTNESS_ENABLE, stTSM.CONTRAST_BRIGHTNESS_ENABLE);
   6714          
   6715                   stTSM.CONTRAST_BRIGHTNESS_VAL = 0x7F;
   6716                   AT24C256C_EEPROM_Write(EEP_CONTRAST_BRIGHTNESS_VAL, stTSM.CONTRAST_BRIGHTNESS_VAL);
   6717          
   6718                   /***************************************************************************************************************************
   6719                   * 2.1.22. AGC Center Position Set (0x29)
   6720                      - [25..75%] default 50%
   6721                   ****************************************************************************************************************************/
   6722                   stTSM.AGC_CENTER_POSITION_SET = 50;
   6723                   AT24C256C_EEPROM_Write(EEP_AGC_CENTER_POSITION_SET, stTSM.AGC_CENTER_POSITION_SET);
   6724          
   6725                   /***************************************************************************************************************************
   6726                   * 2.1.23. AGC Limit Level Set (0x2A)
   6727                      - [1..9] = AGC Limit Level
   6728                      - {1=X1, 2=X1.5, 3=X2, 4=X2.5, 5=X3, 6=X5, 7=X9, 8=X15, 9=X30}
   6729                   ****************************************************************************************************************************/
   6730                   stTSM.AGC_LIMIT_LEVEL_SET = 0x04;
   6731                   AT24C256C_EEPROM_Write(EEP_AGC_LIMIT_LEVEL_SET, stTSM.AGC_LIMIT_LEVEL_SET);
   6732          
   6733                   /***************************************************************************************************************************
   6734                   * 2.1.24. AGC ROI (AGC Region of Interest) Set (0x2B)
   6735                      - 0x00 : FULL
   6736                      - 0x01 : CENTER
   6737                      - 0x02 : UNDER
   6738                      - 0x03 : UPPER
   6739                      - 0x04 : LEFT
   6740                      - 0x05 : RIGHT
   6741                   ****************************************************************************************************************************/
   6742                   stTSM.AGC_ROI = 0x01;
   6743                   AT24C256C_EEPROM_Write(EEP_AGC_ROI, stTSM.AGC_ROI);
   6744          
   6745                   /***************************************************************************************************************************
   6746                   * 2.1.25. MIDE Level Set (0x2C) (when, Sharpness OFF)
   6747                      - [0..15] = {0:OFF, 1..15:MIDE Level}
   6748                   ****************************************************************************************************************************/
   6749                   stTSM.MIDE_LEVEL_SET = 0x00;
   6750                   AT24C256C_EEPROM_Write(EEP_MIDE_LEVEL_SET, stTSM.MIDE_LEVEL_SET);
   6751          
   6752                   /***************************************************************************************************************************
   6753                   * 2.1.26. Sharpness Level Set (0x2D) (when, MIDE OFF)
   6754                      - [0..10] = {0:OFF, 1..10:Sharpness Level}
   6755                   ****************************************************************************************************************************/
   6756                   stTSM.SHARPNESS_LEVEL_SET = 0x00;
   6757                   AT24C256C_EEPROM_Write(EEP_SHARPNESS_LEVEL_SET, stTSM.SHARPNESS_LEVEL_SET);
   6758          
   6759                   // 2.1.27. Detect Mode Set (0x31)
   6760                   // 2.1.28. Area Position Set (0x32)
   6761                   // 2.1.29. Spot Position Set (0x33)
   6762                   // 2.1.30. High Alarm Temperature (0x34)
   6763                   // 2.1.31. Low Alarm Temperature (0x35)
   6764                   // 2.1.32. Select Alarm (0x36)
   6765                   // 2.1.33. Alarm Mode (0x37)
   6766                   // 2.1.34. Temperature OSD (0x38)
   6767                   // 2.1.35. Emissivity Set (0x39)
   6768                   // 2.1.36. Mirror Mode Set (0x44)
   6769                   // 2.1.37. Flip Mode Set (0x45)
   6770          
   6771                   /***************************************************************************************************************************
   6772                   * 2.1.39. Image Color Inverse(White/Black Hot) Set (0x47)
   6773                      - 0x00 = Inverse Mode OFF(White Hot)
   6774                      - 0x01 = Inverse Mode ON(Black Hot)
   6775                   ****************************************************************************************************************************/
   6776                   stTSM.IMAGE_COLOR_INVERSE_SET = 0x00;
   6777                   AT24C256C_EEPROM_Write(EEP_IMAGE_COLOR_INVERSE_SET, stTSM.IMAGE_COLOR_INVERSE_SET);
   6778          
   6779                   break;
   6780                }
   6781          
   6782                AT24C256C_EEPROM_Write(EEP_PROM_MARK, EEP_HEADER);
   6783          
   6784             }
   6785          }
   6786          
   6787          /*******************************************************************************
   6788          * IBDR Main Function
   6789          *******************************************************************************/
   6790          
   6791          
   6792          int main(void)
   6793          {
   6794             // =======================================
   6795             // Initialization Device
   6796             // =======================================
   6797             Initial_Device();
   6798          
   6799          	u16 i;
   6800          
   6801             while (1)
   6802             {
   6803             	for (i = 0; i < 100; i++) {
   6804          	TIM4 -> CCR1 = i;
   6805          	delayR(100);
   6806             	}
   6807          
   6808          	for(i = 98; i > 0; i--) {
   6809          	TIM4 -> CCR1 = i;
   6810          	delayR(100);
   6811          
   6812          	}
   6813          	
   6814          
   6815          /* LED ON/OFF */
   6816          //	      LED_On_Red();
   6817          //	      Delay_1ms(500);
   6818          //	      LED_Off_Red();
   6819          //	      Delay_1ms(500);
   6820          //		  
   6821          //	      LED_On_Green();
   6822          //	      Delay_1ms(500);
   6823          //	      LED_Off_Green();
   6824          //	      Delay_1ms(500);
   6825          //		  
   6826          //	      LED_On_Yellow();
   6827          //	      Delay_1ms(500);
   6828          //	      LED_Off_Yellow();
   6829          //	      Delay_1ms(500);
   6830          
   6831          
   6832          /* SW + LED ON/OFF */
   6833          //	      User_SW_On_LED_Ren_On();
   6834          
   6835             }
   6836          
   6837          } //End Main
   6838          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  AT24C256C_EEPROM_Read
               8 -> I2C2_Read
       16  AT24C256C_EEPROM_Write
              16 -> I2C2_Write
        0  Auto_Day_And_Night_Control
       56  Before_USART1_Data_Parser
              56 -> GPIO_ResetBits
              56 -> GPIO_SetBits
              56 -> Reponse_Data_Send
              56 -> Send_Light_Data
              56 -> Send_Sony_Data
        8  Bypass_Data_Parser
               8 -> Delay_1ms
               8 -> USART_SendData
        0  CDS_Data_Check
        0  DATA_Request_Handing
        8  EEPROM_Memory_Read
               8 -> AT24C256C_EEPROM_Read
               8 -> AT24C256C_EEPROM_Write
        8  Fan_Heater_Control
               8 -> GPIO_ResetBits
               8 -> GPIO_SetBits
               8 -> Temperature_Convert_Data
        8  LRF_Initialization
               8 -> Send_LRF_Data
        8  MDIN_I550_Initialization
               8 -> Delay_ms
               8 -> GPIO_ReadInputDataBit
               8 -> GPIO_ResetBits
               8 -> GPIO_SetBits
               8 -> MDIN_Sprite_Initialization
      136  MDIN_Sprite_Initialization
             136 -> Send_MDIN_Data
       16  Module_Auto_Sync
              16 -> Delay_1ms
              16 -> Send_Sony_Data
              16 -> Send_TSM_Data
              16 -> UART4_Init
       56  OPTION_Data_Handing
              56 -> AT24C256C_EEPROM_Read
              56 -> AT24C256C_EEPROM_Write
              56 -> Delay_1ms
              56 -> USART_SendData
        8  OSD_Layer_Select
               8 -> MDIN_Sprite_Initialization
       64  PELCO_Data_Handing
              64 -> Send_Pelco_Data
              64 -> Send_Sony_Data
              64 -> Send_TSM_Data
       24  PTZ_Data_Handing
              24 -> Delay_1ms
              24 -> USART_SendData
       16  Reponse_Data_Send
              16 -> USART_SendData
        8  Send_Data_Clear
       16  Send_LRF_Data
              16 -> Delay_1ms
              16 -> USART_SendData
       40  Send_Light_Data
              40 -> Delay_1ms
              40 -> USART_SendData
       40  Send_MDIN_Data
              40 -> Delay_1ms
              40 -> USART_SendData
       32  Send_MDIN_String_Data
              32 -> Delay_1ms
              32 -> USART_SendData
       32  Send_Pelco_Data
              32 -> Delay_1ms
              32 -> USART_SendData
       32  Send_Request_Data
              32 -> Delay_1ms
              32 -> USART_SendData
       24  Send_Sony_Data
              24 -> Delay_1ms
              24 -> USART_SendData
       40  Send_TCM_Data
              40 -> Delay_1ms
              40 -> USART_SendData
       32  Send_TSM_Data
              32 -> Delay_1ms
              32 -> USART_SendData
       32  Send_UART4_Ack
              32 -> Delay_1ms
              32 -> USART_SendData
        8  SetSysClockTo72
               8 -> RCC_DeInit
               8 -> RCC_GetFlagStatus
               8 -> RCC_GetSYSCLKSource
               8 -> RCC_HCLKConfig
               8 -> RCC_HSEConfig
               8 -> RCC_PCLK1Config
               8 -> RCC_PCLK2Config
               8 -> RCC_PLLCmd
               8 -> RCC_PLLConfig
               8 -> RCC_SYSCLKConfig
               8 -> RCC_WaitForHSEStartUp
       48  Sony_Data_Handing
              48 -> AT24C256C_EEPROM_Write
              48 -> Send_Sony_Data
              48 -> USART1_Send_Data
      168  System_Data_Parser
             168 -> Delay_1ms
             168 -> MDIN_I550_Initialization
             168 -> Module_Auto_Sync
             168 -> OPTION_Data_Handing
             168 -> OSD_Layer_Select
             168 -> RCC_APB1PeriphClockCmd
             168 -> Send_MDIN_Data
             168 -> Send_MDIN_String_Data
             168 -> Send_TSM_Data
             168 -> Sony_Data_Handing
             168 -> TCM_Data_Handing
             168 -> TSM_Data_Handing
             168 -> UART4_Init
             168 -> USART_SendData
             168 -> VIDEO_Initialization
             168 -> WWDG_Enable
             168 -> WWDG_SetPrescaler
             168 -> WWDG_SetWindowValue
       88  TCM_Data_Handing
              88 -> Send_TCM_Data
       64  TSM_Data_Handing
              64 -> Delay_1ms
              64 -> Send_TSM_Data
              64 -> USART_SendData
        8  TW9900_DECODER_RESET_High
               8 -> GPIO_SetBits
        8  TW9900_DECODER_RESET_Low
               8 -> GPIO_ResetBits
       16  TW9900_Initial
              16 -> Delay_ms
              16 -> TW9900_DECODER_RESET_High
              16 -> TW9900_I2C1_ByteWrite
        0  Temperature_Boot_Mode
        0  Temperature_Convert_Data
        0  Temperature_Data_Check
       16  UART5_Data_Parser
              16 -> DATA_Request_Handing
              16 -> OPTION_Data_Handing
              16 -> PELCO_Data_Handing
              16 -> PTZ_Data_Handing
              16 -> Sony_Data_Handing
              16 -> TCM_Data_Handing
              16 -> TSM_Data_Handing
      168  USART1_Data_Parser
             168 -> OSD_Layer_Select
             168 -> Send_MDIN_Data
             168 -> Send_MDIN_String_Data
             168 -> Sony_Data_Handing
             168 -> TSM_Data_Handing
       40  USART1_Send_Data
              40 -> Delay_1ms
              40 -> USART_SendData
        8  VIDEO_Initialization
               8 -> Delay_1ms
               8 -> Delay_ms
               8 -> GPIO_ResetBits
               8 -> GPIO_SetBits
               8 -> TW9900_DECODER_RESET_Low
               8 -> TW9900_Initial
        0  Zoom_Data_Sync
       40  Zoom_Light_Auto_Control
              40 -> Send_Light_Data
        8  main
               8 -> Initial_Device
               8 -> delayR


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable14
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
       4  ??DataTable20_7
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable23
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_2
       4  ??DataTable24_3
       4  ??DataTable24_4
       4  ??DataTable24_5
       4  ??DataTable28
       4  ??DataTable29
       4  ??DataTable29_1
       4  ??DataTable36
       4  ??DataTable36_1
       4  ??DataTable38
       4  ??DataTable38_1
       4  ??DataTable38_2
       4  ??DataTable38_3
       4  ??DataTable38_4
       4  ??DataTable38_5
       4  ??DataTable39
       4  ??DataTable40
       4  ??DataTable40_1
       4  ??DataTable40_10
       4  ??DataTable40_2
       4  ??DataTable40_3
       4  ??DataTable40_4
       4  ??DataTable40_5
       4  ??DataTable40_6
       4  ??DataTable40_7
       4  ??DataTable40_8
       4  ??DataTable40_9
       1  ABB_255_Flag
       1  ABB_Heater_Set
       1  ACTdCount
       1  ACTnCount
       4  ADCConvertedData
       8  ADCConvertedValue
       4  ADC_Value
       1  AFMTimer
       1  AFManual
       1  AFMode
      12  AFMsg
       1  AFactFlag
       4  AFmsTimer
       1  AFocusFlag
       1  AFsTimer
      20  AGCFreezeMsg
       1  AGCGainBias
       1  AGCLevelBias
       1  AGCLimitLevel
       1  AGCMode
      12  AGCMsg
      44  AGCstatusMsg
       1  AIrisFlag
      14  AT24C256C_EEPROM_Read
      20  AT24C256C_EEPROM_Write
      16  AWBModeMsg
       1  AbsFocusFlag
       1  AdBufCnt
       4  AdCDS
       4  AdCDSBuf
       1  AdChkCnt
       4  AdDone
       4  AdDoneCnt
       4  AdFar
       4  AdFarBuf
       4  AdNear
       4  AdNearBuf
       1  AdProCnt
       1  AdjFlag
      24  AgcFMsg
      24  AgcHMsg
      24  AgcLMsg
      24  AgcMMsg
      56  AgcMsg
       1  AgcVal
       4  AlarmCount
       1  AlarmDetect
       4  AlarmDetectMsg
       1  AlarmDisplayFlag
       1  AlarmFlag
       1  AlarmInMode
       1  AlarmMode
       4  AlarmMsg
      16  AlarmSetMsg
      16  AlarmStatusMsg
      84  AllEraseMsg
      92  AllMsg
       4  AlmAct
      56  AlmActMsg
       4  AlmAuxAct
       8  AlmAuxCnt
       1  AlmBlk
       1  AlmBuf
       1  AlmEnable
       1  AlmFlag
      56  AlmInMsg
       4  AlmInput
      64  AlmMMsg
      64  AlmMsg
       1  AlmNo
      56  AlmNoMsg
       1  AlmOSD
      84  AlmOffMsg
      84  AlmOnMsg
       1  AlmRecv
       1  AlmRx
       1  AlmT
       1  AlmTemp
       1  AperVal
      56  AptMsg
      48  AreaMsg
      52  AutoDrMsg
      52  AutoDwMsg
      52  AutoEdMsg
      52  AutoFnMsg
      12  AutoFocusMsg
      68  AutoMsg
       8  AutoPanMsg
      52  AutoSpdMsg
      52  AutoStMsg
     252  Auto_Day_And_Night_Control
       1  Aux1Buf
      80  Aux1OffMsg
      80  Aux1OnMsg
       1  Aux2Buf
      80  Aux2OffMsg
      80  Aux2OnMsg
      56  AuxActMsg
       1  AuxMode
      16  AuxMsg
       8  BackBuf
      48  BaudMsg
       1  BaudRate
       1  Baud_Buffer
      44  BaudrateMsg
    1768  Before_USART1_Data_Parser
      12  BlankMsg
       1  BlcAreaBottom
       1  BlcAreaLeft
       1  BlcAreaMode
       1  BlcAreaRight
       1  BlcAreaSel
       1  BlcAreaTop
       1  BlcEn
       1  BlcEnI
       1  BlcLevel
       1  BlcMode
      20  BlcMode1Msg
      12  BlcModeMsg
      12  BlcModeSMsg
      56  BlcMsg
      60  BlcOffMsg
      60  BlcOnMsg
      56  BlcSetMsg
      20  BlcShortModeMsg
       1  BlcSubCur
       1  BlcSubEn
       1  BlcSubMenu
      24  BlcSubModeMsg
       4  BlkMsg
     102  Bypass_Data_Parser
       8  CDSMsg
       4  CDS_Average_Value
       4  CDS_Buffer_Cnt
     128  CDS_Data_Check
       4  CDS_Day_Check_Cnt
       4  CDS_Night_Check_Cnt
       4  CDS_Total_Value
       4  CDS_convertV
       1  COMMAND_CODE
      20  CRxBuf
       1  CRxReceived
       1  CRxTail
      20  CTxBuf
       1  CTxMax
       1  CTxTail
       1  CURRENT_STATUS
      24  CZoomModeMsg
      20  CZoomOffMsg
      20  CZoomOnMsg
       1  CZoomSet
       1  CamCodeRecv
      48  CamDisMsg
       1  CamID_Buffer
      64  CamIdMsg
       8  CamIdsMsg
      20  CamInitialMsg
       1  CamModuleInfo
      16  CamRxBuf
       1  CamRxCnt
      64  CamSetMsg
      72  CamTestMsg
      20  CamTxBuf
       1  CamType
       8  CamType1Msg
       8  CamType2Msg
      24  CdZoomModeMsg
      20  CdZoomOffMsg
      20  CdZoomOnMsg
       1  CdZoomSet
      36  CelsiMsg
       1  CharLeng
      24  CheckHeater1Msg
      28  CheckHeaterMsg
      36  CheckLockMsg
       1  CheckSum
      36  CheckSyncMsg
       4  CheckTempValue
      28  CheckZoomMsg
       1  Check_Byte
       1  ChkFlag
      68  ChkMsg
      20  ChkOkMsg
      20  ClrMsg
       1  CndFlag
       1  CntReplyAlm
       4  CntSetReq
      36  CodiMsg
       1  CodiRef
       1  ColBaudFlag
       1  ColdCondition
       4  ColdCondition_Check_Time
       1  ColdCondition_Timer_Flag
      16  ColdStart1Msg
      12  ColdStartMsg
       1  Cold_Module_Init_Check
       1  Cold_Start_EnableFlag
       1  ColorBaud
      16  ColorCamMsg
      20  ColorModuleMsg
      56  ColorMsg
       8  ColorTMsg
       4  ColorVal
      16  ColorbaudMsg
       1  CommAcc
       1  CommAccA
       1  CommAccB
      20  CommErrMsg
       1  CommRate
      16  ConfigMsg
      92  ContinuousTimeMsg
       1  ConvertData
       1  DATA1_CODE
       1  DATA2_CODE
       2  DATA_Request_Handing
      36  DN0Msg
      36  DN1Msg
      36  DN2Msg
      72  DNAMsg
      72  DNDMsg
      36  DNLevMsg
       1  DNLevelFlag
       1  DNLevelSet
       1  DNMode
      72  DNNAMsg
      72  DNNMsg
      20  DRSLogoDisplayMsg
       1  DRS_NtPalSet
       1  DRS_RECIVE_COMPLETE
       4  DRS_Zoom_Count
       1  DSSMode
      76  DSSValMsg
       1  DZoom
       1  DZoomCount
      56  DZoomMsg
       1  DZoomPos
       1  Data_Test
       1  DayFlag
       4  DayFlagMsg
       1  DayNightSubMenu
      84  DefaultInitMsg
      60  DefaultMsg
       1  DirectPattFlag
      56  Dis1Msg
       1  DisEn
      36  DisMsg
       8  DisOffMsg
       8  DisOnMsg
       4  DispBuf
      20  DispCode
      56  DnNMsg
       1  DnrMode
      56  DnrMsg
       1  DomeId
      56  DssMsg
      72  DssNAMsg
      72  DssOffMsg
      72  DssOnMsg
       4  DwellMs
       4  DwellSec
    1016  EEPROM_Memory_Read
       1  EXCUTE_CODE
      36  EnMsg
      12  EngErrMsg
      32  EnglishMsg
      16  EpromCheckMsg
      80  EraseMsg
      32  EraseMsgClr
       4  ErrData
      60  ErrMsg
       1  Error_Offset_Check
       1  Error_Repeat_Cnt
      24  ExitMsg
      20  External_Title_Msg
       1  FRZMode
      36  FahreMsg
       1  FailFlag
       1  FanBuf
       1  FanFlag
       8  FanOffMsg
       8  FanOnMsg
       8  FanSetMsg
       1  Fan_Dewell_End_Flag
       1  Fan_Dewell_Flag
       4  Fan_Dwell_Time_ms
       4  Fan_Dwell_Time_sec
     588  Fan_Heater_Control
       1  Fan_Heater_First_Check_Flag
       4  Fan_Heater_First_Check_Time
       1  Fan_Heater_First_On_Flag
       1  Fan_State
      84  FarMsg
      28  FastMsg
       8  FastTMsg
       1  FlagReqAlm
       1  FlagReqSts
      12  FlickerMsg
      64  FlipMsg
      80  FlipOffMsg
      80  FlipOnMsg
      40  FlipStMsg
       1  FlkEn
      56  FlkMsg
      28  FocuFarMsg
      20  FocuNearMsg
       2  FocuPos
       2  FocuPos_SCM
      76  FocusAdjMsg
       1  FocusFlag
       1  FocusMan
      12  FocusModeMsg
       1  FocusModeVal
      88  FocusSSetMsg
      20  FocusSValMsg
       1  FocusSpdVal
       4  FocusStopCount
      12  FourMsg
      40  FreezeAllMsg
      40  FreezeMsg
       1  Freeze_Data
      72  FrzNAMsg
      88  FrzOffMsg
      88  FrzOnMsg
      12  FullAEMsg
       1  GHeaterActFlag
       1  GHeaterBuf
       1  GHeaterDispFlag
       1  GHeaterInter
       1  GHeaterMode
      20  GHeaterOffMsg
       1  GHeaterOffVal
      20  GHeaterOnMsg
       1  GHeaterOnVal
       4  GInterCount
       1  GInterMCount
       1  GInterSCount
       1  GainMode
      32  GainValMsg
      32  GainValMsg1
      16  GlassHeaterMsg
       4  HeatOffMsg
       4  Heater1OnMsg
       4  Heater2OnMsg
       1  HeaterActFlag
      12  HeaterAutoMsg
       1  HeaterFlag
      12  HeaterIntervalMsg
      12  HeaterOffMsg
      12  HeaterOnMsg
      20  HeaterSetMsg
      16  HeaterStatusMsg
       1  Heater_State
      20  HexCode
      24  HighMsg
       1  HitFlag
       1  HlcLevel
       1  HlcMaskColor
      12  HlcModeSMsg
      60  HlcOffMsg
      60  HlcOnMsg
      32  HomeautoMsg
       8  HomeblankMsg
      32  HomepattMsg
      64  HomeposMsg
      32  HomeprstMsg
      32  HomescanMsg
      32  HometourMsg
       1  HrMode
      56  HrMsg
       1  ICRThreshold
       1  ICanTek
      36  IDEHighInfoMsg
      16  IDEModeMsg
       1  IDEModeVal
       1  IDEModeValFlag
      36  IDElowInfoMsg
      16  IRISMsg
       1  IR_Duty_Step
       1  IR_Set_Check
       8  IR_Set_Msg
       1  IR_Test_Mode
       1  ISMode
      56  ISMsg
       1  IdDisp
       1  IdDisp2
      44  IdDispMsg
       1  IdPosBuf
       1  InHeaterDispFlag
       1  InHeaterInter
       1  InHeaterMode
       1  InHeaterOffVal
       1  InHeaterOnVal
       1  InheaterCount_M
       1  InheaterCount_Ms
       1  InheaterCount_S
      64  Init1Msg
      48  Init21Msg
      52  Init2Msg
      56  Init31Msg
      60  Init3Msg
      52  Init41Msg
      48  Init4Msg
      72  Init51Msg
      76  Init5Msg
      60  Init61Msg
      60  Init6Msg
      84  Init71Msg
      84  Init7Msg
      72  InitMsg
       1  InitOpt
      16  InnerHeaterMsg
      20  InnerHeaterOffMsg
      20  InnerHeaterOnMsg
       1  Inner_Heater_State
       4  InterCount
       1  InterMCount
       1  InterSCount
      16  InterTimeMsg
      12  InterValOnePushMsg
       1  InverseMode
      16  InverseModeMsg
      20  InverseOffMsg
      20  InverseOnMsg
      44  IrBrtMsg
       8  IrisAutoMsg
       8  IrisCloseMsg
       1  IrisFlag
      40  IrisLevelMsg
       1  IrisMan
      24  IrisMaxLevelMsg
       1  IrisMaxVal
       1  IrisMode
       1  IrisModeSet
       1  IrisPeakVal
       1  IrisSubMenu
       1  IrisVal
     144  IrisValMsg
       1  Joy_Zoom
       1  JoystickSW
       1  KeyFlag
       1  KeyInputFlag
      42  LRF_Initialization
      64  LangMsg
       1  Language
       4  Led1BlinkTimeMs
       4  Led2BlinkTimeMs
       4  Led3BlinkTimeMs
       1  LedCurFlag
       1  LedFlag
      12  LedOffMsg
      12  LedOnMsg
       1  LedStatus
       4  LeftMsg
      52  LeftTopMsg
      36  LensMsg
       1  LensSetFlag
      12  LensSetMsg
       1  LensVal
      48  LevelMsg
       1  LimFlag
      48  LimitMsg
      24  LoadingMsg
       1  LockEn
      48  LockMsg
       1  LogoEnFlag
       1  LogoModeVal
       8  LogoMsg
      24  LowMsg
      90  MDIN_I550_Initialization
    1250  MDIN_Sprite_Initialization
       1  MODULE_SELECT
      24  MOffMsg
       1  MPVal
      20  MWbBGainMsg
      20  MWbRGainMsg
      24  MainAlmMsg
      48  MainBarMsg
      60  MainCamMsg
      16  MainCameraMsg
       1  MainCur
      60  MainDomMsg
      24  MainExtMsg
      16  MainMsg
      24  MainMsg10
      56  MainMsg2
      52  MainMsg3
      24  MainMsg9
      24  MainPatMsg
      24  MainPreMsg
      64  MainPriMsg
      32  MainScanMsg
      24  MainTitMsg
      16  MainTourMsg
      64  ManMsg
      48  MaskMsg
      28  MediMsg
       1  MenuFlag
       1  MenuKey
       1  Menu_IR_Set
      24  MiddleMsg
       1  MinusFlag
       8  MinuteMsg
       1  MirrorDisp
      56  MirrorMsg
      12  MirrorOffMsg
      12  MirrorOnMsg
       1  Mode
      48  ModeMsg
     118  Module_Auto_Sync
      28  MotorLevH
      24  MotorLevL
      28  MotorLevM
      40  MotorTrqMsg
       1  Motor_FG_Check
       4  Motor_FG_Count
       4  Motor_FG_Save_Buf
       1  Motor_FG_Temp
       4  NAMsg
      16  NCMsg
      16  NOMsg
      24  NTPALMsg
       8  NTSCMsg
       1  NT_PAL_MODE
      16  NameBuf
      20  New_Test_Msg
      56  NextMsg
       1  NightFlag
       4  NightFlagMsg
      12  NineMsg
      12  NoMsg
      36  NoTestMsg
      72  NonData
      36  NonDataClr
      36  NormalMsg
       4  NotAvailableMsg
       1  NtPalMode
       1  NtPalSetFlag
    1066  OPTION_Data_Handing
       1  OSD_Flag
     158  OSD_Layer_Select
       1  OSD_Refresh
      16  OffMsg
       1  OkFlag
       1  OnAlarm
      16  OnMsg
      12  OnePushMsg
       8  OrCode
      16  OsdCamIDMsg
      40  OsdCooMsg
      60  OsdDispMsg
      16  OsdGHeaterMsg
      16  OsdGTempMsg
      16  OsdHeaterMsg
      40  OsdIdMsg
      40  OsdPattMsg
      40  OsdPreMsg
      40  OsdScanMsg
      40  OsdSecMsg
      16  OsdStatusMsg
      40  OsdTourMsg
       8  OsdWiperMsg
       8  PALMsg
      52  PClearMsg
      60  PClrMsg
    1158  PELCO_Data_Handing
      60  PMainMsg
      60  PSaveMsg
      64  PStatusMsg
     144  PTZ_Data_Handing
       4  PanContCnt
       4  PanMsg
      72  PanTestMsg
      16  PanTiltMsg
       1  PassCode
      40  PassMsg
       1  PassWord
      60  PassWordIn1Msg
      80  PassWordIn2Msg
      48  PassWordIn3Msg
      48  PassWordIn4Msg
       4  PassWordIn5Msg
      48  PassWordIn6Msg
      48  PassWordIn7Msg
      52  PassWordIn8Msg
      60  PatClrMsg
      52  PattIdMsg
      52  PattMsg
       8  PattNMsg
      52  PattNoMsg
       1  PattRdyFlag
      52  PattTmMsg
       1  PicFlip
      56  PicFlipMsg
      16  PicFlipOffMsg
      16  PicFlipOnMsg
       1  PinFlag
       1  PreFlag
      44  PreIdMsg
       1  PreIdPosBuf
       1  PreKey
      60  PreMsg
       1  PreNoBuf
      44  PreNoMsg
       1  PreZoomCnt
       1  PrevKey
      60  PrevMsg
      72  PreviMsg
      48  PriActMsg
      28  PriMoveMsg
      48  PriNumMsg
      48  PriStrMsg
      28  PriTLMsg
      12  ProMsg
       8  ProMsg1
       8  ProMsg2
      12  ProMsg3
      16  PromMsg
      36  ProtoMsg
       1  Protocol
       1  RLFlag
       1  RLKey
       1  RS_ZOOM
       1  RUpDay
       1  RUpMonth
       1  RUpYear
      48  RangeMsg
      24  RangeNMsg
      24  RangeWMsg
      84  RdyMarkMsg
      60  ReStartMsg
      64  RecMsg
       1  Recive_Flag
       1  Recover
       1  RecoverF
      20  RecoverTimeSetMsg
       1  RefTemp
      60  RemoteRstMsg
     148  Reponse_Data_Send
      36  ReverseMsg
      52  RightBottomMsg
       4  RightMsg
       1  RlKey
      48  RstMsg
       8  RxBuf
      16  RxBuf1
      12  RxBuf_DRS
      12  RxBuf_SCM
       1  RxCnt
       1  RxCnt_DRS
       1  RxCnt_SCM
       1  RxMaxCnt
       1  RxMaxCnt_DRS
       1  RxPoint
       1  RxStt1
       1  RxStt_BD
       1  RxTemp
       1  SCM_RECIVE_COMPLETE
       8  SClrMsg
       4  SECMsg
       1  SMark
       1  SSDREn
       4  SSDRLevel
       1  SSDRrange
      48  SaveExitMsg
       1  SaveFlag
      24  SaveMsg
      24  SavingMsg
      24  ScheduleTourDwellMsg
      28  ScheduleTourSpeedMsg
      52  SecFnMsg
      52  SecIdMsg
      60  SecMsg
      52  SecNoMsg
      52  SecStMsg
       8  SecondBuf
       1  SecondCnt
      42  Send_Data_Clear
     470  Send_LRF_Data
     150  Send_Light_Data
     836  Send_MDIN_Data
     242  Send_MDIN_String_Data
     148  Send_Pelco_Data
    1004  Send_Request_Data
     400  Send_Sony_Data
     296  Send_TCM_Data
     122  Send_TSM_Data
     326  Send_UART4_Ack
       1  SetFlag
      94  SetSysClockTo72
       1  SetUpFlag
     364  ShuttNTSpdMsg
     364  ShuttPALSpdMsg
      24  ShuttSValMsg
       1  ShutterMode
      40  ShutterModeMsg
       1  ShutterSpd
     132  ShutterSpdMsg
       1  ShutterSpdVal
       1  ShutterSubMenu
      28  SlowMsg
       8  SlowTMsg
    4306  Sony_Data_Handing
       8  Speed
      52  SpeedMsg
      12  SsdrModeSMsg
      60  SsdrOffMsg
      60  SsdrOnMsg
       1  SsnrEn
      16  SsnrFMsg
      16  SsnrHMsg
      16  SsnrLMsg
      16  SsnrMMsg
      56  SsnrMsg
      64  StatusMsg
       4  SubBlcMsg
       1  SubCur
       1  SubFlag
       4  SubWdrMsg
      48  SureMsg
      64  Sys1SetMsg
      60  SysBMsg
      60  SysCMsg
      20  SysColorMsg
      60  SysFMsg
      20  SysModelMsg
      52  SysMsg
      60  SysPMsg
      60  SysRUMsg
      64  SysSetMsg
      60  SysStsMsg
      20  SysThermalMsg
      60  SysUMsg
      16  SystemStartMsg
      16  SystemStatusMsg
    2134  System_Data_Parser
      16  TAGCGainBiasMsg
      16  TAGCLevelBiasMsg
      16  TAGCLimitMsg
      56  TAGCLimitValMsg
      12  TAGCModeMsg
    3194  TCM_Data_Handing
      12  TCamType1Msg
      12  TCamType2Msg
      12  TCamType3Msg
       4  TCdsMsg
      60  TClrMsg
       4  TEMPBuf
       4  TMcount
       1  TModule
       4  TMscount
    2064  TSM_Data_Handing
       4  TScount
      14  TW9900_DECODER_RESET_High
      14  TW9900_DECODER_RESET_Low
      62  TW9900_Initial
      24  TZoomModeMsg
      20  TZoomOffMsg
      20  TZoomOnMsg
       1  TZoomSet
       1  Temp
       4  TempBlankMsg
       1  TempCheckCount
       1  TempCheckFlag
       1  TempCount
       1  TempDispFlag
       1  TempDispVal
       1  TempFlag
       1  TempMonitorting
       8  TempMsg
      12  TempRxBuf
       1  Temp_Count
       1  Temp_Count_S
       4  TemperCnt
       1  TemperFlag
      36  TemperMsg
       1  Temperature
      64  Temperature_Boot_Mode
     930  Temperature_Convert_Data
     164  Temperature_Data_Check
       8  TestData
      40  TestFailMsg
       8  TestMsg
       4  TestOkMsg
      12  TestStartMsg
       1  TestUse
       1  TherBaudFlag
       1  TherBaudSetFlag
       1  ThermalBaud
       1  ThermalBaudset
      16  ThermalCamMsg
      16  ThermalMainCamMsg
      20  ThermalbaudMsg
      16  ThermalbaudsetMsg
       8  ThreeBuf
      20  TiltInitMsg
       8  TiltMsg
       1  TiltRepeat
      72  TiltTestMsg
       4  Time0
       4  Time1ms
       1  Time1ms2
       4  Time1sec
       4  Time50ms
       4  TimeCnt
       1  TimeFlag
       1  TimeLevel
       4  TmCount
       4  Totol_Motor_FG_Count
      60  TourDwellMsg
      36  TourIdMsg
      60  TourMsg
      16  TourNMsg
      52  TourNoMsg
      52  TourPreMsg
      16  TourSetNoMsg
      24  TourSetPrstMsg
      12  TourSetStepMsg
      52  TourStepMsg
      12  TwoMsg
      20  TxBuf
      16  TxBuf1
       1  TxBufCnt1
       1  TxBufCnt_485
       1  TxBufCnt_DRS
       1  TxBufCnt_SCM
      12  TxBuf_485
      12  TxBuf_DRS
       1  TxCnt
       1  TxCnt1
       1  TxCnt_485
       1  TxCnt_DRS
       1  TxMax
       1  TxMaxRef
       1  TxMaxRef_DRS
       1  TxMaxRef_SCM
       1  TxMax_485
       1  TxMax_DRS
       1  TxMax_SCM
      72  TxTestMsg
     226  UART5_Data_Parser
      12  UDateMsg
       8  URxBuf
     776  USART1_Data_Parser
       1  USART1_RECIVE_COMPLETE
      12  USART1_RxBuf
       1  USART1_RxCnt
       1  USART1_RxMaxCnt
     214  USART1_Send_Data
      12  USART1_TempRxBuf
      12  USART3_TxBuf
       1  USART3_TxCnt
       1  UpDownFlag
       1  UpDownKey
      92  VIDEO_Initialization
       8  VerMsg
      72  VibNAMsg
      88  VibOffMsg
      88  VibOnMsg
      24  VideoGainMsg
      48  VideoModeMsg
      36  WB0Msg
      36  WB1Msg
      36  WB2Msg
      36  WB3Msg
      36  WB4Msg
       1  WBMode
      56  WBMsg
       1  WDRnoInc
      48  Wait1Msg
      40  WasherTimeMsg
      16  Washer_Fluid_Msg
       1  Washer_Fluid_Set
       1  Washer_Spray_Flag
       4  Washer_Spray_time
       4  Washer_Spray_time2
       4  Washer_Spray_time2_Delay
      12  Washer_Time_Msg
       4  Washer_Time_Set
       1  Washer_Time_Val
       1  WbBGain
       1  WbRGain
       1  WdrBlcEn
       1  WdrBlcMode
      60  WdrBlcOffMsg
      12  WdrModeSMsg
      56  WdrMsg
      60  WdrOffMsg
      60  WdrOnMsg
      16  WiperActiveMsg
       4  WiperCntMsg
      12  WiperErrorMsg
       4  WiperOnMsg
      20  WiperRepeatOffMsg
      16  WiperRepeatOn2Msg
      16  WiperRepeatOnMsg
      16  WiperSetMsg
      24  WiperSetOffMsg
      24  WiperSetOnMsg
      24  WiperStateMsg
       1  WiperSubMenu
       1  WiperTimelSet
       1  Wiper_Active_1
       4  Wiper_Active_Checktime
       1  Wiper_Active_Cnt
       1  Wiper_Active_Flag
       1  Wiper_Active_Save
       4  Wiper_Add_time
       1  Wiper_Continuous_Delay_Flag
       4  Wiper_Continuous_Delaytime
      16  Wiper_Continuous_Msg
       1  Wiper_Continuous_flag
      12  Wiper_Count_Msg
       1  Wiper_Count_Val
       1  Wiper_Direction_Flag
       1  Wiper_Dwell_Flag
       1  Wiper_Dwell_Time
       1  Wiper_Dwell_Timer_10ms
       1  Wiper_Dwell_Timer_1hour
       1  Wiper_Dwell_Timer_1minute
       1  Wiper_Dwell_Timer_1s
       1  Wiper_Error_Check
       4  Wiper_Error_Check_Time
       4  Wiper_Error_Check_Time_ms
       1  Wiper_Error_Msg
       1  Wiper_Error_Sensor_Check
       1  Wiper_Error_Sensor_Check_Before
       1  Wiper_Error_Status_Flag
       1  Wiper_Manual_Set
       1  Wiper_Origin_Chk
       1  Wiper_Origin_Reset_Chk
       4  Wiper_Repear_delay_time
       1  Wiper_Repeat2_Sensor_Check
       1  Wiper_Repeat_Active_Flag
       1  Wiper_Repeat_Active_Flag2
       4  Wiper_Repeat_Cnt
       1  Wiper_Sens_Count
       1  Wiper_Sens_High
       1  Wiper_Sens_Low
       1  Wiper_Sens_Temp
      12  Wiper_Set_Msg
       1  Wiper_Test_Mode
       4  Wiper_Timer_Chk_Val
       1  Wiper_Timer_Flag
       1  Wiper_Timer_Set
       4  Wiper_Timer_Set_Val
      12  YesMsg
       1  ZCamCodeRecv
      20  ZCamRxBuf
       1  ZCamRxCnt
       2  ZFocuPos
       1  ZOOMDATA_RECIVE_COMPLETE
       1  ZPosRetryCount
       4  ZPosWaitTime
       1  ZPreZoomCnt
      20  ZTxBuf
       1  ZTxCnt
       1  ZTxMax
       1  ZTxMaxRef
       1  ZZoomCnt
       1  ZZoomLed
       2  ZZoomPos
       1  ZZoomTCnt
       8  ZoomBothMsg
       1  ZoomChkCnt
       1  ZoomCnt
       4  ZoomData
       1  ZoomFlag
       1  ZoomInFlag
       1  ZoomLed
      16  ZoomModeMsg
       1  ZoomModeSet
      64  ZoomMsg
       8  ZoomNAMsg
       1  ZoomOutFlag
       2  ZoomPos
       1  ZoomPosCheckCount
       2  ZoomPos_SCM
       1  ZoomRef
       1  ZoomReferanceSpeed
      76  ZoomSSetMsg
      20  ZoomSValMsg
      20  ZoomSetMsg
       1  ZoomSpd
       1  ZoomSpdVal
      16  ZoomSpeedMsg
      16  ZoomStatusMsg
       4  ZoomStopCount
      52  ZoomSyncData19m
      52  ZoomSyncData35m
      52  ZoomSyncData75m
       8  ZoomSyncMsg
       1  ZoomTCnt
       4  ZoomVal
       4  ZoomVal_SCM
    1110  Zoom_Data_Sync
     180  Zoom_Light_Auto_Control
       1  Ztxsendflag
       4  convertV
       4  convertV_Buffer
       4  convertV_Buffer1
     224  defTW9900Sys
     224  defTW9900Thermal
      32  g_Po_Data
       1  inHeaterBuf
      20  inHeaterOffMsg
      20  inHeaterOnMsg
       4  intFlag
       4  inter
      50  main
       1  minusFlag
       4  msCount
       4  msIdleCnt
      12  ntpalsetMsg
      32  pSTR
       1  rxTest2
       1  rxTest3
       1  tx_watch_count
       1  txsendflag
       1  txsendflag_DRS
       1  txsendflag_SCM

 
  1 062 bytes in section .bss
    199 bytes in section .data
 18 192 bytes in section .rodata
 28 068 bytes in section .text
 
 28 068 bytes of CODE  memory
 18 192 bytes of CONST memory
  1 261 bytes of DATA  memory

Errors: none
Warnings: 17
