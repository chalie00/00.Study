###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     08/Jul/2022  12:01:43 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\src\main.c        #
#    Command line =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\src\main.c -D     #
#                    USE_STDPERIPH_DRIVER -D STM32F10x_HD -D USE_FULL_ASSERT  #
#                    -lcN C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_ #
#                    M32\Debug\List\ -lb C:\Users\TTT\Desktop\zz.STDFW\00.Stu #
#                    dy\project\IAR_M32\Debug\List\ -o                        #
#                    C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_M32\D #
#                    ebug\Obj\ --no_cse --no_unroll --no_inline               #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\I #
#                    AR_M32\..\..\inc\ -I C:\Users\TTT\Desktop\zz.STDFW\00.St #
#                    udy\project\IAR_M32\..\..\Libraries\CMSIS\CM3\DeviceSupp #
#                    ort\ST\STM32F10x\ -I C:\Users\TTT\Desktop\zz.STDFW\00.St #
#                    udy\project\IAR_M32\..\..\Libraries\STM32F10x_StdPeriph_ #
#                    Driver\inc\ -I "C:\Program Files (x86)\IAR               #
#                    Systems\Embedded Workbench 6.0\arm\inc\c\" -On -I        #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_M32\D #
#                    ebug\List\main.lst                                       #
#    Object file  =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_M32\D #
#                    ebug\Obj\main.o                                          #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\TTT\Desktop\zz.STDFW\00.Study\src\main.c
      1          /*=================================================================================
      2          Project Name 		:	TPV HD Type - TILT BOARD (HD IP THERMOGRAPHY PTZ CAMERA)
      3          Author			:	phs@tbtsys.com
      4          ==================================================================================
      5          
      6          ---------------------------------------------------------------------------------
      7          CPU					: 	STM32F103RCT
      8          ---------------------------------------------------------------------------------
      9          Z:LQFP144 	(R:LQFP64, V:LQFP100)
     10          E:512KB 		(B:128KB, C:256KB, F:768KB, G:1024KB)
     11          T:LQFP		(H:UFBGA, Y:WLCSP)
     12          7:-40~105'C	(6:-40~85'C)
     13          ---------------------------------------------------------------------------------
     14          CPU Infomation 	:  ARM 32-bit Cortex-M3 CPU, 120MHz max
     15          Package			: 	LQFP144(20x20mm)
     16          ---------------------------------------------------------------------------------
     17          Clock			: 	4~26MHz Crystal oscillator
     18          	Internal 16MHz RC(factory-trimmed)
     19          	32kHz oscillator for RTC with calibration
     20          	Internal 32kHz RC with calibration
     21          ---------------------------------------------------------------------------------
     22          Program Memory		: 	1MBytes Flash Memory
     23          Data Memory			: 	128KBytes(112+16) + 4KBytes SRAM(BackUp)
     24          OTP Memory			: 	512 Bytes
     25          ---------------------------------------------------------------------------------
     26          Timer				: 10-General, 2-Advanced, 2-Basic, IWDG, WWDG
     27          RTC					: Yes
     28          I2C					: 3
     29          USART				: 4
     30          UART				: 2
     31          USB OTG FS			: Yes (full speed)
     32          USB OTG HS			: Yes (High Speed)
     33          CAN					: 2
     34          Camera Interface		: No
     35          GPIO				: 114
     36          SDIO				: Yes
     37          12-bit ADC			: 3 * 24Channel
     38          12-bit DAC			: 2
     39          Max CPU Frequency	: 120MHz
     40          Operation Volatage		: 1.8V ~ 3.6V
     41          ADC					: 3*12bit up to 24Channel
     42          DAC					: 2*12bit
     43          SPI					: 3 SPIs
     44          ---------------------------------------------------------------------------------
     45          //===============================================================================*/
     46          
     47          /* ==========================================
     48          	Clock Speed Compute
     49          // ==========================================
     50          Clock : 16Mhz 
     51          int Clock : 80Mhz
     52           
     53          Xtal=16Mhz
     54          SysFreq=80Mhz
     55          Desired Baud Rate = 2400 / 38400
     56          ----------2400----------------------------
     57          UxBRG = ((16000000/2400)/16)-1 
     58                = 415.667
     59          Calculated Baud Rate = 16000000/(16(416+1))
     60                               = 2403
     61                               = 0.1%
     62          ----------38400----------------------------                      
     63          UxBRG = ((16000000/38400)/16)-1 
     64                = 25.042
     65          Calculated Baud Rate = 16000000/(16(25+1))
     66                               = 38461.5
     67                               = 0.16%
     68          --------------------------------------------------------*/
     69          
     70          /*******************************************************************************
     71          * INCLUDE
     72          *******************************************************************************/
     73          #include "main.h"
     74          #include "Common.h"
     75          #include <stdio.h>
     76          #include "stm32f10x.h"
     77          #include "sysclk.h"
     78          #include "systickdelay.h"
     79          #include "stm32f10x_it.h"
     80          
     81          
     82          
     83          /*******************************************************************************
     84          * Function : Send_Sony_Data
     85          *******************************************************************************/
     86          void Send_Sony_Data(u8 u_Cmd, u8 u_Data1, u8 u_Data2, u8 u_Leng, u8 u_Timer)
     87          {
     88             switch (u_Leng)
     89             {
     90             case 0x05:
     91          
     92                stUART4.TX_BUF[0] = 0x81;
     93                stUART4.TX_BUF[1] = 0x09;
     94                stUART4.TX_BUF[2] = 0x04;
     95                stUART4.TX_BUF[3] = u_Cmd;
     96                stUART4.TX_BUF[4] = 0xFF;
     97          
     98                stUART4.TX_CNT = 0;
     99                stUART4.TX_MAX = u_Leng;
    100          
    101                break;
    102          
    103             case 0x06:
    104          
    105                stUART4.TX_BUF[0] = 0x81;
    106                stUART4.TX_BUF[1] = 0x01;
    107                stUART4.TX_BUF[2] = 0x04;
    108                stUART4.TX_BUF[3] = u_Cmd;
    109                stUART4.TX_BUF[4] = u_Data1;
    110                stUART4.TX_BUF[5] = 0xFF;
    111          
    112                stUART4.TX_CNT = 0;
    113                stUART4.TX_MAX = u_Leng;
    114          
    115                break;
    116          
    117             case 0x08:
    118          
    119                stUART4.TX_BUF[0] = 0x81;
    120                stUART4.TX_BUF[1] = 0x01;
    121                stUART4.TX_BUF[2] = 0x04;
    122                stUART4.TX_BUF[3] = 0x24;
    123                stUART4.TX_BUF[4] = u_Cmd;
    124                stUART4.TX_BUF[5] = u_Data1;
    125                stUART4.TX_BUF[6] = u_Data2;
    126                stUART4.TX_BUF[7] = 0xFF;
    127          
    128                stUART4.TX_CNT = 0;
    129                stUART4.TX_MAX = u_Leng;
    130          
    131                break;
    132          
    133             case 0x09:
    134          
    135                stUART4.TX_BUF[0] = 0x81;
    136                stUART4.TX_BUF[1] = 0x01;
    137                stUART4.TX_BUF[2] = 0x04;
    138                stUART4.TX_BUF[3] = u_Cmd;
    139                stUART4.TX_BUF[4] = (u_Data1 >> 4) & 0x0F;
    140                stUART4.TX_BUF[5] = u_Data1 & 0x0F;
    141                stUART4.TX_BUF[6] = (u_Data2 >> 4) & 0x0F;
    142                stUART4.TX_BUF[7] = u_Data2 & 0x0F;
    143                stUART4.TX_BUF[8] = 0xFF;
    144          
    145          
    146                stUART4.TX_CNT = 0;
    147                stUART4.TX_MAX = u_Leng;
    148          
    149             case 0xFF:
    150          
    151                stUART4.TX_CNT = 0;
    152                stUART4.TX_MAX = u_Leng;
    153          
    154                break;
    155          
    156                break;
    157          
    158             default:
    159                break;
    160             }
    161          
    162             USART_SendData(UART4, stUART4.TX_BUF[stUART4.TX_CNT++]);
    163             Delay_1ms(u_Timer);
    164          }
    165          
    166          /*******************************************************************************
    167          * Function : Send_LRF_Data
    168          *******************************************************************************/
    169          void Send_LRF_Data(u8 u_Cmd, u16 u_Timer)
    170          {
    171             switch (u_Cmd)
    172             {
    173             case LRF_INIT:
    174          
    175                //ID1
    176                stUSART2.TX_BUF[0] = 0x49;	// I
    177                stUSART2.TX_BUF[1] = 0x44;	// D
    178                stUSART2.TX_BUF[2] = 0x31;	// 1
    179                stUSART2.TX_BUF[3] = 0x0D;	// CR
    180          
    181                stUSART2.TX_CNT = 0;
    182                stUSART2.TX_MAX = 0x04;
    183          
    184                USART_SendData(USART2, stUSART2.TX_BUF[stUSART2.TX_CNT++]);
    185                Delay_1ms(u_Timer);
    186          
    187                break;
    188          
    189             case LRF_MAX_TIME:
    190          
    191                // MT 3 (500ms)
    192                stUSART2.TX_BUF[0] = 0x4D;	// M
    193                stUSART2.TX_BUF[1] = 0x54;	// T
    194                stUSART2.TX_BUF[2] = 0x20;	// SP
    195                stUSART2.TX_BUF[3] = 0x33;	// 3
    196                stUSART2.TX_BUF[4] = 0x0D;	// CR
    197          
    198                stUSART2.TX_CNT = 0;
    199                stUSART2.TX_MAX = 0x05;
    200          
    201                USART_SendData(USART2, stUSART2.TX_BUF[stUSART2.TX_CNT++]);
    202                Delay_1ms(u_Timer);
    203          
    204                break;
    205          
    206             case LRF_LIMIT:
    207          
    208                // MW 1 5000
    209                stUSART2.TX_BUF[0] = 0x4D;	// M
    210                stUSART2.TX_BUF[1] = 0x57;	// W
    211                stUSART2.TX_BUF[2] = 0x20;	// SP
    212                stUSART2.TX_BUF[3] = 0x31;	// 1
    213                stUSART2.TX_BUF[4] = 0x20;	// SP
    214                stUSART2.TX_BUF[5] = 0x35;	// 5
    215                stUSART2.TX_BUF[6] = 0x30;	// 0
    216                stUSART2.TX_BUF[7] = 0x30;	// 0
    217                stUSART2.TX_BUF[8] = 0x30;	// 0
    218                stUSART2.TX_BUF[9] = 0x0D;	// CR
    219          
    220                stUSART2.TX_CNT = 0;
    221                stUSART2.TX_MAX = 0x0A;
    222          
    223                USART_SendData(USART2, stUSART2.TX_BUF[stUSART2.TX_CNT++]);
    224                Delay_1ms(u_Timer);
    225          
    226                break;
    227          
    228             case LRF_CALL_DATA:
    229          
    230                // dm1 1
    231                stUSART2.TX_BUF[0] = 0x64;	// d
    232                stUSART2.TX_BUF[1] = 0x6D;	// m
    233                stUSART2.TX_BUF[2] = 0x31;	// 1
    234                stUSART2.TX_BUF[3] = 0x20;	// SP
    235                stUSART2.TX_BUF[4] = 0x31;	// 1
    236                stUSART2.TX_BUF[5] = 0x0D;	// CR
    237          
    238                stUSART2.TX_CNT = 0;
    239                stUSART2.TX_MAX = 0x06;
    240          
    241                USART_SendData(USART2, stUSART2.TX_BUF[stUSART2.TX_CNT++]);
    242                Delay_1ms(u_Timer);
    243          
    244                break;
    245          
    246             }
    247          }
    248          
    249          /*******************************************************************************
    250          * Function : Send_MDIN_String_Data
    251          *******************************************************************************/
    252          void Send_MDIN_String_Data(u16 u_Cmd, u8 u_Leng, u8 u_Timer)
    253          {
    254             u8 i, i_Max = 0x00;
    255             u8 u_Checksum = 0x00;
    256             u8 u_Rx_Data[50];
    257          
    258             stUSART2.TX_BUF[0] = 0xA0;
    259             stUSART2.TX_BUF[1] = 0x60;
    260             stUSART2.TX_BUF[2] = (u8)(u_Cmd & 0xFF);
    261             stUSART2.TX_BUF[3] = (u8)(u_Cmd >> 8);
    262             stUSART2.TX_BUF[4] = u_Leng - 2;
    263          
    264             i_Max = u_Leng + 3;
    265          
    266             for (i = 5; i < i_Max; i++)
    267             {
    268                stUSART2.TX_BUF[i] = stSYS.RX_BUF[0][i + 1];
    269             }
    270          
    271             for (i = 2; i < i_Max; i++)
    272             {
    273                u_Checksum += stUSART2.TX_BUF[i];
    274             }
    275          
    276             stUSART2.TX_BUF[i_Max] = 0x00;
    277             stUSART2.TX_BUF[i_Max] = (u8)(u_Checksum);
    278             stUSART2.TX_BUF[i_Max + 1] = 0x5F;
    279          
    280             stUSART2.TX_CNT = 0;
    281             stUSART2.TX_MAX = u_Leng + 0x05;
    282          
    283             USART_SendData(USART2, stUSART2.TX_BUF[stUSART2.TX_CNT++]);
    284             Delay_1ms(u_Timer);
    285          }
    286          
    287          /*******************************************************************************
    288          * Function : Send_MDIN_Data
    289          *******************************************************************************/
    290          void Send_MDIN_Data(u16 u_Cmd, u8 u_Leng, u8 u_Data1, u8 u_Data2, u8 u_Data3, u8 u_Data4, u8 u_Data5, u8 u_Data6, u8 u_Data7,
    291                              u8 u_Data8, u8 u_Data9, u8 u_Data10, u8 u_Data11, u8 u_Data12, u8 u_Data13, u8 u_Data14, u8 u_Data15, u8 u_Data16, u8 u_Data17, u8 u_Data18, u8 u_Timer)
    292          {
    293             u8 i = 0, u_Sum_Data = 0x00;
    294          
    295             switch (u_Leng)
    296             {
    297             case 0x03:
    298          
    299                stUSART2.TX_BUF[0] = 0xA0;
    300                stUSART2.TX_BUF[1] = 0x60;
    301                stUSART2.TX_BUF[2] = (u8)(u_Cmd & 0xFF);
    302                stUSART2.TX_BUF[3] = (u8)(u_Cmd >> 8);
    303                stUSART2.TX_BUF[4] = u_Leng;
    304                stUSART2.TX_BUF[5] = u_Data1;
    305                stUSART2.TX_BUF[6] = u_Data2;
    306                stUSART2.TX_BUF[7] = u_Data3;
    307                stUSART2.TX_BUF[8] = (u8)(stUSART2.TX_BUF[2] + stUSART2.TX_BUF[3] + stUSART2.TX_BUF[4] + stUSART2.TX_BUF[5] + stUSART2.TX_BUF[6] + stUSART2.TX_BUF[7]);
    308                stUSART2.TX_BUF[9] = 0x5F;
    309          
    310                stUSART2.TX_CNT = 0;
    311                stUSART2.TX_MAX = u_Leng + 0x07;
    312          
    313                USART_SendData(USART2, stUSART2.TX_BUF[stUSART2.TX_CNT++]);
    314                Delay_1ms(u_Timer);
    315          
    316                break;
    317          
    318             case 0x09:
    319          
    320                stUSART2.TX_BUF[0] = 0xA0;
    321                stUSART2.TX_BUF[1] = 0x60;
    322                stUSART2.TX_BUF[2] = (u8)(u_Cmd & 0xFF);
    323                stUSART2.TX_BUF[3] = (u8)(u_Cmd >> 8);
    324                stUSART2.TX_BUF[4] = u_Leng;
    325          
    326                stUSART2.TX_BUF[5] = u_Data1;		// ID
    327                stUSART2.TX_BUF[6] = u_Data2;		// COLUMN
    328                stUSART2.TX_BUF[7] = u_Data3;		// ROW
    329          
    330                stUSART2.TX_BUF[8] = u_Data4;
    331                stUSART2.TX_BUF[9] = u_Data5;
    332                stUSART2.TX_BUF[10] = u_Data6;
    333                stUSART2.TX_BUF[11] = u_Data7;
    334                stUSART2.TX_BUF[12] = u_Data8;
    335                stUSART2.TX_BUF[13] = u_Data9;
    336          
    337                stUSART2.TX_BUF[14] = 0x00;
    338          
    339                for (i = 2; i < 14; i++)
    340                {
    341                   u_Sum_Data = (u8)(u_Sum_Data + stUSART2.TX_BUF[i]);
    342                }
    343          
    344                stUSART2.TX_BUF[14] = u_Sum_Data;
    345          
    346                stUSART2.TX_BUF[15] = 0x5F;
    347          
    348                stUSART2.TX_CNT = 0;
    349                stUSART2.TX_MAX = u_Leng + 0x07;
    350          
    351                USART_SendData(USART2, stUSART2.TX_BUF[stUSART2.TX_CNT++]);
    352                Delay_1ms(u_Timer);
    353          
    354                break;
    355          
    356             case 0x12:
    357          
    358                stUSART2.TX_BUF[0] = 0xA0;
    359                stUSART2.TX_BUF[1] = 0x60;
    360                stUSART2.TX_BUF[2] = (u8)(u_Cmd & 0xFF);
    361                stUSART2.TX_BUF[3] = (u8)(u_Cmd >> 8);
    362                stUSART2.TX_BUF[4] = u_Leng;
    363          
    364                stUSART2.TX_BUF[5] = u_Data1;		// ID
    365                stUSART2.TX_BUF[6] = u_Data2;		// COLUMN
    366                stUSART2.TX_BUF[7] = u_Data3;		// ROW
    367          
    368                stUSART2.TX_BUF[8] = u_Data4;		// +
    369                stUSART2.TX_BUF[9] = u_Data5;		// 0
    370                stUSART2.TX_BUF[10] = u_Data6;		// 0
    371                stUSART2.TX_BUF[11] = u_Data7;		// 0
    372                stUSART2.TX_BUF[12] = u_Data8;		// .
    373                stUSART2.TX_BUF[13] = u_Data9;		// 0
    374                stUSART2.TX_BUF[14] = u_Data10;		// 0
    375                stUSART2.TX_BUF[15] = u_Data11;		// NULL
    376                stUSART2.TX_BUF[16] = u_Data12;		// -
    377                stUSART2.TX_BUF[17] = u_Data13;		// 0
    378                stUSART2.TX_BUF[18] = u_Data14;		// 0
    379                stUSART2.TX_BUF[19] = u_Data15;		// 0
    380                stUSART2.TX_BUF[20] = u_Data16;		// .
    381                stUSART2.TX_BUF[21] = u_Data17;		// 0
    382                stUSART2.TX_BUF[22] = u_Data18;		// 0
    383          
    384                stUSART2.TX_BUF[23] = 0x00;
    385          
    386                for (i = 2; i < 23; i++)
    387                {
    388                   u_Sum_Data = (u8)(u_Sum_Data + stUSART2.TX_BUF[i]);
    389                }
    390          
    391                stUSART2.TX_BUF[23] = u_Sum_Data;
    392          
    393                stUSART2.TX_BUF[24] = 0x5F;
    394          
    395                stUSART2.TX_CNT = 0;
    396                stUSART2.TX_MAX = u_Leng + 0x07;
    397          
    398                USART_SendData(USART2, stUSART2.TX_BUF[stUSART2.TX_CNT++]);
    399                Delay_1ms(u_Timer);
    400          
    401                break;
    402          
    403             default:
    404                break;
    405             }
    406          
    407          }
    408          
    409          /*******************************************************************************
    410          * Function : LRF_Initialization
    411          *******************************************************************************/
    412          void LRF_Initialization(void)
    413          {
    414             Send_LRF_Data(LRF_INIT, LRF_TRANS_DELAY);
    415             Send_LRF_Data(LRF_MAX_TIME, LRF_TRANS_DELAY);
    416             Send_LRF_Data(LRF_LIMIT, LRF_TRANS_DELAY);
    417             //Send_LRF_Data(LRF_CALL_DATA, LRF_TRANS_DELAY);
    418          
    419             stLRF.INIT_ACTIVE = 0x00;
    420          
    421             // TEST
    422             //stLRF.CONTINUOUS_FLAG = 0x01;
    423          }
    424          
    425          /*******************************************************************************
    426          * Function : Reponse_Data_Send
    427          *******************************************************************************/
    428          void Reponse_Data_Send(u8 Comm, u8 R1_data, u8 R2_data)
    429          {
    430             stUSART1.TX_BUF[0] = 0xCA;
    431             stUSART1.TX_BUF[1] = 0xAC;
    432             stUSART1.TX_BUF[2] = Comm;
    433             stUSART1.TX_BUF[3] = R1_data;
    434             stUSART1.TX_BUF[4] = R2_data;
    435             stUSART1.TX_BUF[5] = 0x00;
    436             stUSART1.TX_BUF[5] = stUSART1.TX_BUF[2] + stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4];
    437          
    438             stUSART1.TX_CNT = 0;
    439             stUSART1.TX_MAX = 6;
    440          
    441             USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
    442          }
    443          
    444          /*******************************************************************************
    445          * Function : Send_COLOR_TILT_Data
    446          *******************************************************************************/
    447          void Send_Light_Data(u8 u_Cmd, u8 u_Sign, u8 u_Data1, u8 u_Data2, u8 u_Data3, u8 u_Data4, u8 u_Leng, u8 u_Timer)
    448          {
    449             stUSART2.TX_BUF[0] = 0x24;
    450             stUSART2.TX_BUF[1] = u_Cmd;
    451             stUSART2.TX_BUF[2] = 0x31;
    452             stUSART2.TX_BUF[3] = u_Sign;
    453             stUSART2.TX_BUF[4] = u_Data1;
    454             stUSART2.TX_BUF[5] = u_Data2;
    455             stUSART2.TX_BUF[6] = u_Data3;
    456             stUSART2.TX_BUF[7] = u_Data4;
    457             stUSART2.TX_BUF[8] = 0x23;
    458          
    459             stUSART2.TX_CNT = 0;
    460             stUSART2.TX_MAX = u_Leng;
    461          
    462             USART_SendData(USART2, stUSART2.TX_BUF[stUSART2.TX_CNT++]);
    463             Delay_1ms(u_Timer);
    464          }
    465          
    466          /*******************************************************************************
    467          * Function : Send_TSM_Data
    468          *******************************************************************************/
    469          void Send_TSM_Data(u8 u_Cmd, u8 u_Data1, u8 u_Data2, u8 u_Data3, u8 u_Leng, u8 u_Timer)
    470          {
    471             stUART4.TX_BUF[0] = 0xA0;
    472             stUART4.TX_BUF[1] = u_Cmd;
    473             stUART4.TX_BUF[2] = u_Data1;
    474             stUART4.TX_BUF[3] = u_Data2;
    475             stUART4.TX_BUF[4] = u_Data3;
    476             stUART4.TX_BUF[5] = 0xAF;
    477          
    478             stUART4.TX_CNT = 0;
    479             stUART4.TX_MAX = u_Leng;
    480          
    481             USART_SendData(UART4, stUART4.TX_BUF[stUART4.TX_CNT++]);
    482             Delay_1ms(u_Timer);
    483          }
    484          
    485          /*******************************************************************************
    486          * Function : Send_TCM_Data
    487          *******************************************************************************/
    488          void Send_TCM_Data(u8 u_Cmd, u8 u_Data1, u8 u_Data2, u8 u_Data3, u8 u_Data4, u8 u_Data5, u8 u_Data6, u8 u_Data7, u8 u_Data8, u8 u_Data9, u8 u_Leng, u8 u_Timer)
    489          {
    490             switch (u_Leng)
    491             {
    492             case 0x06:
    493          
    494                stUART4.TX_BUF[0] = 0xA0;
    495                stUART4.TX_BUF[1] = u_Cmd;
    496                stUART4.TX_BUF[2] = u_Data1;
    497                stUART4.TX_BUF[3] = u_Data2;
    498                stUART4.TX_BUF[4] = u_Data3;
    499                stUART4.TX_BUF[5] = 0xAF;
    500          
    501                stUART4.TX_CNT = 0;
    502                stUART4.TX_MAX = u_Leng;
    503          
    504                break;
    505          
    506             case 0x08:
    507          
    508                stUART4.TX_BUF[0] = 0xA0;
    509                stUART4.TX_BUF[1] = u_Cmd;
    510                stUART4.TX_BUF[2] = u_Data1;
    511                stUART4.TX_BUF[3] = u_Data2;
    512                stUART4.TX_BUF[4] = u_Data3;
    513                stUART4.TX_BUF[5] = u_Data4;
    514                stUART4.TX_BUF[6] = u_Data5;
    515                stUART4.TX_BUF[7] = 0xAF;
    516          
    517                stUART4.TX_CNT = 0;
    518                stUART4.TX_MAX = u_Leng;
    519          
    520                break;
    521          
    522             case 0x0C:
    523          
    524                stUART4.TX_BUF[0] = 0xA0;
    525                stUART4.TX_BUF[1] = u_Cmd;
    526                stUART4.TX_BUF[2] = u_Data1;
    527                stUART4.TX_BUF[3] = u_Data2;
    528                stUART4.TX_BUF[4] = u_Data3;
    529                stUART4.TX_BUF[5] = u_Data4;
    530                stUART4.TX_BUF[6] = u_Data5;
    531                stUART4.TX_BUF[3] = u_Data6;
    532                stUART4.TX_BUF[4] = u_Data7;
    533                stUART4.TX_BUF[5] = u_Data8;
    534                stUART4.TX_BUF[6] = u_Data9;
    535                stUART4.TX_BUF[7] = 0xAF;
    536          
    537                stUART4.TX_CNT = 0;
    538                stUART4.TX_MAX = u_Leng;
    539          
    540                break;
    541          
    542             }
    543          
    544             USART_SendData(UART4, stUART4.TX_BUF[stUART4.TX_CNT++]);
    545             Delay_1ms(u_Timer);
    546          
    547          }
    548          
    549          /*******************************************************************************
    550          * Function : Send_USART1_Ack
    551          *******************************************************************************/
    552          void Send_UART4_Ack(u8 u_Index, u8 u_Leng, u8 u_Address, u8 u_Cmd, u8 u_Data, u8 u_timer)
    553          {
    554             u8 u_Checksum = 0x00;
    555          
    556             switch (u_Leng)
    557             {
    558             case 0x02:
    559          
    560                stUART4.TX_BUF[0] = IP_BOARD_SYNC_BYTE;
    561                stUART4.TX_BUF[1] = IP_BOARD_SYNC_AND_BYTE;
    562          
    563                stUART4.TX_BUF[2] = u_Index;
    564                stUART4.TX_BUF[3] = u_Leng;
    565                stUART4.TX_BUF[4] = u_Address;
    566                stUART4.TX_BUF[5] = u_Cmd;
    567          
    568                u_Checksum = stUART4.TX_BUF[4] + stUART4.TX_BUF[5];
    569          
    570                stUART4.TX_BUF[6] = u_Checksum;
    571          
    572                switch (u_Index)
    573                {
    574                case IP_SONY_FIRST_BYTE:
    575                   stUART4.TX_BUF[7] = 0xAF;
    576                   break;
    577          
    578                case IP_TSM_FIRST_BYTE:
    579                   stUART4.TX_BUF[7] = 0xBF;
    580                   break;
    581          
    582                case IP_OPTION_FIRST_BYTE:
    583                   stUART4.TX_BUF[7] = 0xEF;
    584                   break;
    585                }
    586          
    587                stUART4.TX_MAX = u_Leng + 6;
    588                stUART4.TX_CNT = 0x00;
    589          
    590                USART_SendData(UART4, stUART4.TX_BUF[stUART4.TX_CNT++]);
    591                Delay_1ms(u_timer);
    592          
    593                break;
    594          
    595             case 0x03:
    596          
    597                stUART4.TX_BUF[0] = IP_BOARD_SYNC_BYTE;
    598                stUART4.TX_BUF[1] = IP_BOARD_SYNC_AND_BYTE;
    599          
    600                stUART4.TX_BUF[2] = u_Index;
    601                stUART4.TX_BUF[3] = u_Leng;
    602                stUART4.TX_BUF[4] = u_Address;
    603                stUART4.TX_BUF[5] = u_Cmd;
    604                stUART4.TX_BUF[6] = u_Data;
    605          
    606                u_Checksum = stUART4.TX_BUF[4] + stUART4.TX_BUF[5];
    607          
    608                stUART4.TX_BUF[7] = u_Checksum;
    609          
    610                switch (u_Index)
    611                {
    612                case IP_SONY_FIRST_BYTE:
    613                   stUART4.TX_BUF[8] = 0xAF;
    614                   break;
    615          
    616                case IP_TSM_FIRST_BYTE:
    617                   stUART4.TX_BUF[8] = 0xBF;
    618                   break;
    619          
    620                case IP_OPTION_FIRST_BYTE:
    621                   stUART4.TX_BUF[8] = 0xEF;
    622                   break;
    623                }
    624          
    625                stUART4.TX_MAX = u_Leng + 6;
    626                stUART4.TX_CNT = 0x00;
    627          
    628                USART_SendData(UART4, stUART4.TX_BUF[stUART4.TX_CNT++]);
    629                Delay_1ms(u_timer);
    630          
    631                break;
    632             }
    633          }
    634          
    635          /*******************************************************************************
    636          * Function : Send_Pelco_Data
    637          *******************************************************************************/
    638          void Send_Pelco_Data(u8 u_Comm1, u8 u_Comm2, u8 u_Data1, u8 u_Data2, u8 u_Leng, u8 u_Timer)
    639          {
    640             stUSART1.TX_BUF[0] = 0xFF;
    641             stUSART1.TX_BUF[1] = 0x01;
    642             stUSART1.TX_BUF[2] = u_Comm1;
    643             stUSART1.TX_BUF[3] = u_Comm2;
    644             stUSART1.TX_BUF[4] = u_Data1;
    645             stUSART1.TX_BUF[5] = u_Data2;
    646             stUSART1.TX_BUF[6] = stUSART1.TX_BUF[1] + stUSART1.TX_BUF[2] + stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5];
    647          
    648             stUSART1.TX_CNT = 0;
    649             stUSART1.TX_MAX = u_Leng;
    650          
    651             USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
    652             Delay_1ms(u_Timer);
    653          }
    654          
    655          /*******************************************************************************
    656          * Function Name  : USART1_Data_Parser
    657          *******************************************************************************/
    658          void Bypass_Data_Parser(void)
    659          {
    660             u8 i = 0;
    661          
    662             /*******************************************************************************************
    663             * Data Format
    664             						BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]
    665             1) General Command		0x81		0x01		0x04		CMD			DATA1		0xFF
    666             2) Inquiry Command		0x81		0x09		0x04		CMD			0xFF
    667             3) Address Set			0x88		0x30		0x01		0xFF
    668             4) IF_Clear(Broadcast)		0x88		0x01		0x00		0x01		0xFF
    669             5) IF_Clear (For x)			0x8x		0x01		0x00		0x01		0xFF
    670             6) Command Cancel		0x8x		0x2y		0xFF
    671             *******************************************************************************************/
    672             if (stUSART1.RX_BYPASS == 0x01)
    673             {
    674                stUSART1.RX_BYPASS = 0x00;
    675          
    676                stUART5.TX_CNT = 0;
    677                stUART5.TX_MAX = stUSART1.RX_BYPASS_CNT;
    678          
    679                for (i = 0; i < stUART5.TX_MAX; i++)
    680                {
    681                   stUART5.TX_BUF[i] = stUSART1.RX_BUF[i];
    682                }
    683          
    684                USART_SendData(UART5, stUART5.TX_BUF[stUART5.TX_CNT++]);
    685                Delay_1ms(SONY_COMMAND_TIMER_DELAY);
    686             }
    687          }
    688          
    689          /*******************************************************************************
    690          * Function : Send_Data_Clear
    691          *******************************************************************************/
    692          void Send_Data_Clear(u8 u_sync, u8 u_Leng)
    693          {
    694             u8 i, i_Max = u_Leng + 5;
    695          
    696             for (i = 0; i < u_Leng; i++)
    697             {
    698                switch (u_sync)
    699                {
    700                case USART1_INDEX:
    701          
    702                   stUSART1.RX_BUF[i] = 0x00;
    703          
    704                   break;
    705                }
    706             }
    707          }
    708          
    709          /*******************************************************************************
    710          * Function : USART1_Send_Data
    711          *******************************************************************************/
    712          void USART1_Send_Data(u8 u_sync, u8 u_Comm, u8 u_Data1, u8 u_Data2, u8 u_Data3, u8 u_Leng)
    713          {
    714             u8 i, i_Max = u_Leng + 3;
    715             u8 u_Checksum = 0x00;
    716          
    717             switch (u_sync)
    718             {
    719             case IP_SONY_FIRST_BYTE:
    720          
    721                stUSART1.TX_BUF[0] = IP_SONY_FIRST_BYTE;
    722                stUSART1.TX_BUF[1] = IP_SONY_SECOND_BYTE;
    723                stUSART1.TX_BUF[u_Leng + 4] = 0xAF;
    724          
    725                break;
    726             }
    727          
    728             stUSART1.TX_BUF[2] = u_Leng;
    729             stUSART1.TX_BUF[3] = 0x01;
    730          
    731             switch (u_Leng)
    732             {
    733             case 0x05:
    734          
    735                stUSART1.TX_BUF[4] = u_Comm;
    736                stUSART1.TX_BUF[5] = u_Data1;
    737                stUSART1.TX_BUF[6] = u_Data2;
    738                stUSART1.TX_BUF[7] = u_Data3;
    739          
    740                break;
    741             }
    742          
    743             stUSART1.TX_BUF[i_Max] = 0x00;
    744          
    745             for (i = 3; i < i_Max; i++)
    746             {
    747                u_Checksum += stUSART1.TX_BUF[i];
    748             }
    749          
    750             stUSART1.TX_BUF[i_Max] = u_Checksum;
    751          
    752             stUSART1.TX_CNT = 0;
    753             stUSART1.TX_MAX = u_Leng + 5;
    754          
    755             USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
    756             Delay_1ms(MAIN_COMMAND_TIMER_DELAY);
    757          }
    758          
    759          /***************************************************************************************************************************
    760          * Function : Sony_Data_Handing
    761          * Protocol Version : 0.1 (2016.04.11)
    762          * Data Architecture :
    763          BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]		BYTE[..]		BYTE(n)[LENGTH+4]	BYTE(n+1)[LENGTH+4]
    764          0xA0		0x0A		LENGTH		ADDR		COMM		DATA		...			CS					0xAF
    765          ****************************************************************************************************************************/
    766          void Sony_Data_Handing(u8 u_Port, u8 u_Comm, u8 u_Leng)
    767          {
    768             u8 u_Cmd = 0x00, u_Data_Check = 0x00;	// Camera Command
    769             u8 u_Data[5];
    770             u16 u16_Convert_Data = 0x0000;
    771          
    772             switch (u_Port)
    773             {
    774             case SYSTEM_INDEX:
    775          
    776                u_Cmd = stSYS.RX_BUF[0][5];
    777                u_Data[0] = stSYS.RX_BUF[0][6];
    778                u_Data[1] = stSYS.RX_BUF[0][7];
    779          
    780                break;
    781          
    782             case USART1_INDEX:
    783          
    784                u_Cmd = stUSART1.RX_BUF[4];
    785                u_Data[0] = stUSART1.RX_BUF[5];
    786                u_Data[1] = stUSART1.RX_BUF[6];
    787          
    788                break;
    789          
    790             case USART5_INDEX:
    791          
    792                u_Cmd = stUART5.RX_BUF[4];
    793                u_Data[0] = stUART5.RX_BUF[5];
    794                u_Data[1] = stUART5.RX_BUF[6];
    795          
    796                break;
    797          
    798             default:
    799                break;
    800             }
    801          
    802             switch (u_Comm)
    803             {
    804                // 1.1.	Set Focus Mode (0x91)
    805             case SONY_SET_FOCUS_MODE:
    806          
    807                stSONY.SET_FOCUS_MODE = u_Data[1];
    808          
    809                AT24C256C_EEPROM_Write(EEP_SET_FOCUS_MODE, stSONY.SET_FOCUS_MODE);
    810          
    811                u_Data[0] = 0x00;
    812                u_Data[1] = 0x00;
    813          
    814                switch (stSONY.SET_FOCUS_MODE)
    815                {
    816                   // Auto Focus
    817                case 0x00:
    818          
    819                   switch (stSONY.SET_AUTO_FOCUS_MODE)
    820                   {
    821                   case 0x00:
    822          
    823                      // Normal
    824                      u_Cmd = 0x57;
    825                      u_Data[0] = 0x00;
    826          
    827                      Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    828          
    829                      u_Cmd = 0x38;
    830                      u_Data[0] = 0x02;
    831          
    832                      Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    833          
    834                      break;
    835          
    836                   case 0x01:
    837          
    838                      // Zoom Trigger
    839                      u_Cmd = 0x57;
    840                      u_Data[0] = 0x02;
    841          
    842                      Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    843          
    844                      u_Cmd = 0x38;
    845                      u_Data[0] = 0x02;
    846          
    847                      Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    848          
    849                      break;
    850          
    851                   default:
    852                      break;
    853                   }
    854          
    855                   break;
    856          
    857                   // Manual Focus
    858                case 0x01:
    859          
    860                   u_Cmd = 0x38;
    861                   u_Data[0] = 0x03;
    862          
    863                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    864          
    865                   u_Cmd = SONY_MANUAL_FOCUS_DIRECT;
    866                   u_Data[0] = (u8)(stSONY.SET_MANUAL_FOCUS_DATA >> 8);
    867                   u_Data[1] = (u8)(stSONY.SET_MANUAL_FOCUS_DATA & 0xFF);
    868          
    869                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x09, SONY_COMMAND_TIMER_DELAY);
    870          
    871                   break;
    872          
    873                   // One Push Trigger
    874                case 0x02:
    875          
    876                   u_Cmd = 0x38;
    877                   u_Data[0] = 0x03;
    878          
    879                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    880          
    881                   u_Cmd = 0x18;
    882                   u_Data[0] = 0x01;
    883          
    884                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    885          
    886                   break;
    887          
    888                default:
    889                   break;
    890                }
    891          
    892                break;
    893          
    894                // 1.2.	Set Auto Focus Mode (0x93)
    895             case SONY_SET_AUTO_FOCUS_MODE:
    896          
    897                // Command & Data Convert
    898                u_Cmd = 0x57;
    899          
    900                stSONY.SET_AUTO_FOCUS_MODE = u_Data[1];
    901          
    902                AT24C256C_EEPROM_Write(EEP_SET_AUTO_FOCUS_MODE, stSONY.SET_AUTO_FOCUS_MODE);
    903          
    904                u_Data[0] = 0x00;
    905                u_Data[1] = 0x00;
    906          
    907                switch (stSONY.SET_AUTO_FOCUS_MODE)
    908                {
    909                   // Normal
    910                case 0x00:
    911                   u_Data[0] = 0x00;
    912                   break;
    913          
    914                   // Zoom Trigger
    915                case 0x01:
    916                   u_Data[0] = 0x02;
    917                   break;
    918          
    919                default:
    920                   break;
    921                }
    922          
    923                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    924          
    925                break;
    926          
    927                // 1.3.	Manual Focus (0x08)
    928             case SONY_MANUAL_FOCUS:
    929          
    930                u_Data_Check = stSONY.SET_FOCUS_MODE;
    931          
    932                switch (u_Data_Check)
    933                {
    934                case 0x01:
    935                case 0x02:
    936                   stSONY.SET_MANUAL_FOCUS_MODE = u_Data[1];
    937                   break;
    938          
    939                default:
    940          
    941                   u_Data_Check = 0xFF;
    942          
    943                   break;
    944                }
    945          
    946                u_Data[0] = 0x00;
    947                u_Data[1] = 0x00;
    948          
    949                if (u_Data_Check == 0xFF)
    950                   break;
    951          
    952                switch (stSONY.SET_MANUAL_FOCUS_MODE)
    953                {
    954                   // Stop
    955                case 0x00:
    956          
    957                   u_Cmd = 0x08;
    958                   u_Data[0] = 0x00;
    959                   stSONY.FOCUS_STATUS = STOP;
    960          
    961                   break;
    962          
    963                   // Focus Far
    964                case 0x01:
    965          
    966                   if (stSONY.SET_FOCUS_MODE == 0x02)
    967                   {
    968                      u_Cmd = 0x38;
    969                      u_Data[0] = 0x03;
    970                      Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    971                   }
    972          
    973                   u_Cmd = 0x08;
    974                   u_Data[0] = 0x24;
    975                   stSONY.FOCUS_STATUS = ACTIVE;
    976                   stSONY.DIV_TRIGGER_NON_FOCUS = 0x01;
    977          
    978                   break;
    979          
    980                   // Focus Near
    981                case 0x02:
    982          
    983                   if (stSONY.SET_FOCUS_MODE == 0x02)
    984                   {
    985                      u_Cmd = 0x38;
    986                      u_Data[0] = 0x03;
    987                      Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
    988                   }
    989          
    990                   u_Cmd = 0x08;
    991                   u_Data[0] = 0x34;
    992                   stSONY.FOCUS_STATUS = ACTIVE;
    993                   stSONY.DIV_TRIGGER_NON_FOCUS = 0x01;
    994          
    995                   break;
    996          
    997                default:
    998                   break;
    999                }
   1000          
   1001                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1002          
   1003                break;
   1004          
   1005                // 1.4.	Manual IRIS Mode (0x0B)
   1006             case SONY_MANUAL_IRIS:
   1007          
   1008                stSONY.SET_MANUAL_IRIS_MODE = u_Data[1];
   1009          
   1010                u_Data[0] = 0x00;
   1011                u_Data[1] = 0x00;
   1012          
   1013                switch (stSONY.SET_MANUAL_IRIS_MODE)
   1014                {
   1015                   // Stop
   1016                case 0x00:
   1017                   u_Cmd = 0x39;
   1018                   u_Data[0] = 0x03;
   1019                   stSONY.CIRIS_STATUS = STOP;
   1020                   stSONY.CIRIS_MODE_FLAG = 0x01;
   1021                   break;
   1022          
   1023                   // Iris Open
   1024                case 0x01:
   1025                   u_Cmd = 0x0B;
   1026                   u_Data[0] = 0x02;
   1027                   stSONY.CIRIS_STATUS = ACTIVE;
   1028                   stSONY.CIRIS_MODE_FLAG = 0x01;
   1029                   break;
   1030          
   1031                   // Iris Close
   1032                case 0x02:
   1033                   u_Cmd = 0x0B;
   1034                   u_Data[0] = 0x03;
   1035                   stSONY.CIRIS_STATUS = ACTIVE;
   1036                   stSONY.CIRIS_MODE_FLAG = 0x01;
   1037                   break;
   1038          
   1039                default:
   1040                   break;
   1041                }
   1042          
   1043                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1044          
   1045                break;
   1046          
   1047                // 1.4.	Manual Focus Direct (0x48)
   1048             case SONY_MANUAL_FOCUS_DIRECT:
   1049          
   1050                u_Data_Check = stSONY.SET_FOCUS_MODE;
   1051          
   1052                if (u_Data_Check != 0x01)
   1053                   break;
   1054          
   1055                u_Cmd = SONY_MANUAL_FOCUS_DIRECT;
   1056          
   1057                stSONY.SET_MANUAL_FOCUS_DATA = 0x0000;
   1058                stSONY.SET_MANUAL_FOCUS_DATA = u_Data[0] << 8;
   1059                stSONY.SET_MANUAL_FOCUS_DATA |= u_Data[1];
   1060          
   1061                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x09, SONY_COMMAND_TIMER_DELAY);
   1062          
   1063                AT24C256C_EEPROM_Write(EEP_MANUAL_FOCUS_DATA, u_Data[0]);
   1064                AT24C256C_EEPROM_Write(EEP_MANUAL_FOCUS_DATA + 1, u_Data[1]);
   1065          
   1066                break;
   1067          
   1068                // 1.5.	Manual Zoom (0x07)
   1069             case SONY_MANUAL_ZOOM:
   1070          
   1071                stSONY.SET_MANUAL_ZOOM_MODE = u_Data[1];
   1072          
   1073                u_Data[0] = 0x00;
   1074                u_Data[1] = 0x00;
   1075          
   1076                u_Cmd = 0x07;
   1077          
   1078                switch (stSONY.SET_MANUAL_ZOOM_MODE)
   1079                {
   1080                   // Stop
   1081                case 0x00:
   1082                   stSONY.ZOOM_STATUS = STOP;
   1083                   u_Data[0] = 0x00;
   1084                   break;
   1085          
   1086                   // Tele
   1087                case 0x01:
   1088                   stSONY.ZOOM_STATUS = ACTIVE;
   1089                   u_Data[0] = 0x27;
   1090                   break;
   1091          
   1092                   // Wide
   1093                case 0x02:
   1094                   stSONY.ZOOM_STATUS = ACTIVE;
   1095                   u_Data[0] = 0x37;
   1096                   break;
   1097          
   1098                default:
   1099                   break;
   1100                }
   1101          
   1102                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1103          
   1104                break;
   1105          
   1106                // 1.6.	Manual Focus Direct (0x48)
   1107             case SONY_MANUAL_ZOOM_DIRECT:
   1108          
   1109                u_Cmd = SONY_MANUAL_ZOOM_DIRECT;
   1110          
   1111                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x09, SONY_COMMAND_TIMER_DELAY);
   1112          
   1113                break;
   1114          
   1115                // 1.7.	Set BLC Mode (0x31)
   1116             case SONY_SET_BLC_MODE:
   1117          
   1118                stSONY.SET_BLC_MODE = u_Data[1];
   1119          
   1120                AT24C256C_EEPROM_Write(EEP_SET_BLC_MODE, stSONY.SET_BLC_MODE);
   1121          
   1122                u_Data[0] = 0x00;
   1123                u_Data[1] = 0x00;
   1124          
   1125                switch (stSONY.SET_BLC_MODE)
   1126                {
   1127                   // BLC/WDR OFF
   1128                case 0x00:
   1129          
   1130                   u_Cmd = 0x3D;
   1131                   u_Data[0] = 0x03;
   1132                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1133          
   1134                   u_Cmd = 0x33;
   1135                   u_Data[0] = 0x03;
   1136                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1137          
   1138                   break;
   1139          
   1140                   // BLC ON
   1141                case 0x01:
   1142          
   1143                   u_Cmd = 0x3D;
   1144                   u_Data[0] = 0x03;
   1145                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1146          
   1147                   u_Cmd = 0x33;
   1148                   u_Data[0] = 0x02;
   1149                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1150          
   1151                   break;
   1152          
   1153                   // WDR ON
   1154                case 0x10:
   1155          
   1156                   u_Cmd = 0x3D;
   1157                   u_Data[0] = 0x02;
   1158                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1159          
   1160                   u_Cmd = 0x33;
   1161                   u_Data[0] = 0x03;
   1162                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1163          
   1164                   break;
   1165          
   1166                   // BLC/WDR ON
   1167                case 0x11:
   1168          
   1169                   u_Cmd = 0x3D;
   1170                   u_Data[0] = 0x02;
   1171                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1172          
   1173                   u_Cmd = 0x33;
   1174                   u_Data[0] = 0x02;
   1175                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1176          
   1177                   break;
   1178          
   1179                default:
   1180                   break;
   1181                }
   1182          
   1183                break;
   1184          
   1185                // 1.8.	Set White Balance Mode (0x33)
   1186             case SONY_SET_WHITE_BALANCE_MODE:
   1187          
   1188                // Command & Data Convert
   1189                u_Cmd = 0x35;
   1190          
   1191                stSONY.SET_WHITE_BALANCE_MODE = u_Data[1];
   1192          
   1193                AT24C256C_EEPROM_Write(EEP_SET_WHITE_BALANCE_MODE, stSONY.SET_WHITE_BALANCE_MODE);
   1194          
   1195                u_Data[0] = 0x00;
   1196                u_Data[1] = 0x00;
   1197          
   1198                switch (stSONY.SET_WHITE_BALANCE_MODE)
   1199                {
   1200                   // Auto white balance Mode (Range : 3000 to 7500K)
   1201                case 0x00:
   1202                   u_Data[0] = 0x00;
   1203                   break;
   1204          
   1205                   // In door Mode
   1206                case 0x01:
   1207                   u_Data[0] = 0x01;
   1208                   break;
   1209          
   1210                   // Out door Mode
   1211                case 0x02:
   1212                   u_Data[0] = 0x02;
   1213                   break;
   1214          
   1215                   // Auto tracing white balance Mode (Range : 2000 to 10000K)
   1216                case 0x03:
   1217                   u_Data[0] = 0x04;
   1218                   break;
   1219          
   1220                default:
   1221                   break;
   1222                }
   1223          
   1224                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1225          
   1226                break;
   1227          
   1228                // 1.9.	Set Defog Mode (0x37)
   1229             case SONY_SET_DEFOG_MODE:
   1230          
   1231                stSONY.SET_DEFOG_MODE = u_Data[1];
   1232          
   1233                AT24C256C_EEPROM_Write(EEP_SET_DEFOG_MODE, stSONY.SET_DEFOG_MODE);
   1234          
   1235                u_Data[0] = 0x00;
   1236                u_Data[1] = 0x00;
   1237          
   1238                switch (stSONY.SET_DEFOG_MODE)
   1239                {
   1240                   // Defog Off
   1241                case 0x00:
   1242                   u_Data[0] = 0x03;
   1243                   break;
   1244          
   1245                   // Defog On
   1246                case 0x01:
   1247                   u_Data[0] = 0x02;
   1248                   break;
   1249          
   1250                   //  0x01   Defog On
   1251                default:
   1252                   u_Data[0] = 0x02;
   1253                   stSONY.SET_DEFOG_MODE = 0x02;
   1254                   break;
   1255                }
   1256          
   1257                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x07, SONY_COMMAND_TIMER_DELAY);
   1258          
   1259                break;
   1260          
   1261                // 1.10.	Set Shutter Speed (0x4A)
   1262             case SONY_SET_SHUTTER_SPEED:
   1263          
   1264                u_Data_Check = u_Data[1];
   1265          
   1266                if (u_Data_Check > 0x16)
   1267                   break;
   1268          
   1269                stSONY.SET_SHUTTER_SPEED = u_Data[1];
   1270          
   1271                AT24C256C_EEPROM_Write(EEP_SET_SHUTTER_SPEED, stSONY.SET_SHUTTER_SPEED);
   1272          
   1273                u_Data[0] = 0x00;
   1274                u_Data[1] = 0x00;
   1275          
   1276                if (stSONY.SET_SHUTTER_SPEED == 0x00)
   1277                {
   1278                   if (stSONY.SET_FLICKER_MODE)
   1279                   {
   1280                      // Flicker On   Flicker Off
   1281                      stSONY.SET_FLICKER_MODE = 0x00;
   1282          
   1283                      u_Cmd = 0x39;
   1284                      u_Data[0] = 0x00;
   1285          
   1286                      Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1287                   }
   1288          
   1289                   u_Cmd = 0x4A;
   1290                   u_Data[0] = 0x00;
   1291                   u_Data[1] = 0x06;
   1292          
   1293                   // when, NTSC:1/30, PAL:1/25
   1294                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x09, SONY_COMMAND_TIMER_DELAY);
   1295          
   1296                   u_Cmd = 0x39;
   1297                   u_Data[0] = 0x00;
   1298          
   1299                   // Full-Auto Mode
   1300                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1301          
   1302                   stSONY.SET_SHUTTER_SPEED = 0x00;
   1303                }
   1304                else
   1305                {
   1306                   if (stSONY.SET_DSS_MODE)
   1307                   {
   1308                      if (stSONY.SET_SHUTTER_SPEED <= 0x16)
   1309                      {
   1310                         if (stINFO.NTSC_PAL_STATUS == NTSC_MODE)
   1311                         {
   1312                            if (stSONY.SET_SHUTTER_SPEED == 0x09)
   1313                            {
   1314                               stSONY.SET_FLICKER_MODE = 0x01;
   1315          
   1316                               // Shutter Priority Mode
   1317                               u_Cmd = 0x39;
   1318                               u_Data[0] = 0x0A;
   1319                               Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1320                            }
   1321                            else
   1322                            {
   1323                               stSONY.SET_FLICKER_MODE = 0x00;
   1324          
   1325                               u_Cmd = 0x39;
   1326                               u_Data[0] = 0x00;
   1327          
   1328                               // Full-Auto Mode
   1329                               Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1330                            }
   1331                         }
   1332                         else if (stINFO.NTSC_PAL_STATUS == PAL_MODE)
   1333                         {
   1334                            if (stSONY.SET_SHUTTER_SPEED == 0x08)
   1335                            {
   1336                               stSONY.SET_FLICKER_MODE = 0x01;
   1337          
   1338                               // Shutter Priority Mode
   1339                               u_Cmd = 0x39;
   1340                               u_Data[0] = 0x0A;
   1341                               Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1342                            }
   1343                            else
   1344                            {
   1345                               stSONY.SET_FLICKER_MODE = 0x00;
   1346          
   1347                               u_Cmd = 0x39;
   1348                               u_Data[0] = 0x00;
   1349          
   1350                               // Full-Auto Mode
   1351                               Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1352                            }
   1353                         }
   1354          
   1355                         // Shutter Priority Mode
   1356                         u_Cmd = 0x39;
   1357                         u_Data[0] = 0x0A;
   1358                         Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1359          
   1360                         // Shutter Speed Setting
   1361                         u_Cmd = 0x4A;
   1362                         u_Data[0] = 0x00;
   1363                         u_Data[1] = stSONY.SET_SHUTTER_SPEED - 1;
   1364                         Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x09, SONY_COMMAND_TIMER_DELAY);
   1365          
   1366                      }
   1367                   }
   1368                   else
   1369                   {
   1370                      if ((stSONY.SET_SHUTTER_SPEED <= 0x16) && (stSONY.SET_SHUTTER_SPEED > 0x05))
   1371                      {
   1372                         if (stINFO.NTSC_PAL_STATUS == NTSC_MODE)
   1373                         {
   1374                            if (stSONY.SET_SHUTTER_SPEED == 0x09)
   1375                            {
   1376                               stSONY.SET_FLICKER_MODE = 0x01;
   1377          
   1378                               // Shutter Priority Mode
   1379                               u_Cmd = 0x39;
   1380                               u_Data[0] = 0x0A;
   1381                               Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1382                            }
   1383                            else
   1384                            {
   1385                               stSONY.SET_FLICKER_MODE = 0x00;
   1386          
   1387                               u_Cmd = 0x39;
   1388                               u_Data[0] = 0x00;
   1389          
   1390                               // Full-Auto Mode
   1391                               Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1392                            }
   1393                         }
   1394                         else if (stINFO.NTSC_PAL_STATUS == PAL_MODE)
   1395                         {
   1396                            if (stSONY.SET_SHUTTER_SPEED == 0x08)
   1397                            {
   1398                               stSONY.SET_FLICKER_MODE = 0x01;
   1399          
   1400                               // Shutter Priority Mode
   1401                               u_Cmd = 0x39;
   1402                               u_Data[0] = 0x0A;
   1403                               Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1404                            }
   1405                            else
   1406                            {
   1407                               stSONY.SET_FLICKER_MODE = 0x00;
   1408          
   1409                               u_Cmd = 0x39;
   1410                               u_Data[0] = 0x00;
   1411          
   1412                               // Full-Auto Mode
   1413                               Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1414                            }
   1415                         }
   1416          
   1417                         // Shutter Priority Mode
   1418                         u_Cmd = 0x39;
   1419                         u_Data[0] = 0x0A;
   1420                         Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1421          
   1422                         u_Cmd = 0x4A;
   1423                         u_Data[0] = 0x00;
   1424                         u_Data[1] = stSONY.SET_SHUTTER_SPEED - 1;
   1425          
   1426                         // when, NTSC:1/30, PAL:1/25
   1427                         Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x09, SONY_COMMAND_TIMER_DELAY);
   1428                      }
   1429                   }
   1430                }
   1431                break;
   1432          
   1433                // 1.11.	Set Flicker Mode (0x55)
   1434             case SONY_SET_FLICKER_MODE:
   1435          
   1436                stSONY.SET_FLICKER_MODE = u_Data[1];
   1437          
   1438                AT24C256C_EEPROM_Write(EEP_SET_FLICKER_MODE, stSONY.SET_FLICKER_MODE);
   1439          
   1440                u_Data[0] = 0x00;
   1441                u_Data[1] = 0x00;
   1442          
   1443                switch (stSONY.SET_FLICKER_MODE)
   1444                {
   1445                   // Flicker Off = Full-Auto Mode
   1446                case 0x00:
   1447          
   1448                   u_Cmd = 0x39;
   1449                   u_Data[0] = 0x00;
   1450                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);	// Full-Auto Mode
   1451          
   1452                   stSONY.SET_SHUTTER_SPEED = 0x00;
   1453          
   1454                   break;
   1455          
   1456                   // Flicker On = Shutter Priority Mode
   1457                case 0x01:
   1458          
   1459                   u_Cmd = 0x39;
   1460                   u_Data[0] = 0x0A;
   1461                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);	// Shutter Priority Mode
   1462          
   1463                   u_Cmd = 0x4A;
   1464          
   1465                   if (stINFO.NTSC_PAL_STATUS == NTSC_MODE)
   1466                   {
   1467                      u_Data[0] = 0x00;
   1468                      u_Data[1] = 0x08;	// 1/100s
   1469                      stSONY.SET_SHUTTER_SPEED = 0x0A;
   1470                   }
   1471                   else if (stINFO.NTSC_PAL_STATUS == PAL_MODE)
   1472                   {
   1473                      u_Data[0] = 0x00;
   1474                      u_Data[1] = 0x09;	// 1/120s
   1475                      stSONY.SET_SHUTTER_SPEED = 0x09;
   1476                   }
   1477          
   1478                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x09, SONY_COMMAND_TIMER_DELAY);	// Full-Auto Mode
   1479          
   1480                   break;
   1481                }
   1482          
   1483                break;
   1484          
   1485                // 1.12.	Set Aperture Value (0x59)
   1486             case SONY_SET_APERTURE_VALUE:
   1487          
   1488                u_Data_Check = u_Data[1];
   1489          
   1490                if (u_Data_Check > 0x0F)
   1491                   break;
   1492          
   1493                stSONY.SET_APERTURE_VALUE = u_Data[1];
   1494          
   1495                AT24C256C_EEPROM_Write(EEP_SET_APERTURE_VALUE, stSONY.SET_APERTURE_VALUE);
   1496          
   1497                u_Cmd = 0x42;
   1498                u_Data[0] = 0x00;
   1499                u_Data[1] = stSONY.SET_APERTURE_VALUE;
   1500          
   1501                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x09, SONY_COMMAND_TIMER_DELAY);
   1502          
   1503                break;
   1504          
   1505                // 1.13.	Set Digital Zoom Mode (0x5B)
   1506             case SONY_SET_DIGITAL_ZOOM_MODE:
   1507          
   1508                stSONY.SET_DIGITAL_ZOOM_MODE = u_Data[1];
   1509          
   1510                AT24C256C_EEPROM_Write(EEP_SET_DIGITAL_ZOOM_MODE, stSONY.SET_DIGITAL_ZOOM_MODE);
   1511          
   1512                u_Data[0] = 0x00;
   1513                u_Data[1] = 0x00;
   1514          
   1515                switch (stSONY.SET_DIGITAL_ZOOM_MODE)
   1516                {
   1517                   // Digital Zoom Mode Off
   1518                case 0x00:
   1519          
   1520                   u_Cmd = 0x06;
   1521                   u_Data[0] = 0x03;
   1522                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);	// Shutter Priority Mode
   1523          
   1524                   break;
   1525          
   1526                   // Digital Zoom Mode On
   1527                case 0x01:
   1528          
   1529                   u_Cmd = 0x06;
   1530                   u_Data[0] = 0x02;
   1531                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);	// Shutter Priority Mode
   1532          
   1533                   break;
   1534          
   1535                default:
   1536          
   1537                   // 0x01     Digital Zoom Mode On
   1538                   u_Cmd = 0x06;
   1539                   u_Data[0] = 0x02;
   1540                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);	// Shutter Priority Mode
   1541          
   1542                   stSONY.SET_DIGITAL_ZOOM_MODE = 0x01;
   1543          
   1544                   break;
   1545          
   1546                }
   1547          
   1548                break;
   1549          
   1550                // 1.14.	Set Day & Night Mode (0x5F)
   1551             case SONY_SET_DAY_NIGHT_MODE:
   1552          
   1553                stSONY.SET_DAY_NIGHT_MODE = u_Data[1];
   1554          
   1555                AT24C256C_EEPROM_Write(EEP_SET_DAY_NIGHT_MODE, stSONY.SET_DAY_NIGHT_MODE);
   1556          
   1557                u_Data[0] = 0x00;
   1558                u_Data[1] = 0x00;
   1559          
   1560                switch (stSONY.SET_DAY_NIGHT_MODE)
   1561                {
   1562                   // Night Mode
   1563                case 0x00:
   1564          
   1565                   // Auto Mode Off
   1566                   u_Cmd = 0x51;
   1567                   u_Data[0] = 0x03;
   1568                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1569          
   1570                   // Night Mode
   1571                   u_Cmd = 0x01;
   1572                   u_Data[0] = 0x02;
   1573                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1574          
   1575                   break;
   1576          
   1577                   // Day Mode
   1578                case 0x01:
   1579          
   1580                   // Auto Mode Off
   1581                   u_Cmd = 0x51;
   1582                   u_Data[0] = 0x03;
   1583                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1584          
   1585                   // Day Mode
   1586                   u_Cmd = 0x01;
   1587                   u_Data[0] = 0x03;
   1588                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1589          
   1590                   break;
   1591          
   1592                   // Auto Mode
   1593                case 0x02:
   1594          
   1595                   // Auto Mode On
   1596                   u_Cmd = 0x51;
   1597                   u_Data[0] = 0x02;
   1598                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1599          
   1600                   break;
   1601                }
   1602          
   1603                break;
   1604          
   1605                // 1.15.	Set DSS Mode (0x61)
   1606             case SONY_SET_DSS_MODE:
   1607          
   1608                stSONY.SET_DSS_MODE = u_Data[1];
   1609          
   1610                AT24C256C_EEPROM_Write(EEP_SET_DSS_MODE, stSONY.SET_DSS_MODE);
   1611          
   1612                u_Data[0] = 0x00;
   1613                u_Data[1] = 0x00;
   1614          
   1615                switch (stSONY.SET_DSS_MODE)
   1616                {
   1617                   // DSS OFF
   1618                case 0x00:
   1619          
   1620                   // DSS OFF
   1621                   u_Cmd = 0x5A;
   1622                   u_Data[0] = 0x03;
   1623                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1624          
   1625                   if (stSONY.SET_SHUTTER_SPEED < 0x07)
   1626                   {
   1627                      // Full-Auto Mode
   1628                      u_Cmd = 0x39;
   1629                      u_Data[0] = 0x00;
   1630                      Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1631          
   1632                      stSONY.SET_SHUTTER_SPEED = 0x00;
   1633                   }
   1634          
   1635                   break;
   1636          
   1637                   // DSS ON
   1638                case 0x01:
   1639          
   1640                   u_Cmd = 0x5A;
   1641                   u_Data[0] = 0x02;
   1642                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1643          
   1644                   break;
   1645          
   1646                default:
   1647                   break;
   1648                }
   1649          
   1650                break;
   1651          
   1652                // 1.16.	Select BLC / WDR (0x85)
   1653             case SONY_SELECT_BLC_WDR:
   1654          
   1655                stSONY.SELECT_BLC_WDR = u_Data[1];
   1656          
   1657                AT24C256C_EEPROM_Write(EEP_SELECT_BLC_WDR, stSONY.SELECT_BLC_WDR);
   1658          
   1659                u_Data[0] = 0x00;
   1660                u_Data[1] = 0x00;
   1661          
   1662                //  .
   1663                switch (stSONY.SELECT_BLC_WDR)
   1664                {
   1665                case 0x00:
   1666                   break;
   1667          
   1668                case 0x01:
   1669                   break;
   1670          
   1671                default:
   1672                   break;
   1673                }
   1674          
   1675                break;
   1676          
   1677                // 1.17.	Set High Resolution (0x87)
   1678             case SONY_SET_HIGH_RESOLUTION:
   1679          
   1680                stSONY.SET_HIGH_RESOLUTION = u_Data[1];
   1681          
   1682                AT24C256C_EEPROM_Write(EEP_SET_HIGH_RESOLUTION, stSONY.SET_HIGH_RESOLUTION);
   1683          
   1684                u_Data[0] = 0x00;
   1685                u_Data[1] = 0x00;
   1686          
   1687                switch (stSONY.SET_HIGH_RESOLUTION)
   1688                {
   1689                   // HR Mode Off
   1690                case 0x00:
   1691          
   1692                   u_Cmd = 0x52;
   1693                   u_Data[0] = 0x03;
   1694                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1695          
   1696                   break;
   1697          
   1698                   // HR Mode On
   1699                case 0x01:
   1700          
   1701                   u_Cmd = 0x52;
   1702                   u_Data[0] = 0x02;
   1703                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1704          
   1705                   break;
   1706          
   1707                default:
   1708                   break;
   1709                }
   1710          
   1711                break;
   1712          
   1713                // 1.18.	Set Image Stabilizer (0x89)
   1714             case SONY_SET_IMAGE_STABILIZER:
   1715          
   1716                stSONY.SET_IMAGE_STABILIZER = u_Data[1];
   1717          
   1718                AT24C256C_EEPROM_Write(EEP_SET_IMAGE_STABILIZER, stSONY.SET_IMAGE_STABILIZER);
   1719          
   1720                u_Data[0] = 0x00;
   1721                u_Data[1] = 0x00;
   1722          
   1723                switch (stSONY.SET_IMAGE_STABILIZER)
   1724                {
   1725                   // Image Stabilizer Off
   1726                case 0x00:
   1727          
   1728                   u_Cmd = 0x34;
   1729                   u_Data[0] = 0x03;
   1730                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1731          
   1732                   break;
   1733          
   1734                   // Image Stabilizer On
   1735                case 0x01:
   1736          
   1737                   u_Cmd = 0x34;
   1738                   u_Data[0] = 0x02;
   1739                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1740          
   1741                   break;
   1742          
   1743                default:
   1744                   break;
   1745                }
   1746          
   1747                break;
   1748          
   1749                // 1.19.	Set Noise Reduction (0x8B)
   1750             case SONY_SET_NOISE_REDUCTION:
   1751          
   1752                u_Data_Check = u_Data[1];
   1753          
   1754                if (u_Data_Check > 0x05)
   1755                   break;
   1756          
   1757                stSONY.SET_NOISE_REDUCTION = u_Data[1];
   1758          
   1759                AT24C256C_EEPROM_Write(EEP_SET_NOISE_REDUCTION, stSONY.SET_NOISE_REDUCTION);
   1760          
   1761                u_Data[0] = 0x00;
   1762                u_Data[1] = 0x00;
   1763          
   1764                switch (stSONY.SET_NOISE_REDUCTION)
   1765                {
   1766                   // Noise Reduction Off
   1767                case 0x00:
   1768          
   1769                   u_Cmd = 0x53;
   1770                   u_Data[0] = 0x00;
   1771                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1772          
   1773                   break;
   1774          
   1775                   // Image Stabilizer On [Sensitivity] (Lv.1 ~ Lv.5)
   1776                case 0x01:
   1777                case 0x02:
   1778                case 0x03:
   1779                case 0x04:
   1780                case 0x05:
   1781          
   1782                   u_Cmd = 0x53;
   1783                   u_Data[0] = stSONY.SET_NOISE_REDUCTION;
   1784                   Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x06, SONY_COMMAND_TIMER_DELAY);
   1785          
   1786                   break;
   1787          
   1788                default:
   1789                   break;
   1790                }
   1791          
   1792                break;
   1793          
   1794                // 1.20.	Set Color Module (0xF0) -      
   1795             case SONY_SET_COLOR_MODULE:
   1796                break;
   1797          
   1798                // Set NTSC/PAL Mode (0x72)
   1799             case SONY_SET_NTSC_PAL_MODE:
   1800          
   1801                u_Data_Check = u_Data[1];
   1802          
   1803                stSONY.SET_NTSC_PAL_MODE = u_Data[1];
   1804          
   1805                AT24C256C_EEPROM_Write(EEP_SET_NTSC_PAL_MODE, stSONY.SET_NTSC_PAL_MODE);
   1806          
   1807                u_Data[0] = 0x00;
   1808                u_Data[1] = 0x00;
   1809          
   1810                u_Cmd = SONY_SET_NTSC_PAL_MODE;
   1811                u_Data[0] = 0x00;
   1812          
   1813                switch (stSONY.SET_NTSC_PAL_MODE)
   1814                {
   1815                   // NTSC MODE
   1816                case 0x01:
   1817                   u_Data[1] = 0x07;
   1818                   break;
   1819          
   1820                   // PAL MODE
   1821                case 0x02:
   1822                   u_Data[1] = 0x08;
   1823                   break;
   1824          
   1825                default:
   1826                   break;
   1827                }
   1828          
   1829                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], 0x08, SONY_COMMAND_TIMER_DELAY);
   1830          
   1831                break;
   1832          
   1833                // Call Zoom Position (0xB8 : 0xFF - 0x47)
   1834             case 0xB8:
   1835          
   1836                switch (u_Port)
   1837                {
   1838                case USART1_INDEX:
   1839          
   1840                   u_Cmd = SONY_CALL_ZOOM_POSITION;
   1841          
   1842                   u16_Convert_Data = stSONY.ZOOM_CNT;
   1843                   u_Data[0] = (u8)(u16_Convert_Data >> 8);
   1844                   u_Data[1] = (u8)(u16_Convert_Data & 0xFF);
   1845                   u_Leng = 0x05;
   1846          
   1847                   stUSART1.TX_READY = 0x01;
   1848          
   1849                   break;
   1850          
   1851                default:
   1852                   break;
   1853                }
   1854          
   1855                break;
   1856          
   1857             default:
   1858                break;
   1859          
   1860             }
   1861          
   1862             // Send MAIN Command & Data Trans
   1863             if (stUSART1.TX_READY)
   1864             {
   1865                USART1_Send_Data(IP_SONY_FIRST_BYTE, u_Cmd, u_Data[0], u_Data[1], u_Data[2], u_Leng);
   1866          
   1867                stUSART1.TX_READY = 0;
   1868          
   1869                //Send_Data_Clear(USART1_INDEX, u_Leng);
   1870             }
   1871          
   1872             // Send SONY Command & Data Trans
   1873             if (stUART4.TX_READY)
   1874             {
   1875                Send_Sony_Data(u_Cmd, u_Data[0], u_Data[1], u_Leng, TSM_COMMAND_TIMER_DELAY);
   1876          
   1877                if (!stUART4.TX_REQUEST)
   1878                   stUART4.TX_ACK = 0x01;
   1879          
   1880                stUART4.TX_READY = 0;
   1881          
   1882                //Send_Data_Clear(USART1_INDEX, u_Leng);
   1883             }
   1884          
   1885             // Send Ack Trans
   1886             if (stUART4.TX_ACK)
   1887             {
   1888                stUART4.TX_ACK = 0;
   1889             }
   1890          
   1891          }
   1892          
   1893          /***************************************************************************************************************************
   1894          * Function : TSM_Data_Handing
   1895          * Protocol Version : 0.1 (2016.04.11)
   1896          * Data Architecture :
   1897          BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]		BYTE[..]		BYTE(n)[LENGTH+4]	BYTE(n+1)[LENGTH+4]
   1898          0xB0		0x0B		LENGTH		ADDR		COMM		DATA		...			CS					0xBF
   1899          ****************************************************************************************************************************/
   1900          void TSM_Data_Handing(u8 u_Port, u8 u_Comm, u8 u_Leng)
   1901          {
   1902             u8 u_Cmd = 0x00;	// Camera Command
   1903             u8 u_Data1 = 0x00, u_Data2 = 0x00, u_Data3 = 0x00;
   1904             u8 u_Response_Data = 0x00;
   1905          
   1906             u8 u8_Convert_Data[10];
   1907             u16 u16_Convert_Data = 0x0000;
   1908          
   1909             switch (u_Port)
   1910             {
   1911             case SYSTEM_INDEX:
   1912          
   1913                u_Cmd = stSYS.RX_BUF[0][5];
   1914                u_Data1 = stSYS.RX_BUF[0][6];
   1915                u_Data2 = stSYS.RX_BUF[0][7];
   1916                u_Data3 = stSYS.RX_BUF[0][8];
   1917          
   1918                break;
   1919          
   1920             case USART1_INDEX:
   1921          
   1922                u_Cmd = stUSART1.RX_BUF[4];
   1923                u_Data1 = stUSART1.RX_BUF[5];
   1924                u_Data2 = stUSART1.RX_BUF[6];
   1925                u_Data3 = stUSART1.RX_BUF[7];
   1926          
   1927                break;
   1928          
   1929             case USART5_INDEX:
   1930          
   1931                u_Cmd = stUART5.RX_BUF[4];
   1932                u_Data1 = stUART5.RX_BUF[5];
   1933                u_Data2 = stUART5.RX_BUF[6];
   1934                u_Data3 = stUART5.RX_BUF[7];
   1935          
   1936                break;
   1937          
   1938             default:
   1939                break;
   1940             }
   1941          
   1942             switch (u_Comm)
   1943             {
   1944                // 2.1.1. Initialize (0x01)
   1945             case TSM_INITIALIZE:
   1946                stUART4.TX_READY = 0x01;
   1947                break;
   1948          
   1949                // 2.1.2. Rebooting (0x02)
   1950             case TSM_REBOOTING:
   1951                stUART4.TX_READY = 0x01;
   1952                break;
   1953          
   1954                // 2.1.3. Save Setting (0x04)
   1955             case TSM_SAVE_SETTING:
   1956                stUART4.TX_READY = 0x01;
   1957                break;
   1958          
   1959                // 2.1.4. Shutter Set (0x05)
   1960             case TSM_SHUTTER_SET:
   1961                stUART4.TX_READY = 0x01;
   1962                break;
   1963          
   1964                // 2.1.5. Digital Zoom Start (0x11)
   1965             case TSM_DIGITAL_ZOOM_START:
   1966                stUART4.TX_READY = 0x01;
   1967                break;
   1968          
   1969                // 2.1.6. Digital Zoom Stop (0x10)
   1970             case TSM_DIGITAL_ZOOM_STOP:
   1971                stUART4.TX_READY = 0x01;
   1972                break;
   1973          
   1974                // 2.1.7. Digital Zoom Direct (0x12)
   1975             case TSM_DIGITAL_ZOOM_DIRECT:
   1976                stUART4.TX_READY = 0x01;
   1977                break;
   1978          
   1979                // 2.1.8. Optical Zoom Start (0x13)
   1980             case TSM_OPTICAL_ZOOM_START:
   1981                stUART4.TX_READY = 0x01;
   1982                break;
   1983          
   1984                // 2.1.9. Optical Zoom Stop (0x14)
   1985             case TSM_OPTICAL_ZOOM_STOP:
   1986                stUART4.TX_READY = 0x01;
   1987                break;
   1988          
   1989                // 2.1.10. Optical Zoom Direct (0x15)
   1990             case TSM_OPTICAL_ZOOM_DIRECT:
   1991                stUART4.TX_READY = 0x01;
   1992                break;
   1993          
   1994                // 2.1.11. Focus Start (0x16)
   1995             case TSM_FOCUS_START:
   1996                stUART4.TX_READY = 0x01;
   1997                //stPTZ.TFOCUS_STATUS = FOCUS_ACTIVE;
   1998                break;
   1999          
   2000                // 2.1.12. Focus Stop (0x17)
   2001             case TSM_FOCUS_STOP:
   2002                stUART4.TX_READY = 0x01;
   2003                stTSM.FOCUS_CHECK_FLAG = 0x01;
   2004                //stPTZ.TFOCUS_STATUS = FOCUS_STOP;
   2005                break;
   2006          
   2007                // 2.1.13. Focus Direct (0x18)
   2008             case TSM_FOCUS_DIRECT:
   2009                stUART4.TX_READY = 0x01;
   2010                break;
   2011          
   2012                // 2.1.14. Auto Focus Set (0x19)
   2013             case TSM_AUTO_FOCUS_SET:
   2014                stUART4.TX_READY = 0x01;
   2015                break;
   2016          
   2017                // 2.1.15. Digital Zoom Enable (0x1C)
   2018             case TSM_DIZITAL_ZOOM_ENABLE:
   2019          
   2020                // IP ERROR DATA CONVERT
   2021                switch (u_Data3)
   2022                {
   2023                case 0x01:
   2024                   u_Data3 = 0x80;
   2025                   break;
   2026                }
   2027                stUART4.TX_READY = 0x01;
   2028                break;
   2029          
   2030                // 2.1.16. Total Zoom Start (0x20)
   2031             case TSM_TOTAL_ZOOM_START:
   2032          
   2033                switch (stINFO.THERMAL_MODEL)
   2034                {
   2035                case TSM_72:
   2036                case TSM_1M:
   2037          
   2038          #if(1)
   2039          
   2040                   switch (stINFO.THERMAL_LENS)
   2041                   {
   2042                   case 0x01:
   2043                      u_Cmd = TSM_TOTAL_ZOOM_START;
   2044                      u_Data2 = 0x07;
   2045                      break;
   2046          
   2047                   default:
   2048                      u_Cmd = TSM_TOTAL_ZOOM_START;
   2049                      break;
   2050                   }
   2051          #else
   2052                   switch (stINFO.THERMAL_LENS)
   2053                   {
   2054                   case 0x01:
   2055                      u_Cmd = TSM_TOTAL_ZOOM_START;
   2056                      u_Data2 = 0x07;
   2057                      break;
   2058          
   2059                   default:
   2060                      u_Cmd = TSM_DIGITAL_ZOOM_START;
   2061                      break;
   2062                   }
   2063          #endif
   2064          
   2065                   break;
   2066          
   2067                default:
   2068                   break;
   2069                }
   2070          
   2071                stUART4.TX_READY = 0x01;
   2072                //stPTZ.TZOOM_STATUS = ZOOM_ACTIVE;
   2073                break;
   2074          
   2075                // 2.1.17. Total Zoom Stop (0x21)
   2076             case TSM_TOTAL_ZOOM_STOP:
   2077                stUART4.TX_READY = 0x01;
   2078                stTSM.ZOOM_CHECK_FLAG = 0x01;
   2079                break;
   2080          
   2081                // 2.1.18. Total Zoom Direct (0x22)
   2082             case TSM_TOTAL_ZOOM_DIRECT:
   2083                stUART4.TX_READY = 0x01;
   2084                break;
   2085          
   2086                // 2.1.19. Total Zoom Stop (0x23)
   2087             case TSM_TOTAL_ZOOM_STOP_SUB:
   2088                stUART4.TX_READY = 0x01;
   2089                stTSM.ZOOM_CHECK_FLAG = 0x01;
   2090                break;
   2091          
   2092                // 2.1.20. AGC Mode Set (0x26)
   2093             case TSM_AGC_MODE_SET:
   2094                stUART4.TX_READY = 0x01;
   2095                break;
   2096          
   2097                // 2.1.21. Color Mode Set (0x27)
   2098             case TSM_COLOR_MODE_SET:
   2099                stUART4.TX_READY = 0x01;
   2100                break;
   2101          
   2102                // 2.1.22. Contrast/Brightness (0x28) (when, AGC OFF)
   2103             case TSM_CONTRAST_BRIGHTNESS:
   2104                stUART4.TX_READY = 0x01;
   2105                break;
   2106          
   2107                // 2.1.23. AGC Center Position Set (0x29)
   2108             case TSM_AGC_CENTER_POSITION_SET:
   2109                stUART4.TX_READY = 0x01;
   2110                break;
   2111          
   2112                // 2.1.24. AGC Limit Level Set (0x2A)
   2113             case TSM_AGC_LIMIT_LEVEL_SET:
   2114                stUART4.TX_READY = 0x01;
   2115                break;
   2116          
   2117                // 2.1.25. AGC ROI (AGC Region of Interest) Set (0x2B)
   2118             case TSM_AGC_ROI_SET:
   2119                stUART4.TX_READY = 0x01;
   2120                break;
   2121          
   2122                // 2.1.26. MIDE Level Set (0x2C) (when, Sharpness OFF)
   2123             case TSM_MIDE_LEVEL_SET:
   2124                stUART4.TX_READY = 0x01;
   2125                break;
   2126          
   2127                // 2.1.27. Sharpness Level Set (0x2D) (when, MIDE OFF)
   2128             case TSM_SHARPNESS_LEVEL_SET:
   2129                stUART4.TX_READY = 0x01;
   2130                break;
   2131          
   2132                // 2.1.28. Detect Mode Set (0x31)
   2133             case TSM_DETECT_MODE_SET:
   2134                stUART4.TX_READY = 0x01;
   2135                break;
   2136          
   2137                // 2.1.29. Area Position Set (0x32)
   2138             case TSM_AREA_POSITION_SET:
   2139                stUART4.TX_READY = 0x01;
   2140                break;
   2141          
   2142                // 2.1.30. Spot Position Set (0x33)
   2143             case TSM_SPOT_POSITION_SET:
   2144                stUART4.TX_READY = 0x01;
   2145                break;
   2146          
   2147                // 2.1.31. High Alarm Temperature (0x34)
   2148             case TSM_HIGH_ALARM_TEMPERATURE:
   2149                stUART4.TX_READY = 0x01;
   2150                break;
   2151          
   2152                // 2.1.32. Low Alarm Temperature (0x35)
   2153             case TSM_LOW_ALARM_TEMPERATURE:
   2154                stUART4.TX_READY = 0x01;
   2155                break;
   2156          
   2157                // 2.1.33. Select Alarm (0x36)
   2158             case TSM_SELECT_ALARM:
   2159                stUART4.TX_READY = 0x01;
   2160                break;
   2161          
   2162                // 2.1.34. Alarm Mode (0x37)
   2163             case TSM_ALARM_MODE:
   2164                stUART4.TX_READY = 0x01;
   2165                break;
   2166          
   2167                // 2.1.35. Temperature OSD (0x38)
   2168             case TSM_TEMPERATURE_OSD:
   2169                stUART4.TX_READY = 0x01;
   2170                break;
   2171          
   2172                // 2.1.36. Emissivity Set (0x39)
   2173             case TSM_EMISSIVITY_SET:
   2174                stUART4.TX_READY = 0x01;
   2175                break;
   2176          
   2177                // 2.1.37. Mirror / Flip Mode Set (0x43)
   2178             case TSM_MIRROR_FLIP_MODE_SET:
   2179                stUART4.TX_READY = 0x01;
   2180                break;
   2181          
   2182                // 2.1.38. Mirror Mode Set (0x44)
   2183             case TSM_MIRROR_MODE_SET:
   2184                stUART4.TX_READY = 0x01;
   2185                break;
   2186          
   2187                // 2.1.39. Flip Mode Set (0x45)
   2188             case TSM_FLIP_MODE_SET:
   2189                stUART4.TX_READY = 0x01;
   2190                break;
   2191          
   2192                // 2.1.40. Image Freeze Set (0x46)
   2193             case TSM_IMAGE_FREEZE_SET:
   2194                stUART4.TX_READY = 0x01;
   2195                break;
   2196          
   2197                // 2.1.41. Image Color Inverse(White/Black Hot) Set (0x47)
   2198             case TSM_IMAGE_COLOR_INVERSE:
   2199                stUART4.TX_READY = 0x01;
   2200                break;
   2201          
   2202                // 2.1.42. External Communication Option Set (0x55)
   2203             case TSM_EXTERNAL_OPTION_SET:
   2204                stUART4.TX_READY = 0x01;
   2205                break;
   2206          
   2207                // 2.1.43. Calibration Execute (0x65)
   2208             case TSM_CALIBRATION_EXECUTE:
   2209                stUART4.TX_READY = 0x01;
   2210                break;
   2211          
   2212                // 2.1.44. Calibration Option Set (0x66)
   2213             case TSM_CALIBRATION_OPTION_SET:
   2214                stUART4.TX_READY = 0x01;
   2215                break;
   2216          
   2217                // 2.1.45. OSD All Off (0x76)
   2218             case TSM_OSD_ALL_OFF:
   2219                stUART4.TX_READY = 0x01;
   2220                break;
   2221          
   2222                // 2.1.46. Temperature Mode Set (0x77)
   2223             case TSM_TEMPERATURE_MODE_SET:
   2224                stUART4.TX_READY = 0x01;
   2225                break;
   2226          
   2227                // 2.1.47. Temperature Range Set (0x78) - Not Used
   2228             case TSM_TEMPERATURE_RANGE_SET:
   2229                break;
   2230          
   2231                // 2.1.48. Video Mode Set (0x79)
   2232             case TSM_VIDEO_MODE_SET:
   2233                stUART4.TX_READY = 0x01;
   2234                break;
   2235          
   2236                // 2.1.49. OSD MENU Key Control (0xA0)
   2237             case TSM_OSD_MENU_KEY_CONTROL:
   2238                stUART4.TX_READY = 0x01;
   2239                break;
   2240          
   2241                // 2.1.50. Call Module Status (0x30)
   2242             case TSM_CALL_MODULE_STATUS:
   2243                stUART4.TX_READY = 0x01;
   2244                stUART4.TX_REQUEST = 0x01;
   2245                break;
   2246          
   2247                // 2.1.51. Call Alarm Status (0x3A)
   2248             case TSM_CALL_ALARM_STATUS:
   2249                stUART4.TX_READY = 0x01;
   2250                stUART4.TX_REQUEST = 0x01;
   2251                break;
   2252          
   2253                // 2.1.52. Call Spot Temperature (0x3B)
   2254             case TSM_CALL_SPOT_TEMPERATURE:
   2255                stUART4.TX_READY = 0x01;
   2256                stUART4.TX_REQUEST = 0x01;
   2257                break;
   2258          
   2259                // 2.1.53. Call Area Temperature (0x3C)
   2260             case TSM_CALL_AREA_TEMPERATURE:
   2261                stUART4.TX_READY = 0x01;
   2262                stUART4.TX_REQUEST = 0x01;
   2263                break;
   2264          
   2265                // 2.1.54. Call Center Temperature (0x3D)
   2266             case TSM_CALL_CENTER_TEMPERATURE:
   2267                stUART4.TX_READY = 0x01;
   2268                stUART4.TX_REQUEST = 0x01;
   2269                break;
   2270          
   2271                // 2.1.55. Call Full Temperature (0x3E)
   2272             case TSM_CALL_FULL_TEMPERATURE:
   2273                stUART4.TX_READY = 0x01;
   2274                stUART4.TX_REQUEST = 0x01;
   2275                break;
   2276          
   2277                // 2.1.56. Call External Communication (0x71)
   2278             case TSM_CALL_EXTERNAL_COMMUNICATION:
   2279                stUART4.TX_READY = 0x01;
   2280                stUART4.TX_REQUEST = 0x01;
   2281                break;
   2282          
   2283                // 2.1.57. Call Camera Information (0x80)
   2284             case TSM_CALL_CAMERA_INFORMATION:
   2285                stUART4.TX_READY = 0x01;
   2286                stUART4.TX_REQUEST = 0x01;
   2287                break;
   2288          
   2289                // 2.1.58. Call Firmware Version (0x81)
   2290             case TSM_CALL_FIRMWARE_VERSION:
   2291                stUART4.TX_READY = 0x01;
   2292                stUART4.TX_REQUEST = 0x01;
   2293                break;
   2294          
   2295                // 2.1.59. Call Digital Zoom Position (0x82)
   2296             case TSM_CALL_DIGITAL_ZOOM_POSITION:
   2297                stUART4.TX_READY = 0x01;
   2298                stUART4.TX_REQUEST = 0x01;
   2299                break;
   2300          
   2301                // 2.1.60. Call Optical Zoom Position (0x83)
   2302             case TSM_CALL_OPTICAL_ZOOM_POSITION:
   2303                stUART4.TX_READY = 0x01;
   2304                stUART4.TX_REQUEST = 0x01;
   2305                break;
   2306          
   2307                // 2.1.61. Call Focus Position (0x84)
   2308             case TSM_CALL_FOCUS_POSITION:
   2309                stUART4.TX_READY = 0x01;
   2310                stUART4.TX_REQUEST = 0x01;
   2311                break;
   2312          
   2313                // 2.1.62. Call Total Zoom Position (0x85)
   2314             case TSM_CALL_TOTAL_ZOOM_POSITION:
   2315                stUART4.TX_READY = 0x01;
   2316                stUART4.TX_REQUEST = 0x01;
   2317          
   2318                stTSM.ZOOM_CHECK_FLAG = 0x01;
   2319                break;
   2320          
   2321                // 2.1.63. Call Temperature Mode (0x86)
   2322             case TSM_CALL_TEMPERATURE_MODE:
   2323                stUART4.TX_READY = 0x01;
   2324                stUART4.TX_REQUEST = 0x01;
   2325                break;
   2326          
   2327                // 2.1.64. Call All Temperature (0x87)
   2328             case TSM_CALL_ALL_TEMPERATURE:
   2329                stUART4.TX_READY = 0x01;
   2330                stUART4.TX_REQUEST = 0x01;
   2331          
   2332                // BackUp Data
   2333                stTSM.TEMPERATURE_READ_FLAG = u_Data1;		//     
   2334          
   2335                u16_Convert_Data = (u_Data2 << 8);		//      P2
   2336                u16_Convert_Data |= u_Data3;			//      P3
   2337                stTSM.TEMPERATURE_READ_TIME = u16_Convert_Data;
   2338                break;
   2339          
   2340                // 2.1.65. Call Auto AF (0x88)
   2341             case TSM_CALL_AUTO_AF:
   2342                stUART4.TX_READY = 0x01;
   2343                stUART4.TX_REQUEST = 0x01;
   2344                break;
   2345          
   2346                // Call Focus Position (0x94)
   2347             case TSM_CALL_FOCUS_POSITION_SUB:
   2348          
   2349                u16_Convert_Data = stTSM.FOCUS_CNT;
   2350          
   2351                u8_Convert_Data[0] = (u8)(u16_Convert_Data >> 8);
   2352                u8_Convert_Data[1] = (u8)(u16_Convert_Data & 0xFF);
   2353          
   2354                stUSART1.TX_BUF[0] = IP_TSM_FIRST_BYTE;
   2355                stUSART1.TX_BUF[1] = IP_TSM_SECOND_BYTE;
   2356                stUSART1.TX_BUF[2] = 0x05;
   2357          
   2358                stUSART1.TX_BUF[3] = 0x01;
   2359          
   2360                stUSART1.TX_BUF[4] = TSM_CALL_FOCUS_POSITION_SUB;
   2361                stUSART1.TX_BUF[5] = u8_Convert_Data[0];
   2362                stUSART1.TX_BUF[6] = u8_Convert_Data[1];
   2363                stUSART1.TX_BUF[7] = u8_Convert_Data[2];
   2364          
   2365                stUSART1.TX_BUF[8] = 0x00;
   2366                stUSART1.TX_BUF[8] = stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5] + stUSART1.TX_BUF[6] + stUSART1.TX_BUF[7];
   2367          
   2368                stUSART1.TX_BUF[9] = 0xBF;
   2369          
   2370                stUSART1.TX_CNT = 0;
   2371                stUSART1.TX_MAX = 10;
   2372          
   2373                USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   2374                Delay_1ms(MAIN_COMMAND_TIMER_DELAY);
   2375          
   2376                break;
   2377          
   2378                // Call Total Zoom Position (0x95)
   2379             case TSM_CALL_TOTAL_ZOOM_POSITION_SUB:
   2380          
   2381                u16_Convert_Data = stTSM.ZOOM_CNT;
   2382          
   2383                u8_Convert_Data[0] = (u8)(u16_Convert_Data >> 8);
   2384                u8_Convert_Data[1] = (u8)(u16_Convert_Data & 0xFF);
   2385          
   2386                stUSART1.TX_BUF[0] = IP_TSM_FIRST_BYTE;
   2387                stUSART1.TX_BUF[1] = IP_TSM_SECOND_BYTE;
   2388                stUSART1.TX_BUF[2] = 0x05;
   2389          
   2390                stUSART1.TX_BUF[3] = 0x01;
   2391          
   2392                stUSART1.TX_BUF[4] = TSM_CALL_TOTAL_ZOOM_POSITION_SUB;
   2393                stUSART1.TX_BUF[5] = u8_Convert_Data[0];
   2394                stUSART1.TX_BUF[6] = u8_Convert_Data[1];
   2395                stUSART1.TX_BUF[7] = u8_Convert_Data[2];
   2396          
   2397                stUSART1.TX_BUF[8] = 0x00;
   2398                stUSART1.TX_BUF[8] = stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5] + stUSART1.TX_BUF[6] + stUSART1.TX_BUF[7];
   2399          
   2400                stUSART1.TX_BUF[9] = 0xBF;
   2401          
   2402                stUSART1.TX_CNT = 0;
   2403                stUSART1.TX_MAX = 10;
   2404          
   2405                USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   2406                Delay_1ms(MAIN_COMMAND_TIMER_DELAY);
   2407          
   2408                break;
   2409          
   2410                // 2.1.66. Call Product Identification (0xF0)
   2411             case TSM_CALL_PRODUCT_IDENTIFICATION:
   2412                stUART4.TX_READY = 0x01;
   2413                stUART4.TX_REQUEST = 0x01;
   2414                break;
   2415          
   2416                // 2.1.67. Module Mode Set (0xF1)
   2417             case TSM_MODULE_MODE_SET:
   2418                stUART4.TX_READY = 0x01;
   2419                stUART4.TX_REQUEST = 0x01;
   2420                break;
   2421          
   2422                // 2.1.68. Auto AF Set (0xF2)
   2423             case TSM_AUTO_AF_SET:
   2424                stUART4.TX_READY = 0x01;
   2425                stUART4.TX_REQUEST = 0x01;
   2426                break;
   2427          
   2428                // 2.1.69. Set Thermal Module (0xF3)
   2429             case TSM_SET_THERMAL_MODULE:
   2430                stUART4.TX_READY = 0x01;
   2431                break;
   2432          
   2433             default:
   2434                stUART4.TX_READY = 0x01;
   2435                break;
   2436          
   2437             }
   2438          
   2439             stUART4.TX_CMD = u_Cmd;
   2440             stUART4.TX_PARAMETER1 = u_Data1;
   2441             stUART4.TX_PARAMETER2 = u_Data2;
   2442             stUART4.TX_PARAMETER3 = u_Data3;
   2443          
   2444             // Send TSM Command & Data Trans
   2445             if (stUART4.TX_READY)
   2446             {
   2447                Send_TSM_Data(u_Cmd, u_Data1, u_Data2, u_Data3, 0x06, TSM_COMMAND_TIMER_DELAY);
   2448          
   2449                if (stTSM.ZOOM_CHECK_FLAG == 0x01)
   2450                {
   2451                   stTSM.ZOOM_CHECK_FLAG = 0x00;
   2452                   stUART4.RX_REQUEST_CMD = TSM_CALL_TOTAL_ZOOM_POSITION;
   2453                   Send_TSM_Data(TSM_CALL_TOTAL_ZOOM_POSITION, 0x00, 0x00, 0x00, 0x06, TSM_COMMAND_TIMER_DELAY);
   2454                }
   2455          
   2456                if (stTSM.FOCUS_CHECK_FLAG == 0x01)
   2457                {
   2458                   stTSM.FOCUS_CHECK_FLAG = 0x00;
   2459                   stUART4.RX_REQUEST_CMD = TSM_CALL_FOCUS_POSITION;
   2460                   Send_TSM_Data(TSM_CALL_FOCUS_POSITION, 0x00, 0x00, 0x00, 0x06, TSM_COMMAND_TIMER_DELAY);
   2461                }
   2462          
   2463                if (!stUART4.TX_REQUEST)
   2464                   stUART4.TX_ACK = 0x01;
   2465          
   2466                stUART4.TX_READY = 0;
   2467          
   2468                //Send_Data_Clear(u_Leng);
   2469             }
   2470          
   2471             // Send Ack Trans
   2472             if (stUART4.TX_ACK)
   2473             {
   2474                //Send_UART4_Ack(0xB0, 0x03, 0x01, u_Comm, u_Response_Data, 5);
   2475          
   2476                stUART4.TX_ACK = 0;
   2477             }
   2478          }
   2479          
   2480          /***************************************************************************************************************************
   2481          * Function : TCM_Data_Handing
   2482          * Protocol Version : 2.12 (2017.05.16)
   2483          * Data Architecture :
   2484          BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]		BYTE[..]		BYTE(n)[LENGTH+4]	BYTE(n+1)[LENGTH+4]
   2485          0xB0		0x0B		LENGTH		ADDR		COMM		DATA		...			CS					0xBF
   2486          ****************************************************************************************************************************/
   2487          void TCM_Data_Handing(u8 u_Port, u8 u_Comm, u8 u_Leng)
   2488          {
   2489             u8 u_Cmd = 0x00, u_Length = 0x06;
   2490             u8 u_Data1 = 0x00, u_Data2 = 0x00, u_Data3 = 0x00, u_Data4 = 0x00, u_Data5 = 0x00;
   2491             u8 u_Data6 = 0x00, u_Data7 = 0x00, u_Data8 = 0x00, u_Data9 = 0x00;
   2492             u8 u_Response_Data = 0x00;
   2493          
   2494             u8 u8_Convert_Data[10];
   2495             u16 u16_Convert_Data = 0x0000;
   2496          
   2497             switch (u_Port)
   2498             {
   2499             case SYSTEM_INDEX:
   2500          
   2501                u_Cmd = stSYS.RX_BUF[0][5];
   2502                u_Data1 = stSYS.RX_BUF[0][6];
   2503                u_Data2 = stSYS.RX_BUF[0][7];
   2504                u_Data3 = stSYS.RX_BUF[0][8];
   2505          
   2506                u_Data4 = stSYS.RX_BUF[0][9];
   2507                u_Data5 = stSYS.RX_BUF[0][10];
   2508                u_Data6 = stSYS.RX_BUF[0][11];
   2509          
   2510                u_Data7 = stSYS.RX_BUF[0][12];
   2511                u_Data8 = stSYS.RX_BUF[0][13];
   2512                u_Data9 = stSYS.RX_BUF[0][14];
   2513          
   2514                break;
   2515          
   2516             case USART1_INDEX:
   2517          
   2518                u_Cmd = stUSART1.RX_BUF[4];
   2519                u_Data1 = stUSART1.RX_BUF[5];
   2520                u_Data2 = stUSART1.RX_BUF[6];
   2521                u_Data3 = stUSART1.RX_BUF[7];
   2522          
   2523                u_Data4 = stUSART1.RX_BUF[8];
   2524                u_Data5 = stUSART1.RX_BUF[9];
   2525                u_Data6 = stUSART1.RX_BUF[10];
   2526          
   2527                u_Data7 = stUSART1.RX_BUF[11];
   2528                u_Data8 = stUSART1.RX_BUF[12];
   2529                u_Data9 = stUSART1.RX_BUF[13];
   2530          
   2531                break;
   2532          
   2533             case USART5_INDEX:
   2534          
   2535                u_Cmd = stUART5.RX_BUF[4];
   2536                u_Data1 = stUART5.RX_BUF[5];
   2537                u_Data2 = stUART5.RX_BUF[6];
   2538                u_Data3 = stUART5.RX_BUF[7];
   2539          
   2540                u_Data4 = stUART5.RX_BUF[8];
   2541                u_Data5 = stUART5.RX_BUF[9];
   2542                u_Data6 = stUART5.RX_BUF[10];
   2543          
   2544                u_Data7 = stUSART1.RX_BUF[11];
   2545                u_Data8 = stUSART1.RX_BUF[12];
   2546                u_Data9 = stUSART1.RX_BUF[13];
   2547          
   2548                break;
   2549          
   2550             default:
   2551                break;
   2552             }
   2553          
   2554             switch (u_Comm)
   2555             {
   2556                // 2.3.1. Camera Initialize (0x01)
   2557             case TCM_INITIALIZE:
   2558                stUART4.TX_READY = 0x01;
   2559                break;
   2560          
   2561                // 2.3.2. Rebooting (0x02)
   2562             case TCM_REBOOTING:
   2563                stUART4.TX_READY = 0x01;
   2564                break;
   2565          
   2566                // 2.3.3. Save Current Setting Option (0x04)
   2567             case TCM_SAVE_CURRENT_SETTING_OPTION:
   2568                stUART4.TX_READY = 0x01;
   2569                break;
   2570          
   2571                // 2.3.4. Zoom/Focus Stop (Digital Zoom, Optical Zoom, Focus) (0x10)
   2572             case TCM_ZOOM_FOCUS_STOP:
   2573                stUART4.TX_READY = 0x01;
   2574                break;
   2575          
   2576                // 2.3.5. Digital Zoom Start (0x11)
   2577             case TCM_DIGITAL_ZOOM_START:
   2578                stUART4.TX_READY = 0x01;
   2579                break;
   2580          
   2581                // 2.3.6. Digital Zoom Direct (0x12)
   2582             case TCM_DIGITAL_ZOOM_DIRECT:
   2583                stUART4.TX_READY = 0x01;
   2584                break;
   2585          
   2586                // 2.3.7. Optical Zoom Direct (0x13)
   2587             case TCM_OPTICAL_ZOOM_DIRECT:
   2588                u_Length = 0x08;
   2589                stUART4.TX_READY = 0x01;
   2590                break;
   2591          
   2592                // 2.3.8. Optical Zoom Start (0x14)
   2593             case TCM_OPTICAL_ZOOM_START:
   2594                stUART4.TX_READY = 0x01;
   2595                break;
   2596          
   2597                // 2.3.9. Save FOV (0x15)
   2598             case TCM_SAVE_FOV:
   2599                stUART4.TX_READY = 0x01;
   2600                break;
   2601          
   2602                // 2.3.10. Move FOV (0x16)
   2603             case TCM_MOVE_FOV:
   2604                u_Cmd = 0x18;
   2605                stUART4.TX_READY = 0x01;
   2606                break;
   2607          
   2608                // 2.3.10.1 Focus Stop Sub (0x17)
   2609             case TCM_FOCUS_STOP_SUB:
   2610                u_Cmd = 0xA2;
   2611                stUART4.TX_READY = 0x01;
   2612                break;
   2613          
   2614                // 2.3.13. Focus Start (0x18)
   2615             case TCM_FOCUS_START:
   2616                stUART4.TX_READY = 0x01;
   2617                break;
   2618          
   2619                // IP  PTZ Convert Data
   2620             case CVT_AF_EXCUTE:
   2621                u_Cmd = TCM_AF_EXECUTE;
   2622                stUART4.TX_READY = 0x01;
   2623                break;
   2624          
   2625                // 2.3.14. Integral Time Set (0x1A)
   2626             case TCM_INTEGRAL_TIME_SET:
   2627                stUART4.TX_READY = 0x01;
   2628                break;
   2629          
   2630                // 2.3.15. Digital Zoom Enable Set (0x1C)
   2631             case TCM_DIGITAL_ZOOM_ENABLE_SET:
   2632                stUART4.TX_READY = 0x01;
   2633                break;
   2634          
   2635                // 2.3.29. Total Zoom Start (0x20)
   2636             case TCM_TOTAL_ZOOM_START:
   2637                u_Data2 = 0x07;
   2638                stUART4.TX_READY = 0x01;
   2639                break;
   2640          
   2641                // 2.3.16. AGC Type Set (GAIN, OFFSET) (0x21)
   2642             case TCM_AGC_TYPE_SET:
   2643                u_Length = 0x08;
   2644                stUART4.TX_READY = 0x01;
   2645                break;
   2646          
   2647                // 2.3.28. Total Zoom Direct (0x22)
   2648             case TCM_TOTAL_ZOOM_DIRECT:
   2649                stUART4.TX_READY = 0x01;
   2650                break;
   2651          
   2652                // 2.3.28.1. Total Zoom Stop Sub (0x23)
   2653             case TCM_TOTAL_ZOOM_STOP_SUB:
   2654                stUART4.TX_READY = 0x01;
   2655                break;
   2656          
   2657                // 2.3.17. AGC Mode Set (0x26)
   2658             case TCM_AGC_MODE_SET:
   2659          
   2660                switch (u_Port)
   2661                {
   2662                case SYSTEM_INDEX:
   2663                   stUART4.TX_READY = 0x01;
   2664                   break;
   2665          
   2666                case USART1_INDEX:
   2667                   stUART4.TX_READY = 0x01;
   2668                   break;
   2669          
   2670                case USART5_INDEX:
   2671          
   2672                   switch (u_Data1)
   2673                   {
   2674                   case 0x00:
   2675                      Send_TCM_Data(TCM_AGC_TYPE_SET, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, TCM_COMMAND_TIMER_DELAY);
   2676                      stTCM.AGC_TYPE_SET = 0x00;
   2677                      break;
   2678          
   2679                   case 0x01:
   2680                      if (stTCM.AGC_TYPE_SET == 0x00)
   2681                         Send_TCM_Data(TCM_AGC_TYPE_SET, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, TCM_COMMAND_TIMER_DELAY);
   2682                      Send_TCM_Data(TCM_AGC_MODE_SET, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, TCM_COMMAND_TIMER_DELAY);
   2683                      stTCM.AGC_TYPE_SET = 0x01;
   2684                      break;
   2685          
   2686                   case 0x02:
   2687                      if (stTCM.AGC_TYPE_SET == 0x00)
   2688                         Send_TCM_Data(TCM_AGC_TYPE_SET, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, TCM_COMMAND_TIMER_DELAY);
   2689                      Send_TCM_Data(TCM_AGC_MODE_SET, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, TCM_COMMAND_TIMER_DELAY);
   2690                      stTCM.AGC_TYPE_SET = 0x02;
   2691                      break;
   2692          
   2693                   default:
   2694                      break;
   2695                   }
   2696          
   2697                   break;
   2698                }
   2699          
   2700                break;
   2701          
   2702                // 2.3.18. Color Mode Set (0x27)
   2703             case TCM_COLOR_MODE_SET:
   2704                stUART4.TX_READY = 0x01;
   2705                break;
   2706          
   2707                // 2.3.19. AGC Center Position Set (0x29)
   2708             case TCM_AGC_CENTER_POSITION_SET:
   2709                stUART4.TX_READY = 0x01;
   2710                break;
   2711          
   2712                // 2.3.20. AGC Limit Level Set (0x2A)
   2713             case TCM_AGC_LIMIT_LEVEL_SET:
   2714                stUART4.TX_READY = 0x01;
   2715                break;
   2716          
   2717                // 2.3.21. AGC ROI (Region of Interest) Set (0x2B)
   2718             case TCM_AGC_ROI_SET:
   2719                stUART4.TX_READY = 0x01;
   2720                break;
   2721          
   2722                // 2.3.22. MIDE Level Set (0x2C)
   2723             case TCM_MIDE_LEVEL_SET:
   2724                stUART4.TX_READY = 0x01;
   2725                break;
   2726          
   2727                // 2.3.23. SHARPNESS Level Set (0x2D)
   2728             case TCM_SHARPNESS_LEVEL_SET:
   2729                stUART4.TX_READY = 0x01;
   2730                break;
   2731          
   2732                // 2.3.24. AF ROI (Region of Interest) Set (0x2E)
   2733             case TCM_AF_ROI_SET:
   2734                stUART4.TX_READY = 0x01;
   2735                break;
   2736          
   2737                // 2.3.25. AF Mark Set (0x2F)
   2738             case TCM_AF_MARK_SET:
   2739                stUART4.TX_READY = 0x01;
   2740                break;
   2741          
   2742                // 2.3.26. AGC Smooth (0x31)
   2743             case TCM_AGC_SMOOTH:
   2744                stUART4.TX_READY = 0x01;
   2745                break;
   2746          
   2747                // 2.3.27. AF Execute (0x32)
   2748             case TCM_AF_EXECUTE:
   2749                stUART4.TX_READY = 0x01;
   2750                break;
   2751          
   2752                // 2.3.11. Save FOV EX (0x35)
   2753             case TCM_SAVE_FOV_EX:
   2754                stUART4.TX_READY = 0x01;
   2755                break;
   2756          
   2757                // 2.3.12. Move FOV EX (0x36)
   2758             case TCM_MOVE_FOV_EX:
   2759                stUART4.TX_READY = 0x01;
   2760                break;
   2761          
   2762                // 2.3.30. Calibration Shutter Use (0x40)
   2763             case TCM_CALIBRATION_SHUTTER_USE:
   2764                stUART4.TX_READY = 0x01;
   2765                break;
   2766          
   2767                // 2.3.31. Shutter Set (0x41)
   2768             case TCM_SHUTTER_SET:
   2769                stUART4.TX_READY = 0x01;
   2770                break;
   2771          
   2772                // 2.3.32. AF Mode Set (0x42)
   2773             case TCM_AF_MODE_SET:
   2774                stUART4.TX_READY = 0x01;
   2775                break;
   2776          
   2777                // 2.3.33. Mirror/Flip Mode (0x43)
   2778             case TCM_MIRROR_FLIP_MODE:
   2779          
   2780                // P3 : Status Enable : TCM .
   2781                u_Data3 = 0x00;
   2782          
   2783                stUART4.TX_READY = 0x01;
   2784                break;
   2785          
   2786                // 2.3.34. Mirror Mode Set (0x44)
   2787             case TCM_MIRROR_MODE_SET:
   2788                stUART4.TX_READY = 0x01;
   2789                break;
   2790          
   2791                // 2.3.35. Flip Mode Set (0x45)
   2792             case TCM_FLIP_MODE_SET:
   2793                stUART4.TX_READY = 0x01;
   2794                break;
   2795          
   2796                // 2.3.36. Image Freeze Set (0x46)
   2797             case TCM_IMAGE_FREEZE_SET:
   2798                stUART4.TX_READY = 0x01;
   2799                break;
   2800          
   2801                // 2.3.37. Image Color Inverse (White/Black Hot) Set (0x47)
   2802             case TCM_IMAGE_COLOR_INVERSE:
   2803                stUART4.TX_READY = 0x01;
   2804                break;
   2805          
   2806                // 2.3.38. External Communication Option Set (0x55)
   2807             case TCM_EXTERNAL_COMMUNICATION_OPTION:
   2808                stUART4.TX_READY = 0x01;
   2809                break;
   2810          
   2811                // 2.3.39. Calibration Execute (0x65)
   2812             case TCM_CALIBRATION_EXECUTE:
   2813                stUART4.TX_READY = 0x01;
   2814                break;
   2815          
   2816                // 2.3.40. Calibration Option Set (0x66)
   2817             case TCM_CALIBRATION_OPTION_SET:
   2818                stUART4.TX_READY = 0x01;
   2819                break;
   2820          
   2821                // 2.3.41. Video Mode Set (0x79)
   2822             case TCM_VIDEO_MODE_SET:
   2823                stUART4.TX_READY = 0x01;
   2824                break;
   2825          
   2826                // 2.3.42. OSD MENU Key Control (0xA0)
   2827             case TCM_OSD_MENU_KEY_CONTROL:
   2828                stUART4.TX_READY = 0x01;
   2829                break;
   2830          
   2831                // 2.3.43. ZOOM Stop (0xA1)
   2832             case TCM_ZOOM_STOP:
   2833                stUART4.TX_READY = 0x01;
   2834                break;
   2835          
   2836                // 2.3.44. FOCUS Stop (0xA2)
   2837             case TCM_FOCUS_STOP:
   2838                stUART4.TX_READY = 0x01;
   2839                break;
   2840          
   2841                // 2.3.45. ZOOM Direct (0xA3)
   2842             case TCM_ZOOM_DIRECT:
   2843                stUART4.TX_READY = 0x01;
   2844                break;
   2845          
   2846                // 2.3.46. FOCUS Direct (0xA4)
   2847             case TCM_FOCUS_DIRECT:
   2848                stUART4.TX_READY = 0x01;
   2849                break;
   2850          
   2851                // 2.3.47. OSD Information Print (0xA5)
   2852             case TCM_OSD_INFORMATION_PRINT:
   2853                stUART4.TX_READY = 0x01;
   2854                break;
   2855          
   2856                // 2.3.48. Zoom Focus Speed Set (0xA6)
   2857             case TCM_ZOOM_FOCUS_SPEED_SET:
   2858                stUART4.TX_READY = 0x01;
   2859                break;
   2860          
   2861                // 2.3.49. FOV All Initialize (0xA7)
   2862             case TCM_FOV_ALL_INITIALIZE:
   2863                stUART4.TX_READY = 0x01;
   2864                break;
   2865          
   2866                // 2.3.50. EEPROM Save (0xA8)
   2867             case TCM_EEPROM_SAVE:
   2868                stUART4.TX_READY = 0x01;
   2869                break;
   2870          
   2871                // 2.3.51. NUC Execute (0xF1)
   2872             case TCM_NUC_EXECUTE:
   2873                stUART4.TX_READY = 0x01;
   2874                break;
   2875          
   2876                // 2.3.52. Spot for BPR Set (0xF2)
   2877             case TCM_SPOT_FOR_BPR_SET:
   2878                stUART4.TX_READY = 0x01;
   2879                break;
   2880          
   2881                // 2.3.53. Move Spot (0xF3)
   2882             case TCM_MOVE_SPOT:
   2883                stUART4.TX_READY = 0x01;
   2884                break;
   2885          
   2886                // 2.3.54. Active BPR (0xF4)
   2887             case TCM_ACTIVE_BPR:
   2888                stUART4.TX_READY = 0x01;
   2889                break;
   2890          
   2891                // 2.3.55. Active BPR (0x95)
   2892             case TCM_SET_FRAME_RATE:
   2893                stUART4.TX_READY = 0x01;
   2894                break;
   2895          
   2896                // 2.3.56. Set Integral Time (0x96)
   2897             case TCM_SET_INTEGRAL_TIME:
   2898                stUART4.TX_READY = 0x01;
   2899                break;
   2900          
   2901                // 2.3.57. Operation Parameter Save (0x98)
   2902             case TCM_OPERATION_PARAMETER_SAVE:
   2903                stUART4.TX_READY = 0x01;
   2904                break;
   2905          
   2906             case TCM_DNR_MODE_SET:
   2907                stUART4.TX_READY = 0x01;
   2908                break;
   2909          
   2910             case TCM_DIS_MODE_SET:
   2911                stUART4.TX_READY = 0x01;
   2912                break;
   2913          
   2914                // 2.3.I.1. Module Status Inquiry (0x30)
   2915             case TCM_MODULE_STATUS_INQ:
   2916                stUART4.TX_READY = 0x01;
   2917                stUART4.TX_REQUEST = 0x01;
   2918                break;
   2919          
   2920                // 2.3.I.2. Camera Information Inquiry (0x80)
   2921             case TCM_CAMERA_INFORMATION_INQ:
   2922                stUART4.TX_READY = 0x01;
   2923                stUART4.TX_REQUEST = 0x01;
   2924                break;
   2925          
   2926                // 2.3.I.3. Digital Zoom Position Inquiry (0x82)
   2927             case TCM_DIGITAL_ZOOM_POSITION_INQ:
   2928                stUART4.TX_READY = 0x01;
   2929                stUART4.TX_REQUEST = 0x01;
   2930                break;
   2931          
   2932                // 2.3.I.4. AGC Mode Inquiry (0xB0)
   2933             case TCM_AGC_MODE_INQ:
   2934                stUART4.TX_READY = 0x01;
   2935                stUART4.TX_REQUEST = 0x01;
   2936                break;
   2937          
   2938                // 2.3.I.5. CONTRAST/BRIGHTNESS Level Inquiry (0xB1)
   2939             case TCM_CON_BRI_LEVEL_INQ:
   2940                stUART4.TX_READY = 0x01;
   2941                stUART4.TX_REQUEST = 0x01;
   2942                break;
   2943          
   2944                // 2.3.I.6. AGC Limit Level Inquiry (0xB2)
   2945             case TCM_AGC_LIMIT_LEVEL_INQ:
   2946                stUART4.TX_READY = 0x01;
   2947                stUART4.TX_REQUEST = 0x01;
   2948                break;
   2949          
   2950                // 2.3.I.7. AGC Center Position Inquiry (0xB3)
   2951             case TCM_AGC_CENTER_POSITION_INQ:
   2952                stUART4.TX_READY = 0x01;
   2953                stUART4.TX_REQUEST = 0x01;
   2954                break;
   2955          
   2956                // 2.3.I.8. MIDE Level Inquiry (0xB4)
   2957             case TCM_MIDE_LEVEL_INQ:
   2958                stUART4.TX_READY = 0x01;
   2959                stUART4.TX_REQUEST = 0x01;
   2960                break;
   2961          
   2962                // 2.3.I.9. SHARPNESS Level Inquiry (0xB5)
   2963             case TCM_SHARPNESS_LEVEL_INQ:
   2964                stUART4.TX_READY = 0x01;
   2965                stUART4.TX_REQUEST = 0x01;
   2966                break;
   2967          
   2968                // 2.3.I.10. Color Mode Inquiry (0xB6)
   2969             case TCM_COLOR_MODE_INQ:
   2970                stUART4.TX_READY = 0x01;
   2971                stUART4.TX_REQUEST = 0x01;
   2972                break;
   2973          
   2974                // 2.3.I.11. Mirror Mode Inquiry (0xB7)
   2975             case TCM_MIRROR_MODE_INQ:
   2976                stUART4.TX_READY = 0x01;
   2977                stUART4.TX_REQUEST = 0x01;
   2978                break;
   2979          
   2980                // 2.3.I.12. Flip Mode Inquiry (0xB8)
   2981             case TCM_FLIP_MODE_INQ:
   2982                stUART4.TX_READY = 0x01;
   2983                stUART4.TX_REQUEST = 0x01;
   2984                break;
   2985          
   2986                // 2.3.I.13. Image Freeze Inquiry (0xB9)
   2987             case TCM_IMAGE_FREEZE_INQ:
   2988                stUART4.TX_READY = 0x01;
   2989                stUART4.TX_REQUEST = 0x01;
   2990                break;
   2991          
   2992                // 2.3.I.14. Image Color Inverse (White/Black Hot) Inquiry (0xBA)
   2993             case TCM_IMAGE_COLOR_INVERSE_INQ:
   2994                stUART4.TX_READY = 0x01;
   2995                stUART4.TX_REQUEST = 0x01;
   2996                break;
   2997          
   2998                // 2.3.I.15. Digital Zoom Set Inquiry (0xBB)
   2999             case TCM_DIGITAL_ZOOM_SET_INQ:
   3000                stUART4.TX_READY = 0x01;
   3001                stUART4.TX_REQUEST = 0x01;
   3002                break;
   3003          
   3004                // 2.3.I.16. Video Mode Inquiry (0xBC)
   3005             case TCM_VIDEO_MODE_INQ:
   3006                stUART4.TX_READY = 0x01;
   3007                stUART4.TX_REQUEST = 0x01;
   3008                break;
   3009          
   3010                // 2.3.I.17. Calibration Option Inquiry (0xBD)
   3011             case TCM_CALIBRATION_OPTION_INQ:
   3012                stUART4.TX_READY = 0x01;
   3013                stUART4.TX_REQUEST = 0x01;
   3014                break;
   3015          
   3016                // 2.3.I.18. External Communication Option Inquiry (0xBE)
   3017             case TCM_EXTERNAL_COMMUNICATION_INQ:
   3018                stUART4.TX_READY = 0x01;
   3019                stUART4.TX_REQUEST = 0x01;
   3020                break;
   3021          
   3022                // 2.3.I.19. Focus Position Inquiry (0xBF)
   3023             case TCM_FOCUS_POSITION_INQ:
   3024                stUART4.TX_READY = 0x01;
   3025                stUART4.TX_REQUEST = 0x01;
   3026                break;
   3027          
   3028          
   3029                // 2.3.I.20. Integral Time Inquiry (0xC0)
   3030             case TCM_INTEGRAL_TIME_INQ:
   3031                stUART4.TX_READY = 0x01;
   3032                stUART4.TX_REQUEST = 0x01;
   3033                break;
   3034          
   3035                // 2.3.I.21. AF ROI (Region of Interest) Inquiry (0xC1)
   3036             case TCM_AF_ROI_INQ:
   3037                stUART4.TX_READY = 0x01;
   3038                stUART4.TX_REQUEST = 0x01;
   3039                break;
   3040          
   3041                // 2.3.I.22. AGC Type Inquiry (GAIN, OFFSET) (0xC2)
   3042             case TCM_AGC_TYPE_INQ:
   3043                stUART4.TX_READY = 0x01;
   3044                stUART4.TX_REQUEST = 0x01;
   3045                break;
   3046          
   3047                // 2.3.I.23. AGC Smooth Inquiry (0xC3)
   3048             case TCM_AGC_SMOOTH_INQ:
   3049                stUART4.TX_READY = 0x01;
   3050                stUART4.TX_REQUEST = 0x01;
   3051                break;
   3052          
   3053                // 2.3.I.24. Optical Zoom & Focus Position Inquiry (0xC4)
   3054             case TCM_OPTICAL_ZOOM_FOCUS_POS_INQ:
   3055                stUART4.TX_READY = 0x01;
   3056                stUART4.TX_REQUEST = 0x01;
   3057                break;
   3058          
   3059                // 2.3.I.25. Zoom & Focus Speed Inquiry (0xC5)
   3060             case TCM_ZOOM_FOCUS_SPEED_INQ:
   3061                stUART4.TX_READY = 0x01;
   3062                stUART4.TX_REQUEST = 0x01;
   3063                break;
   3064          
   3065                // 2.3.I.26. AF Mark Inquiry (0xC6)
   3066             case TCM_AF_MARK_INQ:
   3067                stUART4.TX_READY = 0x01;
   3068                stUART4.TX_REQUEST = 0x01;
   3069                break;
   3070          
   3071                // 2.3.I.27. Shutter Set Inquiry (0xC7)
   3072             case TCM_SHUTTER_SET_INQ:
   3073                stUART4.TX_READY = 0x01;
   3074                stUART4.TX_REQUEST = 0x01;
   3075                break;
   3076          
   3077                // 2.3.I.28. AF Mode Inquiry (0xC8)
   3078             case TCM_AF_MODE_INQ:
   3079                stUART4.TX_READY = 0x01;
   3080                stUART4.TX_REQUEST = 0x01;
   3081                break;
   3082          
   3083                // 2.3.I.29. AGC ROI Inquiry (0xC9)
   3084             case TCM_AGC_ROI_INQ:
   3085                stUART4.TX_READY = 0x01;
   3086                stUART4.TX_REQUEST = 0x01;
   3087                break;
   3088          
   3089                // 2.3.I.30. Cooler Runtime Inquiry (0xCA)
   3090             case TCM_COOLER_RUNTIME_INQ:
   3091                stUART4.TX_READY = 0x01;
   3092                stUART4.TX_REQUEST = 0x01;
   3093                break;
   3094          
   3095                // 2.3.I.31. ZOOM POS Inquiry (0xCB)
   3096             case TCM_ZOOM_POS_INQ:
   3097                stUART4.TX_READY = 0x01;
   3098                stUART4.TX_REQUEST = 0x01;
   3099                break;
   3100          
   3101                // 2.3.I.32. Power Cycle Inquiry (0xCE)
   3102             case TCM_POWER_CYCLE_INQ:
   3103                stUART4.TX_READY = 0x01;
   3104                stUART4.TX_REQUEST = 0x01;
   3105                break;
   3106          
   3107                // 2.3.I.33. Get Temperature (0xD0)
   3108             case TCM_GET_TEMPERATURE_INQ:
   3109                stUART4.TX_READY = 0x01;
   3110                stUART4.TX_REQUEST = 0x01;
   3111                break;
   3112          
   3113                // 2.3.I.34. Shutter Use Calibration (0xD1)
   3114             case TCM_CALIBRATION_METHOD_INQ:
   3115                stUART4.TX_READY = 0x01;
   3116                stUART4.TX_REQUEST = 0x01;
   3117                break;
   3118          
   3119                // 2.3.I.35. LENS Information Inquiry (0xD2)
   3120             case TCM_LENS_INFORMATION_INQ:
   3121                stUART4.TX_READY = 0x01;
   3122                stUART4.TX_REQUEST = 0x01;
   3123                break;
   3124          
   3125                // 2.3.I.36.  Total Zoom Position Inquiry (0xD5)
   3126             case TCM_TOTAL_ZOOM_POSITION_INQ:
   3127                stUART4.TX_READY = 0x01;
   3128                stUART4.RX_REQUEST_CMD = TCM_TOTAL_ZOOM_POSITION_INQ;
   3129                break;
   3130          
   3131                // 2.3.I.37. MY ID Inquiry (0xF0)
   3132             case TCM_MY_ID_INQ:
   3133                stUART4.TX_READY = 0x01;
   3134                stUART4.TX_REQUEST = 0x01;
   3135                break;
   3136          
   3137                // 2.3.I.38. Get F/W Update (0xFA)
   3138             case TCM_GET_FW_UPDATE_INQ:
   3139                stUART4.TX_READY = 0x01;
   3140                stUART4.TX_REQUEST = 0x01;
   3141                break;
   3142          
   3143                // 2.3.I.38. Get FPGA Version (0xF8)
   3144             case TCM_GET_FPGA_VERSION:
   3145                stUART4.TX_READY = 0x01;
   3146                stUART4.TX_REQUEST = 0x01;
   3147                break;
   3148          
   3149                // Get ENGINE Version (0xF9)
   3150             case TCM_GET_ENGINE_VERSION:
   3151                stUART4.TX_READY = 0x01;
   3152                stUART4.TX_REQUEST = 0x01;
   3153                break;
   3154          
   3155             default:
   3156                stUART4.TX_READY = 0x01;
   3157                break;
   3158             }
   3159          
   3160             stUART4.TX_CMD = u_Cmd;
   3161             stUART4.TX_PARAMETER1 = u_Data1;
   3162             stUART4.TX_PARAMETER2 = u_Data2;
   3163             stUART4.TX_PARAMETER3 = u_Data3;
   3164             stUART4.TX_PARAMETER4 = u_Data4;
   3165             stUART4.TX_PARAMETER5 = u_Data5;
   3166             stUART4.TX_PARAMETER6 = u_Data6;
   3167             stUART4.TX_PARAMETER7 = u_Data7;
   3168             stUART4.TX_PARAMETER8 = u_Data8;
   3169             stUART4.TX_PARAMETER9 = u_Data9;
   3170          
   3171             // Send TSM Command & Data Trans
   3172             if (stUART4.TX_READY)
   3173             {
   3174                switch (u_Length)
   3175                {
   3176                case 0x06:
   3177                   Send_TCM_Data(u_Cmd, u_Data1, u_Data2, u_Data3, u_Data4, u_Data5, u_Data6, u_Data7, u_Data8, u_Data9, 0x06, TCM_COMMAND_TIMER_DELAY);
   3178                   break;
   3179          
   3180                case 0x08:
   3181                   Send_TCM_Data(u_Cmd, u_Data1, u_Data2, u_Data3, u_Data4, u_Data5, u_Data6, u_Data7, u_Data8, u_Data9, 0x08, TCM_COMMAND_TIMER_DELAY);
   3182                   break;
   3183          
   3184                case 0x0C:
   3185                   Send_TCM_Data(u_Cmd, u_Data1, u_Data2, u_Data3, u_Data4, u_Data5, u_Data6, u_Data7, u_Data8, u_Data9, 0x0C, TCM_COMMAND_TIMER_DELAY);
   3186                   break;
   3187                }
   3188          
   3189                if (stTSM.ZOOM_CHECK_FLAG == 0x01)
   3190                {
   3191                   stTSM.ZOOM_CHECK_FLAG = 0x00;
   3192                   stUART4.RX_REQUEST_CMD = TCM_TOTAL_ZOOM_POSITION_INQ;
   3193                   Send_TCM_Data(TCM_TOTAL_ZOOM_POSITION_INQ, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, TCM_COMMAND_TIMER_DELAY);
   3194                }
   3195          
   3196                if (stTSM.FOCUS_CHECK_FLAG == 0x01)
   3197                {
   3198                   stTSM.FOCUS_CHECK_FLAG = 0x00;
   3199                   stUART4.RX_REQUEST_CMD = TCM_FOCUS_POSITION_INQ;
   3200                   Send_TCM_Data(TCM_FOCUS_POSITION_INQ, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, TCM_COMMAND_TIMER_DELAY);
   3201                }
   3202          
   3203                if (!stUART4.TX_REQUEST)
   3204                   stUART4.TX_ACK = 0x01;
   3205          
   3206                stUART4.TX_READY = 0;
   3207          
   3208                //Send_Data_Clear(u_Leng);
   3209             }
   3210          
   3211             // Send Ack Trans
   3212             if (stUART4.TX_ACK)
   3213             {
   3214                //Send_UART4_Ack(0xB0, 0x03, 0x01, u_Comm, u_Response_Data, 5);
   3215          
   3216                stUART4.TX_ACK = 0;
   3217             }
   3218          }
   3219          
   3220          /***************************************************************************************************************************
   3221          * Function : PTZ_Data_Handing
   3222          * Protocol Version : 0.1 (2016.04.11)
   3223          * Data Architecture :
   3224          BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]		BYTE[..]		BYTE(n)[LENGTH+4]	BYTE(n+1)[LENGTH+4]
   3225          0xC0		0x0C		LENGTH		ADDR		COMM		DATA		...			CS					0xCF
   3226          ****************************************************************************************************************************/
   3227          void PTZ_Data_Handing(u8 u_Comm, u8 u_Leng)
   3228          {
   3229             u8 i = 0, i_Max = u_Leng + 5;
   3230          
   3231             switch (u_Comm)
   3232             {
   3233                // 3.10. Set Preset & Temperature Option (0x10)
   3234             case PTZ_SET_PRESET_TEMPERATURE_OPTION:
   3235          
   3236                stUSART1.TX_READY = 0x01;
   3237          
   3238                break;
   3239          
   3240                // 3.11. Set Preset Index & Name (0x11)
   3241             case PTZ_SET_PRESET_AND_INDEX_NAME:
   3242          
   3243                stUSART1.TX_READY = 0x01;
   3244          
   3245                break;
   3246          
   3247                // 3.F1. PTZ Remote Reset (0xF1)
   3248             case PTZ_REMOTE_RESET:
   3249          
   3250                stUSART1.TX_READY = 0x01;
   3251          
   3252                break;
   3253             }
   3254          
   3255          
   3256             // Send USART1 Command & Data Trans
   3257             if (stUSART1.TX_READY)
   3258             {
   3259                for (i = 0; i < i_Max; i++)
   3260                {
   3261                   stUSART1.TX_BUF[i] = stUART5.RX_BUF[i];
   3262                }
   3263          
   3264                stUSART1.TX_CNT = 0;
   3265                stUSART1.TX_MAX = i_Max;
   3266          
   3267                USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   3268                Delay_1ms(MAIN_COMMAND_TIMER_DELAY);
   3269          
   3270                stUSART1.TX_READY = 0x00;
   3271          
   3272             }
   3273          }
   3274          
   3275          /***************************************************************************************************************************
   3276          * Function : DATA_Request_Handing
   3277          * Protocol Version : 0.1 (2016.04.11)
   3278          * Data Architecture :
   3279          BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]		BYTE[..]		BYTE(n)[LENGTH+4]	BYTE(n+1)[LENGTH+4]
   3280          0xD0		0x0D		LENGTH		ADDR		COMM		DATA		...			CS					0xDF
   3281          ****************************************************************************************************************************/
   3282          void DATA_Request_Handing(u8 u_Comm, u8 u_Leng)
   3283          {}
   3284          
   3285          /***************************************************************************************************************************
   3286          * Function : OPTION_Data_Handing
   3287          * Protocol Version : 0.1 (2016.04.11)
   3288          * Data Architecture :
   3289          BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]		BYTE[..]		BYTE(n)[LENGTH+4]	BYTE(n+1)[LENGTH+4]
   3290          0xE0		0x0E		LENGTH		ADDR		COMM		DATA		...			CS					0xEF
   3291          ****************************************************************************************************************************/
   3292          void OPTION_Data_Handing(u8 u_Port, u8 u_Comm, u8 u_Leng)
   3293          {
   3294             u8 i = 0, i_Max = u_Leng + 5;
   3295          
   3296             u8 u_Cmd = 0x00;	// Camera Command
   3297             u8 u_Data1 = 0x00, u_Data2 = 0x00, u_Data3 = 0x00, u_Data4 = 0x00, u_Data5 = 0x00;
   3298             u8 u_Response_Data = 0x00;
   3299          
   3300             u8 u8_Convert_Data[10];
   3301             u16 u16_Convert_Data = 0x0000;
   3302          
   3303             switch (u_Port)
   3304             {
   3305             case SYSTEM_INDEX:
   3306          
   3307                u_Cmd = stSYS.RX_BUF[0][5];
   3308                u_Data1 = stSYS.RX_BUF[0][6];
   3309                u_Data2 = stSYS.RX_BUF[0][7];
   3310                u_Data3 = stSYS.RX_BUF[0][8];
   3311          
   3312                break;
   3313          
   3314             case USART1_INDEX:
   3315          
   3316                u_Cmd = stUSART1.RX_BUF[4];
   3317                u_Data1 = stUSART1.RX_BUF[5];
   3318                u_Data2 = stUSART1.RX_BUF[6];
   3319                u_Data3 = stUSART1.RX_BUF[7];
   3320          
   3321                break;
   3322          
   3323             case USART5_INDEX:
   3324          
   3325                u_Cmd = stUART5.RX_BUF[4];
   3326                u_Data1 = stUART5.RX_BUF[5];
   3327                u_Data2 = stUART5.RX_BUF[6];
   3328                u_Data3 = stUART5.RX_BUF[7];
   3329                u_Data4 = stUART5.RX_BUF[8];
   3330                u_Data5 = stUART5.RX_BUF[9];
   3331          
   3332                break;
   3333          
   3334             default:
   3335                break;
   3336             }
   3337          
   3338             switch (u_Comm)
   3339             {
   3340             case OPTION_SET_ETHERNET_INIT:
   3341          
   3342                stUSART1.TX_READY = 0x01;
   3343          
   3344                break;
   3345          
   3346             case OPTION_SET_WIPER:
   3347          
   3348                switch (stDIP.MODE2)
   3349                {
   3350                case 0x00:
   3351          
   3352                   if ((u_Data2 == 0x00) || (u_Data2 > 0x0F))
   3353                      break;
   3354          
   3355                   stWIPER2.OPTION = u_Data1;
   3356                   stWIPER2.COUNT = u_Data2;
   3357                   stWIPER2.DWELL_TIME = u_Data3;
   3358          
   3359                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_OPTION, stWIPER2.OPTION);
   3360                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_COUNT, stWIPER2.COUNT);
   3361                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_DWELL_TIME, stWIPER2.DWELL_TIME);
   3362          
   3363                   break;
   3364          
   3365                case 0x01:
   3366          
   3367                   if ((u_Data2 == 0x00) || (u_Data2 > 0x0F))
   3368                      break;
   3369          
   3370                   stWIPER2.OPTION = u_Data1;
   3371                   stWIPER2.COUNT = u_Data2;
   3372                   stWIPER2.DWELL_TIME = u_Data3;
   3373          
   3374                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_OPTION, u_Data1);
   3375                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_COUNT, u_Data2);
   3376                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_DWELL_TIME, u_Data3);
   3377          
   3378                   break;
   3379          
   3380                default:
   3381                   break;
   3382                }
   3383          
   3384          
   3385          
   3386                break;
   3387          
   3388             case OPTION_STOP_WIPER:
   3389          
   3390                switch (stDIP.MODE2)
   3391                {
   3392                case 0x00:
   3393          
   3394                   switch (u_Data1)
   3395                   {
   3396                   case 0x00:
   3397                      stWIPER2.STOP_MODE = WIPER_STOP_ORIGIN;
   3398                      break;
   3399          
   3400                   case 0x01:
   3401                      stWIPER2.STOP_MODE = WIPER_STOP_EMERGENCY;
   3402                      break;
   3403                   }
   3404          
   3405                   if (stWIPER2.DWELL_TIMER_FLAG)
   3406                      stWIPER2.DWELL_TIMER_FLAG = 0x00;
   3407                   if (stWIPER2.CONTINUOUS_FLAG == 0x01)
   3408                   {
   3409                      stWIPER2.CONTINUOUS_FLAG = 0x00;
   3410                   }
   3411          
   3412                   break;
   3413          
   3414                case 0x01:
   3415          
   3416                   stWIPER1.ACTIVE_COUNT = 0;
   3417                   stWIPER1.DWELL_TIME = 0;
   3418          
   3419                   break;
   3420          
   3421                default:
   3422                   break;
   3423                }
   3424          
   3425                break;
   3426          
   3427             case OPTION_RUN_WIPER:
   3428          
   3429                switch (stDIP.MODE2)
   3430                {
   3431                case 0x00:
   3432          
   3433                   stWIPER2.OPTION = u_Data1;
   3434          
   3435                   stWIPER2.COUNT = AT24C256C_EEPROM_Read(EEP_SET_WIPER_COUNT);
   3436                   stWIPER2.DWELL_TIME = AT24C256C_EEPROM_Read(EEP_SET_WIPER_DWELL_TIME);
   3437                   stWIPER2.SPRITE_TIME = AT24C256C_EEPROM_Read(EEP_SET_WASHER_SPRITE_TIME);
   3438                   stWIPER2.CONTINUOUS_TIME = AT24C256C_EEPROM_Read(EEP_SET_WIPER_CONTINUOUS_TIME);
   3439          
   3440                   switch (stWIPER2.OPTION)
   3441                   {
   3442                   case WIPER_NORMAL_MODE:
   3443          
   3444                      stWIPER2.COUNT = AT24C256C_EEPROM_Read(EEP_SET_WIPER_COUNT);
   3445                      if (stWIPER2.COUNT >= 0x0F)
   3446                         break;
   3447          
   3448                      stWIPER2.DWELL_TIME = AT24C256C_EEPROM_Read(EEP_SET_WIPER_DWELL_TIME);
   3449          
   3450                      stWIPER2.DWELL_TIME_DATA = stWIPER2.DWELL_TIME;
   3451                      stWIPER2.FLAG = 0x01;
   3452          
   3453                      stWIPER2.STOP_MODE = WIPER_STOP_READY;
   3454                      stWIPER2.STEP = WIPER_READY;
   3455          
   3456                      break;
   3457          
   3458                   case WIPER_SPRITE_MODE:
   3459                      break;
   3460          
   3461                   case WIPER_CONTINUOUS_MODE:
   3462          
   3463                      stWIPER2.COUNT = AT24C256C_EEPROM_Read(EEP_SET_WIPER_COUNT);
   3464                      if (stWIPER2.COUNT < 0x0F)
   3465                         break;
   3466          
   3467                      stWIPER2.DWELL_TIME = AT24C256C_EEPROM_Read(EEP_SET_WIPER_DWELL_TIME);
   3468          
   3469                      stWIPER2.DWELL_TIME_DATA = stWIPER2.DWELL_TIME;
   3470                      stWIPER2.FLAG = 0x01;
   3471          
   3472                      stWIPER2.STOP_MODE = WIPER_STOP_READY;
   3473                      stWIPER2.STEP = WIPER_READY;
   3474          
   3475                      if (stWIPER2.COUNT >= 0x0F)
   3476                      {
   3477                         stWIPER2.CONTINUOUS_FLAG = 0x01;
   3478                         stWIPER2.CONTINUOUS_ms = 0;
   3479                         stWIPER2.CONTINUOUS_s = 0;
   3480                      }
   3481          
   3482                      break;
   3483          
   3484                   default:
   3485                      break;
   3486                   }
   3487          
   3488                   break;
   3489          
   3490                case 0x01:
   3491          
   3492                   stWIPER1.ACTIVE_COUNT = AT24C256C_EEPROM_Read(EEP_SET_WIPER_COUNT);
   3493                   stWIPER1.DWELL_TIME = AT24C256C_EEPROM_Read(EEP_SET_WIPER_DWELL_TIME);
   3494          
   3495                   break;
   3496          
   3497                default:
   3498                   break;
   3499                }
   3500          
   3501          
   3502          
   3503                break;
   3504          
   3505                // 5.22. Set Wiper Option (0x22)
   3506             case OPTION_SET_WIPER_OPTION:
   3507          
   3508                if ((u_Data2 == 0x00) || (u_Data2 > 0x0F))
   3509                   break;
   3510          
   3511                stWIPER2.OPTION = u_Data1;
   3512                stWIPER2.COUNT = u_Data2;
   3513                stWIPER2.DWELL_TIME = u_Data3;
   3514                stWIPER2.SPRITE_TIME = u_Data4;
   3515                stWIPER2.CONTINUOUS_TIME = u_Data5;
   3516          
   3517                AT24C256C_EEPROM_Write(EEP_SET_WIPER_OPTION, stWIPER2.OPTION);
   3518                AT24C256C_EEPROM_Write(EEP_SET_WIPER_COUNT, stWIPER2.COUNT);
   3519                AT24C256C_EEPROM_Write(EEP_SET_WIPER_DWELL_TIME, stWIPER2.DWELL_TIME);
   3520                AT24C256C_EEPROM_Write(EEP_SET_WASHER_SPRITE_TIME, stWIPER2.SPRITE_TIME);
   3521          
   3522                if (stWIPER2.CONTINUOUS_TIME != 0xFF)
   3523                {
   3524                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_CONTINUOUS_TIME, stWIPER2.CONTINUOUS_TIME);
   3525                }
   3526          
   3527                break;
   3528          
   3529             default:
   3530                break;
   3531             }
   3532          
   3533             // Send USART1 Command & Data Trans
   3534             if (stUSART1.TX_READY)
   3535             {
   3536                for (i = 0; i < i_Max; i++)
   3537                {
   3538                   stUSART1.TX_BUF[i] = stUART5.RX_BUF[i];
   3539                }
   3540          
   3541                stUSART1.TX_CNT = 0;
   3542                stUSART1.TX_MAX = i_Max;
   3543          
   3544                USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   3545                Delay_1ms(MAIN_COMMAND_TIMER_DELAY);
   3546          
   3547                stUSART1.TX_READY = 0x00;
   3548          
   3549             }
   3550          }
   3551          
   3552          /****************************************************************************************************
   3553          * Define : PELCO_Data_Handing
   3554          * Protocol Version : 0.1 (2016.04.11)
   3555          * Data Architecture :
   3556          BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]		BYTE5[6]
   3557          0xFF			ADDR		COMM1		COMM2		DATA1		DATA2		CS		
   3558          *****************************************************************************************************/
   3559          void PELCO_Data_Handing(u8 u_Comm_High, u8 u_Comm_Low, u8 u_Data_High, u8 u_Data_Low)
   3560          {
   3561             u8 u_Cmd = 0x00, u_Data1 = 0x00, u_Data2 = 0x00, u_Data3 = 0x00;
   3562             u8 u_MCmd = 0x00, u_MData1 = 0x00, u_MData2 = 0x00, u_MData3 = 0x00;
   3563             u16 u_Pelco_Comm = 0x0000;
   3564          
   3565             u_Pelco_Comm = (u_Comm_High << 8) | u_Comm_Low;
   3566             u_Data1 = u_Data_High;
   3567             u_Data2 = u_Data_Low;
   3568          
   3569             switch (u_Pelco_Comm)
   3570             {
   3571                // Move Stop Command
   3572             case PELCO_MOVE_STOP:
   3573          
   3574                stUSART1.TX_READY = 0x01;
   3575          
   3576                switch (stINFO.MODULE_TYPE)
   3577                {
   3578                case SONY_MODULE:
   3579          
   3580                   if (stSONY.ZOOM_STATUS == ACTIVE)
   3581                   {
   3582                      u_MCmd = SONY_MANUAL_ZOOM;
   3583          
   3584                      stSONY.ZOOM_STATUS = STOP;
   3585                      stSONY.ZOOM_CHECK_FLAG = 0x01;
   3586                   }
   3587          
   3588                   if (stSONY.FOCUS_STATUS == ACTIVE)
   3589                   {
   3590                      u_MCmd = SONY_MANUAL_FOCUS;
   3591          
   3592                      stSONY.FOCUS_STATUS = STOP;
   3593                      stSONY.FOCUS_CHECK_FLAG = 0x01;
   3594                   }
   3595          
   3596          
   3597                   break;
   3598          
   3599                case TSM_MODULE:
   3600          
   3601                   if (stTSM.ZOOM_STATUS == ACTIVE)
   3602                   {
   3603                      u_MCmd = TCM_TOTAL_ZOOM_STOP_SUB;
   3604          
   3605                      stTSM.ZOOM_STATUS = STOP;
   3606                      stTSM.ZOOM_CHECK_FLAG = 0x01;
   3607                   }
   3608          
   3609                   if (stTSM.FOCUS_STATUS == ACTIVE)
   3610                   {
   3611                      u_MCmd = TCM_FOCUS_STOP_SUB;
   3612          
   3613                      stTSM.FOCUS_STATUS = STOP;
   3614                      stTSM.FOCUS_CHECK_FLAG = 0x01;
   3615                   }
   3616          
   3617                   break;
   3618          
   3619                default:
   3620                   break;
   3621          
   3622                }
   3623          
   3624                stUART4.TX_READY = 0x01;
   3625          
   3626                break;
   3627          
   3628                // Move Right Command
   3629             case PELCO_MOVE_RIGHT:
   3630                stUSART1.TX_READY = 0x01;
   3631                break;
   3632          
   3633                // Move Left Command
   3634             case PELCO_MOVE_LEFT:
   3635                stUSART1.TX_READY = 0x01;
   3636                break;
   3637          
   3638                // Move Up Command
   3639             case PELCO_MOVE_UP:
   3640                stUSART1.TX_READY = 0x01;
   3641                break;
   3642          
   3643                // Move Down Command
   3644             case PELCO_MOVE_DOWN:
   3645                stUSART1.TX_READY = 0x01;
   3646                break;
   3647          
   3648                // Move Right-Up Command
   3649             case PELCO_MOVE_RIGHT_UP:
   3650                stUSART1.TX_READY = 0x01;
   3651                break;
   3652          
   3653                // Move Left-Up Command
   3654             case PELCO_MOVE_LEFT_UP:
   3655                stUSART1.TX_READY = 0x01;
   3656                break;
   3657          
   3658                // Move Right-Down Command
   3659             case PELCO_MOVE_RIGHT_DOWN:
   3660                stUSART1.TX_READY = 0x01;
   3661                break;
   3662          
   3663                // Move Left-Down Command
   3664             case PELCO_MOVE_LEFT_DOWN:
   3665                stUSART1.TX_READY = 0x01;
   3666                break;
   3667          
   3668                // Zoom-Tele Command
   3669             case PELCO_ZOOM_TELE:
   3670          
   3671                switch (stINFO.MODULE_TYPE)
   3672                {
   3673                case SONY_MODULE:
   3674          
   3675                   u_MCmd = SONY_MANUAL_ZOOM;
   3676                   u_MData1 = 0x27;
   3677          
   3678                   stSONY.ZOOM_STATUS = ACTIVE;
   3679          
   3680                   break;
   3681          
   3682                case TSM_MODULE:
   3683          
   3684                   u_MCmd = TCM_TOTAL_ZOOM_START;
   3685                   u_MData1 = 0x00;
   3686                   u_MData2 = 0x09;
   3687          
   3688                   stTSM.ZOOM_STATUS = ACTIVE;
   3689          
   3690                   break;
   3691          
   3692                default:
   3693                   break;
   3694                }
   3695          
   3696                stUART4.TX_READY = 0x01;
   3697          
   3698                break;
   3699          
   3700                // Zoom-Wide Command
   3701             case PELCO_ZOOM_WIDE:
   3702          
   3703                switch (stINFO.MODULE_TYPE)
   3704                {
   3705                case SONY_MODULE:
   3706          
   3707                   u_MCmd = SONY_MANUAL_ZOOM;
   3708                   u_MData1 = 0x37;
   3709          
   3710                   stSONY.ZOOM_STATUS = ACTIVE;
   3711          
   3712                   break;
   3713          
   3714                case TSM_MODULE:
   3715          
   3716                   u_MCmd = TCM_TOTAL_ZOOM_START;
   3717                   u_MData1 = 0x01;
   3718                   u_MData2 = 0x09;
   3719          
   3720                   stTSM.ZOOM_STATUS = ACTIVE;
   3721          
   3722                   break;
   3723          
   3724                default:
   3725                   break;
   3726                }
   3727          
   3728                stUART4.TX_READY = 0x01;
   3729          
   3730                break;
   3731          
   3732                // Focus-Far Command
   3733             case PELCO_FOCUS_FAR:
   3734          
   3735                switch (stINFO.MODULE_TYPE)
   3736                {
   3737                case SONY_MODULE:
   3738          
   3739                   u_MCmd = SONY_MANUAL_FOCUS;
   3740                   u_MData1 = 0x24;
   3741          
   3742                   stSONY.FOCUS_STATUS = ACTIVE;
   3743          
   3744                   break;
   3745          
   3746                case TSM_MODULE:
   3747          
   3748                   u_MCmd = TSM_FOCUS_START;
   3749                   u_MData1 = 0x00;
   3750                   u_MData2 = 0x03;
   3751          
   3752                   stTSM.FOCUS_STATUS = ACTIVE;
   3753          
   3754                   break;
   3755          
   3756                default:
   3757                   break;
   3758                }
   3759          
   3760                stUART4.TX_READY = 0x01;
   3761          
   3762                break;
   3763          
   3764                // Focus-Near Command
   3765             case PELCO_FOCUS_NEAR:
   3766          
   3767                switch (stINFO.MODULE_TYPE)
   3768                {
   3769                case SONY_MODULE:
   3770          
   3771                   u_MCmd = SONY_MANUAL_FOCUS;
   3772                   u_MData1 = 0x34;
   3773          
   3774                   stSONY.FOCUS_STATUS = ACTIVE;
   3775          
   3776                   break;
   3777          
   3778                case TSM_MODULE:
   3779          
   3780                   u_MCmd = TSM_FOCUS_START;
   3781                   u_MData1 = 0x01;
   3782                   u_MData2 = 0x03;
   3783          
   3784                   stTSM.FOCUS_STATUS = ACTIVE;
   3785          
   3786                   break;
   3787          
   3788                default:
   3789                   break;
   3790                }
   3791          
   3792                stUART4.TX_READY = 0x01;
   3793          
   3794                break;
   3795          
   3796                // 5.2. Set Preset (0x03)
   3797             case PELCO_SET_PRESET:
   3798                stUSART1.TX_READY = 0x01;
   3799                break;
   3800          
   3801                // 5.3. Clear Preset (0x05)
   3802             case PELCO_CLEAR_PRESET:
   3803                stUSART1.TX_READY = 0x01;
   3804                break;
   3805          
   3806                // 5.4. Call Preset (0x07)
   3807             case PELCO_CALL_PRESET:
   3808                stUSART1.TX_READY = 0x01;
   3809                break;
   3810          
   3811                // 5.5. Set Zone(Scan) Start (0x11)
   3812             case PELCO_SET_ZONE_START:
   3813                stUSART1.TX_READY = 0x01;
   3814                break;
   3815          
   3816                // 5.6. Set Zone(Scan) End (0x13)
   3817             case PELCO_SET_ZONE_END:
   3818                stUSART1.TX_READY = 0x01;
   3819                break;
   3820          
   3821                // 5.7. Zone(Scan) On (0x1B)
   3822             case PELCO_ZONE_ON:
   3823                stUSART1.TX_READY = 0x01;
   3824                break;
   3825          
   3826                // 5.8. Zone(Scan) Off (0x1D)
   3827             case PELCO_ZONE_OFF:
   3828                stUSART1.TX_READY = 0x01;
   3829                break;
   3830          
   3831                // 5.12. Set Zero Position (0x49)
   3832             case PELCO_SET_ZERO:
   3833                stUSART1.TX_READY = 0x01;
   3834                break;
   3835             }
   3836          
   3837             // Send TSM Command & Data Trans
   3838             if (stUART4.TX_READY)
   3839             {
   3840                stUART4.TX_CMD = u_MCmd;
   3841                stUART4.TX_PARAMETER1 = u_MData1;
   3842                stUART4.TX_PARAMETER2 = u_MData2;
   3843                stUART4.TX_PARAMETER3 = u_MData3;
   3844          
   3845                switch (stINFO.MODULE_TYPE)
   3846                {
   3847                case SONY_MODULE:
   3848          
   3849                   Send_Sony_Data(u_MCmd, u_MData1, u_MData2, 0x06, SONY_COMMAND_TIMER_DELAY);
   3850          
   3851                   if (stSONY.ZOOM_CHECK_FLAG == 0x01)
   3852                   {
   3853                      stSONY.ZOOM_CHECK_FLAG = 0x00;
   3854                      stUART4.RX_REQUEST_CMD = SONY_CALL_ZOOM_POSITION;
   3855                      Send_Sony_Data(SONY_CALL_ZOOM_POSITION, 0x00, 0x00, 0x05, SONY_COMMAND_TIMER_DELAY);
   3856                   }
   3857          
   3858                   if (stSONY.FOCUS_CHECK_FLAG == 0x01)
   3859                   {
   3860                      stSONY.FOCUS_CHECK_FLAG = 0x00;
   3861                      stUART4.RX_REQUEST_CMD = SONY_CALL_FOCUS_POSITION;
   3862                      Send_Sony_Data(SONY_CALL_FOCUS_POSITION, 0x00, 0x00, 0x05, SONY_COMMAND_TIMER_DELAY);
   3863                   }
   3864          
   3865                   break;
   3866          
   3867                case TSM_MODULE:
   3868          
   3869                   Send_TSM_Data(u_MCmd, u_MData1, u_MData2, u_MData3, 0x06, TSM_COMMAND_TIMER_DELAY);
   3870          
   3871                   if (stTSM.ZOOM_CHECK_FLAG == 0x01)
   3872                   {
   3873                      stTSM.ZOOM_CHECK_FLAG = 0x00;
   3874                      stUART4.RX_REQUEST_CMD = TSM_CALL_TOTAL_ZOOM_POSITION;
   3875                      Send_TSM_Data(TSM_CALL_TOTAL_ZOOM_POSITION, 0x00, 0x00, 0x00, 0x06, TSM_COMMAND_TIMER_DELAY);
   3876                   }
   3877          
   3878                   if (stTSM.FOCUS_CHECK_FLAG == 0x01)
   3879                   {
   3880                      stTSM.FOCUS_CHECK_FLAG = 0x00;
   3881                      stUART4.RX_REQUEST_CMD = TSM_CALL_FOCUS_POSITION;
   3882                      Send_TSM_Data(TSM_CALL_FOCUS_POSITION, 0x00, 0x00, 0x00, 0x06, TSM_COMMAND_TIMER_DELAY);
   3883                   }
   3884          
   3885                   break;
   3886          
   3887                default:
   3888                   stUSART1.TX_READY = 0x01;
   3889                   break;
   3890                }
   3891          
   3892                stUART4.TX_READY = 0;
   3893          
   3894                //Send_Data_Clear(u_Leng);
   3895             }
   3896          
   3897             // Send USART1 Command & Data Trans
   3898             if (stUSART1.TX_READY)
   3899             {
   3900                stUSART1.TX_CMD = u_Cmd;
   3901                stUSART1.TX_PARAMETER1 = u_Data1;
   3902                stUSART1.TX_PARAMETER2 = u_Data2;
   3903          
   3904                Send_Pelco_Data(u_Comm_High, u_Comm_Low, u_Data1, u_Data2, 0x07, MAIN_COMMAND_TIMER_DELAY);
   3905          
   3906                if (!stUSART1.TX_REQUEST)
   3907                   stUSART1.TX_ACK = 0x01;
   3908          
   3909                stUSART1.TX_READY = 0x00;
   3910          
   3911                //Send_Data_Clear(u_Leng);
   3912             }
   3913          
   3914          }
   3915          
   3916          /*******************************************************************************
   3917          * Function Name  : OSD_Layer_Select
   3918          *******************************************************************************/
   3919          void OSD_Layer_Select(u8 u_Num)
   3920          {
   3921             switch (u_Num)
   3922             {
   3923             case MDIN_LAYER_INFORMATION:
   3924          
   3925                // ALL OFF
   3926                MDIN_Sprite_Initialization(MDIN_LAYER_COORDINATE, bOFF);
   3927                MDIN_Sprite_Initialization(MDIN_LAYER_CENTER_MSG, bOFF);
   3928                MDIN_Sprite_Initialization(MDIN_LAYER_TARGET, bOFF);
   3929          
   3930                // INFORMATION ON
   3931                MDIN_Sprite_Initialization(MDIN_LAYER_INFORMATION, bON);
   3932          
   3933                break;
   3934          
   3935             case MDIN_LAYER_TARGET:
   3936          
   3937                // ALL OFF
   3938                MDIN_Sprite_Initialization(MDIN_LAYER_COORDINATE, bOFF);
   3939                MDIN_Sprite_Initialization(MDIN_LAYER_CENTER_MSG, bOFF);
   3940                MDIN_Sprite_Initialization(MDIN_LAYER_INFORMATION, bOFF);
   3941          
   3942                // CENTER ON
   3943                MDIN_Sprite_Initialization(MDIN_LAYER_TARGET, bON);
   3944          
   3945                break;
   3946          
   3947             case MDIN_LAYER_CENTER_MSG:
   3948          
   3949                // ALL OFF
   3950                MDIN_Sprite_Initialization(MDIN_LAYER_INFORMATION, bOFF);
   3951                MDIN_Sprite_Initialization(MDIN_LAYER_COORDINATE, bOFF);
   3952                MDIN_Sprite_Initialization(MDIN_LAYER_TARGET, bOFF);
   3953          
   3954                // CENTER ON
   3955                MDIN_Sprite_Initialization(MDIN_LAYER_CENTER_MSG, bON);
   3956          
   3957                break;
   3958          
   3959             case MDIN_LAYER_COORDINATE:
   3960             default:
   3961          
   3962                // ALL OFF
   3963                MDIN_Sprite_Initialization(MDIN_LAYER_INFORMATION, bOFF);
   3964                MDIN_Sprite_Initialization(MDIN_LAYER_CENTER_MSG, bOFF);
   3965                MDIN_Sprite_Initialization(MDIN_LAYER_TARGET, bOFF);
   3966          
   3967                // COORDINATE ON
   3968                MDIN_Sprite_Initialization(MDIN_LAYER_COORDINATE, bON);
   3969          
   3970                break;
   3971             }
   3972          }
   3973          
   3974          /*******************************************************************************
   3975          * Function Name  : UART5_Data_Parser
   3976          *******************************************************************************/
   3977          void UART5_Data_Parser(void)
   3978          {
   3979             u8 u_buf[10];
   3980          
   3981             u_buf[0] = stUART5.RX_BUF[0];	// stUART5.RX_BUF[0] : Protocol Check
   3982             u_buf[2] = stUART5.RX_BUF[2];	// stUART5.RX_BUF[2] : Length Check (when, TBT Protocol), Command High Byte Check (when, PELCO Protocol)
   3983             u_buf[3] = stUART5.RX_BUF[3];	// stUART5.RX_BUF[3] : Command Low Byte Check (when, PELCO Protocol)
   3984             u_buf[4] = stUART5.RX_BUF[4];	// stUART5.RX_BUF[4] : Command Check (when, TBT Protocol), Data High Byte Check (when, PELCO Protocol)
   3985             u_buf[5] = stUART5.RX_BUF[5];	// stUART5.RX_BUF[5] : Data Low Byte Check (when, PELCO Protocol)
   3986          
   3987             /*******************************************************************************
   3988             * Status :   
   3989             *******************************************************************************/ 
   3990             //    (Sync Byte Check)
   3991             switch (u_buf[0])
   3992             {
   3993             case IP_SONY_FIRST_BYTE:
   3994          
   3995                //  
   3996                Sony_Data_Handing(USART5_INDEX, u_buf[4], u_buf[2]);	// Command Check, Length Check
   3997          
   3998                break;
   3999          
   4000             case IP_TSM_FIRST_BYTE:
   4001          
   4002                //  
   4003                switch (stINFO.THERMAL_MODEL)
   4004                {
   4005                case TSM_72:
   4006                case TSM_72T:
   4007                case TSM_1M:
   4008                case TSM_1MT:
   4009                   TSM_Data_Handing(USART5_INDEX, u_buf[4], u_buf[2]);		// Command Check, Length Check
   4010                   break;
   4011          
   4012                case TCM_640:
   4013                   TCM_Data_Handing(USART5_INDEX, u_buf[4], u_buf[2]);		// Command Check, Length Check
   4014                   break;
   4015                }
   4016          
   4017                break;
   4018          
   4019             case IP_TCM_FIRST_BYTE:
   4020          
   4021                //  
   4022                //TCM_Data_Handing(u_buf[4], u_buf[2]);	// Command Check, Length Check
   4023          
   4024                break;
   4025          
   4026             case IP_PTZ_FIRST_BYTE:
   4027          
   4028                //  
   4029                PTZ_Data_Handing(u_buf[4], u_buf[2]);		// Command Check, Length Check
   4030          
   4031                break;
   4032          
   4033             case IP_DATA_FIRST_BYTE:
   4034          
   4035                //  
   4036                DATA_Request_Handing(u_buf[4], u_buf[2]);	// Command Check, Length Check
   4037                break;
   4038          
   4039             case IP_OPTION_FIRST_BYTE:
   4040          
   4041                //  
   4042                OPTION_Data_Handing(USART5_INDEX, u_buf[4], u_buf[2]);	// Command Check, Length Check
   4043                break;
   4044          
   4045             case IP_PELCO_CHK_BYTE:
   4046          
   4047                //  
   4048                PELCO_Data_Handing(u_buf[2], u_buf[3], u_buf[4], u_buf[5]);	// Command Check, Data Check
   4049          
   4050                break;
   4051          
   4052             default:
   4053                break;
   4054             }
   4055          }
   4056          
   4057          u8 g_Po_Data[30];
   4058          
   4059          /*******************************************************************************
   4060          * Function Name  : System_Data_Parser
   4061          *******************************************************************************/
   4062          void System_Data_Parser(void)
   4063          {
   4064             u8 i = 0, i_Max = 0x00;
   4065             u8 u_Sync_Byte = 0x00;
   4066             u8 u_Cmd = 0x00, u_Leng = 0x00;
   4067             u8 u_ID = 0x00, u_Position_x = 0x00, u_Position_y = 0x00;
   4068             u8 u_Rx_Data[50];
   4069          
   4070             u8 u_PT_PAN_SIGN = 0x00, u_PT_TILT_SIGN = 0x00;
   4071             u16 u_PT_PAN_INT = 0x0000, u_PT_PAN_DECIMAL = 0x0000;
   4072             u16 u_PT_TILT_INT = 0x0000, u_PT_TILT_DECIMAL = 0x0000;
   4073          
   4074             u8 u8_Convert_Data = 0x00;
   4075             u16 u16_Convert_Data = 0x0000;
   4076          
   4077             u_Sync_Byte = stSYS.RX_BUF[0][1];
   4078          
   4079             u_Cmd = stSYS.RX_BUF[0][5];
   4080             u_Leng = stSYS.RX_BUF[0][3];
   4081             i_Max = u_Leng + 5;
   4082          
   4083             for (i = 6; i < i_Max; i++)
   4084             {
   4085                u_Rx_Data[i - 6] = stSYS.RX_BUF[0][i];
   4086                g_Po_Data[i - 6] = u_Rx_Data[i - 6];
   4087             }
   4088          
   4089             switch (u_Sync_Byte)
   4090             {
   4091             case TILT_FIRST_BYTE:
   4092          
   4093                switch (u_Cmd)
   4094                {
   4095                case MDIN_OSD_CLEAR:
   4096          
   4097                   if (stOSD.LAYER_NUM != stSYS.RX_BUF[0][6])
   4098                   {
   4099                      stOSD.LAYER_NUM = stSYS.RX_BUF[0][6];
   4100          
   4101                      OSD_Layer_Select(stOSD.LAYER_NUM);
   4102                   }
   4103          
   4104                   Send_MDIN_String_Data(MDIN_SPRITE_CLEAR, u_Leng, MDIN_COMMAND_TIMER_DELAY);
   4105          
   4106                   break;
   4107          
   4108                case MDIN_OSD_DATA:
   4109          
   4110                   if (stOSD.LAYER_NUM != stSYS.RX_BUF[0][6])
   4111                   {
   4112                      stOSD.LAYER_NUM = stSYS.RX_BUF[0][6];
   4113          
   4114                      OSD_Layer_Select(stOSD.LAYER_NUM);
   4115                   }
   4116          
   4117                   Send_MDIN_String_Data(MDIN_SPRITE_STRING, u_Leng, MDIN_COMMAND_TIMER_DELAY);
   4118          
   4119                   break;
   4120          
   4121                case MDIN_COORDINATE_DATA:
   4122          
   4123                   if (stOSD.LAYER_NUM != MDIN_LAYER_COORDINATE)
   4124                   {
   4125                      stOSD.LAYER_NUM = MDIN_LAYER_COORDINATE;
   4126          
   4127                      OSD_Layer_Select(stOSD.LAYER_NUM);
   4128                   }
   4129          
   4130                   u_PT_PAN_INT = (u_Rx_Data[1] << 4);
   4131                   u_PT_PAN_INT |= (u_Rx_Data[2]);
   4132          
   4133                   u_PT_PAN_DECIMAL = (u_Rx_Data[3] << 4);
   4134                   u_PT_PAN_DECIMAL |= (u_Rx_Data[4]);
   4135          
   4136                   switch (u_Rx_Data[5])
   4137                   {
   4138                   case 0x00:
   4139                      u_PT_TILT_SIGN = 0x00;	// NULL
   4140                      break;
   4141          
   4142                   case 0x01:
   4143                      u_PT_TILT_SIGN = 0x2D;	// -
   4144                      break;
   4145          
   4146                   default:
   4147                      break;
   4148                   }
   4149          
   4150                   u_PT_TILT_INT = (u_Rx_Data[6] << 4);
   4151                   u_PT_TILT_INT |= (u_Rx_Data[7]);
   4152                   u_PT_TILT_DECIMAL = (u_Rx_Data[8] << 4);
   4153                   u_PT_TILT_DECIMAL |= (u_Rx_Data[9]);
   4154          
   4155                   /*
   4156                   u_ID = MDIN_LAYER_CENTER_MSG;				// ID
   4157                   u_Rx_Data[0] = 0x00;		// ON
   4158                   u_Rx_Data[1] = 0x00;		// RESERVED
   4159          
   4160                   Send_MDIN_Data(MDIN_FREEZE, 0x03, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   4161                   				u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   4162                   */
   4163          
   4164                   u_ID = MDIN_LAYER_COORDINATE;										// ID : Main 0
   4165                   u_Position_x = 0x01;								// COLUMN : 1
   4166                   u_Position_y = 0x00;								// ROW : 0
   4167          
   4168                   u_Rx_Data[0] = 0x00;								// NULL
   4169                   u_Rx_Data[1] = (u_PT_PAN_INT / 100) + 0x30;			// 1
   4170                   u_Rx_Data[2] = ((u_PT_PAN_INT % 100) / 10) + 0x30;	// 8
   4171                   u_Rx_Data[3] = (u_PT_PAN_INT % 10) + 0x30;			// 0
   4172                   u_Rx_Data[4] = 0x2E;								// .
   4173                   u8_Convert_Data = (u_PT_PAN_DECIMAL / 10) + 0x30;
   4174                   u_Rx_Data[5] = u8_Convert_Data;					// 0
   4175                   u8_Convert_Data = (u_PT_PAN_DECIMAL % 10) + 0x30;
   4176                   u_Rx_Data[6] = u8_Convert_Data;					// 0
   4177                   u_Rx_Data[7] = 0x00;								// NULL
   4178                   u_Rx_Data[8] = u_PT_TILT_SIGN;					// NULL / -
   4179                   u_Rx_Data[9] = (u_PT_TILT_INT / 100) + 0x30;		// 1
   4180                   u_Rx_Data[10] = ((u_PT_TILT_INT % 100) / 10) + 0x30;	// 8
   4181                   u_Rx_Data[11] = (u_PT_TILT_INT % 10) + 0x30;		// 0
   4182                   u_Rx_Data[12] = 0x2E;								// .
   4183                   u8_Convert_Data = (u_PT_TILT_DECIMAL / 10) + 0x30;
   4184                   u_Rx_Data[13] = u8_Convert_Data;					// 0
   4185                   u8_Convert_Data = (u_PT_TILT_DECIMAL % 10) + 0x30;
   4186                   u_Rx_Data[14] = u8_Convert_Data;					// 0
   4187          
   4188                   Send_MDIN_Data(MDIN_SPRITE_STRING, 0x12, u_ID, u_Position_x, u_Position_y, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7],
   4189                                  u_Rx_Data[8], u_Rx_Data[9], u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], MDIN_COMMAND_TIMER_DELAY);
   4190          
   4191                   break;
   4192          
   4193                case MDIN_BYPASS_DATA:
   4194          
   4195                   u16_Convert_Data = u_Rx_Data[0];
   4196                   u16_Convert_Data |= (u_Rx_Data[1] << 8);
   4197          
   4198                   Send_MDIN_Data(u16_Convert_Data, u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9], u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13],
   4199                                  u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], u_Rx_Data[17], u_Rx_Data[18], u_Rx_Data[19], u_Rx_Data[20], MDIN_COMMAND_TIMER_DELAY);
   4200                   break;
   4201          
   4202                case TILT_BOOT_STATUS:
   4203          
   4204                   u_Cmd = TILT_BOOT_STATUS;
   4205                   u_Leng = 0x04;
   4206                   u_ID = MDIN_LAYER_CENTER_MSG;
   4207          
   4208                   stUSART1.TX_BUF[0] = TILT_FIRST_BYTE;
   4209                   stUSART1.TX_BUF[1] = TILT_SECOND_BYTE;
   4210                   stUSART1.TX_BUF[2] = u_Leng;
   4211                   stUSART1.TX_BUF[3] = u_ID;
   4212                   stUSART1.TX_BUF[4] = u_Cmd;
   4213                   stUSART1.TX_BUF[5] = ACTIVE;
   4214                   stUSART1.TX_BUF[6] = 0x00;
   4215          
   4216                   stUSART1.TX_BUF[7] = 0x00;
   4217                   stUSART1.TX_BUF[7] = stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5] + stUSART1.TX_BUF[6];
   4218          
   4219                   stUSART1.TX_BUF[8] = 0xCF;
   4220          
   4221                   stUSART1.TX_CNT = 0;
   4222                   stUSART1.TX_MAX = u_Leng + 5;
   4223          
   4224                   USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   4225          
   4226                   break;
   4227          
   4228                case TILT_RESET:
   4229          
   4230                   RCC_APB1PeriphClockCmd(RCC_APB1Periph_WWDG, ENABLE);
   4231                   WWDG_SetPrescaler(WWDG_Prescaler_8);
   4232                   WWDG_SetWindowValue(80);
   4233                   WWDG_Enable(127);
   4234          
   4235                   break;
   4236          
   4237                case TILT_MDIN_RESET:
   4238          
   4239                   stINFO.BOOT_FLAG = 0x01;
   4240          
   4241                   while (stINFO.BOOT_FLAG)
   4242                   {
   4243                      Module_Auto_Sync();
   4244          
   4245                      if (stINFO.MODULE_TYPE != INDEX_NON)
   4246                         stINFO.BOOT_FLAG = 0x00;
   4247                   }
   4248          
   4249                   switch (stINFO.MODULE_TYPE)
   4250                   {
   4251                   case SONY_MODULE:
   4252          
   4253                      UART4_Init(9600);
   4254                      Delay_1ms(200);
   4255          
   4256                      break;
   4257          
   4258                   case TSM_MODULE:
   4259          
   4260                      UART4_Init(38400);
   4261          
   4262                      VIDEO_Initialization(PAL_MODE);
   4263                      Delay_1ms(200);
   4264                      MDIN_I550_Initialization();
   4265          
   4266                      stUART4.RX_REQUEST_CMD = TSM_CALL_PRODUCT_IDENTIFICATION;
   4267                      Send_TSM_Data(TSM_CALL_PRODUCT_IDENTIFICATION, 0x00, 0x00, 0x00, 0x06, TSM_COMMAND_TIMER_DELAY);
   4268                      Delay_1ms(TSM_REQUEST_TIMER_MAX);
   4269          
   4270                      stUART4.RX_REQUEST_CMD = TSM_CALL_CAMERA_INFORMATION;
   4271                      Send_TSM_Data(TSM_CALL_CAMERA_INFORMATION, 0x00, 0x00, 0x00, 0x06, TSM_COMMAND_TIMER_DELAY);
   4272                      Delay_1ms(TSM_REQUEST_TIMER_MAX);
   4273          
   4274                      stUART4.RX_REQUEST_CMD = TSM_CALL_FIRMWARE_VERSION;
   4275                      Send_TSM_Data(TSM_CALL_FIRMWARE_VERSION, 0x00, 0x00, 0x00, 0x06, TSM_COMMAND_TIMER_DELAY);
   4276                      Delay_1ms(TSM_REQUEST_TIMER_MAX);
   4277          
   4278                      break;
   4279          
   4280                   default:
   4281          
   4282                      UART4_Init(38400);
   4283          
   4284                      VIDEO_Initialization(PAL_MODE);
   4285                      Delay_1ms(200);
   4286                      MDIN_I550_Initialization();
   4287                      Delay_1ms(200);
   4288          
   4289                      Send_MDIN_Data(MDIN_OUTPUT_PATTERN, 0x03, 0x0D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, MDIN_COMMAND_TIMER_DELAY);
   4290                      Send_MDIN_Data(MDIN_OUTPUT_PATTERN, 0x03, 0x0D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, MDIN_COMMAND_TIMER_DELAY);
   4291                      Send_MDIN_Data(MDIN_OUTPUT_PATTERN, 0x03, 0x0D, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, MDIN_COMMAND_TIMER_DELAY);
   4292          
   4293                      break;
   4294          
   4295                   }
   4296          
   4297                   break;
   4298          
   4299                case CALL_INFORMATION:
   4300          
   4301                   u_Cmd = CALL_INFORMATION;
   4302                   u_Leng = 0x0E;
   4303                   u_ID = 0x01;
   4304          
   4305                   stUSART1.TX_BUF[0] = TILT_FIRST_BYTE;
   4306                   stUSART1.TX_BUF[1] = TILT_SECOND_BYTE;
   4307                   stUSART1.TX_BUF[2] = u_Leng;
   4308                   stUSART1.TX_BUF[3] = u_ID;
   4309                   stUSART1.TX_BUF[4] = u_Cmd;
   4310          
   4311                   stUSART1.TX_BUF[5] = Version_High;
   4312                   stUSART1.TX_BUF[6] = Version_Low;
   4313          
   4314                   stUSART1.TX_BUF[7] = Upgrade_Year_Month;
   4315                   stUSART1.TX_BUF[8] = Upgrade_Day;
   4316          
   4317                   stUSART1.TX_BUF[9] = stINFO.MODULE_TYPE;
   4318          
   4319                   switch (stINFO.MODULE_TYPE)
   4320                   {
   4321                   case SONY_MODULE:
   4322          
   4323                      stUSART1.TX_BUF[10] = 0x00;
   4324                      stUSART1.TX_BUF[11] = 0x00;
   4325                      stUSART1.TX_BUF[12] = 0x00;
   4326                      stUSART1.TX_BUF[13] = 0x00;
   4327                      stUSART1.TX_BUF[14] = 0x00;
   4328                      stUSART1.TX_BUF[15] = 0x00;
   4329                      stUSART1.TX_BUF[16] = 0x00;
   4330          
   4331                      break;
   4332          
   4333                   case TSM_MODULE:
   4334          
   4335                      stUSART1.TX_BUF[10] = stINFO.THERMAL_MODEL;
   4336                      stUSART1.TX_BUF[11] = stINFO.THERMAL_LENS;
   4337                      stUSART1.TX_BUF[12] = stINFO.THERMAL_VER_HIGH;
   4338                      stUSART1.TX_BUF[13] = stINFO.THERMAL_VER_LOW;
   4339                      stUSART1.TX_BUF[14] = stINFO.THERMAL_DAY;
   4340                      stUSART1.TX_BUF[15] = stINFO.THERMAL_MONTH;
   4341                      stUSART1.TX_BUF[16] = stINFO.THERMAL_YEAR;
   4342          
   4343                      break;
   4344          
   4345                   default:
   4346                      break;
   4347                   }
   4348          
   4349                   stUSART1.TX_BUF[17] = 0x00;
   4350                   stUSART1.TX_BUF[17] = stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5] + stUSART1.TX_BUF[6];
   4351          
   4352                   stUSART1.TX_BUF[18] = 0xCF;
   4353          
   4354                   stUSART1.TX_CNT = 0;
   4355                   stUSART1.TX_MAX = u_Leng + 5;
   4356          
   4357                   USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   4358          
   4359                   break;
   4360          
   4361                default:
   4362                   break;
   4363                }
   4364          
   4365                break;
   4366          
   4367             case IP_SONY_FIRST_BYTE:
   4368          
   4369                Sony_Data_Handing(SYSTEM_INDEX, u_Cmd, u_Leng);		// Command Check, Length Check
   4370          
   4371                break;
   4372          
   4373             case IP_TSM_FIRST_BYTE:
   4374          
   4375                //  
   4376                switch (stINFO.THERMAL_MODEL)
   4377                {
   4378                case TSM_72:
   4379                case TSM_72T:
   4380                case TSM_1M:
   4381                case TSM_1MT:
   4382                   TSM_Data_Handing(SYSTEM_INDEX, u_Cmd, u_Leng);		// Command Check, Length Check
   4383                   break;
   4384          
   4385                case TCM_640:
   4386                   TCM_Data_Handing(SYSTEM_INDEX, u_Cmd, u_Leng);		// Command Check, Length Check
   4387                   break;
   4388                }
   4389          
   4390                break;
   4391          
   4392             case IP_OPTION_FIRST_BYTE:
   4393                OPTION_Data_Handing(SYSTEM_INDEX, u_Cmd, u_Leng);		// Command Check, Length Check
   4394                break;
   4395          
   4396             default:
   4397                break;
   4398             }
   4399          }
   4400          
   4401          /*******************************************************************************
   4402          * Function Name  : USART1_Data_Parser
   4403          *******************************************************************************/
   4404          void USART1_Data_Parser(void)
   4405          {
   4406             u8 i = 0, i_Max = 0x00;
   4407             u8 u_Cmd = 0x00, u_Leng = 0x00;
   4408             u8 u_ID = 0x00, u_Position_x = 0x00, u_Position_y = 0x00;
   4409             u8 u_Rx_Data[50];
   4410          
   4411             u8 u_PT_PAN_SIGN = 0x00, u_PT_TILT_SIGN = 0x00;
   4412             u16 u_PT_PAN_INT = 0x0000, u_PT_PAN_DECIMAL = 0x0000;
   4413             u16 u_PT_TILT_INT = 0x0000, u_PT_TILT_DECIMAL = 0x0000;
   4414          
   4415             u8 u8_Convert_Data = 0x00;
   4416             u16 u16_Convert_Data = 0x0000;
   4417          
   4418             u_Cmd = stUSART1.RX_BUF[4];
   4419             u_Leng = stUSART1.RX_BUF[2];
   4420             i_Max = u_Leng + 4;
   4421          
   4422             for (i = 5; i < i_Max; i++)
   4423             {
   4424                u_Rx_Data[i - 5] = stUSART1.RX_BUF[i];
   4425             }
   4426          
   4427             switch (stUSART1.RX_BUF[0])
   4428             {
   4429             case TILT_FIRST_BYTE:
   4430          
   4431                switch (u_Cmd)
   4432                {
   4433                case MDIN_OSD_CLEAR:
   4434          
   4435                   if (stOSD.LAYER_NUM != stUSART2.TX_BUF[5])
   4436                   {
   4437                      stOSD.LAYER_NUM = stUSART2.TX_BUF[5];
   4438          
   4439                      OSD_Layer_Select(stOSD.LAYER_NUM);
   4440                   }
   4441          
   4442                   Send_MDIN_String_Data(MDIN_SPRITE_CLEAR, u_Leng, MDIN_COMMAND_TIMER_DELAY);
   4443          
   4444                   break;
   4445          
   4446                case MDIN_OSD_DATA:
   4447          
   4448                   if (stOSD.LAYER_NUM != stUSART2.TX_BUF[5])
   4449                   {
   4450                      stOSD.LAYER_NUM = stUSART2.TX_BUF[5];
   4451          
   4452                      OSD_Layer_Select(stOSD.LAYER_NUM);
   4453                   }
   4454          
   4455                   Send_MDIN_String_Data(MDIN_SPRITE_STRING, u_Leng, MDIN_COMMAND_TIMER_DELAY);
   4456          
   4457                   break;
   4458          
   4459                case MDIN_COORDINATE_DATA:
   4460          
   4461                   if (stOSD.LAYER_NUM != MDIN_LAYER_COORDINATE)
   4462                   {
   4463                      stOSD.LAYER_NUM = MDIN_LAYER_COORDINATE;
   4464          
   4465                      OSD_Layer_Select(stOSD.LAYER_NUM);
   4466                   }
   4467          
   4468                   u_PT_PAN_INT = (u_Rx_Data[1] << 4);
   4469                   u_PT_PAN_INT |= (u_Rx_Data[2]);
   4470          
   4471                   u_PT_PAN_DECIMAL = (u_Rx_Data[3] << 4);
   4472                   u_PT_PAN_DECIMAL |= (u_Rx_Data[4]);
   4473          
   4474                   switch (u_Rx_Data[5])
   4475                   {
   4476                   case 0x00:
   4477                      u_PT_TILT_SIGN = 0x00;	// NULL
   4478                      break;
   4479          
   4480                   case 0x01:
   4481                      u_PT_TILT_SIGN = 0x2D;	// -
   4482                      break;
   4483          
   4484                   default:
   4485                      break;
   4486                   }
   4487          
   4488                   u_PT_TILT_INT = (u_Rx_Data[6] << 4);
   4489                   u_PT_TILT_INT |= (u_Rx_Data[7]);
   4490                   u_PT_TILT_DECIMAL = (u_Rx_Data[8] << 4);
   4491                   u_PT_TILT_DECIMAL |= (u_Rx_Data[9]);
   4492          
   4493                   /*
   4494                   u_ID = MDIN_LAYER_CENTER_MSG;				// ID : Main 0
   4495                   u_Rx_Data[0] = 0x00;		// ON
   4496                   u_Rx_Data[1] = 0x00;		// RESERVED
   4497          
   4498                   Send_MDIN_Data(MDIN_FREEZE, 0x03, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   4499                   				u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   4500                   */
   4501          
   4502                   u_ID = MDIN_LAYER_COORDINATE;					// ID
   4503                   u_Position_x = 0x01;								// COLUMN : 1
   4504                   u_Position_y = 0x00;								// ROW : 0
   4505          
   4506                   u_Rx_Data[0] = 0x00;								// NULL
   4507                   u_Rx_Data[1] = (u_PT_PAN_INT / 100) + 0x30;			// 1
   4508                   u_Rx_Data[2] = ((u_PT_PAN_INT % 100) / 10) + 0x30;	// 8
   4509                   u_Rx_Data[3] = (u_PT_PAN_INT % 10) + 0x30;			// 0
   4510                   u_Rx_Data[4] = 0x2E;								// .
   4511                   u8_Convert_Data = (u_PT_PAN_DECIMAL / 10) + 0x30;
   4512                   u_Rx_Data[5] = u8_Convert_Data;					// 0
   4513                   u8_Convert_Data = (u_PT_PAN_DECIMAL % 10) + 0x30;
   4514                   u_Rx_Data[6] = u8_Convert_Data;					// 0
   4515                   u_Rx_Data[7] = 0x00;								// NULL
   4516                   u_Rx_Data[8] = u_PT_TILT_SIGN;					// NULL / -
   4517                   u_Rx_Data[9] = (u_PT_TILT_INT / 100) + 0x30;		// 1
   4518                   u_Rx_Data[10] = ((u_PT_TILT_INT % 100) / 10) + 0x30;	// 8
   4519                   u_Rx_Data[11] = (u_PT_TILT_INT % 10) + 0x30;		// 0
   4520                   u_Rx_Data[12] = 0x2E;								// .
   4521                   u8_Convert_Data = (u_PT_TILT_DECIMAL / 10) + 0x30;
   4522                   u_Rx_Data[13] = u8_Convert_Data;					// 0
   4523                   u8_Convert_Data = (u_PT_TILT_DECIMAL % 10) + 0x30;
   4524                   u_Rx_Data[14] = u8_Convert_Data;					// 0
   4525          
   4526                   Send_MDIN_Data(MDIN_SPRITE_STRING, 0x12, u_ID, u_Position_x, u_Position_y, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7],
   4527                                  u_Rx_Data[8], u_Rx_Data[9], u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], MDIN_COMMAND_TIMER_DELAY);
   4528          
   4529                   break;
   4530          
   4531                default:
   4532                   break;
   4533                }
   4534          
   4535                break;
   4536          
   4537             case IP_SONY_FIRST_BYTE:
   4538          
   4539                Sony_Data_Handing(USART1_INDEX, u_Cmd, u_Leng);		// Command Check, Length Check
   4540          
   4541                break;
   4542          
   4543             case IP_TSM_FIRST_BYTE:
   4544          
   4545                //  
   4546                switch (stINFO.THERMAL_MODEL)
   4547                {
   4548                case TSM_72:
   4549                case TSM_72T:
   4550                case TSM_1M:
   4551                case TSM_1MT:
   4552                   TSM_Data_Handing(USART1_INDEX, u_Cmd, u_Leng);		// Command Check, Length Check
   4553                   break;
   4554          
   4555                case TCM_640:
   4556                   //TCM_Data_Handing(u_buf[4], u_buf[2]);		// Command Check, Length Check
   4557                   break;
   4558                }
   4559          
   4560                break;
   4561          
   4562             default:
   4563                break;
   4564             }
   4565          }
   4566          
   4567          /*******************************************************************************
   4568          * Function Name  : Before_USART1_Data_Parser
   4569          *******************************************************************************/
   4570          void Before_USART1_Data_Parser(void)
   4571          {
   4572             /*******************************************************************************
   4573             * Data Format
   4574             BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]
   4575             0xCA		0xAC		CMD			DATA1(P1)	DATA2(P2)	CS
   4576             *******************************************************************************/
   4577             u8 u_Cmd = 0x00, u_Rx_Data1 = 0x00, u_Rx_Data2 = 0x00;
   4578             u8 u_Tx_Data1 = 0x00, u_Tx_Data2 = 0x00, u_Tx_Data3 = 0x00, u_Tx_Data4 = 0x00;
   4579             u16 u_Convert_Data = 0x0000;
   4580          
   4581             if (stUSART1.RX_PARITY == 0x01)
   4582             {
   4583                stUSART1.RX_PARITY = 0x00;
   4584                u_Cmd = stUSART1.RX_BUF[2];
   4585                u_Rx_Data1 = stUSART1.RX_BUF[3];
   4586                u_Rx_Data2 = stUSART1.RX_BUF[4];
   4587          
   4588                switch (u_Cmd)
   4589                {
   4590                   /*******************************************************************************
   4591                   * Command : 0x02
   4592                   * Mode : Set Wiper
   4593                   BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]
   4594                   0xCA		0xAC		0x02		P1			P2			CS
   4595                   - P1 : Count - 0x01 ~ 0x0E (1~14), 0x0F : Continuous Active
   4596                   - P2 : Dwell Time (s) - 0x00 ~ 0x3B (0~59)
   4597                   *******************************************************************************/ 
   4598                   // 5.2. Set Wiper (0x02)
   4599                case SET_WIPER:
   4600          
   4601                   stWIPER2.COUNT = u_Rx_Data1;
   4602                   stWIPER2.DWELL_TIME_DATA = u_Rx_Data2;
   4603                   stWIPER2.FLAG = 0x01;
   4604          
   4605                   stWIPER2.STOP_MODE = WIPER_STOP_READY;
   4606                   stWIPER2.STEP = WIPER_READY;
   4607          
   4608                   if (stWIPER2.COUNT >= 0x0F)
   4609                   {
   4610                      stWIPER2.CONTINUOUS_FLAG = 0x01;
   4611                      stWIPER2.CONTINUOUS_ms = 0;
   4612                      stWIPER2.CONTINUOUS_s = 0;
   4613                   }
   4614          
   4615                   break;
   4616          
   4617                   /*******************************************************************************
   4618                   * Command : 0x03
   4619                   * Mode : Stop Wiper
   4620                   BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]
   4621                   0xCA		0xAC		0x03		P1			0x00			CS
   4622                   - P1 : 
   4623                   0x00 : Origin Stop
   4624                   0x01 : Emergency Stop 
   4625                   *******************************************************************************/ 
   4626                   // 5.3. Stop Wiper (0x03)
   4627                case STOP_WIPER:
   4628          
   4629                   switch (u_Rx_Data1)
   4630                   {
   4631                   case 0x00:
   4632                      stWIPER2.STOP_MODE = WIPER_STOP_ORIGIN;
   4633                      break;
   4634          
   4635                   case 0x01:
   4636                      stWIPER2.STOP_MODE = WIPER_STOP_EMERGENCY;
   4637                      break;
   4638                   }
   4639          
   4640                   if (stWIPER2.DWELL_TIMER_FLAG)
   4641                      stWIPER2.DWELL_TIMER_FLAG = 0x00;
   4642                   if (stWIPER2.CONTINUOUS_FLAG == 0x01)
   4643                   {
   4644                      stWIPER2.CONTINUOUS_FLAG = 0x00;
   4645                   }
   4646          
   4647                   break;
   4648          
   4649                   // 5.5. Set LRF (0x05)
   4650                case SET_LRF:
   4651          
   4652                   switch (u_Rx_Data2)
   4653                   {
   4654                   case 0x00:
   4655                      break;
   4656          
   4657                   default:
   4658          
   4659                      stLRF.CONTINUOUS_TIME_MAX = u_Rx_Data2 * 50;
   4660          
   4661                      break;
   4662                   }
   4663          
   4664                   switch (u_Rx_Data1)
   4665                   {
   4666                   case 0x01:
   4667          
   4668                      stLRF.CONTINUOUS_FLAG = 0x01;
   4669          
   4670                      break;
   4671          
   4672                   default:
   4673          
   4674                      stLRF.CONTINUOUS_FLAG = 0x00;
   4675          
   4676                      break;
   4677                   }
   4678          
   4679                   break;
   4680          
   4681          
   4682                   /*******************************************************************************
   4683                   * Command : 0x07
   4684                   * Mode : Light On/Off [0x00:Off, 0x01:On]
   4685                   BYTE1[0]		BYTE2[1]		BYTE3[2]		BYTE4[3]		BYTE5[4]		BYTE5[5]
   4686                   0xCA		0xAC		0x07		P1			0x00		CS
   4687                   - P1 :
   4688                   0x00 : Light Off
   4689                   0x01 : Light On
   4690                   *******************************************************************************/ 
   4691                   // 5.7. Set Light On/Off (0x07)
   4692                case SET_LIGHT:
   4693          
   4694                   switch (u_Rx_Data1)
   4695                   {
   4696                   case 0x00:
   4697          
   4698                      EXTERNAL_LIGHT_PORT_OFF;
   4699                      stLIGHT.EXTERNAL_STATUS = LIGHT_OFF;
   4700          
   4701                      break;
   4702          
   4703                   case 0x01:
   4704          
   4705                      EXTERNAL_LIGHT_PORT_ON;
   4706                      stLIGHT.EXTERNAL_STATUS = LIGHT_ON;
   4707          
   4708                      break;
   4709          
   4710                   default:
   4711                      break;
   4712                   }
   4713          
   4714                   break;
   4715          
   4716                   // 5.8. Set Zoom-Light On/Off (0x08)
   4717                case SET_ZOOM_LIGHT:
   4718          
   4719                   switch (u_Rx_Data1)
   4720                   {
   4721                   case 0x00:
   4722          
   4723                      // Zoom Light Off
   4724                      Send_Light_Data(ZOOM_LIGHT_ENABLE, 0x30, 0x30, 0x30, 0x30, 0x30, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4725                      stLIGHT.ZOOM_STATUS = LIGHT_OFF;
   4726          
   4727                      break;
   4728          
   4729                   case 0x01:
   4730          
   4731                      // Zoom Light On
   4732                      Send_Light_Data(ZOOM_LIGHT_ENABLE, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4733                      stLIGHT.ZOOM_STATUS = LIGHT_ON;
   4734          
   4735                      break;
   4736          
   4737                   default:
   4738                      break;
   4739                   }
   4740          
   4741                   break;
   4742          
   4743                   // 5.9. Set Zoom-Light Direct Position (0x09)
   4744                case SET_ZOOM_LIGHT_DIRECT_POSITION:
   4745          
   4746                   u_Convert_Data = (u_Rx_Data1 << 8);
   4747                   u_Convert_Data |= u_Rx_Data2;
   4748          
   4749                   u_Tx_Data1 = (u_Convert_Data / 1000) & 0xFF;
   4750                   if (u_Tx_Data1 >= 9)
   4751                      u_Tx_Data1 = 9;
   4752                   u_Tx_Data1 = u_Tx_Data1 + 0x30;
   4753          
   4754                   u_Convert_Data = u_Convert_Data % 1000;
   4755                   u_Tx_Data2 = (u_Convert_Data / 100) & 0xFF;
   4756                   u_Tx_Data2 = u_Tx_Data2 + 0x30;
   4757          
   4758                   u_Convert_Data = u_Convert_Data % 100;
   4759                   u_Tx_Data3 = (u_Convert_Data / 10) & 0xFF;
   4760                   u_Tx_Data3 = u_Tx_Data3 + 0x30;
   4761          
   4762                   u_Tx_Data4 = (u_Convert_Data % 10) & 0xFF;
   4763                   u_Tx_Data4 = u_Tx_Data4 + 0x30;
   4764          
   4765                   Send_Light_Data(ZOOM_LIGHT_DIRECT, 0x2B, u_Tx_Data1, u_Tx_Data2, u_Tx_Data3, u_Tx_Data4, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4766          
   4767                   break;
   4768          
   4769                   // 5.A. (Special CMD) Call Zoom-Light Data (0x0A)
   4770                case CALL_ZOOM_LIGHT_DATA:
   4771          
   4772                   Send_Light_Data(CALL_ZOOM_LIGHT_POSITION, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4773          
   4774                   break;
   4775          
   4776                   // 5.B. (Special CMD) Set Zoom-Light Manual Control (0x0B)
   4777                case SET_ZOOM_LIGHT_MANUAL_CONTROL:
   4778          
   4779                   switch (u_Rx_Data1)
   4780                   {
   4781                   case 0x00:
   4782          
   4783                      stLIGHT.DIRECTION = CMD_ZOOM_LIGHT_WIDE;
   4784                      u_Tx_Data1 = 0x30;
   4785          
   4786                      u_Tx_Data2 = u_Rx_Data2 / 100;
   4787                      u_Tx_Data2 = u_Tx_Data2 + 0x30;
   4788          
   4789                      u_Rx_Data2 = u_Rx_Data2 % 100;
   4790                      u_Tx_Data3 = u_Rx_Data2 / 10;
   4791                      u_Tx_Data3 = u_Tx_Data3 + 0x30;
   4792          
   4793                      u_Tx_Data4 = u_Rx_Data2 % 10;
   4794                      u_Tx_Data4 = u_Tx_Data4 + 0x30;
   4795          
   4796                      Send_Light_Data(ZOOM_LIGHT_STEP, CMD_ZOOM_LIGHT_WIDE, u_Tx_Data1, u_Tx_Data2, u_Tx_Data3, u_Tx_Data4, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4797          
   4798                      break;
   4799          
   4800                   case 0x01:
   4801          
   4802                      stLIGHT.DIRECTION = CMD_ZOOM_LIGHT_TELE;
   4803          
   4804                      u_Tx_Data1 = 0x30;
   4805          
   4806                      u_Tx_Data2 = u_Rx_Data2 / 100;
   4807                      u_Tx_Data2 = u_Tx_Data2 + 0x30;
   4808          
   4809                      u_Rx_Data2 = u_Rx_Data2 % 100;
   4810                      u_Tx_Data3 = u_Rx_Data2 / 10;
   4811                      u_Tx_Data3 = u_Tx_Data3 + 0x30;
   4812          
   4813                      u_Tx_Data4 = u_Rx_Data2 % 10;
   4814                      u_Tx_Data4 = u_Tx_Data4 + 0x30;
   4815          
   4816                      Send_Light_Data(ZOOM_LIGHT_STEP, CMD_ZOOM_LIGHT_TELE, u_Tx_Data1, u_Tx_Data2, u_Tx_Data3, u_Tx_Data4, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4817          
   4818                      break;
   4819          
   4820                   default:
   4821                      break;
   4822                   }
   4823          
   4824                   break;
   4825          
   4826                   // 5.C. (Special CMD) Initialization Zoom-Light (0x0C)
   4827                case INITIALIZATION_ZOOM_LIGHT:
   4828          
   4829                   Send_Light_Data(ZOOM_LIGHT_INITIALIZATION, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4830          
   4831                   break;
   4832          
   4833                   // 5.10. LRF Initialization (0x10)
   4834                case LRF_INITIALIZATION:
   4835          
   4836                   // =======================================
   4837                   // Set LRF Initialization Flag
   4838                   // =======================================
   4839                   stLRF.INIT_FLAG = 0x01;
   4840          
   4841                   break;
   4842          
   4843                   // 5.18. Set Dual Light On/Off (0x18)
   4844                case OPTION_SET_EXTERNAL_IR_MODE:
   4845          
   4846                   switch (u_Rx_Data1)
   4847                   {
   4848                   case 0x00:
   4849          
   4850                      stCDS.IR_AUTO_ENABLE = 0x01;
   4851          
   4852                      switch (stCDS.DAY_AND_NIGHT_STATUS)
   4853                      {
   4854                         // Day Mode
   4855                      case 0x00:
   4856          
   4857                         EXTERNAL_LIGHT_PORT_OFF;
   4858                         stLIGHT.EXTERNAL_STATUS = LIGHT_OFF;
   4859          
   4860                         // Zoom Light Off
   4861                         Send_Light_Data(ZOOM_LIGHT_ENABLE, 0x30, 0x30, 0x30, 0x30, 0x30, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4862                         stLIGHT.ZOOM_STATUS = LIGHT_OFF;
   4863          
   4864                         break;
   4865          
   4866                         // Night Mode
   4867                      case 0x01:
   4868          
   4869                         EXTERNAL_LIGHT_PORT_ON;
   4870                         stLIGHT.EXTERNAL_STATUS = LIGHT_ON;
   4871          
   4872                         // Zoom Light On
   4873                         Send_Light_Data(ZOOM_LIGHT_ENABLE, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4874                         stLIGHT.ZOOM_STATUS = LIGHT_ON;
   4875          
   4876                         break;
   4877                      }
   4878          
   4879                      break;
   4880          
   4881                   case 0x01:
   4882          
   4883                      stCDS.IR_AUTO_ENABLE = 0x00;
   4884          
   4885                      EXTERNAL_LIGHT_PORT_ON;
   4886                      stLIGHT.EXTERNAL_STATUS = LIGHT_ON;
   4887          
   4888                      // Zoom Light On
   4889                      Send_Light_Data(ZOOM_LIGHT_ENABLE, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4890                      stLIGHT.ZOOM_STATUS = LIGHT_ON;
   4891          
   4892                      break;
   4893          
   4894                   case 0x02:
   4895          
   4896                      stCDS.IR_AUTO_ENABLE = 0x00;
   4897          
   4898                      EXTERNAL_LIGHT_PORT_OFF;
   4899                      stLIGHT.EXTERNAL_STATUS = LIGHT_OFF;
   4900          
   4901                      // Zoom Light Off
   4902                      Send_Light_Data(ZOOM_LIGHT_ENABLE, 0x30, 0x30, 0x30, 0x30, 0x30, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   4903                      stLIGHT.ZOOM_STATUS = LIGHT_OFF;
   4904          
   4905                      break;
   4906          
   4907                   default:
   4908                      break;
   4909                   }
   4910          
   4911                   break;
   4912          
   4913                   // 5.19. Set External IR Change Lux (0x19)
   4914                case OPTION_SET_EXTERNAL_IR_CHANGE_LUX:
   4915          
   4916                   stCDS.LUX = u_Rx_Data1;
   4917          
   4918                   switch (stCDS.LUX)
   4919                   {
   4920                      // -5
   4921                   case 0x75:
   4922                      stCDS.DAY_AND_NIGHT_LEVEL = 10;
   4923                      break;
   4924          
   4925                      // -4
   4926                   case 0x77:
   4927                      stCDS.DAY_AND_NIGHT_LEVEL = 9;
   4928                      break;
   4929          
   4930                      // -3
   4931                   case 0x79:
   4932                      stCDS.DAY_AND_NIGHT_LEVEL = 8;
   4933                      break;
   4934          
   4935                      // -2
   4936                   case 0x7B:
   4937                      stCDS.DAY_AND_NIGHT_LEVEL = 7;
   4938                      break;
   4939          
   4940                      // -1
   4941                   case 0x7D:
   4942                      stCDS.DAY_AND_NIGHT_LEVEL = 6;
   4943                      break;
   4944          
   4945                      // Default
   4946                   case 0x7F:
   4947                      stCDS.DAY_AND_NIGHT_LEVEL = 5;
   4948                      break;
   4949          
   4950                      // +1
   4951                   case 0x81:
   4952                      stCDS.DAY_AND_NIGHT_LEVEL = 4;
   4953                      break;
   4954          
   4955                      // +2
   4956                   case 0x83:
   4957                      stCDS.DAY_AND_NIGHT_LEVEL = 3;
   4958                      break;
   4959          
   4960                      // +3
   4961                   case 0x85:
   4962                      stCDS.DAY_AND_NIGHT_LEVEL = 2;
   4963                      break;
   4964          
   4965                      // +4
   4966                   case 0x87:
   4967                      stCDS.DAY_AND_NIGHT_LEVEL = 1;
   4968                      break;
   4969          
   4970                      // +5
   4971                   case 0x89:
   4972                      stCDS.DAY_AND_NIGHT_LEVEL = 0;
   4973                      break;
   4974                   }
   4975          
   4976                   break;
   4977          
   4978                   // 5.20. Set External IR Offset (0x20)
   4979                case OPTION_SET_EXTERNAL_IR_OFFSET:
   4980          
   4981                   stCDS.OFFSET = u_Rx_Data1 * 1000;
   4982          
   4983                   break;
   4984          
   4985                   // 5.21. Set Wiper Continuous Time (0x21)
   4986                case OPTION_SET_WIPER_CONTINUOUS_TIME:
   4987          
   4988                   stWIPER2.CONTINUOUS_TIME = u_Rx_Data1;
   4989          
   4990                   break;
   4991          
   4992                   // 5.90. Call Version Data (0x90)
   4993                case CALL_VERSION:
   4994          
   4995                   Reponse_Data_Send(CALL_VERSION, Version_High, Version_Low);
   4996          
   4997                   break;
   4998          
   4999                   // 5.91. Call Update Data (0x91)
   5000                case CALL_UPGRADE_DATE:
   5001          
   5002                   Reponse_Data_Send(CALL_UPGRADE_DATE, Upgrade_Year_Month, Upgrade_Day);
   5003          
   5004                   break;
   5005          
   5006                   // 5.A0. CDS - Day & Night (Auto Mode) (0xA0)
   5007                case DAY_AND_NIGHT_AUTO_MODE:
   5008          
   5009                   switch (u_Rx_Data1)
   5010                   {
   5011                      // Night Mode
   5012                   case 0x00:
   5013          
   5014                      stCDS.DAY_AND_NIGHT_AUTO_ENABLE = 0x00;
   5015                      stCDS.DAY_AND_NIGHT_STATUS = 0x01;
   5016          
   5017                      // Auto Mode Off
   5018                      Send_Sony_Data(0x51, 0x03, 0x00, 0x06, SONY_COMMAND_TIMER_DELAY);
   5019          
   5020                      // Night Mode
   5021                      Send_Sony_Data(0x01, 0x02, 0x00, 0x06, SONY_COMMAND_TIMER_DELAY);
   5022          
   5023                      EXTERNAL_LIGHT_PORT_ON;
   5024                      stLIGHT.EXTERNAL_STATUS = LIGHT_ON;
   5025          
   5026                      // Zoom Light On
   5027                      Send_Light_Data(ZOOM_LIGHT_ENABLE, 0x30, 0x30, 0x30, 0x30, 0x31, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   5028                      stLIGHT.ZOOM_STATUS = LIGHT_ON;
   5029          
   5030                      break;
   5031          
   5032                      // Day Mode
   5033                   case 0x01:
   5034          
   5035                      stCDS.DAY_AND_NIGHT_AUTO_ENABLE = 0x00;
   5036                      stCDS.DAY_AND_NIGHT_STATUS = 0x00;
   5037          
   5038                      // Auto Mode Off
   5039                      Send_Sony_Data(0x51, 0x03, 0x00, 0x06, SONY_COMMAND_TIMER_DELAY);
   5040          
   5041                      // Day Mode
   5042                      Send_Sony_Data(0x01, 0x03, 0x00, 0x06, SONY_COMMAND_TIMER_DELAY);
   5043          
   5044                      EXTERNAL_LIGHT_PORT_OFF;
   5045                      stLIGHT.EXTERNAL_STATUS = LIGHT_OFF;
   5046          
   5047                      // Zoom Light Off
   5048                      Send_Light_Data(ZOOM_LIGHT_ENABLE, 0x30, 0x30, 0x30, 0x30, 0x30, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   5049                      stLIGHT.ZOOM_STATUS = LIGHT_OFF;
   5050          
   5051                      break;
   5052          
   5053                      // Auto Mode
   5054                   case 0x02:
   5055          
   5056                      // Auto Mode Off
   5057                      Send_Sony_Data(0x51, 0x02, 0x00, 0x06, SONY_COMMAND_TIMER_DELAY);
   5058          
   5059                      stCDS.DAY_AND_NIGHT_AUTO_ENABLE = 0x01;
   5060          
   5061                      break;
   5062                   }
   5063          
   5064                   break;
   5065          
   5066                   // TEST_ZOOM_DATA
   5067                case TEST_ZOOM_DATA:
   5068          
   5069                   Send_Sony_Data(0x07, 0x27, 0x00, 0x06, SONY_COMMAND_TIMER_DELAY);
   5070          
   5071                   stTEST.TIMER_FLAG = 0x01;
   5072          
   5073                   break;
   5074          
   5075                default:
   5076                   break;
   5077                }
   5078             }
   5079          }
   5080          
   5081          /*******************************************************************************
   5082          * Function Name  : Zoom_Data_Sync
   5083          /=============================================================/
   5084          Step		Light-Zoom(DEC)	Light-Zoom(HEX)	Sony-Zoom(DEC)	Sony-Zoom(HEX)
   5085          0		1036			0x040B			0				0x0000
   5086          1		1000			0x03E8			550				0x0226
   5087          2		964				0x03C4			1096			0x0448
   5088          3		929				0x03A0			1642			0x066A
   5089          4		893				0x037D			2188			0x088C
   5090          5		857				0x0359			2734			0x0AAE
   5091          6		822				0x0335			3280			0x0CD0
   5092          7		786				0x0311			3826			0x0EF2
   5093          8		750				0x02EE			4372			0x1114
   5094          9		714				0x02CA			4918			0x1336
   5095          10		679				0x02A6			5464			0x1558
   5096          11		643				0x0282			6010			0x177A
   5097          12		607				0x025F			6556			0x199C
   5098          13		572				0x023B			7102			0x1BBE
   5099          14		536				0x0217			7648			0x1DE0
   5100          15		500				0x01F4			8194			0x2002
   5101          16		464				0x01D0			8740			0x2224
   5102          17		429				0x01AC			9286			0x2446
   5103          18		393				0x0188			9832			0x2668
   5104          19		357				0x0165			10378			0x288A
   5105          20		321				0x0141			10924			0x2AAC
   5106          21		286				0x011D			11470			0x2CCE
   5107          22		250				0x00FA			12016			0x2EF0
   5108          23		214				0x00D6			12562			0x3112
   5109          24		179				0x00B2			13108			0x3334
   5110          25		143				0x008E			13654			0x3556
   5111          26		107				0x006B			14200			0x3778
   5112          27		71				0x0047			14746			0x399A
   5113          28		36				0x0023			15292			0x3BBC
   5114          29		0				0x0000			15838			0x3DDE
   5115          30										16384			0x4000
   5116          *******************************************************************************/
   5117          void Zoom_Data_Sync(void)
   5118          {
   5119             // STEP 0 - HEX : 0x0000 ~ 0x0226 (DEC : 0 ~ 550)
   5120             if (stSONY.ZOOM_POSITION < 0x0225)
   5121             {
   5122                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_0;
   5123             }
   5124             // STEP 1 - HEX : 0x0226 ~ 0x0448 (DEC : 550 ~ 1096)
   5125             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_0) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_1))
   5126             {
   5127                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_1;
   5128             }
   5129             // STEP 2 - HEX : 0x0448 ~ 0x066A (DEC : 1096 ~ 1642)
   5130             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_1) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_2))
   5131             {
   5132                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_2;
   5133             }
   5134             // STEP 3 - HEX : 0x066A ~ 0x088C (DEC : 1642 ~ 2188)
   5135             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_2) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_3))
   5136             {
   5137                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_3;
   5138             }
   5139             // STEP 4 - HEX : 0x088C ~ 0x0AAE (DEC : 2188 ~ 2734)
   5140             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_3) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_4))
   5141             {
   5142                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_4;
   5143             }
   5144             // STEP 5 - HEX : 0x0AAE ~ 0x0CD0 (DEC : 2734 ~ 3280)
   5145             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_4) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_5))
   5146             {
   5147                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_5;
   5148             }
   5149             // STEP 6 - HEX : 0x0CD0 ~ 0x0EF2 (DEC : 3280 ~ 3826)
   5150             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_5) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_6))
   5151             {
   5152                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_6;
   5153             }
   5154             // STEP 7 - HEX : 0x0EF2 ~ 0x1114 (DEC : 3826 ~ 4372)
   5155             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_6) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_7))
   5156             {
   5157                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_7;
   5158             }
   5159             // STEP 8 - HEX : 0x1114 ~ 0x1336 (DEC : 4372 ~ 4918)
   5160             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_7) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_8))
   5161             {
   5162                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_8;
   5163             }
   5164             // STEP 9 - HEX : 0x1336 ~ 0x1558 (DEC : 4918 ~ 5464)
   5165             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_8) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_9))
   5166             {
   5167                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_9;
   5168             }
   5169             // STEP 10 - HEX : 0x1558 ~ 0x177A (DEC : 5464 ~ 6010)
   5170             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_9) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_10))
   5171             {
   5172                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_10;
   5173             }
   5174             // STEP 11 - HEX : 0x177A ~ 0x199C (DEC : 6010 ~ 6556)
   5175             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_10) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_11))
   5176             {
   5177                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_11;
   5178             }
   5179             // STEP 12 - HEX : 0x199C ~ 0x1BBE (DEC : 6556 ~ 7102)
   5180             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_11) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_12))
   5181             {
   5182                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_12;
   5183             }
   5184             // STEP 13 - HEX : 0x1BBE ~ 0x1DE0 (DEC : 7102 ~ 7648)
   5185             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_12) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_13))
   5186             {
   5187                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_13;
   5188             }
   5189             // STEP 14 - HEX : 0x1DE0 ~ 0x2002 (DEC : 7648 ~ 8194)
   5190             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_13) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_14))
   5191             {
   5192                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_14;
   5193             }
   5194             // STEP 15 - HEX : 0x2002 ~ 0x2224 (DEC : 8194 ~ 8740)
   5195             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_14) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_15))
   5196             {
   5197                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_15;
   5198             }
   5199             // STEP 16 - HEX : 0x2224 ~ 0x2446 (DEC : 8740 ~ 9286)
   5200             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_15) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_16))
   5201             {
   5202                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_16;
   5203             }
   5204             // STEP 17 - HEX : 0x2446 ~ 0x2668 (DEC : 9286 ~ 9832)
   5205             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_16) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_17))
   5206             {
   5207                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_17;
   5208             }
   5209             // STEP 18 - HEX : 0x2668 ~ 0x288A (DEC : 9832 ~ 10378)
   5210             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_17) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_18))
   5211             {
   5212                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_18;
   5213             }
   5214             // STEP 19 - HEX : 0x288A ~ 0x2AAC (DEC : 10378 ~ 10924)
   5215             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_18) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_19))
   5216             {
   5217                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_19;
   5218             }
   5219             // STEP 20 - HEX : 0x2AAC ~ 0x2CCE (DEC : 10924 ~ 11470)
   5220             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_19) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_20))
   5221             {
   5222                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_20;
   5223             }
   5224             // STEP 21 - HEX : 0x2CCE ~ 0x2EF0 (DEC : 11470 ~ 12016)
   5225             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_20) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_21))
   5226             {
   5227                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_21;
   5228             }
   5229             // STEP 22 - HEX : 0x2EF0 ~ 0x3112 (DEC : 12016 ~ 12562)
   5230             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_21) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_22))
   5231             {
   5232                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_22;
   5233             }
   5234             // STEP 23 - HEX : 0x3112 ~ 0x3334 (DEC : 12562 ~ 13108)
   5235             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_22) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_23))
   5236             {
   5237                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_23;
   5238             }
   5239             // STEP 24 - HEX : 0x3334 ~ 0x3556 (DEC : 13108 ~ 13654)
   5240             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_23) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_24))
   5241             {
   5242                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_24;
   5243             }
   5244             // STEP 25 - HEX : 0x3556 ~ 0x3778 (DEC : 13654 ~ 14200)
   5245             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_24) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_25))
   5246             {
   5247                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_25;
   5248             }
   5249             // STEP 26 - HEX : 0x3778 ~ 0x399A (DEC : 14200 ~ 14746)
   5250             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_25) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_26))
   5251             {
   5252                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_26;
   5253             }
   5254             // STEP 27 - HEX : 0x399A ~ 0x3BBC (DEC : 14746 ~ 15292)
   5255             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_26) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_27))
   5256             {
   5257                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_27;
   5258             }
   5259             // STEP 28 - HEX : 0x3BBC ~ 0x3DDE (DEC : 15292 ~ 15838)
   5260             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_27) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_28))
   5261             {
   5262                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_28;
   5263             }
   5264             // STEP 29 - HEX : 0x3DDE ~ 0x4000 (DEC : 15838 ~ 16384)
   5265             else if ((stSONY.ZOOM_POSITION >= SONY_ZOOM_STEP_28) && (stSONY.ZOOM_POSITION < SONY_ZOOM_STEP_29))
   5266             {
   5267                stLIGHT.POSITION_DATA = LIGHT_ZOOM_STEP_29;
   5268             }
   5269          }
   5270          
   5271          /*******************************************************************************
   5272          * Function Name  : Temperature_Convert_Data
   5273          :  ADC  
   5274          *******************************************************************************/
   5275          u16 Temperature_Convert_Data(u8 u_Celsius_Data)
   5276          {
   5277             u16 u_ADC_Data;
   5278          
   5279             switch (u_Celsius_Data)
   5280             {
   5281             case 0:     		//-30'
   5282                u_ADC_Data = 2875;
   5283                break;
   5284             case 1:
   5285                u_ADC_Data = 2857;
   5286                break;
   5287             case 2:
   5288                u_ADC_Data = 2838;
   5289                break;
   5290             case 3:
   5291                u_ADC_Data = 2819;
   5292                break;
   5293             case 4:
   5294                u_ADC_Data = 2799;
   5295                break;
   5296             case 5:    		//-15'
   5297                u_ADC_Data = 2779;
   5298                break;
   5299             case 6:
   5300                u_ADC_Data = 2758;
   5301                break;
   5302             case 7:
   5303                u_ADC_Data = 2737;
   5304                break;
   5305             case 8:
   5306                u_ADC_Data = 2715;
   5307                break;
   5308             case 9:
   5309                u_ADC_Data = 2693;
   5310                break;
   5311             case 10:    		//-10'
   5312                u_ADC_Data = 2670;
   5313                break;
   5314             case 11:
   5315                u_ADC_Data = 2647;
   5316                break;
   5317             case 12:
   5318                u_ADC_Data = 2623;
   5319                break;
   5320             case 13:
   5321                u_ADC_Data = 2598;
   5322                break;
   5323             case 14:
   5324                u_ADC_Data = 2574;
   5325                break;
   5326             case 15:    		//-5'
   5327                u_ADC_Data = 2548;
   5328                break;
   5329             case 16:
   5330                u_ADC_Data = 2522;
   5331                break;
   5332             case 17:
   5333                u_ADC_Data = 2496;
   5334                break;
   5335             case 18:
   5336                u_ADC_Data = 2469;
   5337                break;
   5338             case 19:
   5339                u_ADC_Data = 2442;
   5340                break;
   5341             case 20:    		//0'
   5342                u_ADC_Data = 2414;
   5343                break;
   5344             case 21:
   5345                u_ADC_Data = 2386;
   5346                break;
   5347             case 22:
   5348                u_ADC_Data = 2358;
   5349                break;
   5350             case 23:
   5351                u_ADC_Data = 2329;
   5352                break;
   5353             case 24:
   5354                u_ADC_Data = 2300;
   5355                break;
   5356             case 25:    		//5'
   5357                u_ADC_Data = 2271;
   5358                break;
   5359             case 26:
   5360                u_ADC_Data = 2241;
   5361                break;
   5362             case 27:
   5363                u_ADC_Data = 2211;
   5364                break;
   5365             case 28:
   5366                u_ADC_Data = 2181;
   5367                break;
   5368             case 29:
   5369                u_ADC_Data = 2150;
   5370                break;
   5371             case 30:    		//10'
   5372                u_ADC_Data = 2119;
   5373                break;
   5374             case 31:
   5375                u_ADC_Data = 2088;
   5376                break;
   5377             case 32:
   5378                u_ADC_Data = 2057;
   5379                break;
   5380             case 33:
   5381                u_ADC_Data = 2026;
   5382                break;
   5383             case 34:
   5384                u_ADC_Data = 1995;
   5385                break;
   5386             case 35:
   5387                u_ADC_Data = 1963;
   5388                break;
   5389             case 36:
   5390                u_ADC_Data = 1932;
   5391                break;
   5392             case 37:
   5393                u_ADC_Data = 1900;
   5394                break;
   5395             case 38:
   5396                u_ADC_Data = 1869;
   5397                break;
   5398             case 39:
   5399                u_ADC_Data = 1837;
   5400                break;
   5401             case 40:    		//20'
   5402                u_ADC_Data = 1806;
   5403                break;
   5404             case 41:
   5405                u_ADC_Data = 1774;
   5406                break;
   5407             case 42:
   5408                u_ADC_Data = 1743;
   5409                break;
   5410             case 43:
   5411                u_ADC_Data = 1712;
   5412                break;
   5413             case 44:
   5414                u_ADC_Data = 1680;
   5415                break;
   5416             case 45:    		//25'
   5417                u_ADC_Data = 1650;
   5418                break;
   5419             case 46:
   5420                u_ADC_Data = 1619;
   5421                break;
   5422             case 47:
   5423                u_ADC_Data = 1588;
   5424                break;
   5425             case 48:
   5426                u_ADC_Data = 1558;
   5427                break;
   5428             case 49:
   5429                u_ADC_Data = 1527;
   5430                break;
   5431             case 50:    		//30'
   5432                u_ADC_Data = 1497;
   5433                break;
   5434             case 51:
   5435                u_ADC_Data = 1468;
   5436                break;
   5437             case 52:
   5438                u_ADC_Data = 1438;
   5439                break;
   5440             case 53:
   5441                u_ADC_Data = 1409;
   5442                break;
   5443             case 54:
   5444                u_ADC_Data = 1380;
   5445                break;
   5446             case 55:
   5447                u_ADC_Data = 1352;
   5448                break;
   5449             case 56:
   5450                u_ADC_Data = 1324;
   5451                break;
   5452             case 57:
   5453                u_ADC_Data = 1296;
   5454                break;
   5455             case 58:
   5456                u_ADC_Data = 1268;
   5457                break;
   5458             case 59:
   5459                u_ADC_Data = 1241;
   5460                break;
   5461             case 60:    		// 40'
   5462                u_ADC_Data = 1214;
   5463                break;
   5464             case 61:    		// 41'
   5465                u_ADC_Data = 1188;
   5466                break;
   5467             case 62:    		// 42'
   5468                u_ADC_Data = 1162;
   5469                break;
   5470             case 63:    		// 43'
   5471                u_ADC_Data = 1136;
   5472                break;
   5473             case 64:    		// 44'
   5474                u_ADC_Data = 1111;
   5475                break;
   5476             case 65:    		// 45'
   5477                u_ADC_Data = 1087;
   5478                break;
   5479             case 66:    		// 46'
   5480                u_ADC_Data = 1062;
   5481                break;
   5482             case 67:    		// 47'
   5483                u_ADC_Data = 1038;
   5484                break;
   5485             case 68:    		// 48'
   5486                u_ADC_Data = 1015;
   5487                break;
   5488             case 69:    		// 49'
   5489                u_ADC_Data = 992;
   5490                break;
   5491             case 70:    		// 50'
   5492                u_ADC_Data = 969;
   5493                break;
   5494             }
   5495             return u_ADC_Data;
   5496          }
   5497          
   5498          /*******************************************************************************
   5499          * Function Name  : Temperature_Data_Check
   5500          *******************************************************************************/
   5501          void Temperature_Data_Check(void)
   5502          {
   5503             if (stTEMP.ENABLE)
   5504             {
   5505                stTEMP.DATA_CHECK_1ms++;
   5506                stTEMP.TOTAL_VALUE_1ms = stTEMP.TOTAL_VALUE_1ms + ((stADC.DMA1_ADC_VALUE[0] * 3300) / 4096);
   5507          
   5508                if (stTEMP.DATA_CHECK_1ms >= TEMP_CHECK_DATA_COUNT_1ms)
   5509                {
   5510                   stTEMP.DATA_CHECK_1ms = 0;
   5511          
   5512                   stTEMP.DATA_CHECK_10ms++;
   5513                   stTEMP.TOTAL_VALUE_10ms = stTEMP.TOTAL_VALUE_10ms + (stTEMP.TOTAL_VALUE_1ms / TEMP_CHECK_DATA_COUNT_1ms);
   5514                   stTEMP.TOTAL_VALUE_1ms = 0;
   5515          
   5516                   if (stTEMP.DATA_CHECK_10ms >= TEMP_CHECK_DATA_COUNT_10ms)
   5517                   {
   5518                      stTEMP.DATA_CHECK_10ms = 0;
   5519          
   5520                      stTEMP.AVERAGE_DATA = stTEMP.TOTAL_VALUE_10ms / TEMP_CHECK_DATA_COUNT_10ms;
   5521                      stTEMP.TOTAL_VALUE_10ms = 0;
   5522                   }
   5523                }
   5524             }
   5525          }
   5526          
   5527          /*******************************************************************************
   5528          * Function Name  : CDS_Data_Check
   5529          *******************************************************************************/
   5530          void CDS_Data_Check(void)
   5531          {
   5532             if (stCDS.ENABLE)
   5533             {
   5534                stCDS.DATA_CHECK_1ms++;
   5535                stCDS.TOTAL_VALUE_1ms = stCDS.TOTAL_VALUE_1ms + ((stADC.DMA1_ADC_VALUE[1] * 3300) / 4096);
   5536          
   5537                if (stCDS.DATA_CHECK_1ms >= TEMP_CHECK_DATA_COUNT_1ms)
   5538                {
   5539                   stCDS.DATA_CHECK_1ms = 0;
   5540          
   5541                   stCDS.DATA_CHECK_10ms++;
   5542                   stCDS.TOTAL_VALUE_10ms = stCDS.TOTAL_VALUE_10ms + (stCDS.TOTAL_VALUE_1ms / TEMP_CHECK_DATA_COUNT_1ms);
   5543                   stCDS.TOTAL_VALUE_1ms = 0;
   5544          
   5545                   if (stCDS.DATA_CHECK_10ms >= TEMP_CHECK_DATA_COUNT_10ms)
   5546                   {
   5547                      stCDS.DATA_CHECK_10ms = 0;
   5548          
   5549                      stCDS.AVERAGE_DATA = stCDS.TOTAL_VALUE_10ms / TEMP_CHECK_DATA_COUNT_10ms;
   5550                      stCDS.TOTAL_VALUE_10ms = 0;
   5551                   }
   5552                }
   5553             }
   5554          }
   5555          
   5556          /*******************************************************************************
   5557          * Function Name  : Temperature_Boot_Mode
   5558          *******************************************************************************/
   5559          void Temperature_Boot_Mode(void)
   5560          {
   5561             if (stTEMP.STARTING_MODE_TIMER_FLAG)
   5562             {
   5563                stTEMP.STARTING_MODE_TIMER_ms++;
   5564          
   5565                if (stTEMP.STARTING_MODE_TIMER_ms >= TEMP_BOOT_START_TIME)
   5566                {
   5567                   stTEMP.STARTING_MODE_TIMER_ms = 0;
   5568          
   5569                   stTEMP.STARTING_MODE_TIMER_FLAG = 0x00;
   5570                   stTEMP.STARTING_MODE_COMPLETE = 0x01;
   5571                }
   5572             }
   5573          }
   5574          
   5575          /*******************************************************************************
   5576          * Function Name  : Zoom_Light_Auto_Control
   5577          *******************************************************************************/
   5578          void Zoom_Light_Auto_Control(void)
   5579          {
   5580             u8 u_Tx_Data1 = 0x00, u_Tx_Data2 = 0x00, u_Tx_Data3 = 0x00, u_Tx_Data4 = 0x00;
   5581             u16 u_Convert_Data = 0x0000;
   5582          
   5583             if (stLIGHT.POSITION_STATUS != stLIGHT.POSITION_DATA)
   5584             {
   5585                u_Convert_Data = stLIGHT.POSITION_DATA;
   5586          
   5587                if (u_Convert_Data >= 1035)
   5588                   u_Convert_Data = 1035;
   5589          
   5590                u_Tx_Data1 = (u_Convert_Data / 1000) & 0xFF;
   5591                if (u_Tx_Data1 >= 9)
   5592                   u_Tx_Data1 = 9;
   5593                u_Tx_Data1 = u_Tx_Data1 + 0x30;
   5594          
   5595                u_Convert_Data = u_Convert_Data % 1000;
   5596                u_Tx_Data2 = (u_Convert_Data / 100) & 0xFF;
   5597                u_Tx_Data2 = u_Tx_Data2 + 0x30;
   5598          
   5599                u_Convert_Data = u_Convert_Data % 100;
   5600                u_Tx_Data3 = (u_Convert_Data / 10) & 0xFF;
   5601                u_Tx_Data3 = u_Tx_Data3 + 0x30;
   5602          
   5603                u_Tx_Data4 = (u_Convert_Data % 10) & 0xFF;
   5604                u_Tx_Data4 = u_Tx_Data4 + 0x30;
   5605          
   5606                Send_Light_Data(ZOOM_LIGHT_DIRECT, 0x2B, u_Tx_Data1, u_Tx_Data2, u_Tx_Data3, u_Tx_Data4, 0x0A, ZOOM_LIGHT_TRANS_DELAY);
   5607          
   5608                stLIGHT.POSITION_STATUS = stLIGHT.POSITION_DATA;
   5609             }
   5610          }
   5611          
   5612          /*******************************************************************************
   5613          * Function Name  : Fan_Heater_Control
   5614          *******************************************************************************/
   5615          void Fan_Heater_Control(u8 u_Mode)
   5616          {
   5617             switch (u_Mode)
   5618             {
   5619             case DISABLE_MODE:
   5620                break;
   5621          
   5622             case BOOT_MODE:
   5623          
   5624                if (stTEMP.STARTING_MODE_ENABLE == 0x00)
   5625                {
   5626                   Heater_ON;
   5627                   Fan_ON;
   5628          
   5629                   stTEMP.STARTING_MODE_ENABLE = 0x01;
   5630                   stTEMP.STARTING_MODE_TIMER_FLAG = 0x01;
   5631                }
   5632                else
   5633                {
   5634                   if (stTEMP.STARTING_MODE_COMPLETE == 0x01)
   5635                   {
   5636                      Heater_OFF;
   5637                      Fan_OFF;
   5638          
   5639                      stTEMP.STARTING_MODE_COMPLETE = 0x00;
   5640                      stTEMP.STARTING_MODE = 0x01;
   5641                      stTEMP.ENABLE = 0x01;
   5642                   }
   5643                }
   5644          
   5645                break;
   5646          
   5647             case NORMAL_MODE:
   5648          
   5649                // FAN 30   
   5650                if (stFAN.FAN_DWELL_FLAG)
   5651                {
   5652                   Fan_OFF;
   5653                   stFAN.STATUS = bOFF;
   5654          
   5655                   stFAN.FAN_DWELL_FLAG = 0x00;
   5656                   stFAN.FAN_DWELL_END_FLAG = 0x00;
   5657          
   5658                   stFAN.FAN_DWELL_TIMER_ms = 0;
   5659                   stFAN.FAN_DWELL_TIMER_s = 0;
   5660                }
   5661          
   5662                /*******************************************************************************
   5663                * FAN  
   5664                 50(969)  : FAN ON
   5665                 40(1214)  & 50(969)    : 
   5666                 40(1214)  : FAN OFF
   5667                 IR LED ON  : FAN ON
   5668                 LRF ON  : FAN ON
   5669          
   5670          
   5671                * HEATER  
   5672                 -10(1806)  : HEATER ON
   5673                 0(1497)  : HEATER OFF
   5674          
   5675                * stFAN.FAN_DWELL_FLAG = 1  FAN 30  . (  FAN ON     FLAG  .)
   5676                * stFAN.FAN_DWELL_FLAG = 0  FAN .
   5677                *******************************************************************************/
   5678          
   5679                if (stFAN.FAN_DWELL_FLAG == 0x01)
   5680                {
   5681                   //  -10(2670)  : HEATER ON
   5682                   if (stTEMP.AVERAGE_DATA >= Temperature_Convert_Data(TEMP_COMPARE_VALUE - 10))
   5683                   {
   5684                      Heater_ON;
   5685                      stHEATER.STATUS = bON;
   5686                   }
   5687          
   5688                   //  0(2414)  : HEATER OFF
   5689                   else if (stTEMP.AVERAGE_DATA < Temperature_Convert_Data(TEMP_COMPARE_VALUE + 0))
   5690                   {
   5691                      Heater_OFF;
   5692                      stHEATER.STATUS = bOFF;
   5693                   }
   5694                }
   5695                else
   5696                {
   5697                   //  50(969)  : FAN ON
   5698                   if (stTEMP.AVERAGE_DATA < Temperature_Convert_Data(TEMP_COMPARE_VALUE + 50))
   5699                   {
   5700                      Fan_ON;
   5701                      stFAN.STATUS = bON;
   5702                   }
   5703          
   5704                   //  40(1214)  & 50(969)    : 
   5705                   else if ((stTEMP.AVERAGE_DATA < Temperature_Convert_Data(TEMP_COMPARE_VALUE + 40)) && (stTEMP.AVERAGE_DATA >= Temperature_Convert_Data(TEMP_COMPARE_VALUE + 50)))
   5706                   {
   5707                      if (stFAN.STATUS == bOFF)
   5708                      {
   5709                         if ((stLIGHT.ZOOM_STATUS == LIGHT_OFF) && (stLRF.CONTINUOUS_FLAG == 0x00))
   5710                         {
   5711                            Fan_OFF;
   5712                            stFAN.STATUS = bOFF;
   5713                         }
   5714                      }
   5715                      else
   5716                      {
   5717                         Fan_ON;
   5718                         stFAN.STATUS = bON;
   5719                      }
   5720                   }
   5721          
   5722                   //  40(1214)  : FAN OFF
   5723                   else if (stTEMP.AVERAGE_DATA >= Temperature_Convert_Data(TEMP_COMPARE_VALUE + 40))
   5724                   {
   5725                      //  -10(1806)  : HEATER ON
   5726                      if (stTEMP.AVERAGE_DATA >= Temperature_Convert_Data(TEMP_COMPARE_VALUE - 10))
   5727                      {
   5728                         Heater_ON;
   5729                         stHEATER.STATUS = bON;
   5730          
   5731                         if (stFAN.STATUS == bOFF)
   5732                         {
   5733                            Fan_ON;
   5734                            stFAN.STATUS = bON;
   5735                         }
   5736                      }
   5737          
   5738                      //  0(1497)  : HEATER OFF
   5739                      else if (stTEMP.AVERAGE_DATA < Temperature_Convert_Data(TEMP_COMPARE_VALUE + 0))
   5740                      {
   5741                         Heater_OFF;
   5742                         stHEATER.STATUS = bOFF;
   5743          
   5744                         if (stFAN.STATUS == bON)
   5745                         {
   5746                            if ((stLIGHT.ZOOM_STATUS == LIGHT_OFF) && (stLRF.CONTINUOUS_FLAG == 0x00))
   5747                               stFAN.FAN_DWELL_FLAG = 0x01;
   5748                         }
   5749                      }
   5750                   }
   5751          
   5752                   break;
   5753          
   5754                default:
   5755                   break;
   5756                }
   5757             }
   5758          }
   5759          
   5760          /*******************************************************************************
   5761          * Function Name  : Auto_Day_And_Night_Control
   5762          *******************************************************************************/ 
   5763          /* TNS 3.3V Table ()
   5764          ==========================================================
   5765          Lux           7     10    15   20   25   30   40   50
   5766          ----------------------------------------------------------
   5767          ADCValue1    875   547   358  277  240  206  166  140 
   5768          ==========================================================*/
   5769          void Auto_Day_And_Night_Control(void)
   5770          {
   5771             u16 u_Data_Convert = 0;
   5772          
   5773             if (stCDS.ENABLE)
   5774             {
   5775                u_Data_Convert = stCDS.AVERAGE_DATA;
   5776          
   5777                if (stCDS.DAY_AND_NIGHT_AUTO_ENABLE)
   5778                {
   5779          
   5780                   // 
   5781                   //  Table -> 0:755, 1:775, 2:795, 3:815, 4:835, 5:855, 6:875, 7:895, 8:915, 9:935, 10:955
   5782                   // Day -> Night   : 1200 -> step 5
   5783                   // 0:1100, 1:1120, 2:1140, 3:1160, 4:1180, 5:1200, 6:1220, 7:1240, 8:1260, 9:1280, 10:1300
   5784          
   5785                   // IBDR: 3100K, 10K FULL-UP
   5786                   //                                                                                                                                  
   5787                   // LUX		     11       10       9        8        7		  6		5          4          3          2           1
   5788                   // 6 LUX  -> 0:930, 1:950, 2:970, 3:990, 4:1010, 5:1030, 6:1050, 7:1070, 8:1090, 9:1110, 10:1130
   5789                   if (u_Data_Convert > (930 + (stCDS.DAY_AND_NIGHT_LEVEL * 20)))
   5790                   {
   5791                      stCDS.NIGHT_CONVERT_CHECK_Cnt++;
   5792          
   5793                      if (stCDS.NIGHT_CONVERT_CHECK_Cnt == stCDS.OFFSET)
   5794                      {
   5795                         stCDS.NIGHT_CONVERT_CHECK_Cnt = 0;
   5796                         stCDS.DAY_AND_NIGHT_CONVERT_FLAG = 0x01;
   5797                         stCDS.DAY_AND_NIGHT_CONVERT_MODE = 0x01;
   5798                      }
   5799                   }
   5800          
   5801                   // 0:500, 1:520, 2:540, 3:560, 4:580, 5:600, 6:620, 7:640, 8:660, 9:680, 10:700
   5802                   // Night -> Day   : 900 -> step 5
   5803                   //                                                                                                                                  
   5804                   // LUX		      11       10       9         8        7	  10	     9         8        7          6           5
   5805                   // 10 LUX  -> 0:850, 1:870, 2:890, 3:910, 4:930, 5:950, 6:970, 7:990, 8:1010, 9:1030, 10:1050
   5806                   else if (u_Data_Convert < (850 + (stCDS.DAY_AND_NIGHT_LEVEL * 20)))
   5807                   {
   5808                      stCDS.DAY_CONVERT_CHECK_Cnt++;
   5809          
   5810                      if (stCDS.DAY_CONVERT_CHECK_Cnt == stCDS.OFFSET)
   5811                      {
   5812                         stCDS.DAY_CONVERT_CHECK_Cnt = 0;
   5813                         stCDS.DAY_AND_NIGHT_CONVERT_FLAG = 0x01;
   5814                         stCDS.DAY_AND_NIGHT_CONVERT_MODE = 0x00;
   5815                      }
   5816                   }
   5817          
   5818                   // 0:755, 1:775, 2:795, 3:815, 4:835, 5:855, 6:875, 7:895, 8:915, 9:935, 10:955
   5819                   if ((stCDS.NIGHT_CONVERT_CHECK_Cnt > 0) && (!(u_Data_Convert > (1100 + (stCDS.DAY_AND_NIGHT_LEVEL * 20)))))
   5820                   {
   5821                      stCDS.NIGHT_CONVERT_CHECK_Cnt = 0;
   5822                   }
   5823                   else if ((stCDS.DAY_CONVERT_CHECK_Cnt > 0) && (!(u_Data_Convert < (800 + (stCDS.DAY_AND_NIGHT_LEVEL * 20)))))
   5824                   {
   5825                      stCDS.DAY_CONVERT_CHECK_Cnt = 0;
   5826                   }
   5827                }
   5828             }
   5829          }
   5830          
   5831          /*******************************************************************************
   5832          * Function Name  : AT24C256C_EEPROM_Write
   5833          *******************************************************************************/
   5834          void AT24C256C_EEPROM_Write(u16 EepAddr, u8 EepData)
   5835          {
   5836             I2C2_Write(AT24C256_ADDR, EepAddr, EepData);
   5837          }
   5838          
   5839          /*******************************************************************************
   5840          * Function Name  : AT24C256C_EEPROM_Read
   5841          *******************************************************************************/
   5842          u8 AT24C256C_EEPROM_Read(u16 EepAddr)
   5843          {
   5844             return I2C2_Read(AT24C256_ADDR, EepAddr);
   5845          }
   5846          
   5847          /*******************************************************************************
   5848          * Function Name  : MDIN_Sprite_Initialization
   5849          *******************************************************************************/
   5850          void MDIN_Sprite_Initialization(u8 u_Layer, u8 u_OnOff)
   5851          {
   5852             u8 u_ID = 0x00;
   5853             u8 u_Rx_Data[50];
   5854          
   5855             switch (u_Layer)
   5856             {
   5857                // Layer 0 : Information
   5858             case MDIN_LAYER_INFORMATION:
   5859          
   5860                stOSD.LAYER_NUM = u_Layer;
   5861          
   5862                u_ID = u_Layer;			// ID
   5863          
   5864                u_Rx_Data[0] = 0x0C;		// X position L
   5865                u_Rx_Data[1] = 0x00;		// X position H
   5866          
   5867                u_Rx_Data[2] = 0x00;		// Y Position L
   5868                u_Rx_Data[3] = 0x00;		// Y Position H
   5869          
   5870                u_Rx_Data[4] = 0xB0;		// Width L : 12 x 100 = 1200, 0xB0
   5871                u_Rx_Data[5] = 0x04;		// Width H : 0x04
   5872          
   5873                u_Rx_Data[6] = 0xD0;		// Height L : 20 x 36 = 720, 0xD0
   5874                u_Rx_Data[7] = 0x02;		// Height H : 0x02
   5875          
   5876                Send_MDIN_Data(MDIN_SPRITE_RECT, 0x09, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   5877                               u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   5878          
   5879                u_ID = u_Layer;			// ID
   5880          
   5881                u_Rx_Data[0] = u_OnOff;	// ON
   5882                u_Rx_Data[1] = 0x00;		// RESERVED
   5883          
   5884                Send_MDIN_Data(MDIN_SPRITE, 0x03, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   5885                               u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   5886          
   5887                break;
   5888          
   5889                // Layer 1 : Information
   5890             case MDIN_LAYER_TARGET:
   5891          
   5892                stOSD.LAYER_NUM = u_Layer;
   5893          
   5894                u_ID = u_Layer;			// ID
   5895          
   5896                u_Rx_Data[0] = 0x0C;		// X position L
   5897                u_Rx_Data[1] = 0x00;		// X position H
   5898          
   5899                u_Rx_Data[2] = 0x00;		// Y Position L
   5900                u_Rx_Data[3] = 0x00;		// Y Position H
   5901          
   5902                u_Rx_Data[4] = 0xB0;		// Width L : 12 x 100 = 1200, 0xB0
   5903                u_Rx_Data[5] = 0x04;		// Width H : 0x04
   5904          
   5905                u_Rx_Data[6] = 0xBC;		// Height L : 20 x 35 = 700, 0xBC
   5906                u_Rx_Data[7] = 0x02;		// Height H : 0x02
   5907          
   5908                Send_MDIN_Data(MDIN_SPRITE_RECT, 0x09, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   5909                               u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   5910          
   5911                u_ID = u_Layer;			// ID
   5912          
   5913                u_Rx_Data[0] = u_OnOff;	// ON
   5914                u_Rx_Data[1] = 0x00;		// RESERVED
   5915          
   5916                Send_MDIN_Data(MDIN_SPRITE, 0x03, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   5917                               u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   5918          
   5919                break;
   5920          
   5921                // Layer 2 : Coordinate
   5922             case MDIN_LAYER_COORDINATE:
   5923          
   5924                stOSD.LAYER_NUM = u_Layer;
   5925          
   5926                u_ID = u_Layer;			// ID
   5927          
   5928                u_Rx_Data[0] = 0x0C;		// X position L
   5929                u_Rx_Data[1] = 0x00;		// X position H
   5930          
   5931                u_Rx_Data[2] = 0xA8;		// Y Position L
   5932                u_Rx_Data[3] = 0x02;		// Y Position H
   5933          
   5934                u_Rx_Data[4] = 0xC0;		// Width L : 12 x 16 = 192, 0xC0
   5935                u_Rx_Data[5] = 0x00;		// Width H : 0x00
   5936          
   5937                u_Rx_Data[6] = 0x14;		// HeightL : 20 x 1 = 20, 0x14
   5938                u_Rx_Data[7] = 0x00;		// HeightL : 0x00
   5939          
   5940                Send_MDIN_Data(MDIN_SPRITE_RECT, 0x09, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   5941                               u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   5942          
   5943                u_ID = u_Layer;			// ID : Main 0
   5944          
   5945                u_Rx_Data[0] = u_OnOff;	// ON
   5946                u_Rx_Data[1] = 0x00;		// RESERVED
   5947          
   5948                Send_MDIN_Data(MDIN_SPRITE, 0x03, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   5949                               u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   5950          
   5951                break;
   5952          
   5953                // Layer 7 : Center Message
   5954             case MDIN_LAYER_CENTER_MSG:
   5955          
   5956                stOSD.LAYER_NUM = u_Layer;
   5957          
   5958                u_ID = u_Layer;			// ID
   5959          
   5960                u_Rx_Data[0] = 0x0C;		// X position L
   5961                u_Rx_Data[1] = 0x00;		// X position H
   5962          
   5963                u_Rx_Data[2] = 0xC8;		// Y Position L
   5964                u_Rx_Data[3] = 0x00;		// Y Position H
   5965          
   5966                u_Rx_Data[4] = 0xB0;		// Width L : 12 x 100 = 1200, 0xB0
   5967                u_Rx_Data[5] = 0x04;		// Width H : 0x04
   5968          
   5969                u_Rx_Data[6] = 0xB4;		// HeightL : 20 x 9 = 180, 0xB4
   5970                u_Rx_Data[7] = 0x00;		// HeightL : 0x00
   5971          
   5972                Send_MDIN_Data(MDIN_SPRITE_RECT, 0x09, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   5973                               u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   5974          
   5975                u_ID = u_Layer;			// ID
   5976          
   5977                u_Rx_Data[0] = u_OnOff;	// ON
   5978                u_Rx_Data[1] = 0x00;		// RESERVED
   5979          
   5980                Send_MDIN_Data(MDIN_SPRITE, 0x03, u_ID, u_Rx_Data[0], u_Rx_Data[1], u_Rx_Data[2], u_Rx_Data[3], u_Rx_Data[4], u_Rx_Data[5], u_Rx_Data[6], u_Rx_Data[7], u_Rx_Data[8], u_Rx_Data[9],
   5981                               u_Rx_Data[10], u_Rx_Data[11], u_Rx_Data[12], u_Rx_Data[13], u_Rx_Data[14], u_Rx_Data[15], u_Rx_Data[16], MDIN_COMMAND_TIMER_DELAY);
   5982          
   5983                break;
   5984          
   5985             default:
   5986                break;
   5987             }
   5988          
   5989          
   5990          
   5991          }
   5992          
   5993          /*******************************************************************************
   5994          * Function Name  : MDIN_I550_Initialization
   5995          *******************************************************************************/
   5996          void MDIN_I550_Initialization(void)
   5997          {
   5998             u8 u_Port_Check = 0x01;
   5999          
   6000             MDIN_RESET_LOW;
   6001             Delay_ms(20);
   6002          
   6003             MDIN_RESET_HIGH;
   6004             Delay_ms(60);
   6005          
   6006             while (u_Port_Check)
   6007             {
   6008                if (MDIN_I550_INT == 0x01)
   6009                {
   6010                   u_Port_Check = 0x00;
   6011                }
   6012             }
   6013          
   6014             // DELAY TIME
   6015             Delay_ms(100);
   6016          
   6017             // MDIN SETTING
   6018             //Send_MDIN_Data(MDIN_INITIALIZATION, 0x03, 0x00, 0x00, 0x03, MDIN_COMMAND_TIMER_DELAY);
   6019             //Send_MDIN_Data(MDIN_INPUT_RESOLUTION, 0x03, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, MDIN_COMMAND_TIMER_DELAY);
   6020             //Send_MDIN_Data(MDIN_OUTPUT_RESOLUTION, 0x03, 0x0E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, MDIN_COMMAND_TIMER_DELAY);
   6021          
   6022             // DELAY TIME
   6023             Delay_ms(100);
   6024          
   6025             // SPRITE SETTING
   6026             //MDIN_Sprite_Initialization(MDIN_LAYER_COORDINATE, bON);
   6027             //Delay_ms(100);
   6028             MDIN_Sprite_Initialization(MDIN_LAYER_CENTER_MSG, bON);
   6029             Delay_ms(100);
   6030          
   6031          }
   6032          
   6033          /*******************************************************************************
   6034          * Function Name  : TW9900_DECODER_RESET_Low
   6035          *******************************************************************************/
   6036          void TW9900_DECODER_RESET_Low(void)
   6037          // Low:Reset
   6038          {
   6039             GPIO_ResetBits(GPIOC, GPIO_Pin_5);
   6040          }
   6041          
   6042          /*******************************************************************************
   6043          * Function Name  : TW9900_DECODER_RESET_Low
   6044          *******************************************************************************/
   6045          void TW9900_DECODER_RESET_High(void)
   6046          // High:Normal
   6047          {
   6048             GPIO_SetBits(GPIOC, GPIO_Pin_5);
   6049          }
   6050          
   6051          /*******************************************************************************
   6052          * TW9900
   6053          *******************************************************************************/
   6054          const char defTW9900Sys[2][112]	=
   6055             {
   6056                //      00    01    02    03    04    05    06    07    08    09    0A    0B    0C    0D    0E    0F	// NTSC
   6057                {
   6058                   0x00, 0x00, 0x40, 0xA0, 0x00, 0x00, 0x00, 0x02, 0x14, 0xF0, 0x11, 0xD0, 0xDC, 0x00, 0x11, 0x00,       //00
   6059                   0xFE, 0x6F, 0x31, 0x80, 0x80, 0x00, 0x00, 0x30, 0x44, 0x58, 0x0A, 0x00, 0x07, 0x7F, 0x08, 0x00,       //01
   6060                   0x50, 0x42, 0xF0, 0xD8, 0xBC, 0xB8, 0x44, 0x2A, 0x00, 0x00, 0x78, 0x44, 0x30, 0x14, 0xA5, 0xE6,       //02
   6061                   0x00, 0x00, 0x00, 0x05, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,       //03
   6062                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x40, 0x00, 0x00,       //04
   6063                   0xA0, 0x22, 0x31, 0x80, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,       //05
   6064                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x24, 0x00, 0x00, 0x13    //06
   6065                },
   6066          
   6067                //      00    01    02    03    04    05    06    07    08    09    0A    0B    0C    0D    0E    0F	// PAL
   6068                {
   6069                   0x00, 0x00, 0x40, 0xA0, 0x00, 0x00, 0x00, 0x12, 0x17, 0x20, 0x0C, 0xD0, 0xDC, 0x00, 0x11, 0x00,       //00
   6070                   0x0C, 0x67, 0x20, 0x7E, 0x7C, 0x00, 0x00, 0x30, 0x44, 0x58, 0x0A, 0x00, 0x07, 0x7F, 0x08, 0x00,       //01
   6071                   0x50, 0x42, 0xF0, 0xD8, 0xBC, 0xB8, 0x44, 0x2A, 0x00, 0x00, 0x78, 0x44, 0x30, 0x14, 0xA5, 0xE6,       //02
   6072                   0x00, 0x00, 0x00, 0x05, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,       //03
   6073                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x50, 0x00, 0x00,       //04
   6074                   0xA0, 0x22, 0x31, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,       //05
   6075                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x24, 0x00, 0x00, 0x13    //06
   6076                }
   6077             };
   6078          
   6079          const char defTW9900Thermal[2][112]	=
   6080             {
   6081                // NTSC
   6082                {
   6083                   //		  00    01    02    03    04    05    06    07    08    09    0A    0B    0C    0D    0E    0F
   6084                   0x00, 0x00, 0x40, 0xA0, 0x00, 0x00, 0x00, 0x02, 0x15, 0xF4, 0x00, 0xE0, 0xDC, 0x00, 0x11, 0x00,
   6085                   0xFE, 0x6F, 0x31, 0x80, 0x80, 0x00, 0x00, 0x30, 0x44, 0x58, 0x0A, 0x00, 0x07, 0x7F, 0x08, 0x00,
   6086                   0x50, 0x42, 0xF0, 0xD8, 0xBC, 0xB8, 0x44, 0x2A, 0x00, 0x00, 0x78, 0x44, 0x30, 0x14, 0xA5, 0xE6,
   6087                   0x00, 0x00, 0x00, 0x05, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   6088                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x40, 0x00, 0x00,
   6089                   0xA0, 0x22, 0x31, 0x80, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   6090                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x24, 0x00, 0x00, 0x13,
   6091                },
   6092          
   6093                // PAL
   6094                {
   6095                   //		  00    01    02    03    04    05    06    07    08    09    0A    0B    0C    0D    0E    0F
   6096                   0x00, 0x00, 0x40, 0xA0, 0x00, 0x00, 0x00, 0x12, 0x17, 0x20, 0x0D, 0xE0, 0xDC, 0x00, 0x11, 0x00,
   6097                   0x0C, 0x67, 0x20, 0x7E, 0x7C, 0x00, 0x00, 0x30, 0x44, 0x58, 0x0A, 0x00, 0x07, 0x7F, 0x08, 0x00,
   6098                   0x50, 0x42, 0xF0, 0xD8, 0xBC, 0xB8, 0x44, 0x2A, 0x00, 0x00, 0x78, 0x44, 0x30, 0x14, 0xA5, 0xE6,
   6099                   0x00, 0x00, 0x00, 0x05, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   6100                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x50, 0x00, 0x00,
   6101                   0xA0, 0x22, 0x31, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   6102                   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x24, 0x00, 0x00, 0x13,
   6103                },
   6104             };
   6105          
   6106          /*******************************************************************************
   6107          * Function Name  : TW9900_Initial
   6108          *******************************************************************************/
   6109          void TW9900_Initial(u8 VMode)
   6110          // VMode : NTSC_MODE/PAL_MODE
   6111          {
   6112             u8 i;
   6113          
   6114             TW9900_DECODER_RESET_High();
   6115             Delay_ms(100);
   6116          
   6117             for (i = 2; i < 0x70; i++)
   6118             {
   6119                TW9900_I2C1_ByteWrite(TW9900_ADDR, BYTE_ADDR, i, defTW9900Thermal[VMode - 1][i]);
   6120             }
   6121          }
   6122          
   6123          /*******************************************************************************
   6124          * Function Name  : VIDEO_Initialization
   6125          *******************************************************************************/
   6126          void VIDEO_Initialization(u8 u_Video_Mode)
   6127          {
   6128             TW9900_DECODER_RESET_Low();
   6129             MDIN_RESET_LOW;
   6130             Delay_ms(50);
   6131          
   6132             switch (u_Video_Mode)
   6133             {
   6134             case NTSC_MODE:
   6135                TW9900_Initial(NTSC_MODE);
   6136                break;
   6137          
   6138             case PAL_MODE:
   6139                TW9900_Initial(PAL_MODE);
   6140                break;
   6141          
   6142             default:
   6143                TW9900_Initial(NTSC_MODE);
   6144                break;
   6145             }
   6146             Delay_ms(50);
   6147          
   6148             // 4. MDIN Initial
   6149             Delay_1ms(10);
   6150             MDIN_RESET_HIGH;
   6151             Delay_1ms(1000);
   6152          
   6153             //MDIN_I550_Initialization();
   6154          
   6155          }
   6156          
   6157          /*******************************************************************************
   6158          * Function Name  : Send_Request_Data
   6159          *******************************************************************************/
   6160          void Send_Request_Data(u8 u_Cmd, u8 u_Index)
   6161          {
   6162             u8 u8_Convert_Data[10];
   6163             u16 u16_Convert_Data = 0x0000;
   6164          
   6165             switch (stINFO.MODULE_TYPE)
   6166             {
   6167             case SONY_MODULE:
   6168          
   6169                switch (u_Cmd)
   6170                {
   6171                case SONY_CALL_ZOOM_POSITION:
   6172          
   6173                   u16_Convert_Data = stSONY.ZOOM_CNT;
   6174          
   6175                   u8_Convert_Data[0] = (u8)(u16_Convert_Data >> 8);
   6176                   u8_Convert_Data[1] = (u8)(u16_Convert_Data & 0xFF);
   6177          
   6178                   stUSART1.TX_BUF[0] = IP_SONY_FIRST_BYTE;
   6179                   stUSART1.TX_BUF[1] = IP_SONY_SECOND_BYTE;
   6180                   stUSART1.TX_BUF[2] = 0x05;
   6181          
   6182                   stUSART1.TX_BUF[3] = 0x01;
   6183          
   6184                   stUSART1.TX_BUF[4] = 0xB8;
   6185                   stUSART1.TX_BUF[5] = u8_Convert_Data[0];
   6186                   stUSART1.TX_BUF[6] = u8_Convert_Data[1];
   6187                   stUSART1.TX_BUF[7] = u8_Convert_Data[2];
   6188          
   6189                   stUSART1.TX_BUF[8] = 0x00;
   6190                   stUSART1.TX_BUF[8] = stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5] + stUSART1.TX_BUF[6] + stUSART1.TX_BUF[7];
   6191          
   6192                   stUSART1.TX_BUF[9] = 0xAF;
   6193          
   6194                   stUSART1.TX_CNT = 0;
   6195                   stUSART1.TX_MAX = 10;
   6196          
   6197                   USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   6198                   Delay_1ms(MAIN_COMMAND_TIMER_DELAY);
   6199          
   6200                   break;
   6201          
   6202                case SONY_CALL_FOCUS_POSITION:
   6203          
   6204                   u16_Convert_Data = stSONY.FOCUS_CNT;
   6205          
   6206                   u8_Convert_Data[0] = (u8)(u16_Convert_Data >> 8);
   6207                   u8_Convert_Data[1] = (u8)(u16_Convert_Data & 0xFF);
   6208          
   6209                   stUSART1.TX_BUF[0] = IP_SONY_FIRST_BYTE;
   6210                   stUSART1.TX_BUF[1] = IP_SONY_SECOND_BYTE;
   6211                   stUSART1.TX_BUF[2] = 0x05;
   6212          
   6213                   stUSART1.TX_BUF[3] = 0x01;
   6214          
   6215                   stUSART1.TX_BUF[4] = u_Cmd;
   6216                   stUSART1.TX_BUF[5] = u8_Convert_Data[0];
   6217                   stUSART1.TX_BUF[6] = u8_Convert_Data[1];
   6218                   stUSART1.TX_BUF[7] = u8_Convert_Data[2];
   6219          
   6220                   stUSART1.TX_BUF[8] = 0x00;
   6221                   stUSART1.TX_BUF[8] = stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5] + stUSART1.TX_BUF[6] + stUSART1.TX_BUF[7];
   6222          
   6223                   stUSART1.TX_BUF[9] = 0xAF;
   6224          
   6225                   stUSART1.TX_CNT = 0;
   6226                   stUSART1.TX_MAX = 10;
   6227          
   6228                   USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   6229                   Delay_1ms(MAIN_COMMAND_TIMER_DELAY);
   6230          
   6231                   break;
   6232                }
   6233          
   6234                break;
   6235          
   6236             case TSM_MODULE:
   6237          
   6238                switch (u_Cmd)
   6239                {
   6240                case TSM_CALL_TOTAL_ZOOM_POSITION:
   6241          
   6242                   u16_Convert_Data = stTSM.ZOOM_CNT;
   6243          
   6244                   u8_Convert_Data[0] = (u8)(u16_Convert_Data >> 8);
   6245                   u8_Convert_Data[1] = (u8)(u16_Convert_Data & 0xFF);
   6246          
   6247                   stUSART1.TX_BUF[0] = IP_TSM_FIRST_BYTE;
   6248                   stUSART1.TX_BUF[1] = IP_TSM_SECOND_BYTE;
   6249                   stUSART1.TX_BUF[2] = 0x05;
   6250          
   6251                   stUSART1.TX_BUF[3] = 0x01;
   6252          
   6253                   stUSART1.TX_BUF[4] = u_Cmd;
   6254                   stUSART1.TX_BUF[5] = u8_Convert_Data[0];
   6255                   stUSART1.TX_BUF[6] = u8_Convert_Data[1];
   6256                   stUSART1.TX_BUF[7] = u8_Convert_Data[2];
   6257          
   6258                   stUSART1.TX_BUF[8] = 0x00;
   6259                   stUSART1.TX_BUF[8] = stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5] + stUSART1.TX_BUF[6] + stUSART1.TX_BUF[7];
   6260          
   6261                   stUSART1.TX_BUF[9] = 0xBF;
   6262          
   6263                   stUSART1.TX_CNT = 0;
   6264                   stUSART1.TX_MAX = 10;
   6265          
   6266                   USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   6267                   Delay_1ms(MAIN_COMMAND_TIMER_DELAY);
   6268          
   6269                   break;
   6270          
   6271                case TSM_CALL_FOCUS_POSITION:
   6272          
   6273                   u16_Convert_Data = stTSM.FOCUS_CNT;
   6274          
   6275                   u8_Convert_Data[0] = (u8)(u16_Convert_Data >> 8);
   6276                   u8_Convert_Data[1] = (u8)(u16_Convert_Data & 0xFF);
   6277          
   6278                   stUSART1.TX_BUF[0] = IP_TSM_FIRST_BYTE;
   6279                   stUSART1.TX_BUF[1] = IP_TSM_SECOND_BYTE;
   6280                   stUSART1.TX_BUF[2] = 0x05;
   6281          
   6282                   stUSART1.TX_BUF[3] = 0x01;
   6283          
   6284                   stUSART1.TX_BUF[4] = u_Cmd;
   6285                   stUSART1.TX_BUF[5] = u8_Convert_Data[0];
   6286                   stUSART1.TX_BUF[6] = u8_Convert_Data[1];
   6287                   stUSART1.TX_BUF[7] = u8_Convert_Data[2];
   6288          
   6289                   stUSART1.TX_BUF[8] = 0x00;
   6290                   stUSART1.TX_BUF[8] = stUSART1.TX_BUF[3] + stUSART1.TX_BUF[4] + stUSART1.TX_BUF[5] + stUSART1.TX_BUF[6] + stUSART1.TX_BUF[7];
   6291          
   6292                   stUSART1.TX_BUF[9] = 0xBF;
   6293          
   6294                   stUSART1.TX_CNT = 0;
   6295                   stUSART1.TX_MAX = 10;
   6296          
   6297                   USART_SendData(USART1, stUSART1.TX_BUF[stUSART1.TX_CNT++]);
   6298                   Delay_1ms(MAIN_COMMAND_TIMER_DELAY);
   6299          
   6300                   break;
   6301          
   6302                default:
   6303                   break;
   6304                }
   6305          
   6306                break;
   6307             }
   6308          
   6309          
   6310          }
   6311          
   6312          u8 Data_Test = 0;
   6313          
   6314          /*******************************************************************************
   6315          * Function Name  : Module_Auto_Sync
   6316          *******************************************************************************/
   6317          void Module_Auto_Sync(void)
   6318          {
   6319             UART4_Init(9600);
   6320             Delay_1ms(500);
   6321          
   6322             stUART4.RX_REQUEST_CMD = SONY_POWER_INQ;
   6323             Send_Sony_Data(0x00, 0x00, 0x00, 0x05, SONY_COMMAND_TIMER_DELAY);
   6324             Delay_1ms(SONY_REQUEST_TIMER_DELAY);
   6325             Delay_1ms(500);
   6326          
   6327             UART4_Init(38400);
   6328             Delay_1ms(500);
   6329          
   6330             stUART4.RX_REQUEST_CMD = TSM_CALL_MODULE_STATUS;
   6331             Send_TSM_Data(TSM_CALL_MODULE_STATUS, 0x00, 0x00, 0x00, 0x06, TSM_COMMAND_TIMER_DELAY);
   6332             Delay_1ms(TSM_REQUEST_TIMER_MAX);
   6333             Delay_1ms(500);
   6334          }
   6335          
   6336          /*******************************************************************************
   6337          * Function Name  : EEPROM_Memory_Read
   6338          *******************************************************************************/
   6339          void EEPROM_Memory_Read(void)
   6340          {
   6341             u8 u_EEP_Mark = 0x00;
   6342          
   6343             u_EEP_Mark = AT24C256C_EEPROM_Read(EEP_PROM_MARK);
   6344          
   6345             // =======================================
   6346             // Data Read
   6347             // =======================================
   6348             if (u_EEP_Mark == EEP_HEADER)
   6349             {
   6350                switch (stINFO.MODULE_TYPE)
   6351                {
   6352                case SONY_MODULE:
   6353          
   6354                   // --------------------------------------------------------------------------------------------------//
   6355                   // 1. Color Module Control Command (0xAx)																 //
   6356                   // --------------------------------------------------------------------------------------------------//
   6357          
   6358                   // 1.1.	Set Focus Mode (0x91)
   6359                   stSONY.SET_FOCUS_MODE = AT24C256C_EEPROM_Read(EEP_SET_FOCUS_MODE);
   6360          
   6361                   // 1.2.	Set Auto Focus Mode (0x93)
   6362                   stSONY.SET_AUTO_FOCUS_MODE = AT24C256C_EEPROM_Read(EEP_SET_AUTO_FOCUS_MODE);
   6363          
   6364                   // 1.3.	Manual Focus Mode (0x08)
   6365                   // 1.4.	Manual Focus Direct (0x48)
   6366                   // 1.5.	Manual Zoom Mode (0x07)
   6367                   // 1.6.	Manual Zoom Direct (0x47)
   6368          
   6369                   // 1.7.	Set BLC Mode (0x31)
   6370                   stSONY.SET_BLC_MODE = AT24C256C_EEPROM_Read(EEP_SET_BLC_MODE);
   6371          
   6372                   // 1.8.	Set White Balance Mode (0x33)
   6373                   stSONY.SET_WHITE_BALANCE_MODE = AT24C256C_EEPROM_Read(EEP_SET_WHITE_BALANCE_MODE);
   6374          
   6375                   // 1.9.	Set Defog Mode (0x37)
   6376                   stSONY.SET_DEFOG_MODE = AT24C256C_EEPROM_Read(EEP_SET_DEFOG_MODE);
   6377          
   6378                   // 1.10.	Set Shutter Speed (0x4A)
   6379                   stSONY.SET_SHUTTER_SPEED = AT24C256C_EEPROM_Read(EEP_SET_SHUTTER_SPEED);
   6380          
   6381                   // 1.11.	Set Flicker Mode (0x55)
   6382                   stSONY.SET_FLICKER_MODE = AT24C256C_EEPROM_Read(EEP_SET_FLICKER_MODE);
   6383          
   6384                   // 1.12.	Set Aperture Value (0x59)
   6385                   stSONY.SET_APERTURE_VALUE = AT24C256C_EEPROM_Read(EEP_SET_APERTURE_VALUE);
   6386          
   6387                   // 1.13.	Set Digital Zoom Mode (0x5B)
   6388                   stSONY.SET_DIGITAL_ZOOM_MODE = AT24C256C_EEPROM_Read(EEP_SET_DIGITAL_ZOOM_MODE);
   6389          
   6390                   // 1.14.	Set Day & Night Mode (0x5F)
   6391                   stSONY.SET_DAY_NIGHT_MODE = AT24C256C_EEPROM_Read(EEP_SET_DAY_NIGHT_MODE);
   6392          
   6393                   // 1.15.	Set DSS Mode (0x61)
   6394                   stSONY.SET_DSS_MODE = AT24C256C_EEPROM_Read(EEP_SET_DSS_MODE);
   6395          
   6396                   // 1.16.	Select BLC / WDR (0x85)
   6397                   stSONY.SELECT_BLC_WDR = AT24C256C_EEPROM_Read(EEP_SELECT_BLC_WDR);
   6398          
   6399                   // 1.17.	Set High Resolution (0x87)
   6400                   stSONY.SET_HIGH_RESOLUTION = AT24C256C_EEPROM_Read(EEP_SET_HIGH_RESOLUTION);
   6401          
   6402                   // 1.18.	Set Image Stabilizer (0x89)
   6403                   stSONY.SET_IMAGE_STABILIZER = AT24C256C_EEPROM_Read(EEP_SET_IMAGE_STABILIZER);
   6404          
   6405                   // 1.19.	Set Noise Reduction (0x8B)
   6406                   stSONY.SET_NOISE_REDUCTION = AT24C256C_EEPROM_Read(EEP_SET_NOISE_REDUCTION);
   6407          
   6408                   // ETC.
   6409                   stSONY.SET_NTSC_PAL_MODE = AT24C256C_EEPROM_Read(EEP_SET_NTSC_PAL_MODE);
   6410          
   6411                   stSONY.SET_MANUAL_FOCUS_DATA = (AT24C256C_EEPROM_Read(EEP_MANUAL_FOCUS_DATA) << 8);
   6412                   stSONY.SET_MANUAL_FOCUS_DATA |= AT24C256C_EEPROM_Read(EEP_MANUAL_FOCUS_DATA + 1);
   6413          
   6414                   // --------------------------------------------------------------------------------------------------//
   6415                   // 5. Option Command (0xEx)																			 //
   6416                   // --------------------------------------------------------------------------------------------------//
   6417                   // 5.2. Set Wiper (0x02)
   6418                   stWIPER2.COUNT = AT24C256C_EEPROM_Read(EEP_SET_WIPER_COUNT);
   6419                   stWIPER2.DWELL_TIME = AT24C256C_EEPROM_Read(EEP_SET_WIPER_DWELL_TIME);
   6420          
   6421                   // 5.22. Set Wiper Option (0x22)
   6422                   stWIPER2.OPTION = AT24C256C_EEPROM_Read(EEP_SET_WIPER_OPTION);
   6423                   stWIPER2.SPRITE_TIME = AT24C256C_EEPROM_Read(EEP_SET_WASHER_SPRITE_TIME);
   6424                   stWIPER2.CONTINUOUS_TIME = AT24C256C_EEPROM_Read(EEP_SET_WIPER_CONTINUOUS_TIME);
   6425          
   6426                   break;
   6427          
   6428                case TSM_MODULE:
   6429          
   6430                   // --------------------------------------------------------------------------------------------------//
   6431                   // 2. Thermal Module Control Command (0xBx)																 //
   6432                   // --------------------------------------------------------------------------------------------------//
   6433          
   6434                   // 2.1.4. Shutter Set (0x05)
   6435                   stTSM.SHUTTER_SET = AT24C256C_EEPROM_Read(EEP_SHUTTER_SET);
   6436          
   6437                   // 2.1.15. Digital Zoom Enable (0x1C)
   6438                   stTSM.DIGITAL_ZOOM_ENABLE = AT24C256C_EEPROM_Read(EEP_DIGITAL_ZOOM_ENABLE);
   6439          
   6440                   // 2.1.19. AGC Mode Set (0x26)
   6441                   stTSM.AGC_MODE_SET = AT24C256C_EEPROM_Read(EEP_AGC_MODE_SET);
   6442          
   6443                   // 2.1.20. Color Mode Set (0x27)
   6444                   stTSM.COLOR_MODE_SET = AT24C256C_EEPROM_Read(EEP_COLOR_MODE_SET);
   6445          
   6446                   // 2.1.21. Contrast/Brightness (0x28) (when, AGC OFF)
   6447                   stTSM.CONTRAST_BRIGHTNESS_ENABLE = AT24C256C_EEPROM_Read(EEP_CONTRAST_BRIGHTNESS_ENABLE);
   6448                   stTSM.CONTRAST_BRIGHTNESS_VAL = AT24C256C_EEPROM_Read(EEP_CONTRAST_BRIGHTNESS_VAL);
   6449          
   6450                   // 2.1.22. AGC Center Position Set (0x29)
   6451                   stTSM.AGC_CENTER_POSITION_SET = AT24C256C_EEPROM_Read(EEP_AGC_CENTER_POSITION_SET);
   6452          
   6453                   // 2.1.23. AGC Limit Level Set (0x2A)
   6454                   stTSM.AGC_LIMIT_LEVEL_SET = AT24C256C_EEPROM_Read(EEP_AGC_LIMIT_LEVEL_SET);
   6455          
   6456                   // 2.1.24. AGC ROI (AGC Region of Interest) Set (0x2B)
   6457                   stTSM.AGC_ROI = AT24C256C_EEPROM_Read(EEP_AGC_ROI);
   6458          
   6459                   // 2.1.25. MIDE Level Set (0x2C) (when, Sharpness OFF)
   6460                   stTSM.MIDE_LEVEL_SET = AT24C256C_EEPROM_Read(EEP_MIDE_LEVEL_SET);
   6461          
   6462                   // 2.1.26. Sharpness Level Set (0x2D) (when, MIDE OFF)
   6463                   stTSM.SHARPNESS_LEVEL_SET = AT24C256C_EEPROM_Read(EEP_SHARPNESS_LEVEL_SET);
   6464          
   6465                   // 2.1.27. Detect Mode Set (0x31)
   6466                   // 2.1.28. Area Position Set (0x32)
   6467                   // 2.1.29. Spot Position Set (0x33)
   6468                   // 2.1.30. High Alarm Temperature (0x34)
   6469                   // 2.1.31. Low Alarm Temperature (0x35)
   6470                   // 2.1.32. Select Alarm (0x36)
   6471                   // 2.1.33. Alarm Mode (0x37)
   6472                   // 2.1.34. Temperature OSD (0x38)
   6473                   // 2.1.35. Emissivity Set (0x39)
   6474                   // 2.1.36. Mirror Mode Set (0x44)
   6475                   // 2.1.37. Flip Mode Set (0x45)
   6476          
   6477                   // 2.1.39. Image Color Inverse(White/Black Hot) Set (0x47)
   6478                   stTSM.IMAGE_COLOR_INVERSE_SET = AT24C256C_EEPROM_Read(EEP_IMAGE_COLOR_INVERSE_SET);
   6479          
   6480                   break;
   6481                }
   6482             }
   6483          
   6484             // =======================================
   6485             // Data Write
   6486             // =======================================
   6487             else
   6488             {
   6489                switch (stINFO.MODULE_TYPE)
   6490                {
   6491                case SONY_MODULE:
   6492          
   6493                   // --------------------------------------------------------------------------------------------------//
   6494                   // STATUS																						 	 //
   6495                   // --------------------------------------------------------------------------------------------------//
   6496                   stSONY.SET_NTSC_PAL_MODE = NTSC_MODE;
   6497                   AT24C256C_EEPROM_Write(EEP_SET_NTSC_PAL_MODE, stSONY.SET_NTSC_PAL_MODE);
   6498          
   6499                   // --------------------------------------------------------------------------------------------------//
   6500                   // 1. Color Module Control Command (0xAx)																 //
   6501                   // --------------------------------------------------------------------------------------------------//
   6502          
   6503                   /***************************************************************************************************************************
   6504                   * 1.1.	Set Focus Mode (0x91)
   6505                      - 0x00 : Auto Focus
   6506                      - 0x01 : Manual Focus
   6507                      - 0x02 : One Push Trigger
   6508                   ****************************************************************************************************************************/
   6509                   stSONY.SET_FOCUS_MODE = 0x00;
   6510                   AT24C256C_EEPROM_Write(EEP_SET_FOCUS_MODE, stSONY.SET_FOCUS_MODE);
   6511          
   6512                   /***************************************************************************************************************************
   6513                   * 1.2.	Set Auto Focus Mode (0x93)
   6514                      - 0x00 : Normal 
   6515                      - 0x01 : Zoom Trigger
   6516                   ****************************************************************************************************************************/
   6517                   stSONY.SET_AUTO_FOCUS_MODE = 0x00;
   6518                   AT24C256C_EEPROM_Write(EEP_SET_AUTO_FOCUS_MODE, stSONY.SET_AUTO_FOCUS_MODE);
   6519          
   6520                   // 1.3.	Manual Focus Mode (0x08)
   6521                   // 1.4.	Manual Focus Direct (0x48)
   6522                   // 1.5.	Manual Zoom Mode (0x07)
   6523                   // 1.6.	Manual Zoom Direct (0x47)
   6524          
   6525                   /***************************************************************************************************************************
   6526                   * 1.7.	Set BLC Mode (0x31)
   6527                      - 0x00 : BLC/WDR OFF
   6528                      - 0x01 : BLC ON
   6529                      - 0x10 : WDR ON
   6530                      - 0x11 : BLC/WDR ON
   6531                   ****************************************************************************************************************************/
   6532                   stSONY.SET_BLC_MODE = 0x00;
   6533                   AT24C256C_EEPROM_Write(EEP_SET_BLC_MODE, stSONY.SET_BLC_MODE);
   6534          
   6535                   /***************************************************************************************************************************
   6536                   * 1.8.	Set White Balance Mode (0x33)
   6537                      - 0x00 : Auto white balance Mode (Range : 3000 to 7500K)
   6538                      - 0x01 : In door Mode
   6539                      - 0x02 : Out door Mode
   6540                      - 0x03 : Auto tracing white balance Mode (Range : 2000 to 10000K))
   6541                   ****************************************************************************************************************************/
   6542                   stSONY.SET_WHITE_BALANCE_MODE = 0x00;
   6543                   AT24C256C_EEPROM_Write(EEP_SET_WHITE_BALANCE_MODE, stSONY.SET_WHITE_BALANCE_MODE);
   6544          
   6545                   /***************************************************************************************************************************
   6546                   * 1.9.	Set Defog Mode (0x37)
   6547                      - 0x00 : Defog Off
   6548                      - 0x01 : Defog On
   6549                   ****************************************************************************************************************************/
   6550                   stSONY.SET_DEFOG_MODE = 0x00;
   6551                   AT24C256C_EEPROM_Write(EEP_SET_DEFOG_MODE, stSONY.SET_DEFOG_MODE);
   6552          
   6553                   /***************************************************************************************************************************
   6554                   * 1.10.	Set Shutter Speed (0x4A)
   6555                      - 0x00 : Shutter Speed Auto
   6556                      - 0x00~0x16 (when, DSS On)
   6557                      - 0x00, 0x07~0x16 (when, DSS Off)
   6558                   ****************************************************************************************************************************/
   6559                   stSONY.SET_SHUTTER_SPEED = 0x00;
   6560                   AT24C256C_EEPROM_Write(EEP_SET_SHUTTER_SPEED, stSONY.SET_SHUTTER_SPEED);
   6561          
   6562                   /***************************************************************************************************************************
   6563                   * 1.11.	Set Flicker Mode (0x55)
   6564                      - 0x00 : Flicker OFF
   6565                      - 0x01 : Flicker ON
   6566                   ****************************************************************************************************************************/
   6567                   stSONY.SET_FLICKER_MODE = 0x00;
   6568                   AT24C256C_EEPROM_Write(EEP_SET_FLICKER_MODE, stSONY.SET_FLICKER_MODE);
   6569          
   6570                   /***************************************************************************************************************************
   6571                   * 1.12.	Set Aperture Value (0x59)
   6572                      - 0x00~0x0F (16 Step)
   6573                   ****************************************************************************************************************************/
   6574                   stSONY.SET_APERTURE_VALUE = 0x00;
   6575                   AT24C256C_EEPROM_Write(EEP_SET_APERTURE_VALUE, stSONY.SET_APERTURE_VALUE);
   6576          
   6577                   /***************************************************************************************************************************
   6578                   * 1.13.	Set Digital Zoom Mode (0x5B)
   6579                      - 0x00 : D Zoom OFF
   6580                      - 0x01 : D Zoom ON
   6581                   ****************************************************************************************************************************/
   6582                   stSONY.SET_DIGITAL_ZOOM_MODE = 0x00;
   6583                   AT24C256C_EEPROM_Write(EEP_SET_DIGITAL_ZOOM_MODE, stSONY.SET_DIGITAL_ZOOM_MODE);
   6584          
   6585                   /***************************************************************************************************************************
   6586                   * 1.14.	Set Day & Night Mode (0x5F)
   6587                      - 0x00 : Night Mode
   6588                      - 0x01 : Day Mode 
   6589                      - 0x02 : Auto Mode
   6590                   ****************************************************************************************************************************/
   6591                   stSONY.SET_DAY_NIGHT_MODE = 0x02;
   6592                   AT24C256C_EEPROM_Write(EEP_SET_DAY_NIGHT_MODE, stSONY.SET_DAY_NIGHT_MODE);
   6593          
   6594                   /***************************************************************************************************************************
   6595                   * 1.15.	Set DSS Mode (0x61)
   6596                      - 0x00 : DSS OFF
   6597                      - 0x01 : DSS ON
   6598                   ****************************************************************************************************************************/
   6599                   stSONY.SET_DSS_MODE = 0x00;
   6600                   AT24C256C_EEPROM_Write(EEP_SET_DSS_MODE, stSONY.SET_DSS_MODE);
   6601          
   6602                   /***************************************************************************************************************************
   6603                   * 1.16.	Select BLC / WDR (0x85)
   6604                      - 0x00 : BLC Mode Select
   6605                      - 0x01 : WDR Mode Select
   6606                   ****************************************************************************************************************************/
   6607                   stSONY.SELECT_BLC_WDR = 0x00;
   6608                   AT24C256C_EEPROM_Write(EEP_SELECT_BLC_WDR, stSONY.SELECT_BLC_WDR);
   6609          
   6610                   /***************************************************************************************************************************
   6611                   * 1.17.	Set High Resolution (0x87)
   6612                      - 0x00 : HR Mode OFF
   6613                      - 0x01 : HR Mode On
   6614                   ****************************************************************************************************************************/
   6615                   stSONY.SET_HIGH_RESOLUTION = 0x00;
   6616                   AT24C256C_EEPROM_Write(EEP_SET_HIGH_RESOLUTION, stSONY.SET_HIGH_RESOLUTION);
   6617          
   6618                   /***************************************************************************************************************************
   6619                   * 1.18.	Set Image Stabilizer (0x89)
   6620                      - 0x00 : IS Mode OFF
   6621                      - 0x01 : IS Mode On
   6622                   ****************************************************************************************************************************/
   6623                   stSONY.SET_IMAGE_STABILIZER = 0x00;
   6624                   AT24C256C_EEPROM_Write(EEP_SET_IMAGE_STABILIZER, stSONY.SET_IMAGE_STABILIZER);
   6625          
   6626                   /***************************************************************************************************************************
   6627                   * 1.19.	Set Noise Reduction (0x8B)
   6628                      - 0x00 : NR OFF
   6629                      - 0x01~0x05 : NR ON [Sensitivity]
   6630                   ****************************************************************************************************************************/
   6631                   stSONY.SET_NOISE_REDUCTION = 0x00;
   6632                   AT24C256C_EEPROM_Write(EEP_SET_NOISE_REDUCTION, stSONY.SET_NOISE_REDUCTION);
   6633          
   6634                   // --------------------------------------------------------------------------------------------------//
   6635                   // 5. Option Command (0xEx)																			 //
   6636                   // --------------------------------------------------------------------------------------------------//
   6637                   // 5.2. Set Wiper (0x02)
   6638                   stWIPER2.COUNT = 0x01;
   6639                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_COUNT, stWIPER2.COUNT);
   6640          
   6641                   stWIPER2.DWELL_TIME = 0x00;
   6642                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_DWELL_TIME, stWIPER2.DWELL_TIME);
   6643          
   6644                   // 5.22. Set Wiper Option (0x22)
   6645                   stWIPER2.OPTION = WIPER_NORMAL_MODE;
   6646                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_OPTION, stWIPER2.OPTION);
   6647          
   6648                   stWIPER2.SPRITE_TIME = 0x00;
   6649                   AT24C256C_EEPROM_Write(EEP_SET_WASHER_SPRITE_TIME, stWIPER2.SPRITE_TIME);
   6650          
   6651                   stWIPER2.CONTINUOUS_TIME = 0x00;
   6652                   AT24C256C_EEPROM_Write(EEP_SET_WIPER_CONTINUOUS_TIME, stWIPER2.CONTINUOUS_TIME);
   6653          
   6654                   break;
   6655          
   6656                case TSM_MODULE:
   6657          
   6658                   // --------------------------------------------------------------------------------------------------//
   6659                   // STATUS																							 //
   6660                   // --------------------------------------------------------------------------------------------------//
   6661                   stTSM.SET_NTSC_PAL_MODE = NTSC_MODE;
   6662                   AT24C256C_EEPROM_Write(EEP_SET_NTSC_PAL_MODE, stTSM.SET_NTSC_PAL_MODE);
   6663          
   6664                   // --------------------------------------------------------------------------------------------------//
   6665                   // 2. Thermal Module Control Command (0xBx)																 //
   6666                   // --------------------------------------------------------------------------------------------------//
   6667          
   6668                   /***************************************************************************************************************************
   6669                   * 2.1.4. Shutter Set (0x05)
   6670                      - 0x00 = Shutter Open
   6671                     		   - 0x01 = Shutter Close
   6672                   ****************************************************************************************************************************/
   6673                   stTSM.SHUTTER_SET = 0x00;
   6674                   AT24C256C_EEPROM_Write(EEP_SHUTTER_SET, stTSM.SHUTTER_SET);
   6675          
   6676                   /***************************************************************************************************************************
   6677                   * 2.1.15. Digital Zoom Enable (0x1C)
   6678                      - 0x00 = Shutter Open
   6679                     		   - 0x01 = Shutter Close
   6680                   ****************************************************************************************************************************/
   6681                   stTSM.DIGITAL_ZOOM_ENABLE = 0x00;
   6682                   AT24C256C_EEPROM_Write(EEP_DIGITAL_ZOOM_ENABLE, stTSM.DIGITAL_ZOOM_ENABLE);
   6683          
   6684                   /***************************************************************************************************************************
   6685                   * 2.1.19. AGC Mode Set (0x26)
   6686                      - 0x00 = AGC Mode OFF
   6687                      - 0x01 = AGC Mode
   6688                      - 0x02 = WAGC Mode
   6689                   ****************************************************************************************************************************/
   6690                   stTSM.AGC_MODE_SET = 0x00;
   6691                   AT24C256C_EEPROM_Write(EEP_AGC_MODE_SET, stTSM.AGC_MODE_SET);
   6692          
   6693                   /***************************************************************************************************************************
   6694                   * 2.1.20. Color Mode Set (0x27)
   6695                      - 0x00 = Gray Color Mode
   6696                      - 0x01 = Rainbow Color Mode
   6697                      - 0x02 = Iron Color Mode
   6698                      - 0x03 = Glowbow Color Mode
   6699                      - 0x04 = 2Color Mode
   6700                   ****************************************************************************************************************************/
   6701                   stTSM.COLOR_MODE_SET = 0x00;
   6702                   AT24C256C_EEPROM_Write(EEP_COLOR_MODE_SET, stTSM.COLOR_MODE_SET);
   6703          
   6704                   /***************************************************************************************************************************
   6705                   * 2.1.21. Contrast/Brightness (0x28) (when, AGC OFF)
   6706                      - 0x00:None, 0x01:Contrast, 0x02:Brightnes
   6707                      - [1..255] = GAIN Level (default : 127)
   6708                      - [1..255] = OFFSET Level (default : 127)
   6709                   ****************************************************************************************************************************/
   6710                   stTSM.CONTRAST_BRIGHTNESS_ENABLE = 0x00;
   6711                   AT24C256C_EEPROM_Write(EEP_CONTRAST_BRIGHTNESS_ENABLE, stTSM.CONTRAST_BRIGHTNESS_ENABLE);
   6712          
   6713                   stTSM.CONTRAST_BRIGHTNESS_VAL = 0x7F;
   6714                   AT24C256C_EEPROM_Write(EEP_CONTRAST_BRIGHTNESS_VAL, stTSM.CONTRAST_BRIGHTNESS_VAL);
   6715          
   6716                   /***************************************************************************************************************************
   6717                   * 2.1.22. AGC Center Position Set (0x29)
   6718                      - [25..75%] default 50%
   6719                   ****************************************************************************************************************************/
   6720                   stTSM.AGC_CENTER_POSITION_SET = 50;
   6721                   AT24C256C_EEPROM_Write(EEP_AGC_CENTER_POSITION_SET, stTSM.AGC_CENTER_POSITION_SET);
   6722          
   6723                   /***************************************************************************************************************************
   6724                   * 2.1.23. AGC Limit Level Set (0x2A)
   6725                      - [1..9] = AGC Limit Level
   6726                      - {1=X1, 2=X1.5, 3=X2, 4=X2.5, 5=X3, 6=X5, 7=X9, 8=X15, 9=X30}
   6727                   ****************************************************************************************************************************/
   6728                   stTSM.AGC_LIMIT_LEVEL_SET = 0x04;
   6729                   AT24C256C_EEPROM_Write(EEP_AGC_LIMIT_LEVEL_SET, stTSM.AGC_LIMIT_LEVEL_SET);
   6730          
   6731                   /***************************************************************************************************************************
   6732                   * 2.1.24. AGC ROI (AGC Region of Interest) Set (0x2B)
   6733                      - 0x00 : FULL
   6734                      - 0x01 : CENTER
   6735                      - 0x02 : UNDER
   6736                      - 0x03 : UPPER
   6737                      - 0x04 : LEFT
   6738                      - 0x05 : RIGHT
   6739                   ****************************************************************************************************************************/
   6740                   stTSM.AGC_ROI = 0x01;
   6741                   AT24C256C_EEPROM_Write(EEP_AGC_ROI, stTSM.AGC_ROI);
   6742          
   6743                   /***************************************************************************************************************************
   6744                   * 2.1.25. MIDE Level Set (0x2C) (when, Sharpness OFF)
   6745                      - [0..15] = {0:OFF, 1..15:MIDE Level}
   6746                   ****************************************************************************************************************************/
   6747                   stTSM.MIDE_LEVEL_SET = 0x00;
   6748                   AT24C256C_EEPROM_Write(EEP_MIDE_LEVEL_SET, stTSM.MIDE_LEVEL_SET);
   6749          
   6750                   /***************************************************************************************************************************
   6751                   * 2.1.26. Sharpness Level Set (0x2D) (when, MIDE OFF)
   6752                      - [0..10] = {0:OFF, 1..10:Sharpness Level}
   6753                   ****************************************************************************************************************************/
   6754                   stTSM.SHARPNESS_LEVEL_SET = 0x00;
   6755                   AT24C256C_EEPROM_Write(EEP_SHARPNESS_LEVEL_SET, stTSM.SHARPNESS_LEVEL_SET);
   6756          
   6757                   // 2.1.27. Detect Mode Set (0x31)
   6758                   // 2.1.28. Area Position Set (0x32)
   6759                   // 2.1.29. Spot Position Set (0x33)
   6760                   // 2.1.30. High Alarm Temperature (0x34)
   6761                   // 2.1.31. Low Alarm Temperature (0x35)
   6762                   // 2.1.32. Select Alarm (0x36)
   6763                   // 2.1.33. Alarm Mode (0x37)
   6764                   // 2.1.34. Temperature OSD (0x38)
   6765                   // 2.1.35. Emissivity Set (0x39)
   6766                   // 2.1.36. Mirror Mode Set (0x44)
   6767                   // 2.1.37. Flip Mode Set (0x45)
   6768          
   6769                   /***************************************************************************************************************************
   6770                   * 2.1.39. Image Color Inverse(White/Black Hot) Set (0x47)
   6771                      - 0x00 = Inverse Mode OFF(White Hot)
   6772                      - 0x01 = Inverse Mode ON(Black Hot)
   6773                   ****************************************************************************************************************************/
   6774                   stTSM.IMAGE_COLOR_INVERSE_SET = 0x00;
   6775                   AT24C256C_EEPROM_Write(EEP_IMAGE_COLOR_INVERSE_SET, stTSM.IMAGE_COLOR_INVERSE_SET);
   6776          
   6777                   break;
   6778                }
   6779          
   6780                AT24C256C_EEPROM_Write(EEP_PROM_MARK, EEP_HEADER);
   6781          
   6782             }
   6783          }
   6784          
   6785          /*******************************************************************************
   6786          * IBDR Main Function
   6787          *******************************************************************************/
   6788          int main(void)
   6789          {
   6790             // =======================================
   6791             // Initialization Device
   6792             // =======================================
   6793             Initial_Device();
   6794          
   6795             while (1)
   6796             {
   6797          
   6798          /* LED ON/OFF */
   6799          //	      LED_On_Red();
   6800          //	      Delay_1ms(500);
   6801          //	      LED_Off_Red();
   6802          //	      Delay_1ms(500);
   6803          //		  
   6804          //	      LED_On_Green();
   6805          //	      Delay_1ms(500);
   6806          //	      LED_Off_Green();
   6807          //	      Delay_1ms(500);
   6808          //		  
   6809          //	      LED_On_Yellow();
   6810          //	      Delay_1ms(500);
   6811          //	      LED_Off_Yellow();
   6812          //	      Delay_1ms(500);
   6813          
   6814          
   6815          /* SW + LED ON/OFF */
   6816          //	      User_SW_On_LED_Ren_On();
   6817          
   6818             }
   6819          
   6820          } //End Main
   6821          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  AT24C256C_EEPROM_Read
               8 -> I2C2_Read
       16  AT24C256C_EEPROM_Write
              16 -> I2C2_Write
        0  Auto_Day_And_Night_Control
       56  Before_USART1_Data_Parser
              56 -> GPIO_ResetBits
              56 -> GPIO_SetBits
              56 -> Reponse_Data_Send
              56 -> Send_Light_Data
              56 -> Send_Sony_Data
        8  Bypass_Data_Parser
               8 -> Delay_1ms
               8 -> USART_SendData
        0  CDS_Data_Check
        0  DATA_Request_Handing
        8  EEPROM_Memory_Read
               8 -> AT24C256C_EEPROM_Read
               8 -> AT24C256C_EEPROM_Write
        8  Fan_Heater_Control
               8 -> GPIO_ResetBits
               8 -> GPIO_SetBits
               8 -> Temperature_Convert_Data
        8  LRF_Initialization
               8 -> Send_LRF_Data
        8  MDIN_I550_Initialization
               8 -> Delay_ms
               8 -> GPIO_ReadInputDataBit
               8 -> GPIO_ResetBits
               8 -> GPIO_SetBits
               8 -> MDIN_Sprite_Initialization
      136  MDIN_Sprite_Initialization
             136 -> Send_MDIN_Data
       16  Module_Auto_Sync
              16 -> Delay_1ms
              16 -> Send_Sony_Data
              16 -> Send_TSM_Data
              16 -> UART4_Init
       56  OPTION_Data_Handing
              56 -> AT24C256C_EEPROM_Read
              56 -> AT24C256C_EEPROM_Write
              56 -> Delay_1ms
              56 -> USART_SendData
        8  OSD_Layer_Select
               8 -> MDIN_Sprite_Initialization
       64  PELCO_Data_Handing
              64 -> Send_Pelco_Data
              64 -> Send_Sony_Data
              64 -> Send_TSM_Data
       24  PTZ_Data_Handing
              24 -> Delay_1ms
              24 -> USART_SendData
       16  Reponse_Data_Send
              16 -> USART_SendData
        8  Send_Data_Clear
       16  Send_LRF_Data
              16 -> Delay_1ms
              16 -> USART_SendData
       40  Send_Light_Data
              40 -> Delay_1ms
              40 -> USART_SendData
       40  Send_MDIN_Data
              40 -> Delay_1ms
              40 -> USART_SendData
       32  Send_MDIN_String_Data
              32 -> Delay_1ms
              32 -> USART_SendData
       32  Send_Pelco_Data
              32 -> Delay_1ms
              32 -> USART_SendData
       32  Send_Request_Data
              32 -> Delay_1ms
              32 -> USART_SendData
       24  Send_Sony_Data
              24 -> Delay_1ms
              24 -> USART_SendData
       40  Send_TCM_Data
              40 -> Delay_1ms
              40 -> USART_SendData
       32  Send_TSM_Data
              32 -> Delay_1ms
              32 -> USART_SendData
       32  Send_UART4_Ack
              32 -> Delay_1ms
              32 -> USART_SendData
        8  SetSysClockTo72
               8 -> RCC_DeInit
               8 -> RCC_GetFlagStatus
               8 -> RCC_GetSYSCLKSource
               8 -> RCC_HCLKConfig
               8 -> RCC_HSEConfig
               8 -> RCC_PCLK1Config
               8 -> RCC_PCLK2Config
               8 -> RCC_PLLCmd
               8 -> RCC_PLLConfig
               8 -> RCC_SYSCLKConfig
               8 -> RCC_WaitForHSEStartUp
       48  Sony_Data_Handing
              48 -> AT24C256C_EEPROM_Write
              48 -> Send_Sony_Data
              48 -> USART1_Send_Data
      168  System_Data_Parser
             168 -> Delay_1ms
             168 -> MDIN_I550_Initialization
             168 -> Module_Auto_Sync
             168 -> OPTION_Data_Handing
             168 -> OSD_Layer_Select
             168 -> RCC_APB1PeriphClockCmd
             168 -> Send_MDIN_Data
             168 -> Send_MDIN_String_Data
             168 -> Send_TSM_Data
             168 -> Sony_Data_Handing
             168 -> TCM_Data_Handing
             168 -> TSM_Data_Handing
             168 -> UART4_Init
             168 -> USART_SendData
             168 -> VIDEO_Initialization
             168 -> WWDG_Enable
             168 -> WWDG_SetPrescaler
             168 -> WWDG_SetWindowValue
       88  TCM_Data_Handing
              88 -> Send_TCM_Data
       64  TSM_Data_Handing
              64 -> Delay_1ms
              64 -> Send_TSM_Data
              64 -> USART_SendData
        8  TW9900_DECODER_RESET_High
               8 -> GPIO_SetBits
        8  TW9900_DECODER_RESET_Low
               8 -> GPIO_ResetBits
       16  TW9900_Initial
              16 -> Delay_ms
              16 -> TW9900_DECODER_RESET_High
              16 -> TW9900_I2C1_ByteWrite
        0  Temperature_Boot_Mode
        0  Temperature_Convert_Data
        0  Temperature_Data_Check
       16  UART5_Data_Parser
              16 -> DATA_Request_Handing
              16 -> OPTION_Data_Handing
              16 -> PELCO_Data_Handing
              16 -> PTZ_Data_Handing
              16 -> Sony_Data_Handing
              16 -> TCM_Data_Handing
              16 -> TSM_Data_Handing
      168  USART1_Data_Parser
             168 -> OSD_Layer_Select
             168 -> Send_MDIN_Data
             168 -> Send_MDIN_String_Data
             168 -> Sony_Data_Handing
             168 -> TSM_Data_Handing
       40  USART1_Send_Data
              40 -> Delay_1ms
              40 -> USART_SendData
        8  VIDEO_Initialization
               8 -> Delay_1ms
               8 -> Delay_ms
               8 -> GPIO_ResetBits
               8 -> GPIO_SetBits
               8 -> TW9900_DECODER_RESET_Low
               8 -> TW9900_Initial
        0  Zoom_Data_Sync
       40  Zoom_Light_Auto_Control
              40 -> Send_Light_Data
        8  main
               8 -> Initial_Device


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable14
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_2
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable20
       4  ??DataTable20_1
       4  ??DataTable20_2
       4  ??DataTable20_3
       4  ??DataTable20_4
       4  ??DataTable20_5
       4  ??DataTable20_6
       4  ??DataTable20_7
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable21_2
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_2
       4  ??DataTable22_3
       4  ??DataTable22_4
       4  ??DataTable23
       4  ??DataTable24
       4  ??DataTable24_1
       4  ??DataTable24_2
       4  ??DataTable24_3
       4  ??DataTable24_4
       4  ??DataTable24_5
       4  ??DataTable28
       4  ??DataTable29
       4  ??DataTable29_1
       4  ??DataTable36
       4  ??DataTable36_1
       4  ??DataTable38
       4  ??DataTable38_1
       4  ??DataTable38_2
       4  ??DataTable38_3
       4  ??DataTable38_4
       4  ??DataTable38_5
       4  ??DataTable39
       4  ??DataTable39_1
       4  ??DataTable39_10
       4  ??DataTable39_2
       4  ??DataTable39_3
       4  ??DataTable39_4
       4  ??DataTable39_5
       4  ??DataTable39_6
       4  ??DataTable39_7
       4  ??DataTable39_8
       4  ??DataTable39_9
       1  ABB_255_Flag
       1  ABB_Heater_Set
       1  ACTdCount
       1  ACTnCount
       4  ADCConvertedData
       8  ADCConvertedValue
       4  ADC_Value
       1  AFMTimer
       1  AFManual
       1  AFMode
      12  AFMsg
       1  AFactFlag
       4  AFmsTimer
       1  AFocusFlag
       1  AFsTimer
      20  AGCFreezeMsg
       1  AGCGainBias
       1  AGCLevelBias
       1  AGCLimitLevel
       1  AGCMode
      12  AGCMsg
      44  AGCstatusMsg
       1  AIrisFlag
      14  AT24C256C_EEPROM_Read
      20  AT24C256C_EEPROM_Write
      16  AWBModeMsg
       1  AbsFocusFlag
       1  AdBufCnt
       4  AdCDS
       4  AdCDSBuf
       1  AdChkCnt
       4  AdDone
       4  AdDoneCnt
       4  AdFar
       4  AdFarBuf
       4  AdNear
       4  AdNearBuf
       1  AdProCnt
       1  AdjFlag
      24  AgcFMsg
      24  AgcHMsg
      24  AgcLMsg
      24  AgcMMsg
      56  AgcMsg
       1  AgcVal
       4  AlarmCount
       1  AlarmDetect
       4  AlarmDetectMsg
       1  AlarmDisplayFlag
       1  AlarmFlag
       1  AlarmInMode
       1  AlarmMode
       4  AlarmMsg
      16  AlarmSetMsg
      16  AlarmStatusMsg
      84  AllEraseMsg
      92  AllMsg
       4  AlmAct
      56  AlmActMsg
       4  AlmAuxAct
       8  AlmAuxCnt
       1  AlmBlk
       1  AlmBuf
       1  AlmEnable
       1  AlmFlag
      56  AlmInMsg
       4  AlmInput
      64  AlmMMsg
      64  AlmMsg
       1  AlmNo
      56  AlmNoMsg
       1  AlmOSD
      84  AlmOffMsg
      84  AlmOnMsg
       1  AlmRecv
       1  AlmRx
       1  AlmT
       1  AlmTemp
       1  AperVal
      56  AptMsg
      48  AreaMsg
      52  AutoDrMsg
      52  AutoDwMsg
      52  AutoEdMsg
      52  AutoFnMsg
      12  AutoFocusMsg
      68  AutoMsg
       8  AutoPanMsg
      52  AutoSpdMsg
      52  AutoStMsg
     252  Auto_Day_And_Night_Control
       1  Aux1Buf
      80  Aux1OffMsg
      80  Aux1OnMsg
       1  Aux2Buf
      80  Aux2OffMsg
      80  Aux2OnMsg
      56  AuxActMsg
       1  AuxMode
      16  AuxMsg
       8  BackBuf
      48  BaudMsg
       1  BaudRate
       1  Baud_Buffer
      44  BaudrateMsg
    1768  Before_USART1_Data_Parser
      12  BlankMsg
       1  BlcAreaBottom
       1  BlcAreaLeft
       1  BlcAreaMode
       1  BlcAreaRight
       1  BlcAreaSel
       1  BlcAreaTop
       1  BlcEn
       1  BlcEnI
       1  BlcLevel
       1  BlcMode
      20  BlcMode1Msg
      12  BlcModeMsg
      12  BlcModeSMsg
      56  BlcMsg
      60  BlcOffMsg
      60  BlcOnMsg
      56  BlcSetMsg
      20  BlcShortModeMsg
       1  BlcSubCur
       1  BlcSubEn
       1  BlcSubMenu
      24  BlcSubModeMsg
       4  BlkMsg
     102  Bypass_Data_Parser
       8  CDSMsg
       4  CDS_Average_Value
       4  CDS_Buffer_Cnt
     128  CDS_Data_Check
       4  CDS_Day_Check_Cnt
       4  CDS_Night_Check_Cnt
       4  CDS_Total_Value
       4  CDS_convertV
       1  COMMAND_CODE
      20  CRxBuf
       1  CRxReceived
       1  CRxTail
      20  CTxBuf
       1  CTxMax
       1  CTxTail
       1  CURRENT_STATUS
      24  CZoomModeMsg
      20  CZoomOffMsg
      20  CZoomOnMsg
       1  CZoomSet
       1  CamCodeRecv
      48  CamDisMsg
       1  CamID_Buffer
      64  CamIdMsg
       8  CamIdsMsg
      20  CamInitialMsg
       1  CamModuleInfo
      16  CamRxBuf
       1  CamRxCnt
      64  CamSetMsg
      72  CamTestMsg
      20  CamTxBuf
       1  CamType
       8  CamType1Msg
       8  CamType2Msg
      24  CdZoomModeMsg
      20  CdZoomOffMsg
      20  CdZoomOnMsg
       1  CdZoomSet
      36  CelsiMsg
       1  CharLeng
      24  CheckHeater1Msg
      28  CheckHeaterMsg
      36  CheckLockMsg
       1  CheckSum
      36  CheckSyncMsg
       4  CheckTempValue
      28  CheckZoomMsg
       1  Check_Byte
       1  ChkFlag
      68  ChkMsg
      20  ChkOkMsg
      20  ClrMsg
       1  CndFlag
       1  CntReplyAlm
       4  CntSetReq
      36  CodiMsg
       1  CodiRef
       1  ColBaudFlag
       1  ColdCondition
       4  ColdCondition_Check_Time
       1  ColdCondition_Timer_Flag
      16  ColdStart1Msg
      12  ColdStartMsg
       1  Cold_Module_Init_Check
       1  Cold_Start_EnableFlag
       1  ColorBaud
      16  ColorCamMsg
      20  ColorModuleMsg
      56  ColorMsg
       8  ColorTMsg
       4  ColorVal
      16  ColorbaudMsg
       1  CommAcc
       1  CommAccA
       1  CommAccB
      20  CommErrMsg
       1  CommRate
      16  ConfigMsg
      92  ContinuousTimeMsg
       1  ConvertData
       1  DATA1_CODE
       1  DATA2_CODE
       2  DATA_Request_Handing
      36  DN0Msg
      36  DN1Msg
      36  DN2Msg
      72  DNAMsg
      72  DNDMsg
      36  DNLevMsg
       1  DNLevelFlag
       1  DNLevelSet
       1  DNMode
      72  DNNAMsg
      72  DNNMsg
      20  DRSLogoDisplayMsg
       1  DRS_NtPalSet
       1  DRS_RECIVE_COMPLETE
       4  DRS_Zoom_Count
       1  DSSMode
      76  DSSValMsg
       1  DZoom
       1  DZoomCount
      56  DZoomMsg
       1  DZoomPos
       1  Data_Test
       1  DayFlag
       4  DayFlagMsg
       1  DayNightSubMenu
      84  DefaultInitMsg
      60  DefaultMsg
       1  DirectPattFlag
      56  Dis1Msg
       1  DisEn
      36  DisMsg
       8  DisOffMsg
       8  DisOnMsg
       4  DispBuf
      20  DispCode
      56  DnNMsg
       1  DnrMode
      56  DnrMsg
       1  DomeId
      56  DssMsg
      72  DssNAMsg
      72  DssOffMsg
      72  DssOnMsg
       4  DwellMs
       4  DwellSec
    1002  EEPROM_Memory_Read
       1  EXCUTE_CODE
      36  EnMsg
      12  EngErrMsg
      32  EnglishMsg
      16  EpromCheckMsg
      80  EraseMsg
      32  EraseMsgClr
       4  ErrData
      60  ErrMsg
       1  Error_Offset_Check
       1  Error_Repeat_Cnt
      24  ExitMsg
      20  External_Title_Msg
       1  FRZMode
      36  FahreMsg
       1  FailFlag
       1  FanBuf
       1  FanFlag
       8  FanOffMsg
       8  FanOnMsg
       8  FanSetMsg
       1  Fan_Dewell_End_Flag
       1  Fan_Dewell_Flag
       4  Fan_Dwell_Time_ms
       4  Fan_Dwell_Time_sec
     588  Fan_Heater_Control
       1  Fan_Heater_First_Check_Flag
       4  Fan_Heater_First_Check_Time
       1  Fan_Heater_First_On_Flag
       1  Fan_State
      84  FarMsg
      28  FastMsg
       8  FastTMsg
       1  FlagReqAlm
       1  FlagReqSts
      12  FlickerMsg
      64  FlipMsg
      80  FlipOffMsg
      80  FlipOnMsg
      40  FlipStMsg
       1  FlkEn
      56  FlkMsg
      28  FocuFarMsg
      20  FocuNearMsg
       2  FocuPos
       2  FocuPos_SCM
      76  FocusAdjMsg
       1  FocusFlag
       1  FocusMan
      12  FocusModeMsg
       1  FocusModeVal
      88  FocusSSetMsg
      20  FocusSValMsg
       1  FocusSpdVal
       4  FocusStopCount
      12  FourMsg
      40  FreezeAllMsg
      40  FreezeMsg
       1  Freeze_Data
      72  FrzNAMsg
      88  FrzOffMsg
      88  FrzOnMsg
      12  FullAEMsg
       1  GHeaterActFlag
       1  GHeaterBuf
       1  GHeaterDispFlag
       1  GHeaterInter
       1  GHeaterMode
      20  GHeaterOffMsg
       1  GHeaterOffVal
      20  GHeaterOnMsg
       1  GHeaterOnVal
       4  GInterCount
       1  GInterMCount
       1  GInterSCount
       1  GainMode
      32  GainValMsg
      32  GainValMsg1
      16  GlassHeaterMsg
       4  HeatOffMsg
       4  Heater1OnMsg
       4  Heater2OnMsg
       1  HeaterActFlag
      12  HeaterAutoMsg
       1  HeaterFlag
      12  HeaterIntervalMsg
      12  HeaterOffMsg
      12  HeaterOnMsg
      20  HeaterSetMsg
      16  HeaterStatusMsg
       1  Heater_State
      20  HexCode
      24  HighMsg
       1  HitFlag
       1  HlcLevel
       1  HlcMaskColor
      12  HlcModeSMsg
      60  HlcOffMsg
      60  HlcOnMsg
      32  HomeautoMsg
       8  HomeblankMsg
      32  HomepattMsg
      64  HomeposMsg
      32  HomeprstMsg
      32  HomescanMsg
      32  HometourMsg
       1  HrMode
      56  HrMsg
       1  ICRThreshold
       1  ICanTek
      36  IDEHighInfoMsg
      16  IDEModeMsg
       1  IDEModeVal
       1  IDEModeValFlag
      36  IDElowInfoMsg
      16  IRISMsg
       1  IR_Duty_Step
       1  IR_Set_Check
       8  IR_Set_Msg
       1  IR_Test_Mode
       1  ISMode
      56  ISMsg
       1  IdDisp
       1  IdDisp2
      44  IdDispMsg
       1  IdPosBuf
       1  InHeaterDispFlag
       1  InHeaterInter
       1  InHeaterMode
       1  InHeaterOffVal
       1  InHeaterOnVal
       1  InheaterCount_M
       1  InheaterCount_Ms
       1  InheaterCount_S
      64  Init1Msg
      48  Init21Msg
      52  Init2Msg
      56  Init31Msg
      60  Init3Msg
      52  Init41Msg
      48  Init4Msg
      72  Init51Msg
      76  Init5Msg
      60  Init61Msg
      60  Init6Msg
      84  Init71Msg
      84  Init7Msg
      72  InitMsg
       1  InitOpt
      16  InnerHeaterMsg
      20  InnerHeaterOffMsg
      20  InnerHeaterOnMsg
       1  Inner_Heater_State
       4  InterCount
       1  InterMCount
       1  InterSCount
      16  InterTimeMsg
      12  InterValOnePushMsg
       1  InverseMode
      16  InverseModeMsg
      20  InverseOffMsg
      20  InverseOnMsg
      44  IrBrtMsg
       8  IrisAutoMsg
       8  IrisCloseMsg
       1  IrisFlag
      40  IrisLevelMsg
       1  IrisMan
      24  IrisMaxLevelMsg
       1  IrisMaxVal
       1  IrisMode
       1  IrisModeSet
       1  IrisPeakVal
       1  IrisSubMenu
       1  IrisVal
     144  IrisValMsg
       1  Joy_Zoom
       1  JoystickSW
       1  KeyFlag
       1  KeyInputFlag
      42  LRF_Initialization
      64  LangMsg
       1  Language
       4  Led1BlinkTimeMs
       4  Led2BlinkTimeMs
       4  Led3BlinkTimeMs
       1  LedCurFlag
       1  LedFlag
      12  LedOffMsg
      12  LedOnMsg
       1  LedStatus
       4  LeftMsg
      52  LeftTopMsg
      36  LensMsg
       1  LensSetFlag
      12  LensSetMsg
       1  LensVal
      48  LevelMsg
       1  LimFlag
      48  LimitMsg
      24  LoadingMsg
       1  LockEn
      48  LockMsg
       1  LogoEnFlag
       1  LogoModeVal
       8  LogoMsg
      24  LowMsg
      90  MDIN_I550_Initialization
    1250  MDIN_Sprite_Initialization
       1  MODULE_SELECT
      24  MOffMsg
       1  MPVal
      20  MWbBGainMsg
      20  MWbRGainMsg
      24  MainAlmMsg
      48  MainBarMsg
      60  MainCamMsg
      16  MainCameraMsg
       1  MainCur
      60  MainDomMsg
      24  MainExtMsg
      16  MainMsg
      24  MainMsg10
      56  MainMsg2
      52  MainMsg3
      24  MainMsg9
      24  MainPatMsg
      24  MainPreMsg
      64  MainPriMsg
      32  MainScanMsg
      24  MainTitMsg
      16  MainTourMsg
      64  ManMsg
      48  MaskMsg
      28  MediMsg
       1  MenuFlag
       1  MenuKey
       1  Menu_IR_Set
      24  MiddleMsg
       1  MinusFlag
       8  MinuteMsg
       1  MirrorDisp
      56  MirrorMsg
      12  MirrorOffMsg
      12  MirrorOnMsg
       1  Mode
      48  ModeMsg
     118  Module_Auto_Sync
      28  MotorLevH
      24  MotorLevL
      28  MotorLevM
      40  MotorTrqMsg
       1  Motor_FG_Check
       4  Motor_FG_Count
       4  Motor_FG_Save_Buf
       1  Motor_FG_Temp
       4  NAMsg
      16  NCMsg
      16  NOMsg
      24  NTPALMsg
       8  NTSCMsg
       1  NT_PAL_MODE
      16  NameBuf
      20  New_Test_Msg
      56  NextMsg
       1  NightFlag
       4  NightFlagMsg
      12  NineMsg
      12  NoMsg
      36  NoTestMsg
      72  NonData
      36  NonDataClr
      36  NormalMsg
       4  NotAvailableMsg
       1  NtPalMode
       1  NtPalSetFlag
    1066  OPTION_Data_Handing
       1  OSD_Flag
     158  OSD_Layer_Select
       1  OSD_Refresh
      16  OffMsg
       1  OkFlag
       1  OnAlarm
      16  OnMsg
      12  OnePushMsg
       8  OrCode
      16  OsdCamIDMsg
      40  OsdCooMsg
      60  OsdDispMsg
      16  OsdGHeaterMsg
      16  OsdGTempMsg
      16  OsdHeaterMsg
      40  OsdIdMsg
      40  OsdPattMsg
      40  OsdPreMsg
      40  OsdScanMsg
      40  OsdSecMsg
      16  OsdStatusMsg
      40  OsdTourMsg
       8  OsdWiperMsg
       8  PALMsg
      52  PClearMsg
      60  PClrMsg
    1158  PELCO_Data_Handing
      60  PMainMsg
      60  PSaveMsg
      64  PStatusMsg
     144  PTZ_Data_Handing
       4  PanContCnt
       4  PanMsg
      72  PanTestMsg
      16  PanTiltMsg
       1  PassCode
      40  PassMsg
       1  PassWord
      60  PassWordIn1Msg
      80  PassWordIn2Msg
      48  PassWordIn3Msg
      48  PassWordIn4Msg
       4  PassWordIn5Msg
      48  PassWordIn6Msg
      48  PassWordIn7Msg
      52  PassWordIn8Msg
      60  PatClrMsg
      52  PattIdMsg
      52  PattMsg
       8  PattNMsg
      52  PattNoMsg
       1  PattRdyFlag
      52  PattTmMsg
       1  PicFlip
      56  PicFlipMsg
      16  PicFlipOffMsg
      16  PicFlipOnMsg
       1  PinFlag
       1  PreFlag
      44  PreIdMsg
       1  PreIdPosBuf
       1  PreKey
      60  PreMsg
       1  PreNoBuf
      44  PreNoMsg
       1  PreZoomCnt
       1  PrevKey
      60  PrevMsg
      72  PreviMsg
      48  PriActMsg
      28  PriMoveMsg
      48  PriNumMsg
      48  PriStrMsg
      28  PriTLMsg
      12  ProMsg
       8  ProMsg1
       8  ProMsg2
      12  ProMsg3
      16  PromMsg
      36  ProtoMsg
       1  Protocol
       1  RLFlag
       1  RLKey
       1  RS_ZOOM
       1  RUpDay
       1  RUpMonth
       1  RUpYear
      48  RangeMsg
      24  RangeNMsg
      24  RangeWMsg
      84  RdyMarkMsg
      60  ReStartMsg
      64  RecMsg
       1  Recive_Flag
       1  Recover
       1  RecoverF
      20  RecoverTimeSetMsg
       1  RefTemp
      60  RemoteRstMsg
     148  Reponse_Data_Send
      36  ReverseMsg
      52  RightBottomMsg
       4  RightMsg
       1  RlKey
      48  RstMsg
       8  RxBuf
      16  RxBuf1
      12  RxBuf_DRS
      12  RxBuf_SCM
       1  RxCnt
       1  RxCnt_DRS
       1  RxCnt_SCM
       1  RxMaxCnt
       1  RxMaxCnt_DRS
       1  RxPoint
       1  RxStt1
       1  RxStt_BD
       1  RxTemp
       1  SCM_RECIVE_COMPLETE
       8  SClrMsg
       4  SECMsg
       1  SMark
       1  SSDREn
       4  SSDRLevel
       1  SSDRrange
      48  SaveExitMsg
       1  SaveFlag
      24  SaveMsg
      24  SavingMsg
      24  ScheduleTourDwellMsg
      28  ScheduleTourSpeedMsg
      52  SecFnMsg
      52  SecIdMsg
      60  SecMsg
      52  SecNoMsg
      52  SecStMsg
       8  SecondBuf
       1  SecondCnt
      42  Send_Data_Clear
     470  Send_LRF_Data
     150  Send_Light_Data
     836  Send_MDIN_Data
     242  Send_MDIN_String_Data
     148  Send_Pelco_Data
    1004  Send_Request_Data
     400  Send_Sony_Data
     296  Send_TCM_Data
     122  Send_TSM_Data
     326  Send_UART4_Ack
       1  SetFlag
      94  SetSysClockTo72
       1  SetUpFlag
     364  ShuttNTSpdMsg
     364  ShuttPALSpdMsg
      24  ShuttSValMsg
       1  ShutterMode
      40  ShutterModeMsg
       1  ShutterSpd
     132  ShutterSpdMsg
       1  ShutterSpdVal
       1  ShutterSubMenu
      28  SlowMsg
       8  SlowTMsg
    4306  Sony_Data_Handing
       8  Speed
      52  SpeedMsg
      12  SsdrModeSMsg
      60  SsdrOffMsg
      60  SsdrOnMsg
       1  SsnrEn
      16  SsnrFMsg
      16  SsnrHMsg
      16  SsnrLMsg
      16  SsnrMMsg
      56  SsnrMsg
      64  StatusMsg
       4  SubBlcMsg
       1  SubCur
       1  SubFlag
       4  SubWdrMsg
      48  SureMsg
      64  Sys1SetMsg
      60  SysBMsg
      60  SysCMsg
      20  SysColorMsg
      60  SysFMsg
      20  SysModelMsg
      52  SysMsg
      60  SysPMsg
      60  SysRUMsg
      64  SysSetMsg
      60  SysStsMsg
      20  SysThermalMsg
      60  SysUMsg
      16  SystemStartMsg
      16  SystemStatusMsg
    2134  System_Data_Parser
      16  TAGCGainBiasMsg
      16  TAGCLevelBiasMsg
      16  TAGCLimitMsg
      56  TAGCLimitValMsg
      12  TAGCModeMsg
    3194  TCM_Data_Handing
      12  TCamType1Msg
      12  TCamType2Msg
      12  TCamType3Msg
       4  TCdsMsg
      60  TClrMsg
       4  TEMPBuf
       4  TMcount
       1  TModule
       4  TMscount
    2064  TSM_Data_Handing
       4  TScount
      14  TW9900_DECODER_RESET_High
      14  TW9900_DECODER_RESET_Low
      62  TW9900_Initial
      24  TZoomModeMsg
      20  TZoomOffMsg
      20  TZoomOnMsg
       1  TZoomSet
       1  Temp
       4  TempBlankMsg
       1  TempCheckCount
       1  TempCheckFlag
       1  TempCount
       1  TempDispFlag
       1  TempDispVal
       1  TempFlag
       1  TempMonitorting
       8  TempMsg
      12  TempRxBuf
       1  Temp_Count
       1  Temp_Count_S
       4  TemperCnt
       1  TemperFlag
      36  TemperMsg
       1  Temperature
      64  Temperature_Boot_Mode
     930  Temperature_Convert_Data
     164  Temperature_Data_Check
       8  TestData
      40  TestFailMsg
       8  TestMsg
       4  TestOkMsg
      12  TestStartMsg
       1  TestUse
       1  TherBaudFlag
       1  TherBaudSetFlag
       1  ThermalBaud
       1  ThermalBaudset
      16  ThermalCamMsg
      16  ThermalMainCamMsg
      20  ThermalbaudMsg
      16  ThermalbaudsetMsg
       8  ThreeBuf
      20  TiltInitMsg
       8  TiltMsg
       1  TiltRepeat
      72  TiltTestMsg
       4  Time0
       4  Time1ms
       1  Time1ms2
       4  Time1sec
       4  Time50ms
       4  TimeCnt
       1  TimeFlag
       1  TimeLevel
       4  TmCount
       4  Totol_Motor_FG_Count
      60  TourDwellMsg
      36  TourIdMsg
      60  TourMsg
      16  TourNMsg
      52  TourNoMsg
      52  TourPreMsg
      16  TourSetNoMsg
      24  TourSetPrstMsg
      12  TourSetStepMsg
      52  TourStepMsg
      12  TwoMsg
      20  TxBuf
      16  TxBuf1
       1  TxBufCnt1
       1  TxBufCnt_485
       1  TxBufCnt_DRS
       1  TxBufCnt_SCM
      12  TxBuf_485
      12  TxBuf_DRS
       1  TxCnt
       1  TxCnt1
       1  TxCnt_485
       1  TxCnt_DRS
       1  TxMax
       1  TxMaxRef
       1  TxMaxRef_DRS
       1  TxMaxRef_SCM
       1  TxMax_485
       1  TxMax_DRS
       1  TxMax_SCM
      72  TxTestMsg
     226  UART5_Data_Parser
      12  UDateMsg
       8  URxBuf
     776  USART1_Data_Parser
       1  USART1_RECIVE_COMPLETE
      12  USART1_RxBuf
       1  USART1_RxCnt
       1  USART1_RxMaxCnt
     214  USART1_Send_Data
      12  USART1_TempRxBuf
      12  USART3_TxBuf
       1  USART3_TxCnt
       1  UpDownFlag
       1  UpDownKey
      92  VIDEO_Initialization
       8  VerMsg
      72  VibNAMsg
      88  VibOffMsg
      88  VibOnMsg
      24  VideoGainMsg
      48  VideoModeMsg
      36  WB0Msg
      36  WB1Msg
      36  WB2Msg
      36  WB3Msg
      36  WB4Msg
       1  WBMode
      56  WBMsg
       1  WDRnoInc
      48  Wait1Msg
      40  WasherTimeMsg
      16  Washer_Fluid_Msg
       1  Washer_Fluid_Set
       1  Washer_Spray_Flag
       4  Washer_Spray_time
       4  Washer_Spray_time2
       4  Washer_Spray_time2_Delay
      12  Washer_Time_Msg
       4  Washer_Time_Set
       1  Washer_Time_Val
       1  WbBGain
       1  WbRGain
       1  WdrBlcEn
       1  WdrBlcMode
      60  WdrBlcOffMsg
      12  WdrModeSMsg
      56  WdrMsg
      60  WdrOffMsg
      60  WdrOnMsg
      16  WiperActiveMsg
       4  WiperCntMsg
      12  WiperErrorMsg
       4  WiperOnMsg
      20  WiperRepeatOffMsg
      16  WiperRepeatOn2Msg
      16  WiperRepeatOnMsg
      16  WiperSetMsg
      24  WiperSetOffMsg
      24  WiperSetOnMsg
      24  WiperStateMsg
       1  WiperSubMenu
       1  WiperTimelSet
       1  Wiper_Active_1
       4  Wiper_Active_Checktime
       1  Wiper_Active_Cnt
       1  Wiper_Active_Flag
       1  Wiper_Active_Save
       4  Wiper_Add_time
       1  Wiper_Continuous_Delay_Flag
       4  Wiper_Continuous_Delaytime
      16  Wiper_Continuous_Msg
       1  Wiper_Continuous_flag
      12  Wiper_Count_Msg
       1  Wiper_Count_Val
       1  Wiper_Direction_Flag
       1  Wiper_Dwell_Flag
       1  Wiper_Dwell_Time
       1  Wiper_Dwell_Timer_10ms
       1  Wiper_Dwell_Timer_1hour
       1  Wiper_Dwell_Timer_1minute
       1  Wiper_Dwell_Timer_1s
       1  Wiper_Error_Check
       4  Wiper_Error_Check_Time
       4  Wiper_Error_Check_Time_ms
       1  Wiper_Error_Msg
       1  Wiper_Error_Sensor_Check
       1  Wiper_Error_Sensor_Check_Before
       1  Wiper_Error_Status_Flag
       1  Wiper_Manual_Set
       1  Wiper_Origin_Chk
       1  Wiper_Origin_Reset_Chk
       4  Wiper_Repear_delay_time
       1  Wiper_Repeat2_Sensor_Check
       1  Wiper_Repeat_Active_Flag
       1  Wiper_Repeat_Active_Flag2
       4  Wiper_Repeat_Cnt
       1  Wiper_Sens_Count
       1  Wiper_Sens_High
       1  Wiper_Sens_Low
       1  Wiper_Sens_Temp
      12  Wiper_Set_Msg
       1  Wiper_Test_Mode
       4  Wiper_Timer_Chk_Val
       1  Wiper_Timer_Flag
       1  Wiper_Timer_Set
       4  Wiper_Timer_Set_Val
      12  YesMsg
       1  ZCamCodeRecv
      20  ZCamRxBuf
       1  ZCamRxCnt
       2  ZFocuPos
       1  ZOOMDATA_RECIVE_COMPLETE
       1  ZPosRetryCount
       4  ZPosWaitTime
       1  ZPreZoomCnt
      20  ZTxBuf
       1  ZTxCnt
       1  ZTxMax
       1  ZTxMaxRef
       1  ZZoomCnt
       1  ZZoomLed
       2  ZZoomPos
       1  ZZoomTCnt
       8  ZoomBothMsg
       1  ZoomChkCnt
       1  ZoomCnt
       4  ZoomData
       1  ZoomFlag
       1  ZoomInFlag
       1  ZoomLed
      16  ZoomModeMsg
       1  ZoomModeSet
      64  ZoomMsg
       8  ZoomNAMsg
       1  ZoomOutFlag
       2  ZoomPos
       1  ZoomPosCheckCount
       2  ZoomPos_SCM
       1  ZoomRef
       1  ZoomReferanceSpeed
      76  ZoomSSetMsg
      20  ZoomSValMsg
      20  ZoomSetMsg
       1  ZoomSpd
       1  ZoomSpdVal
      16  ZoomSpeedMsg
      16  ZoomStatusMsg
       4  ZoomStopCount
      52  ZoomSyncData19m
      52  ZoomSyncData35m
      52  ZoomSyncData75m
       8  ZoomSyncMsg
       1  ZoomTCnt
       4  ZoomVal
       4  ZoomVal_SCM
    1110  Zoom_Data_Sync
     180  Zoom_Light_Auto_Control
       1  Ztxsendflag
       4  convertV
       4  convertV_Buffer
       4  convertV_Buffer1
     224  defTW9900Sys
     224  defTW9900Thermal
      32  g_Po_Data
       1  inHeaterBuf
      20  inHeaterOffMsg
      20  inHeaterOnMsg
       4  intFlag
       4  inter
       8  main
       1  minusFlag
       4  msCount
       4  msIdleCnt
      12  ntpalsetMsg
      32  pSTR
       1  rxTest2
       1  rxTest3
       1  tx_watch_count
       1  txsendflag
       1  txsendflag_DRS
       1  txsendflag_SCM

 
  1 062 bytes in section .bss
    199 bytes in section .data
 18 192 bytes in section .rodata
 28 008 bytes in section .text
 
 28 008 bytes of CODE  memory
 18 192 bytes of CONST memory
  1 261 bytes of DATA  memory

Errors: none
Warnings: 15
