###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     01/Jul/2022  17:10:05 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\src\Device.c      #
#    Command line =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\src\Device.c -D   #
#                    USE_STDPERIPH_DRIVER -D STM32F10x_HD -D USE_FULL_ASSERT  #
#                    -lcN C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_ #
#                    M32\Debug\List\ -lb C:\Users\TTT\Desktop\zz.STDFW\00.Stu #
#                    dy\project\IAR_M32\Debug\List\ -o                        #
#                    C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_M32\D #
#                    ebug\Obj\ --no_cse --no_unroll --no_inline               #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\I #
#                    AR_M32\..\..\inc\ -I C:\Users\TTT\Desktop\zz.STDFW\00.St #
#                    udy\project\IAR_M32\..\..\Libraries\CMSIS\CM3\DeviceSupp #
#                    ort\ST\STM32F10x\ -I C:\Users\TTT\Desktop\zz.STDFW\00.St #
#                    udy\project\IAR_M32\..\..\Libraries\STM32F10x_StdPeriph_ #
#                    Driver\inc\ -I "C:\Program Files (x86)\IAR               #
#                    Systems\Embedded Workbench 6.0\arm\inc\c\" -On -I        #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_M32\D #
#                    ebug\List\Device.lst                                     #
#    Object file  =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_M32\D #
#                    ebug\Obj\Device.o                                        #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\TTT\Desktop\zz.STDFW\00.Study\src\Device.c
      1          
      2          #include "Device.h"
      3          #include "Common.h"
      4          
      5          /*******************************************************************************
      6          * TYPE DEFINE STRUCTURE
      7          *******************************************************************************/
      8          USART_InitTypeDef USART_InitStructure;
      9          NVIC_InitTypeDef NVIC_InitStructure;
     10          GPIO_InitTypeDef GPIO_InitStructure;
     11          TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
     12          TIM_OCInitTypeDef TIM_OCInitStructure;
     13          DMA_InitTypeDef DMA_InitStructure;
     14          ADC_InitTypeDef ADC_InitStructure;
     15          RCC_ClocksTypeDef  rcc_clocks;
     16          I2C_InitTypeDef	I2C_InitStructure;
     17          
     18          void I2C_Configuration(void);
     19          
     20          
     21          /*******************************************************************************/
     22          uint16_t PrescalerValue = 0;
     23          
     24          /*******************************************************************************
     25          * Dipswitch_Mode_Check
     26          1) MODE 1 
     27          2) MODE 2
     28          - 0x00 : IR LED
     29          - 0x01 : LRF
     30          *******************************************************************************/
     31          void Dipswitch_Mode_Check(void)
     32          {
     33          	stDIP.MODE1 = DIP_MODE1;
     34          	stDIP.MODE2 = DIP_MODE2;
     35          }
     36          
     37          /*******************************************************************************
     38          * Divece Initialization
     39          *******************************************************************************/
     40          void Initial_Device(void)
     41          {
     42          	RCC_Configuration();
     43          	RCC_GetClocksFreq(&rcc_clocks);
     44          	GPIO_Configuration();
     45          
     46          	TIMER_Init();
     47          
     48          	// =======================================
     49          	// Dip Switch Check
     50          	// =======================================	
     51          	Dipswitch_Mode_Check();
     52          	
     53          	// MAIN <-> TILT
     54          	USART1_Init(115200);
     55          
     56          	// MDIN <-> TILT
     57          	USART2_Init(115200);
     58          
     59          	// NONE
     60          	//USART3_Init();
     61          
     62          	// CAMERA <-> TILT
     63          	UART4_Init(38400);
     64          
     65          	// IP B/D <-> TILT
     66          	UART5_Init(115200);
     67          	
     68          	if (SysTick_Config(rcc_clocks.SYSCLK_Frequency / 1000)) {while (1);}
     69          
     70          	NVIC_Configuration();
     71          	DMA_Configuration();
     72          	ADC_Configuration();
     73          	I2C_Configuration();		
     74          }
     75          
     76          /*******************************************************************************
     77          * Function : USART1_Init
     78          *******************************************************************************/
     79          void USART1_Init(u16 BRate)
     80          {
     81              USART_InitStructure.USART_BaudRate   = 115200;
     82              USART_InitStructure.USART_WordLength = USART_WordLength_8b;
     83              USART_InitStructure.USART_StopBits   = USART_StopBits_1;
     84              USART_InitStructure.USART_Parity     = USART_Parity_No ;
     85              USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
     86              USART_InitStructure.USART_Mode       = USART_Mode_Rx | USART_Mode_Tx;
     87          
     88              USART_Init(USART1, &USART_InitStructure);
     89          
     90              USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
     91              USART_ITConfig(USART1, USART_IT_TC, ENABLE);
     92          
     93              USART_Cmd(USART1, ENABLE);
     94          }
     95          
     96          /*******************************************************************************
     97          * Function : USART2_Init
     98          *******************************************************************************/
     99          void USART2_Init(u16 BRate)
    100          {
    101          /*
    102          	switch(BRate)
    103          	{
    104          		case LRF_MODE:
    105          			
    106          			USART_InitStructure.USART_BaudRate   = 19200;
    107          			
    108          			break;
    109          
    110          		case IR_MODE:
    111          
    112          			USART_InitStructure.USART_BaudRate   = 9600;
    113          			
    114          			break;
    115          	}
    116          */
    117          	USART_InitStructure.USART_BaudRate   = BRate;
    118          	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    119          	USART_InitStructure.USART_StopBits   = USART_StopBits_1;
    120          	USART_InitStructure.USART_Parity     = USART_Parity_No ;
    121          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    122          	USART_InitStructure.USART_Mode       = USART_Mode_Rx | USART_Mode_Tx;
    123          
    124          	USART_Init(USART2, &USART_InitStructure);
    125          
    126          	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
    127          	USART_ITConfig(USART2, USART_IT_TC, ENABLE);
    128          
    129          	USART_Cmd(USART2, ENABLE);
    130          }
    131          
    132          /*******************************************************************************
    133          * Function : USART3_Init
    134          *******************************************************************************/
    135          void USART3_Init(void)
    136          {
    137              USART_InitStructure.USART_BaudRate   = 9600;//38400;
    138              USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    139              USART_InitStructure.USART_StopBits   = USART_StopBits_1;
    140              USART_InitStructure.USART_Parity     = USART_Parity_No ;
    141              USART_InitStructure.USART_HardwareFlowControl
    142                                                   = USART_HardwareFlowControl_None;
    143              USART_InitStructure.USART_Mode       = USART_Mode_Rx | USART_Mode_Tx;
    144          
    145              USART_Init(USART3, &USART_InitStructure);
    146          
    147              USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
    148              USART_ITConfig(USART3, USART_IT_TC, ENABLE);
    149          
    150              USART_Cmd(USART3, ENABLE);
    151          }
    152          
    153          /*******************************************************************************
    154          * Function : UART4_Init
    155          *******************************************************************************/
    156          void UART4_Init(u32 BRate)
    157          {
    158          	USART_InitStructure.USART_BaudRate   	= BRate;
    159          	USART_InitStructure.USART_WordLength 	= USART_WordLength_8b;
    160          	USART_InitStructure.USART_StopBits   	= USART_StopBits_1;
    161          	USART_InitStructure.USART_Parity     	= USART_Parity_No ;
    162          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    163          	USART_InitStructure.USART_Mode       	= USART_Mode_Rx | USART_Mode_Tx;
    164          
    165          	USART_Init(UART4, &USART_InitStructure);
    166          
    167          	USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);
    168          	USART_ITConfig(UART4, USART_IT_TC, ENABLE);
    169          
    170          	USART_Cmd(UART4, ENABLE);
    171          }
    172          
    173          /*******************************************************************************
    174          * Function : UART5_Init
    175          *******************************************************************************/
    176          void UART5_Init(u32 BRate)
    177          {
    178          	USART_InitStructure.USART_BaudRate   	= BRate;
    179          	USART_InitStructure.USART_WordLength 	= USART_WordLength_8b;
    180          	USART_InitStructure.USART_StopBits   	= USART_StopBits_1;
    181          	USART_InitStructure.USART_Parity     	= USART_Parity_No ;
    182          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    183          	USART_InitStructure.USART_Mode       	= USART_Mode_Rx | USART_Mode_Tx;
    184          
    185          	USART_Init(UART5, &USART_InitStructure);
    186          
    187          	USART_ITConfig(UART5, USART_IT_RXNE, ENABLE);
    188          	USART_ITConfig(UART5, USART_IT_TC, ENABLE);
    189          
    190          	USART_Cmd(UART5, ENABLE);
    191          }
    192          
    193          /*******************************************************************************
    194          * Function : TIMER1_CH4_DutyPeriod
    195          *******************************************************************************/
    196          void TIMER1_CH4_DutyPeriod(uint16_t val) 
    197          {
    198          	uint16_t	period;
    199          	uint16_t	pulse;
    200          
    201          	if(val == 0)
    202          	{
    203          		period = (SystemCoreClock / 1200 ) - 1;
    204          		pulse = (uint16_t) (((uint32_t) val * (period - 1)) / 100); 
    205          		
    206          		TIM_OCInitStructure.TIM_Pulse = pulse;
    207          		TIM_OC4Init(TIM1, &TIM_OCInitStructure);
    208          
    209          		/* TIM1 counter enable */
    210          		//TIM_Cmd(TIM1, ENABLE);
    211          		TIM_Cmd(TIM1, DISABLE);
    212          		/* TIM1 Main Output Enable */
    213          		TIM_CtrlPWMOutputs(TIM1, DISABLE);
    214          	}
    215          	else
    216          	{
    217          		period = (SystemCoreClock / 1200 ) - 1;
    218          		pulse = (uint16_t) (((uint32_t) val * (period - 1)) / 100); 
    219          		
    220          		TIM_OCInitStructure.TIM_Pulse = pulse;
    221          		TIM_OC4Init(TIM1, &TIM_OCInitStructure);
    222          
    223          		/* TIM1 counter enable */
    224          		//TIM_Cmd(TIM1, ENABLE);
    225          		TIM_Cmd(TIM1, ENABLE);
    226          		/* TIM1 Main Output Enable */
    227          		TIM_CtrlPWMOutputs(TIM1, ENABLE);
    228          	}
    229          }
    230          
    231          /*******************************************************************************
    232          * Function : Wiper_Active
    233          *******************************************************************************/
    234          void Wiper_Active(void)
    235          {
    236          	if((stWIPER2.INITIALIZATION == 0x01) && (stWIPER2.FLAG == 0x01))
    237          	{
    238          		if(stWIPER2.COUNT)
    239          		{
    240          			stWIPER2.STATUS = 0x01;
    241          			
    242          			switch(stWIPER2.STEP)
    243          			{
    244          				case WIPER_READY:
    245          					Run_Wiper(WIPER_ON, DIRECTION_CCW);			// Wiper On
    246          					stWIPER2.STEP = WIPER_SENSOR1_OFF_CHECK;
    247          					break;
    248          
    249          				case WIPER_SENSOR1_OFF_CHECK:
    250          					
    251          					if(stWIPER2.SENSOR_1 == WIPER_SENS1_OFF) 
    252          					{
    253          						stWIPER2.STEP = WIPER_SENSOR2_ON_CHECK;
    254          					}
    255          					
    256          					break;
    257          
    258          				case WIPER_SENSOR2_ON_CHECK:
    259          					
    260          					if(stWIPER2.SENSOR_2 == WIPER_SENS2_ON) 
    261          					{
    262          						Run_Wiper(WIPER_OFF, DIRECTION_CCW);			// Wiper On
    263          						Delay_1ms(1);
    264          						Run_Wiper(WIPER_ON, DIRECTION_CW);				// Wiper On
    265          						stWIPER2.STEP = WIPER_SENSOR2_OFF_CHECK;
    266          					}
    267          					
    268          					break;
    269          
    270          				case WIPER_SENSOR2_OFF_CHECK:
    271          
    272          					if(stWIPER2.SENSOR_2 == WIPER_SENS2_OFF) 
    273          					{
    274          						stWIPER2.STEP = WIPER_END_CHECK;
    275          					}
    276          					
    277          					break;
    278          
    279          				case WIPER_END_CHECK:
    280          					
    281          					if(stWIPER2.SENSOR_1 == WIPER_SENS1_ON) 
    282          					{
    283          						Run_Wiper(WIPER_OFF, DIRECTION_CW);			// Wiper Off
    284          						stWIPER2.STEP = WIPER_DWELL_CHECK;
    285          						stWIPER2.DWELL_TIMER_FLAG = 0x01;
    286          
    287          						if(stWIPER2.COUNT < 0x0F) stWIPER2.COUNT--;
    288          					}
    289          					
    290          					break;
    291          
    292          				case WIPER_DWELL_CHECK:
    293          
    294          					if(stWIPER2.DWELL_TIME_DATA)
    295          					{
    296          						switch(stWIPER2.STOP_MODE)
    297          						{
    298          							case WIPER_STOP_READY:
    299          								
    300          								if(stWIPER2.DWELL_END_FLAG)
    301          								{
    302          									stWIPER2.STEP = WIPER_READY;
    303          									stWIPER2.DWELL_END_FLAG = 0x00;
    304          									stWIPER2.DWELL_TIMER_FLAG = 0x00;
    305          								}								
    306          
    307          								break;
    308          
    309          							case WIPER_STOP_ORIGIN:
    310          								
    311          								stWIPER2.DWELL_TIMER_FLAG = 0x00;
    312          
    313          								if(stWIPER2.DWELL_TIMER_ms) stWIPER2.DWELL_TIMER_ms = 0;
    314          								if(stWIPER2.DWELL_TIMER_s) stWIPER2.DWELL_TIMER_s = 0;
    315          								if(stWIPER2.COUNT > 0x00) stWIPER2.COUNT = 0x00;
    316          
    317          								break;
    318          						}
    319          					}
    320          					else
    321          					{
    322          						stWIPER2.STEP = WIPER_READY;
    323          						stWIPER2.DWELL_END_FLAG = 0x00;
    324          						stWIPER2.DWELL_TIMER_FLAG = 0x00;
    325          
    326          						if(stWIPER2.STOP_MODE == WIPER_STOP_ORIGIN)
    327          						{
    328          							if(stWIPER2.COUNT > 0x00) stWIPER2.COUNT = 0x00;
    329          						}					
    330          					}
    331          
    332          					break;
    333          
    334          				default:
    335          					break;
    336          			}
    337          		}
    338          		else
    339          		{
    340          			stWIPER2.STATUS = 0x00;
    341          			stWIPER2.FLAG = 0x00;
    342          			stWIPER2.COUNT = 0x00;
    343          		}
    344          	}	
    345          }
    346          
    347          /*******************************************************************************
    348          * Function : Wiper_Function
    349          *******************************************************************************/
    350          void Wiper_Function(u8 u_Type)
    351          {
    352          	switch(u_Type)
    353          	{
    354          		case 0x00:
    355          
    356          			if(stWIPER2.STOP_MODE == WIPER_STOP_EMERGENCY)
    357          			{
    358          				Run_Wiper(WIPER_OFF, 0xFF);			// Wiper Off
    359          				
    360          				stWIPER2.STATUS = 0x00;
    361          				stWIPER2.FLAG = 0x00;
    362          				stWIPER2.COUNT = 0x00;
    363          			}
    364          			else
    365          			{
    366          				Wiper_Active();
    367          			}
    368          			
    369          			if(stWIPER2.CONTINUOUS_STOP_FLAG == 0x01)
    370          			{
    371          				stWIPER2.CONTINUOUS_STOP_FLAG = 0x00;
    372          
    373          				stWIPER2.STOP_MODE = WIPER_STOP_ORIGIN;
    374          
    375          				if(stWIPER2.DWELL_TIMER_FLAG) stWIPER2.DWELL_TIMER_FLAG = 0x00;
    376          				if(stWIPER2.CONTINUOUS_FLAG == 0x01) 
    377          				{
    378          					stWIPER2.CONTINUOUS_FLAG = 0x00;
    379          				}		
    380          			}
    381          			
    382          			break;
    383          
    384          		case 0x01:
    385          
    386          			if(stWIPER1.INITIALIZATION == 0x01)
    387          			{
    388          				if((stWIPER1.ACTIVE_COUNT != 0) && (stWIPER2.SENSOR_1 == WIPER_SENS1_ON) && (stWIPER2.STATUS == WIPER_OFF) && (stWIPER1.DWELL_FLAG == 0x00))
    389          				{
    390          					Run_Wiper(WIPER_ON, DIRECTION_CW);				// Wiper On
    391          				}
    392          			}
    393          
    394          			break;
    395          
    396          		default:
    397          			break;
    398          	}
    399          
    400          }
    401          
    402          /*******************************************************************************
    403          * Function : Initial_Wiper
    404          *******************************************************************************/
    405          void Initial_Wiper(u8 u_Type)
    406          {
    407          	switch(u_Type)
    408          	{
    409          		case 0x00:
    410          
    411          			if(stWIPER2.INITIALIZATION == 0x00)
    412          			{
    413          				switch(stWIPER2.STEP)
    414          				{
    415          					// ① Wiper 초기화를 위한 모터 동작 : CW → Sensor 1
    416          					case WIPER_INITIAL:
    417          
    418          						Run_Wiper(WIPER_ON, DIRECTION_CCW);			// Wiper On
    419          						stWIPER2.STEP = WIPER_SENSOR1_ON_CHECK;
    420          						
    421          						break;
    422          
    423          
    424          					// ② 초기화 위치 : Sensor 1 Stop
    425          					case WIPER_SENSOR1_ON_CHECK:
    426          
    427          						if(stWIPER2.SENSOR_1 == WIPER_SENS1_ON) 
    428          						{
    429          							Run_Wiper(WIPER_OFF, DIRECTION_CW);			// Wiper On
    430          							stWIPER2.STEP = WIPER_READY;
    431          							stWIPER2.INITIALIZATION = 0x01;
    432          						}
    433          
    434          						if(stWIPER2.SENSOR_2 == WIPER_SENS2_ON) 
    435          						{
    436          							Run_Wiper(WIPER_OFF, DIRECTION_CCW);			// Wiper On
    437          							Delay_1ms(1);
    438          							Run_Wiper(WIPER_ON, DIRECTION_CW);				// Wiper On
    439          							stWIPER2.STEP = WIPER_SENSOR2_OFF_CHECK;
    440          						}
    441          
    442          						break;
    443          
    444          					case WIPER_SENSOR2_OFF_CHECK:
    445          
    446          						if(stWIPER2.SENSOR_2 == WIPER_SENS2_OFF) 
    447          						{
    448          							stWIPER2.STEP = WIPER_END_CHECK;
    449          						}
    450          						
    451          						break;
    452          
    453          					case WIPER_END_CHECK:
    454          						
    455          						if(stWIPER2.SENSOR_1 == WIPER_SENS1_ON) 
    456          						{
    457          							Run_Wiper(WIPER_OFF, DIRECTION_CW);			// Wiper Off
    458          							stWIPER2.STEP = WIPER_READY;
    459          							stWIPER2.INITIALIZATION = 0x01;
    460          						}
    461          						
    462          						break;
    463          
    464          					default:
    465          						break;
    466          				}
    467          			}
    468          	
    469          			break;
    470          
    471          		case 0x01:
    472          
    473          			if(stWIPER1.INITIALIZATION == 0x00)
    474          			{
    475          				if(stWIPER2.SENSOR_1 == WIPER_SENS1_OFF) 
    476          				{
    477          					Run_Wiper(WIPER_ON, DIRECTION_CW);			// Wiper On
    478          				}
    479          				else
    480          				{
    481          					Run_Wiper(WIPER_OFF, DIRECTION_CW);			// Wiper Off
    482          					stWIPER1.INITIALIZATION = 0x01;
    483          				}
    484          			}
    485          			
    486          			break;
    487          
    488          		default:
    489          			break;
    490          	}
    491          	
    492          
    493          }
    494          
    495          /*******************************************************************************
    496          * Function : Run_Wiper
    497          *******************************************************************************/
    498          void Run_Wiper(u8 u_Cmd, u8 u_Direction)
    499          {
    500          	switch(u_Cmd)
    501          	{
    502          		case WIPER_OFF:
    503          		
    504          			WIPER_STOP;			
    505          			TIMER1_CH4_DutyPeriod(1);
    506          
    507          			stWIPER2.STATUS = WIPER_OFF;
    508          
    509          			Wiper_Active_Flag = 0;	// 동작 상태를 체크하기 위해 항상 정지 시에는 0으로 해줄 것.
    510          			break;
    511          			
    512          		case WIPER_ON:
    513          
    514          			switch(u_Direction)
    515          			{
    516          				case 0x00:
    517          					
    518          					WIPER_CW;
    519          					stWIPER2.DIRECTION = DIRECTION_CW;
    520          
    521          					break;
    522          
    523          				case 0x01:
    524          					
    525          					WIPER_CCW;
    526          					stWIPER2.DIRECTION = DIRECTION_CCW;
    527          
    528          					break;
    529          
    530          				default:
    531          					break;
    532          			}
    533          			
    534          			WIPER_START;
    535          			TIMER1_CH4_DutyPeriod(100);
    536          
    537          			stWIPER2.STATUS = WIPER_ON;
    538          			
    539          			if(!Wiper_Error_Status_Flag) Wiper_Active_Flag = 1;	// 동작 상태를 체크하기 위해 항상 동작 시에는 1로 해줄 것.
    540          			
    541          			break;
    542          	}
    543          }
    544          
    545          /*******************************************************************************
    546          * Function : TIMER_Init
    547          *******************************************************************************/
    548          void TIMER_Init(void)
    549          {
    550          	uint16_t	period;
    551          	//uint16_t	pulse;
    552          	
    553          	/* Timer Base configuration */
    554          	/* Compute the value for the ARR register to have a period of 20 KHz */
    555          	// 72000000/7200 = 10000 (10KHz)
    556          	period = (SystemCoreClock / 1200 ) - 1;
    557          	/* Compute the CCR1 value to generate a PWN signal with 50% duty cycle */
    558          	//pulse = (uint16_t) (((uint32_t) 5 * (period - 1)) / 100);
    559          	
    560          	// TIMER1 TEST MODE !!!!
    561          //		/* Time base configuration */
    562          //		TIM_TimeBaseStructure.TIM_Period = period;
    563          //		TIM_TimeBaseStructure.TIM_Prescaler = 0;
    564          //		TIM_TimeBaseStructure.TIM_ClockDivision = 0;
    565          //		TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
    566          //	
    567          //		TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure);
    568          //	
    569          //		/* PWM1 Mode configuration: Channel1 */
    570          //		TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
    571          //		TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
    572          //		TIM_OCInitStructure.TIM_Pulse = 0;//CCR1_Val;
    573          //		TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
    574          //	
    575          //		TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_Low;  
    576          //		TIM_OCInitStructure.TIM_OCIdleState  = TIM_OCIdleState_Set;    
    577          //		TIM_OCInitStructure.TIM_OCNIdleState  = TIM_OCIdleState_Reset;    
    578          //	
    579          //	
    580          //		TIM_BDTRInitTypeDef TIM_BDTRInitStructure; 
    581          //		// Automatic Output enable, Break, dead time and lock configuration    
    582          //		TIM_BDTRInitStructure.TIM_OSSRState = TIM_OSSRState_Enable;   
    583          //		TIM_BDTRInitStructure.TIM_OSSIState = TIM_OSSIState_Enable;   
    584          //		TIM_BDTRInitStructure.TIM_LOCKLevel = TIM_LOCKLevel_1;   
    585          //		TIM_BDTRInitStructure.TIM_DeadTime = 0x05;   
    586          //		TIM_BDTRInitStructure.TIM_Break = TIM_Break_Disable;   
    587          //		TIM_BDTRInitStructure.TIM_BreakPolarity = TIM_BreakPolarity_High;   
    588          //		TIM_BDTRInitStructure.TIM_AutomaticOutput = TIM_AutomaticOutput_Enable;   
    589          //	
    590          //		TIM_BDTRConfig(TIM1, &TIM_BDTRInitStructure);  
    591          //		TIM_OC1Init(TIM1, &TIM_OCInitStructure);
    592          //		TIM_OC1PreloadConfig(TIM1, TIM_OCPreload_Enable);	
    593          //	
    594          //		/* TIM1 counter enable */
    595          //		TIM_Cmd(TIM1, DISABLE);
    596          //		//TIM_Cmd(TIM1, DISABLE);
    597          //		/* TIM1 Main Output Enable */
    598          //		TIM_CtrlPWMOutputs(TIM1, DISABLE);   
    599          
    600          	PrescalerValue = (uint16_t) (SystemCoreClock /120000);
    601          	
    602          //		TIM_TimeBaseStructure.TIM_Period = 9500;
    603          //		TIM_TimeBaseStructure.TIM_Prescaler = 0;
    604          //		TIM_TimeBaseStructure.TIM_ClockDivision = 0;
    605          //		TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
    606          //		//TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
    607          //		TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
    608          //	
    609          //		TIM_PrescalerConfig(TIM2, PrescalerValue, TIM_PSCReloadMode_Immediate);
    610          //		TIM_ClearFlag(TIM2, TIM_FLAG_Update);
    611          //		TIM_ITConfig(TIM2, TIM_FLAG_Update, ENABLE);
    612          //		TIM_Cmd(TIM2, ENABLE);
    613          //	
    614          //		TIM_TimeBaseStructure.TIM_Period = 950;
    615          //		TIM_TimeBaseStructure.TIM_Prescaler = 0;
    616          //		TIM_TimeBaseStructure.TIM_ClockDivision = 0;
    617          //		TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
    618          //		//TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
    619          //		TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
    620          //	
    621          //		TIM_PrescalerConfig(TIM3, PrescalerValue, TIM_PSCReloadMode_Immediate);
    622          //		TIM_ClearFlag(TIM3, TIM_FLAG_Update);
    623          //		TIM_ITConfig(TIM3, TIM_FLAG_Update, ENABLE);
    624          //		TIM_Cmd(TIM3, ENABLE);
    625          
    626          	
    627          
    628          
    629          	//TIM4 (CH3): GPIOB 8 LED Green
    630          	//TIM4 (CH4): GPIOB 9 LED Red
    631          	
    632          	TIM_TimeBaseStructure.TIM_Period = 3600-1;
    633          	TIM_TimeBaseStructure.TIM_Prescaler = 60000-1;
    634          	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
    635          	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
    636          	//TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
    637          	TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);
    638          
    639          	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Disable;
    640          	TIM_OC1Init(TIM4, &TIM_OCInitStructure);
    641          	TIM_OC2Init(TIM4, &TIM_OCInitStructure);
    642          
    643          	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
    644          	TIM_OCInitStructure.TIM_Pulse = 1;
    645          	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
    646          	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_Toggle;
    647          	TIM_OC3Init(TIM4, &TIM_OCInitStructure);
    648          	TIM_Cmd(TIM4, ENABLE);
    649          	
    650          	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
    651          	TIM_OCInitStructure.TIM_Pulse = 1;
    652          	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low;
    653          	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_Toggle;
    654          	TIM_OC4Init(TIM4, &TIM_OCInitStructure);
    655          	TIM_Cmd(TIM4, ENABLE);	
    656          
    657          
    658          	
    659          	//TIM_PrescalerConfig(TIM4, PrescalerValue, TIM_PSCReloadMode_Immediate);
    660          	//TIM_ClearFlag(TIM4, TIM_FLAG_Update); //s
    661          	//TIM_ITConfig(TIM4, TIM_FLAG_Update, ENABLE);
    662          
    663          	
    664          
    665          }
    666          
    667          /*******************************************************************************
    668          * Function : RCC_Configuration
    669          *******************************************************************************/
    670          void RCC_Configuration(void)
    671          {
    672          	SystemInit();
    673          
    674          	/* GPIOx clock enable */
    675          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA |RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_AFIO, ENABLE);
    676          
    677          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    678          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
    679          	//RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
    680          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
    681          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE);	
    682          
    683          	/* I2C1,2 Periph clock enable */
    684          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);
    685          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, ENABLE);	
    686          	
    687          	 /* Enable DMA1 clock */
    688          	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
    689          
    690          	/* ENABLE ADC1 and GPIO clock */
    691          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
    692          
    693          	/* TIM clock enable */
    694          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
    695          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);	
    696          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
    697          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);	
    698          
    699          	
    700          }
    701          
    702          /*******************************************************************************
    703          * Function : NVIC_Configuration
    704          *******************************************************************************/
    705          void NVIC_Configuration(void)
    706          { 
    707          
    708          	//  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
    709          
    710          	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
    711          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;  
    712          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
    713          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    714          	NVIC_Init(&NVIC_InitStructure);
    715          
    716          	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
    717          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;  
    718          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
    719          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    720          	NVIC_Init(&NVIC_InitStructure);
    721          
    722          	/*
    723          	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
    724          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 4;
    725          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 4;
    726          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    727          	NVIC_Init(&NVIC_InitStructure);  
    728          	*/
    729          	
    730          	NVIC_InitStructure.NVIC_IRQChannel = UART4_IRQn;
    731          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 4;
    732          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 4;
    733          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    734          	NVIC_Init(&NVIC_InitStructure);
    735          
    736          	NVIC_InitStructure.NVIC_IRQChannel = UART5_IRQn;
    737          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 5;  
    738          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 5;
    739          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    740          	NVIC_Init(&NVIC_InitStructure);	
    741          
    742          	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
    743          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    744          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    745          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    746          	NVIC_Init(&NVIC_InitStructure);
    747          
    748          	NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;
    749          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    750          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    751          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    752          	NVIC_Init(&NVIC_InitStructure);  
    753          
    754          	NVIC_InitStructure.NVIC_IRQChannel = TIM4_IRQn;
    755          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 6;
    756          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 6;
    757          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    758          	NVIC_Init(&NVIC_InitStructure);  
    759          	
    760          
    761          	//RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
    762          }
    763          
    764          /*******************************************************************************
    765          * Function : GPIO_Configuration
    766          *******************************************************************************/
    767          void GPIO_Configuration(void)
    768          {
    769          	// ========== GPIO A ===============================================
    770          	// GPIO_Pin_0 : TEMPERATURE_ADC (IN)
    771          	// GPIO_Pin_1 : MDIN_I550_INT
    772          	// GPIO_Pin_2 : MDIN_I550_RX
    773          	// GPIO_Pin_3 : MDIN_I550_TX
    774          	// GPIO_Pin_4 : NC
    775          	// GPIO_Pin_5 : NC
    776          	// GPIO_Pin_6 : NC
    777          	// GPIO_Pin_7 : NC
    778          	// GPIO_Pin_8 : NC
    779          	// GPIO_Pin_9 : USART1_Tx (OUT) : MAIN
    780          	// GPIO_Pin_10 : USART1_Rx (IN) : MAIN
    781          	// GPIO_Pin_11 : PWM (OUT)
    782          	// GPIO_Pin_12 : NC
    783          	// GPIO_Pin_13 : SWDIO
    784          	// GPIO_Pin_14 : SWCLK
    785          	// GPIO_Pin_15 : NC
    786          	// ===============================================================
    787          
    788          	// ----- Configure the INPUT-PIN --------------------
    789          //		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
    790          //		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    791          //		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
    792          //		GPIO_Init(GPIOA, &GPIO_InitStructure);
    793          //		
    794          //		// ----- Configure the INPUT-PIN --------------------
    795          //		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10|GPIO_Pin_3|GPIO_Pin_1;
    796          //		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    797          //		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    798          //		GPIO_Init(GPIOA, &GPIO_InitStructure);
    799          //		
    800          //		// ----- Configure the OUTPUT-PIN -------------------
    801          //		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9|GPIO_Pin_11|GPIO_Pin_2;
    802          //		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    803          //		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    804          //		GPIO_Init(GPIOA, &GPIO_InitStructure);
    805          
    806          
    807          
    808          
    809          	    //GPIOA Pin 0: Set The WKUP SW Of Mango B'd
    810          		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
    811          		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
    812          		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
    813          		GPIO_Init(GPIOA, &GPIO_InitStructure);
    814          		
    815          	    //GPIOA Pin 1: Set The UserKey SW Of Mango B'd
    816          		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
    817          		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
    818          		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
    819          		GPIO_Init(GPIOA, &GPIO_InitStructure);
    820          
    821          
    822          
    823          
    824          	// ========== GPIO B ===============================================
    825          	// GPIO_Pin_0 : NC
    826          	// GPIO_Pin_1 : NC
    827          	// GPIO_Pin_2 : MDIN_I550_RSTN
    828          	// GPIO_Pin_3 : NC
    829          	// GPIO_Pin_4 : NC
    830          	// GPIO_Pin_5 : NC
    831          	// GPIO_Pin_6 : TW9900_SCL
    832          	// GPIO_Pin_7 : TW9900_SDA
    833          	// GPIO_Pin_8 : NC
    834          	// GPIO_Pin_9 : NC
    835          	// GPIO_Pin_10 : AT24C256C_SCL
    836          	// GPIO_Pin_11 : AT24C256C_SDA
    837          	// GPIO_Pin_12 : MODE1 (IN)
    838          	// GPIO_Pin_13 : MODE2 (IN)
    839          	// GPIO_Pin_14 : 12V_EN
    840          	// GPIO_Pin_15 : NC
    841          	// ===============================================================
    842          
    843          	// ----- Configure the INPUT-PIN --------------------
    844          //		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14|GPIO_Pin_15;
    845          //		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    846          //		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    847          //		GPIO_Init(GPIOB, &GPIO_InitStructure);
    848          //	
    849          //		// ----- Configure the OUTPUT-PIN -------------------
    850          //		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    851          //		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
    852          //		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    853          //		GPIO_Init(GPIOB, &GPIO_InitStructure);
    854          //	
    855          //		// ----- Configure the OUTPUT-PIN -------------------
    856          //		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;// | GPIO_Pin_10 | GPIO_Pin_11;
    857          //		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
    858          //		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    859          //		GPIO_Init(GPIOB, &GPIO_InitStructure);
    860          //		
    861          //		// ----- Configure the OUTPUT-PIN -------------------
    862          //		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2|GPIO_Pin_11;//|GPIO_Pin_7|GPIO_Pin_11;
    863          //		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    864          //		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    865          //		GPIO_Init(GPIOB, &GPIO_InitStructure);
    866          
    867          
    868          
    869          
    870          			//GPIOB Pin5: Yellow, Pin8: Green, Pin9: Red
    871          			GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_8 | GPIO_Pin_5;
    872          			GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
    873          			GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
    874          			GPIO_Init(GPIOB, &GPIO_InitStructure);
    875          
    876          
    877          
    878          
    879          	// ========== GPIO C ===============================================
    880          	// GPIO_Pin_0 : WIPER1 SENSOR (IN)
    881          	// GPIO_Pin_1 : WIPER2 SENSOR (IN)
    882          	// GPIO_Pin_2 : NC
    883          	// GPIO_Pin_3 : LED1 (OUT)
    884          	// GPIO_Pin_4 : TW9900_IRQ
    885          	// GPIO_Pin_5 : TW9900_RST
    886          	// GPIO_Pin_6 : MOTOR START (OUT)
    887          	// GPIO_Pin_7 : MOTOR FG (IN)
    888          	// GPIO_Pin_8 : MOTOR CW/CCW (OUT)
    889          	// GPIO_Pin_9 : NC
    890          	// GPIO_Pin_10 : UART4_Tx (OUT) : CAMERA
    891          	// GPIO_Pin_11 : UART4_Rx (IN) : CAMERA
    892          	// GPIO_Pin_12 : UART5_Tx (OUT) : IP BOARD
    893          	// GPIO_Pin_13 : HEATER (OUT)
    894          	// GPIO_Pin_14 : NC
    895          	// GPIO_Pin_15 : FAN (OUT)
    896          	// ===============================================================
    897          
    898          	// ----- Configure the INPUT-PIN --------------------
    899          //		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_4|GPIO_Pin_7|GPIO_Pin_11;
    900          //		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    901          //		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    902          //		GPIO_Init(GPIOC, &GPIO_InitStructure);
    903          
    904          	// ----- Configure the OUTPUT-PIN -------------------
    905          //		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_8|GPIO_Pin_13|GPIO_Pin_15; 
    906          //		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    907          //		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    908          //		GPIO_Init(GPIOC, &GPIO_InitStructure);
    909          
    910          	// ----- Configure the OUTPUT-PIN -------------------
    911          //		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10|GPIO_Pin_12;
    912          //		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    913          //		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    914          //		GPIO_Init(GPIOC, &GPIO_InitStructure);
    915          	
    916          	// ========== GPIO D ===============================================
    917          	// GPIO_Pin_0 : OSCI
    918          	// GPIO_Pin_1 : OSCO
    919          	// GPIO_Pin_2 : UART5_Rx (IN) : IP BOARD
    920          	// ===============================================================
    921          	// ----- Configure the INPUT-PIN --------------------
    922          //		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
    923          //		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    924          //		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    925          //		GPIO_Init(GPIOD, &GPIO_InitStructure);
    926          }
    927          
    928          /*******************************************************************************
    929          * Function : DMA_Configuration
    930          *******************************************************************************/
    931          void DMA_Configuration(void)
    932          {
    933          	DMA_DeInit(DMA1_Channel1);
    934          	DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address;
    935          	DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&stADC.DMA1_ADC_VALUE;
    936          	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
    937          	DMA_InitStructure.DMA_BufferSize = 2;
    938          	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    939          	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
    940          	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
    941          	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;
    942          	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
    943          	DMA_InitStructure.DMA_Priority = DMA_Priority_High;
    944          	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
    945          	DMA_Init(DMA1_Channel1, &DMA_InitStructure);
    946          
    947          	DMA_Cmd(DMA1_Channel1, ENABLE);
    948          }
    949          
    950          /*******************************************************************************
    951          * Function : ADC_Configuration
    952          *******************************************************************************/
    953          void ADC_Configuration(void)
    954          {
    955          	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
    956          	ADC_InitStructure.ADC_ScanConvMode = ENABLE;
    957          	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
    958          	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
    959          	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
    960          	ADC_InitStructure.ADC_NbrOfChannel = 2;
    961          	ADC_Init(ADC1, &ADC_InitStructure);
    962          	ADC_TempSensorVrefintCmd(ENABLE);
    963          	
    964          	// PA0, CH0, TEMP
    965          	ADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, ADC_SampleTime_28Cycles5);
    966          
    967          	// PA4, CH4, CDS
    968          	ADC_RegularChannelConfig(ADC1, ADC_Channel_4, 2, ADC_SampleTime_28Cycles5);
    969          
    970          	ADC_Cmd(ADC1, ENABLE);
    971          	ADC_DMACmd(ADC1, ENABLE);
    972          
    973          	ADC_ResetCalibration(ADC1);  
    974          	while(ADC_GetResetCalibrationStatus(ADC1));	
    975          	ADC_StartCalibration(ADC1);  
    976          	while(ADC_GetCalibrationStatus(ADC1));  
    977          	ADC_SoftwareStartConvCmd(ADC1, ENABLE);  
    978          }
    979          
    980          /*******************************************************************************
    981          * Function : ADC_Configuration
    982          *******************************************************************************/
    983          void I2C_Configuration(void)
    984          {
    985          	/* I2C1,2 Periph clock enable */
    986          	//RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);
    987          	//RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, ENABLE);	
    988          
    989          	//I2C1 Initial - TW9900 #1/#2 : PF0,1===========================================
    990          	/* Reset sEE_I2C IP */
    991          	//RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
    992          	/* Release reset signal of sEE_I2C IP */
    993          	//RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
    994          	/* Connect PF1 to I2C_SCL*/
    995          	//GPIO_PinAFConfig(GPIOF, GPIO_PinSource1, GPIO_AF_I2C1);
    996          	/* Connect PF0 to I2C_SDA*/
    997          	//GPIO_PinAFConfig(GPIOF, GPIO_PinSource0, GPIO_AF_I2C1);
    998          
    999          	// I2C1 Configuration	
   1000          	#if(1)
   1001          	I2C_InitStructure.I2C_ClockSpeed = 100000;	//100KB, 400000;
   1002          	I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
   1003          	I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
   1004          	I2C_InitStructure.I2C_OwnAddress1 = TW9900_ADDR;
   1005          	I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
   1006          	I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
   1007          	I2C_Cmd(I2C1, ENABLE); /* I2C Peripheral Enable enable */
   1008          	I2C_Init(I2C1, &I2C_InitStructure);	/* Apply I2C configuration after enabling it */
   1009          	//======================================================== I2C1 Initial END
   1010          	#endif
   1011          	
   1012          	#if(1)
   1013          	// I2C2 Configuration	
   1014          	I2C_InitStructure.I2C_ClockSpeed = 100000;	//100KB, 400000;
   1015          	I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
   1016          	I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
   1017          	I2C_InitStructure.I2C_OwnAddress1 = AT24C256_ADDR;
   1018          	I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
   1019          	I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
   1020          	I2C_Cmd(I2C2, ENABLE); /* I2C Peripheral Enable enable */
   1021          	I2C_Init(I2C2, &I2C_InitStructure);	/* Apply I2C configuration after enabling it */	
   1022          	#endif	
   1023          	//======================================================== I2C2 Initial END
   1024          
   1025          }
   1026          
   1027          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  ADC_Configuration
              8 -> ADC_Cmd
              8 -> ADC_DMACmd
              8 -> ADC_GetCalibrationStatus
              8 -> ADC_GetResetCalibrationStatus
              8 -> ADC_Init
              8 -> ADC_RegularChannelConfig
              8 -> ADC_ResetCalibration
              8 -> ADC_SoftwareStartConvCmd
              8 -> ADC_StartCalibration
              8 -> ADC_TempSensorVrefintCmd
        8  DMA_Configuration
              8 -> DMA_Cmd
              8 -> DMA_DeInit
              8 -> DMA_Init
        8  Dipswitch_Mode_Check
              8 -> GPIO_ReadInputDataBit
        8  GPIO_Configuration
              8 -> GPIO_Init
        8  I2C_Configuration
              8 -> I2C_Cmd
              8 -> I2C_Init
        8  Initial_Device
              8 -> ADC_Configuration
              8 -> DMA_Configuration
              8 -> Dipswitch_Mode_Check
              8 -> GPIO_Configuration
              8 -> I2C_Configuration
              8 -> NVIC_Configuration
              8 -> RCC_Configuration
              8 -> RCC_GetClocksFreq
              8 -> SysTick_Config
              8 -> TIMER_Init
              8 -> UART4_Init
              8 -> UART5_Init
              8 -> USART1_Init
              8 -> USART2_Init
        8  Initial_Wiper
              8 -> Delay_1ms
              8 -> Run_Wiper
        8  NVIC_Configuration
              8 -> NVIC_Init
        0  NVIC_SetPriority
        8  RCC_Configuration
              8 -> RCC_AHBPeriphClockCmd
              8 -> RCC_APB1PeriphClockCmd
              8 -> RCC_APB2PeriphClockCmd
              8 -> SystemInit
       16  Run_Wiper
             16 -> GPIO_ResetBits
             16 -> GPIO_SetBits
             16 -> TIMER1_CH4_DutyPeriod
        8  SysTick_Config
              8 -> NVIC_SetPriority
       16  TIMER1_CH4_DutyPeriod
             16 -> TIM_Cmd
             16 -> TIM_CtrlPWMOutputs
             16 -> TIM_OC4Init
        8  TIMER_Init
              8 -> TIM_Cmd
              8 -> TIM_OC1Init
              8 -> TIM_OC2Init
              8 -> TIM_OC3Init
              8 -> TIM_OC4Init
              8 -> TIM_TimeBaseInit
        8  UART4_Init
              8 -> USART_Cmd
              8 -> USART_ITConfig
              8 -> USART_Init
        8  UART5_Init
              8 -> USART_Cmd
              8 -> USART_ITConfig
              8 -> USART_Init
        8  USART1_Init
              8 -> USART_Cmd
              8 -> USART_ITConfig
              8 -> USART_Init
        8  USART2_Init
              8 -> USART_Cmd
              8 -> USART_ITConfig
              8 -> USART_Init
        8  USART3_Init
              8 -> USART_Cmd
              8 -> USART_ITConfig
              8 -> USART_Init
        8  Wiper_Active
              8 -> Delay_1ms
              8 -> Run_Wiper
        8  Wiper_Function
              8 -> Run_Wiper
              8 -> Wiper_Active


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_10
       4  ??DataTable19_11
       4  ??DataTable19_12
       4  ??DataTable19_13
       4  ??DataTable19_14
       4  ??DataTable19_15
       4  ??DataTable19_16
       4  ??DataTable19_17
       4  ??DataTable19_18
       4  ??DataTable19_19
       4  ??DataTable19_2
       4  ??DataTable19_20
       4  ??DataTable19_21
       4  ??DataTable19_22
       4  ??DataTable19_23
       4  ??DataTable19_24
       4  ??DataTable19_25
       4  ??DataTable19_26
       4  ??DataTable19_27
       4  ??DataTable19_28
       4  ??DataTable19_29
       4  ??DataTable19_3
       4  ??DataTable19_30
       4  ??DataTable19_31
       4  ??DataTable19_32
       4  ??DataTable19_33
       4  ??DataTable19_34
       4  ??DataTable19_35
       4  ??DataTable19_36
       4  ??DataTable19_37
       4  ??DataTable19_38
       4  ??DataTable19_4
       4  ??DataTable19_5
       4  ??DataTable19_6
       4  ??DataTable19_7
       4  ??DataTable19_8
       4  ??DataTable19_9
     136  ADC_Configuration
      20  ADC_InitStructure
      98  DMA_Configuration
      44  DMA_InitStructure
      40  Dipswitch_Mode_Check
      84  GPIO_Configuration
       4  GPIO_InitStructure
     120  I2C_Configuration
      16  I2C_InitStructure
     100  Initial_Device
     252  Initial_Wiper
     214  NVIC_Configuration
       4  NVIC_InitStructure
      38  NVIC_SetPriority
       2  PrescalerValue
     128  RCC_Configuration
     152  Run_Wiper
      56  SysTick_Config
     162  TIMER1_CH4_DutyPeriod
     230  TIMER_Init
      16  TIM_OCInitStructure
      12  TIM_TimeBaseStructure
     102  UART4_Init
     102  UART5_Init
     106  USART1_Init
     102  USART2_Init
     104  USART3_Init
      16  USART_InitStructure
     446  Wiper_Active
     190  Wiper_Function
      20  rcc_clocks

 
   154 bytes in section .bss
 3 118 bytes in section .text
 
 3 118 bytes of CODE memory
   154 bytes of DATA memory

Errors: none
Warnings: 1
