###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     29/Jun/2022  18:05:44 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\src\Device.c      #
#    Command line =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\src\Device.c -D   #
#                    USE_STDPERIPH_DRIVER -D STM32F10x_HD -D USE_FULL_ASSERT  #
#                    -lcN C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_ #
#                    M32\Debug\List\ -lb C:\Users\TTT\Desktop\zz.STDFW\00.Stu #
#                    dy\project\IAR_M32\Debug\List\ -o                        #
#                    C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_M32\D #
#                    ebug\Obj\ --no_cse --no_unroll --no_inline               #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\I #
#                    AR_M32\..\..\inc\ -I C:\Users\TTT\Desktop\zz.STDFW\00.St #
#                    udy\project\IAR_M32\..\..\Libraries\CMSIS\CM3\DeviceSupp #
#                    ort\ST\STM32F10x\ -I C:\Users\TTT\Desktop\zz.STDFW\00.St #
#                    udy\project\IAR_M32\..\..\Libraries\STM32F10x_StdPeriph_ #
#                    Driver\inc\ -I "C:\Program Files (x86)\IAR               #
#                    Systems\Embedded Workbench 6.0\arm\inc\c\" -On -I        #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_M32\D #
#                    ebug\List\Device.lst                                     #
#    Object file  =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_M32\D #
#                    ebug\Obj\Device.o                                        #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\TTT\Desktop\zz.STDFW\00.Study\src\Device.c
      1          
      2          #include "Device.h"
      3          #include "Common.h"
      4          
      5          /*******************************************************************************
      6          * TYPE DEFINE STRUCTURE
      7          *******************************************************************************/
      8          USART_InitTypeDef USART_InitStructure;
      9          NVIC_InitTypeDef NVIC_InitStructure;
     10          GPIO_InitTypeDef GPIO_InitStructure;
     11          TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
     12          TIM_OCInitTypeDef TIM_OCInitStructure;
     13          DMA_InitTypeDef DMA_InitStructure;
     14          ADC_InitTypeDef ADC_InitStructure;
     15          RCC_ClocksTypeDef  rcc_clocks;
     16          I2C_InitTypeDef	I2C_InitStructure;
     17          
     18          void I2C_Configuration(void);
     19          
     20          
     21          /*******************************************************************************/
     22          uint16_t PrescalerValue = 0;
     23          
     24          /*******************************************************************************
     25          * Dipswitch_Mode_Check
     26          1) MODE 1 
     27          2) MODE 2
     28          - 0x00 : IR LED
     29          - 0x01 : LRF
     30          *******************************************************************************/
     31          void Dipswitch_Mode_Check(void)
     32          {
     33          	stDIP.MODE1 = DIP_MODE1;
     34          	stDIP.MODE2 = DIP_MODE2;
     35          }
     36          
     37          /*******************************************************************************
     38          * Divece Initialization
     39          *******************************************************************************/
     40          void Initial_Device(void)
     41          {
     42          	RCC_Configuration();
     43          	RCC_GetClocksFreq(&rcc_clocks);
     44          	GPIO_Configuration();
     45          
     46          	TIMER_Init();
     47          
     48          	// =======================================
     49          	// Dip Switch Check
     50          	// =======================================	
     51          	Dipswitch_Mode_Check();
     52          	
     53          	// MAIN <-> TILT
     54          	USART1_Init(115200);
     55          
     56          	// MDIN <-> TILT
     57          	USART2_Init(115200);
     58          
     59          	// NONE
     60          	//USART3_Init();
     61          
     62          	// CAMERA <-> TILT
     63          	UART4_Init(38400);
     64          
     65          	// IP B/D <-> TILT
     66          	UART5_Init(115200);
     67          	
     68          	if (SysTick_Config(rcc_clocks.SYSCLK_Frequency / 1000)) {while (1);}
     69          
     70          	NVIC_Configuration();
     71          	DMA_Configuration();
     72          	ADC_Configuration();
     73          	I2C_Configuration();		
     74          }
     75          
     76          /*******************************************************************************
     77          * Function : USART1_Init
     78          *******************************************************************************/
     79          void USART1_Init(u16 BRate)
     80          {
     81              USART_InitStructure.USART_BaudRate   = 115200;
     82              USART_InitStructure.USART_WordLength = USART_WordLength_8b;
     83              USART_InitStructure.USART_StopBits   = USART_StopBits_1;
     84              USART_InitStructure.USART_Parity     = USART_Parity_No ;
     85              USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
     86              USART_InitStructure.USART_Mode       = USART_Mode_Rx | USART_Mode_Tx;
     87          
     88              USART_Init(USART1, &USART_InitStructure);
     89          
     90              USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
     91              USART_ITConfig(USART1, USART_IT_TC, ENABLE);
     92          
     93              USART_Cmd(USART1, ENABLE);
     94          }
     95          
     96          /*******************************************************************************
     97          * Function : USART2_Init
     98          *******************************************************************************/
     99          void USART2_Init(u16 BRate)
    100          {
    101          /*
    102          	switch(BRate)
    103          	{
    104          		case LRF_MODE:
    105          			
    106          			USART_InitStructure.USART_BaudRate   = 19200;
    107          			
    108          			break;
    109          
    110          		case IR_MODE:
    111          
    112          			USART_InitStructure.USART_BaudRate   = 9600;
    113          			
    114          			break;
    115          	}
    116          */
    117          	USART_InitStructure.USART_BaudRate   = BRate;
    118          	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    119          	USART_InitStructure.USART_StopBits   = USART_StopBits_1;
    120          	USART_InitStructure.USART_Parity     = USART_Parity_No ;
    121          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    122          	USART_InitStructure.USART_Mode       = USART_Mode_Rx | USART_Mode_Tx;
    123          
    124          	USART_Init(USART2, &USART_InitStructure);
    125          
    126          	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);
    127          	USART_ITConfig(USART2, USART_IT_TC, ENABLE);
    128          
    129          	USART_Cmd(USART2, ENABLE);
    130          }
    131          
    132          /*******************************************************************************
    133          * Function : USART3_Init
    134          *******************************************************************************/
    135          void USART3_Init(void)
    136          {
    137              USART_InitStructure.USART_BaudRate   = 9600;//38400;
    138              USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    139              USART_InitStructure.USART_StopBits   = USART_StopBits_1;
    140              USART_InitStructure.USART_Parity     = USART_Parity_No ;
    141              USART_InitStructure.USART_HardwareFlowControl
    142                                                   = USART_HardwareFlowControl_None;
    143              USART_InitStructure.USART_Mode       = USART_Mode_Rx | USART_Mode_Tx;
    144          
    145              USART_Init(USART3, &USART_InitStructure);
    146          
    147              USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);
    148              USART_ITConfig(USART3, USART_IT_TC, ENABLE);
    149          
    150              USART_Cmd(USART3, ENABLE);
    151          }
    152          
    153          /*******************************************************************************
    154          * Function : UART4_Init
    155          *******************************************************************************/
    156          void UART4_Init(u32 BRate)
    157          {
    158          	USART_InitStructure.USART_BaudRate   	= BRate;
    159          	USART_InitStructure.USART_WordLength 	= USART_WordLength_8b;
    160          	USART_InitStructure.USART_StopBits   	= USART_StopBits_1;
    161          	USART_InitStructure.USART_Parity     	= USART_Parity_No ;
    162          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    163          	USART_InitStructure.USART_Mode       	= USART_Mode_Rx | USART_Mode_Tx;
    164          
    165          	USART_Init(UART4, &USART_InitStructure);
    166          
    167          	USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);
    168          	USART_ITConfig(UART4, USART_IT_TC, ENABLE);
    169          
    170          	USART_Cmd(UART4, ENABLE);
    171          }
    172          
    173          /*******************************************************************************
    174          * Function : UART5_Init
    175          *******************************************************************************/
    176          void UART5_Init(u32 BRate)
    177          {
    178          	USART_InitStructure.USART_BaudRate   	= BRate;
    179          	USART_InitStructure.USART_WordLength 	= USART_WordLength_8b;
    180          	USART_InitStructure.USART_StopBits   	= USART_StopBits_1;
    181          	USART_InitStructure.USART_Parity     	= USART_Parity_No ;
    182          	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    183          	USART_InitStructure.USART_Mode       	= USART_Mode_Rx | USART_Mode_Tx;
    184          
    185          	USART_Init(UART5, &USART_InitStructure);
    186          
    187          	USART_ITConfig(UART5, USART_IT_RXNE, ENABLE);
    188          	USART_ITConfig(UART5, USART_IT_TC, ENABLE);
    189          
    190          	USART_Cmd(UART5, ENABLE);
    191          }
    192          
    193          /*******************************************************************************
    194          * Function : TIMER1_CH4_DutyPeriod
    195          *******************************************************************************/
    196          void TIMER1_CH4_DutyPeriod(uint16_t val) 
    197          {
    198          	uint16_t	period;
    199          	uint16_t	pulse;
    200          
    201          	if(val == 0)
    202          	{
    203          		period = (SystemCoreClock / 1200 ) - 1;
    204          		pulse = (uint16_t) (((uint32_t) val * (period - 1)) / 100); 
    205          		
    206          		TIM_OCInitStructure.TIM_Pulse = pulse;
    207          		TIM_OC4Init(TIM1, &TIM_OCInitStructure);
    208          
    209          		/* TIM1 counter enable */
    210          		//TIM_Cmd(TIM1, ENABLE);
    211          		TIM_Cmd(TIM1, DISABLE);
    212          		/* TIM1 Main Output Enable */
    213          		TIM_CtrlPWMOutputs(TIM1, DISABLE);
    214          	}
    215          	else
    216          	{
    217          		period = (SystemCoreClock / 1200 ) - 1;
    218          		pulse = (uint16_t) (((uint32_t) val * (period - 1)) / 100); 
    219          		
    220          		TIM_OCInitStructure.TIM_Pulse = pulse;
    221          		TIM_OC4Init(TIM1, &TIM_OCInitStructure);
    222          
    223          		/* TIM1 counter enable */
    224          		//TIM_Cmd(TIM1, ENABLE);
    225          		TIM_Cmd(TIM1, ENABLE);
    226          		/* TIM1 Main Output Enable */
    227          		TIM_CtrlPWMOutputs(TIM1, ENABLE);
    228          	}
    229          }
    230          
    231          /*******************************************************************************
    232          * Function : Wiper_Active
    233          *******************************************************************************/
    234          void Wiper_Active(void)
    235          {
    236          	if((stWIPER2.INITIALIZATION == 0x01) && (stWIPER2.FLAG == 0x01))
    237          	{
    238          		if(stWIPER2.COUNT)
    239          		{
    240          			stWIPER2.STATUS = 0x01;
    241          			
    242          			switch(stWIPER2.STEP)
    243          			{
    244          				case WIPER_READY:
    245          					Run_Wiper(WIPER_ON, DIRECTION_CCW);			// Wiper On
    246          					stWIPER2.STEP = WIPER_SENSOR1_OFF_CHECK;
    247          					break;
    248          
    249          				case WIPER_SENSOR1_OFF_CHECK:
    250          					
    251          					if(stWIPER2.SENSOR_1 == WIPER_SENS1_OFF) 
    252          					{
    253          						stWIPER2.STEP = WIPER_SENSOR2_ON_CHECK;
    254          					}
    255          					
    256          					break;
    257          
    258          				case WIPER_SENSOR2_ON_CHECK:
    259          					
    260          					if(stWIPER2.SENSOR_2 == WIPER_SENS2_ON) 
    261          					{
    262          						Run_Wiper(WIPER_OFF, DIRECTION_CCW);			// Wiper On
    263          						Delay_1ms(1);
    264          						Run_Wiper(WIPER_ON, DIRECTION_CW);				// Wiper On
    265          						stWIPER2.STEP = WIPER_SENSOR2_OFF_CHECK;
    266          					}
    267          					
    268          					break;
    269          
    270          				case WIPER_SENSOR2_OFF_CHECK:
    271          
    272          					if(stWIPER2.SENSOR_2 == WIPER_SENS2_OFF) 
    273          					{
    274          						stWIPER2.STEP = WIPER_END_CHECK;
    275          					}
    276          					
    277          					break;
    278          
    279          				case WIPER_END_CHECK:
    280          					
    281          					if(stWIPER2.SENSOR_1 == WIPER_SENS1_ON) 
    282          					{
    283          						Run_Wiper(WIPER_OFF, DIRECTION_CW);			// Wiper Off
    284          						stWIPER2.STEP = WIPER_DWELL_CHECK;
    285          						stWIPER2.DWELL_TIMER_FLAG = 0x01;
    286          
    287          						if(stWIPER2.COUNT < 0x0F) stWIPER2.COUNT--;
    288          					}
    289          					
    290          					break;
    291          
    292          				case WIPER_DWELL_CHECK:
    293          
    294          					if(stWIPER2.DWELL_TIME_DATA)
    295          					{
    296          						switch(stWIPER2.STOP_MODE)
    297          						{
    298          							case WIPER_STOP_READY:
    299          								
    300          								if(stWIPER2.DWELL_END_FLAG)
    301          								{
    302          									stWIPER2.STEP = WIPER_READY;
    303          									stWIPER2.DWELL_END_FLAG = 0x00;
    304          									stWIPER2.DWELL_TIMER_FLAG = 0x00;
    305          								}								
    306          
    307          								break;
    308          
    309          							case WIPER_STOP_ORIGIN:
    310          								
    311          								stWIPER2.DWELL_TIMER_FLAG = 0x00;
    312          
    313          								if(stWIPER2.DWELL_TIMER_ms) stWIPER2.DWELL_TIMER_ms = 0;
    314          								if(stWIPER2.DWELL_TIMER_s) stWIPER2.DWELL_TIMER_s = 0;
    315          								if(stWIPER2.COUNT > 0x00) stWIPER2.COUNT = 0x00;
    316          
    317          								break;
    318          						}
    319          					}
    320          					else
    321          					{
    322          						stWIPER2.STEP = WIPER_READY;
    323          						stWIPER2.DWELL_END_FLAG = 0x00;
    324          						stWIPER2.DWELL_TIMER_FLAG = 0x00;
    325          
    326          						if(stWIPER2.STOP_MODE == WIPER_STOP_ORIGIN)
    327          						{
    328          							if(stWIPER2.COUNT > 0x00) stWIPER2.COUNT = 0x00;
    329          						}					
    330          					}
    331          
    332          					break;
    333          
    334          				default:
    335          					break;
    336          			}
    337          		}
    338          		else
    339          		{
    340          			stWIPER2.STATUS = 0x00;
    341          			stWIPER2.FLAG = 0x00;
    342          			stWIPER2.COUNT = 0x00;
    343          		}
    344          	}	
    345          }
    346          
    347          /*******************************************************************************
    348          * Function : Wiper_Function
    349          *******************************************************************************/
    350          void Wiper_Function(u8 u_Type)
    351          {
    352          	switch(u_Type)
    353          	{
    354          		case 0x00:
    355          
    356          			if(stWIPER2.STOP_MODE == WIPER_STOP_EMERGENCY)
    357          			{
    358          				Run_Wiper(WIPER_OFF, 0xFF);			// Wiper Off
    359          				
    360          				stWIPER2.STATUS = 0x00;
    361          				stWIPER2.FLAG = 0x00;
    362          				stWIPER2.COUNT = 0x00;
    363          			}
    364          			else
    365          			{
    366          				Wiper_Active();
    367          			}
    368          			
    369          			if(stWIPER2.CONTINUOUS_STOP_FLAG == 0x01)
    370          			{
    371          				stWIPER2.CONTINUOUS_STOP_FLAG = 0x00;
    372          
    373          				stWIPER2.STOP_MODE = WIPER_STOP_ORIGIN;
    374          
    375          				if(stWIPER2.DWELL_TIMER_FLAG) stWIPER2.DWELL_TIMER_FLAG = 0x00;
    376          				if(stWIPER2.CONTINUOUS_FLAG == 0x01) 
    377          				{
    378          					stWIPER2.CONTINUOUS_FLAG = 0x00;
    379          				}		
    380          			}
    381          			
    382          			break;
    383          
    384          		case 0x01:
    385          
    386          			if(stWIPER1.INITIALIZATION == 0x01)
    387          			{
    388          				if((stWIPER1.ACTIVE_COUNT != 0) && (stWIPER2.SENSOR_1 == WIPER_SENS1_ON) && (stWIPER2.STATUS == WIPER_OFF) && (stWIPER1.DWELL_FLAG == 0x00))
    389          				{
    390          					Run_Wiper(WIPER_ON, DIRECTION_CW);				// Wiper On
    391          				}
    392          			}
    393          
    394          			break;
    395          
    396          		default:
    397          			break;
    398          	}
    399          
    400          }
    401          
    402          /*******************************************************************************
    403          * Function : Initial_Wiper
    404          *******************************************************************************/
    405          void Initial_Wiper(u8 u_Type)
    406          {
    407          	switch(u_Type)
    408          	{
    409          		case 0x00:
    410          
    411          			if(stWIPER2.INITIALIZATION == 0x00)
    412          			{
    413          				switch(stWIPER2.STEP)
    414          				{
    415          					// ① Wiper 초기화를 위한 모터 동작 : CW → Sensor 1
    416          					case WIPER_INITIAL:
    417          
    418          						Run_Wiper(WIPER_ON, DIRECTION_CCW);			// Wiper On
    419          						stWIPER2.STEP = WIPER_SENSOR1_ON_CHECK;
    420          						
    421          						break;
    422          
    423          
    424          					// ② 초기화 위치 : Sensor 1 Stop
    425          					case WIPER_SENSOR1_ON_CHECK:
    426          
    427          						if(stWIPER2.SENSOR_1 == WIPER_SENS1_ON) 
    428          						{
    429          							Run_Wiper(WIPER_OFF, DIRECTION_CW);			// Wiper On
    430          							stWIPER2.STEP = WIPER_READY;
    431          							stWIPER2.INITIALIZATION = 0x01;
    432          						}
    433          
    434          						if(stWIPER2.SENSOR_2 == WIPER_SENS2_ON) 
    435          						{
    436          							Run_Wiper(WIPER_OFF, DIRECTION_CCW);			// Wiper On
    437          							Delay_1ms(1);
    438          							Run_Wiper(WIPER_ON, DIRECTION_CW);				// Wiper On
    439          							stWIPER2.STEP = WIPER_SENSOR2_OFF_CHECK;
    440          						}
    441          
    442          						break;
    443          
    444          					case WIPER_SENSOR2_OFF_CHECK:
    445          
    446          						if(stWIPER2.SENSOR_2 == WIPER_SENS2_OFF) 
    447          						{
    448          							stWIPER2.STEP = WIPER_END_CHECK;
    449          						}
    450          						
    451          						break;
    452          
    453          					case WIPER_END_CHECK:
    454          						
    455          						if(stWIPER2.SENSOR_1 == WIPER_SENS1_ON) 
    456          						{
    457          							Run_Wiper(WIPER_OFF, DIRECTION_CW);			// Wiper Off
    458          							stWIPER2.STEP = WIPER_READY;
    459          							stWIPER2.INITIALIZATION = 0x01;
    460          						}
    461          						
    462          						break;
    463          
    464          					default:
    465          						break;
    466          				}
    467          			}
    468          	
    469          			break;
    470          
    471          		case 0x01:
    472          
    473          			if(stWIPER1.INITIALIZATION == 0x00)
    474          			{
    475          				if(stWIPER2.SENSOR_1 == WIPER_SENS1_OFF) 
    476          				{
    477          					Run_Wiper(WIPER_ON, DIRECTION_CW);			// Wiper On
    478          				}
    479          				else
    480          				{
    481          					Run_Wiper(WIPER_OFF, DIRECTION_CW);			// Wiper Off
    482          					stWIPER1.INITIALIZATION = 0x01;
    483          				}
    484          			}
    485          			
    486          			break;
    487          
    488          		default:
    489          			break;
    490          	}
    491          	
    492          
    493          }
    494          
    495          /*******************************************************************************
    496          * Function : Run_Wiper
    497          *******************************************************************************/
    498          void Run_Wiper(u8 u_Cmd, u8 u_Direction)
    499          {
    500          	switch(u_Cmd)
    501          	{
    502          		case WIPER_OFF:
    503          		
    504          			WIPER_STOP;			
    505          			TIMER1_CH4_DutyPeriod(1);
    506          
    507          			stWIPER2.STATUS = WIPER_OFF;
    508          
    509          			Wiper_Active_Flag = 0;	// 동작 상태를 체크하기 위해 항상 정지 시에는 0으로 해줄 것.
    510          			break;
    511          			
    512          		case WIPER_ON:
    513          
    514          			switch(u_Direction)
    515          			{
    516          				case 0x00:
    517          					
    518          					WIPER_CW;
    519          					stWIPER2.DIRECTION = DIRECTION_CW;
    520          
    521          					break;
    522          
    523          				case 0x01:
    524          					
    525          					WIPER_CCW;
    526          					stWIPER2.DIRECTION = DIRECTION_CCW;
    527          
    528          					break;
    529          
    530          				default:
    531          					break;
    532          			}
    533          			
    534          			WIPER_START;
    535          			TIMER1_CH4_DutyPeriod(100);
    536          
    537          			stWIPER2.STATUS = WIPER_ON;
    538          			
    539          			if(!Wiper_Error_Status_Flag) Wiper_Active_Flag = 1;	// 동작 상태를 체크하기 위해 항상 동작 시에는 1로 해줄 것.
    540          			
    541          			break;
    542          	}
    543          }
    544          
    545          /*******************************************************************************
    546          * Function : TIMER_Init
    547          *******************************************************************************/
    548          void TIMER_Init(void)
    549          {
    550          	uint16_t	period;
    551          	//uint16_t	pulse;
    552          	
    553          	/* Timer Base configuration */
    554          	/* Compute the value for the ARR register to have a period of 20 KHz */
    555          	// 72000000/7200 = 10000 (10KHz)
    556          	period = (SystemCoreClock / 1200 ) - 1;
    557          	/* Compute the CCR1 value to generate a PWN signal with 50% duty cycle */
    558          	//pulse = (uint16_t) (((uint32_t) 5 * (period - 1)) / 100);
    559          	
    560          	// TIMER1 TEST MODE !!!!
    561          //		/* Time base configuration */
    562          //		TIM_TimeBaseStructure.TIM_Period = period;
    563          //		TIM_TimeBaseStructure.TIM_Prescaler = 0;
    564          //		TIM_TimeBaseStructure.TIM_ClockDivision = 0;
    565          //		TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
    566          //	
    567          //		TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure);
    568          //	
    569          //		/* PWM1 Mode configuration: Channel1 */
    570          //		TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;
    571          //		TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
    572          //		TIM_OCInitStructure.TIM_Pulse = 0;//CCR1_Val;
    573          //		TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
    574          //	
    575          //		TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_Low;  
    576          //		TIM_OCInitStructure.TIM_OCIdleState  = TIM_OCIdleState_Set;    
    577          //		TIM_OCInitStructure.TIM_OCNIdleState  = TIM_OCIdleState_Reset;    
    578          //	
    579          //	
    580          //		TIM_BDTRInitTypeDef TIM_BDTRInitStructure; 
    581          //		// Automatic Output enable, Break, dead time and lock configuration    
    582          //		TIM_BDTRInitStructure.TIM_OSSRState = TIM_OSSRState_Enable;   
    583          //		TIM_BDTRInitStructure.TIM_OSSIState = TIM_OSSIState_Enable;   
    584          //		TIM_BDTRInitStructure.TIM_LOCKLevel = TIM_LOCKLevel_1;   
    585          //		TIM_BDTRInitStructure.TIM_DeadTime = 0x05;   
    586          //		TIM_BDTRInitStructure.TIM_Break = TIM_Break_Disable;   
    587          //		TIM_BDTRInitStructure.TIM_BreakPolarity = TIM_BreakPolarity_High;   
    588          //		TIM_BDTRInitStructure.TIM_AutomaticOutput = TIM_AutomaticOutput_Enable;   
    589          //	
    590          //		TIM_BDTRConfig(TIM1, &TIM_BDTRInitStructure);  
    591          //		TIM_OC1Init(TIM1, &TIM_OCInitStructure);
    592          //		TIM_OC1PreloadConfig(TIM1, TIM_OCPreload_Enable);	
    593          //	
    594          //		/* TIM1 counter enable */
    595          //		TIM_Cmd(TIM1, DISABLE);
    596          //		//TIM_Cmd(TIM1, DISABLE);
    597          //		/* TIM1 Main Output Enable */
    598          //		TIM_CtrlPWMOutputs(TIM1, DISABLE);   
    599          
    600          	PrescalerValue = (uint16_t) (SystemCoreClock /120000);
    601          	
    602          //		TIM_TimeBaseStructure.TIM_Period = 9500;
    603          //		TIM_TimeBaseStructure.TIM_Prescaler = 0;
    604          //		TIM_TimeBaseStructure.TIM_ClockDivision = 0;
    605          //		TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
    606          //		//TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
    607          //		TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
    608          //	
    609          //		TIM_PrescalerConfig(TIM2, PrescalerValue, TIM_PSCReloadMode_Immediate);
    610          //		TIM_ClearFlag(TIM2, TIM_FLAG_Update);
    611          //		TIM_ITConfig(TIM2, TIM_FLAG_Update, ENABLE);
    612          //		TIM_Cmd(TIM2, ENABLE);
    613          //	
    614          //		TIM_TimeBaseStructure.TIM_Period = 950;
    615          //		TIM_TimeBaseStructure.TIM_Prescaler = 0;
    616          //		TIM_TimeBaseStructure.TIM_ClockDivision = 0;
    617          //		TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
    618          //		//TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
    619          //		TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
    620          //	
    621          //		TIM_PrescalerConfig(TIM3, PrescalerValue, TIM_PSCReloadMode_Immediate);
    622          //		TIM_ClearFlag(TIM3, TIM_FLAG_Update);
    623          //		TIM_ITConfig(TIM3, TIM_FLAG_Update, ENABLE);
    624          //		TIM_Cmd(TIM3, ENABLE);
    625          
    626          	TIM_TimeBaseStructure.TIM_Period = 3600-1;
    627          	TIM_TimeBaseStructure.TIM_Prescaler = 60000-1;
    628          	TIM_TimeBaseStructure.TIM_ClockDivision = 0;
    629          	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
    630          	//TIM_TimeBaseStructure.TIM_RepetitionCounter = 0;
    631          	TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);
    632          
    633          	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Disable;
    634          	TIM_OC1Init(TIM4, &TIM_OCInitStructure);
    635          	TIM_OC2Init(TIM4, &TIM_OCInitStructure);
    636          	TIM_OC3Init(TIM4, &TIM_OCInitStructure);
    637          
    638          	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
    639          	TIM_OCInitStructure.TIM_Pulse = 1;
    640          	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
    641          	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_Toggle;
    642          	TIM_OC4Init(TIM4, &TIM_OCInitStructure);
    643          
    644          
    645          	
    646          	//TIM_PrescalerConfig(TIM4, PrescalerValue, TIM_PSCReloadMode_Immediate);
    647          	//TIM_ClearFlag(TIM4, TIM_FLAG_Update);
    648          	//TIM_ITConfig(TIM4, TIM_FLAG_Update, ENABLE);
    649          	TIM_Cmd(TIM4, ENABLE);	
    650          
    651          	
    652          
    653          }
    654          
    655          /*******************************************************************************
    656          * Function : RCC_Configuration
    657          *******************************************************************************/
    658          void RCC_Configuration(void)
    659          {
    660          	SystemInit();
    661          
    662          	/* GPIOx clock enable */
    663          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA |RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_AFIO, ENABLE);
    664          
    665          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    666          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
    667          	//RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
    668          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
    669          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE);	
    670          
    671          	/* I2C1,2 Periph clock enable */
    672          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);
    673          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, ENABLE);	
    674          	
    675          	 /* Enable DMA1 clock */
    676          	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
    677          
    678          	/* ENABLE ADC1 and GPIO clock */
    679          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
    680          
    681          	/* TIM clock enable */
    682          	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
    683          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2, ENABLE);	
    684          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
    685          	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE);	
    686          
    687          	
    688          }
    689          
    690          /*******************************************************************************
    691          * Function : NVIC_Configuration
    692          *******************************************************************************/
    693          void NVIC_Configuration(void)
    694          { 
    695          
    696          	//  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_0);
    697          
    698          	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;
    699          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 2;  
    700          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
    701          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    702          	NVIC_Init(&NVIC_InitStructure);
    703          
    704          	NVIC_InitStructure.NVIC_IRQChannel = USART2_IRQn;
    705          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 3;  
    706          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
    707          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    708          	NVIC_Init(&NVIC_InitStructure);
    709          
    710          	/*
    711          	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
    712          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 4;
    713          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 4;
    714          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    715          	NVIC_Init(&NVIC_InitStructure);  
    716          	*/
    717          	
    718          	NVIC_InitStructure.NVIC_IRQChannel = UART4_IRQn;
    719          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 4;
    720          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 4;
    721          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    722          	NVIC_Init(&NVIC_InitStructure);
    723          
    724          	NVIC_InitStructure.NVIC_IRQChannel = UART5_IRQn;
    725          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 5;  
    726          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 5;
    727          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    728          	NVIC_Init(&NVIC_InitStructure);	
    729          
    730          	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
    731          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    732          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    733          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    734          	NVIC_Init(&NVIC_InitStructure);
    735          
    736          	NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;
    737          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 1;
    738          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
    739          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    740          	NVIC_Init(&NVIC_InitStructure);  
    741          
    742          	NVIC_InitStructure.NVIC_IRQChannel = TIM4_IRQn;
    743          	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 6;
    744          	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 6;
    745          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
    746          	NVIC_Init(&NVIC_InitStructure);  
    747          	
    748          
    749          	//RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
    750          }
    751          
    752          /*******************************************************************************
    753          * Function : GPIO_Configuration
    754          *******************************************************************************/
    755          void GPIO_Configuration(void)
    756          {
    757          	// ========== GPIO A ===============================================
    758          	// GPIO_Pin_0 : TEMPERATURE_ADC (IN)
    759          	// GPIO_Pin_1 : MDIN_I550_INT
    760          	// GPIO_Pin_2 : MDIN_I550_RX
    761          	// GPIO_Pin_3 : MDIN_I550_TX
    762          	// GPIO_Pin_4 : NC
    763          	// GPIO_Pin_5 : NC
    764          	// GPIO_Pin_6 : NC
    765          	// GPIO_Pin_7 : NC
    766          	// GPIO_Pin_8 : NC
    767          	// GPIO_Pin_9 : USART1_Tx (OUT) : MAIN
    768          	// GPIO_Pin_10 : USART1_Rx (IN) : MAIN
    769          	// GPIO_Pin_11 : PWM (OUT)
    770          	// GPIO_Pin_12 : NC
    771          	// GPIO_Pin_13 : SWDIO
    772          	// GPIO_Pin_14 : SWCLK
    773          	// GPIO_Pin_15 : NC
    774          	// ===============================================================
    775          
    776          	// ----- Configure the INPUT-PIN --------------------
    777          //		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
    778          //		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
    779          //		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
    780          //		GPIO_Init(GPIOA, &GPIO_InitStructure);
    781          //		
    782          //		// ----- Configure the INPUT-PIN --------------------
    783          //		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10|GPIO_Pin_3|GPIO_Pin_1;
    784          //		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    785          //		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    786          //		GPIO_Init(GPIOA, &GPIO_InitStructure);
    787          //		
    788          //		// ----- Configure the OUTPUT-PIN -------------------
    789          //		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9|GPIO_Pin_11|GPIO_Pin_2;
    790          //		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    791          //		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    792          //		GPIO_Init(GPIOA, &GPIO_InitStructure);
    793          
    794          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1;
    795          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;
    796          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
    797          	GPIO_Init(GPIOA, &GPIO_InitStructure);
    798          
    799          	// ========== GPIO B ===============================================
    800          	// GPIO_Pin_0 : NC
    801          	// GPIO_Pin_1 : NC
    802          	// GPIO_Pin_2 : MDIN_I550_RSTN
    803          	// GPIO_Pin_3 : NC
    804          	// GPIO_Pin_4 : NC
    805          	// GPIO_Pin_5 : NC
    806          	// GPIO_Pin_6 : TW9900_SCL
    807          	// GPIO_Pin_7 : TW9900_SDA
    808          	// GPIO_Pin_8 : NC
    809          	// GPIO_Pin_9 : NC
    810          	// GPIO_Pin_10 : AT24C256C_SCL
    811          	// GPIO_Pin_11 : AT24C256C_SDA
    812          	// GPIO_Pin_12 : MODE1 (IN)
    813          	// GPIO_Pin_13 : MODE2 (IN)
    814          	// GPIO_Pin_14 : 12V_EN
    815          	// GPIO_Pin_15 : NC
    816          	// ===============================================================
    817          
    818          	// ----- Configure the INPUT-PIN --------------------
    819          //		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14|GPIO_Pin_15;
    820          //		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    821          //		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    822          //		GPIO_Init(GPIOB, &GPIO_InitStructure);
    823          //	
    824          //		// ----- Configure the OUTPUT-PIN -------------------
    825          //		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    826          //		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
    827          //		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    828          //		GPIO_Init(GPIOB, &GPIO_InitStructure);
    829          //	
    830          //		// ----- Configure the OUTPUT-PIN -------------------
    831          //		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;// | GPIO_Pin_10 | GPIO_Pin_11;
    832          //		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_OD;
    833          //		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    834          //		GPIO_Init(GPIOB, &GPIO_InitStructure);
    835          //		
    836          //		// ----- Configure the OUTPUT-PIN -------------------
    837          //		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2|GPIO_Pin_11;//|GPIO_Pin_7|GPIO_Pin_11;
    838          //		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    839          //		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    840          //		GPIO_Init(GPIOB, &GPIO_InitStructure);
    841          
    842          //		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9|GPIO_Pin_8|GPIO_Pin_5;
    843          //		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    844          //		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
    845          //		GPIO_Init(GPIOB, &GPIO_InitStructure);
    846          
    847          	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    848          	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    849          	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
    850          	GPIO_Init(GPIOB, &GPIO_InitStructure);
    851          	
    852          	
    853          	// ========== GPIO C ===============================================
    854          	// GPIO_Pin_0 : WIPER1 SENSOR (IN)
    855          	// GPIO_Pin_1 : WIPER2 SENSOR (IN)
    856          	// GPIO_Pin_2 : NC
    857          	// GPIO_Pin_3 : LED1 (OUT)
    858          	// GPIO_Pin_4 : TW9900_IRQ
    859          	// GPIO_Pin_5 : TW9900_RST
    860          	// GPIO_Pin_6 : MOTOR START (OUT)
    861          	// GPIO_Pin_7 : MOTOR FG (IN)
    862          	// GPIO_Pin_8 : MOTOR CW/CCW (OUT)
    863          	// GPIO_Pin_9 : NC
    864          	// GPIO_Pin_10 : UART4_Tx (OUT) : CAMERA
    865          	// GPIO_Pin_11 : UART4_Rx (IN) : CAMERA
    866          	// GPIO_Pin_12 : UART5_Tx (OUT) : IP BOARD
    867          	// GPIO_Pin_13 : HEATER (OUT)
    868          	// GPIO_Pin_14 : NC
    869          	// GPIO_Pin_15 : FAN (OUT)
    870          	// ===============================================================
    871          
    872          	// ----- Configure the INPUT-PIN --------------------
    873          //		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0|GPIO_Pin_1|GPIO_Pin_4|GPIO_Pin_7|GPIO_Pin_11;
    874          //		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    875          //		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    876          //		GPIO_Init(GPIOC, &GPIO_InitStructure);
    877          
    878          	// ----- Configure the OUTPUT-PIN -------------------
    879          //		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3|GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_8|GPIO_Pin_13|GPIO_Pin_15; 
    880          //		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
    881          //		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    882          //		GPIO_Init(GPIOC, &GPIO_InitStructure);
    883          
    884          	// ----- Configure the OUTPUT-PIN -------------------
    885          //		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10|GPIO_Pin_12;
    886          //		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    887          //		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    888          //		GPIO_Init(GPIOC, &GPIO_InitStructure);
    889          	
    890          	// ========== GPIO D ===============================================
    891          	// GPIO_Pin_0 : OSCI
    892          	// GPIO_Pin_1 : OSCO
    893          	// GPIO_Pin_2 : UART5_Rx (IN) : IP BOARD
    894          	// ===============================================================
    895          	// ----- Configure the INPUT-PIN --------------------
    896          //		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
    897          //		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    898          //		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    899          //		GPIO_Init(GPIOD, &GPIO_InitStructure);
    900          }
    901          
    902          /*******************************************************************************
    903          * Function : DMA_Configuration
    904          *******************************************************************************/
    905          void DMA_Configuration(void)
    906          {
    907          	DMA_DeInit(DMA1_Channel1);
    908          	DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address;
    909          	DMA_InitStructure.DMA_MemoryBaseAddr = (u32)&stADC.DMA1_ADC_VALUE;
    910          	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
    911          	DMA_InitStructure.DMA_BufferSize = 2;
    912          	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    913          	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
    914          	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Word;
    915          	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Word;
    916          	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
    917          	DMA_InitStructure.DMA_Priority = DMA_Priority_High;
    918          	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
    919          	DMA_Init(DMA1_Channel1, &DMA_InitStructure);
    920          
    921          	DMA_Cmd(DMA1_Channel1, ENABLE);
    922          }
    923          
    924          /*******************************************************************************
    925          * Function : ADC_Configuration
    926          *******************************************************************************/
    927          void ADC_Configuration(void)
    928          {
    929          	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
    930          	ADC_InitStructure.ADC_ScanConvMode = ENABLE;
    931          	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
    932          	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
    933          	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
    934          	ADC_InitStructure.ADC_NbrOfChannel = 2;
    935          	ADC_Init(ADC1, &ADC_InitStructure);
    936          	ADC_TempSensorVrefintCmd(ENABLE);
    937          	
    938          	// PA0, CH0, TEMP
    939          	ADC_RegularChannelConfig(ADC1, ADC_Channel_0, 1, ADC_SampleTime_28Cycles5);
    940          
    941          	// PA4, CH4, CDS
    942          	ADC_RegularChannelConfig(ADC1, ADC_Channel_4, 2, ADC_SampleTime_28Cycles5);
    943          
    944          	ADC_Cmd(ADC1, ENABLE);
    945          	ADC_DMACmd(ADC1, ENABLE);
    946          
    947          	ADC_ResetCalibration(ADC1);  
    948          	while(ADC_GetResetCalibrationStatus(ADC1));	
    949          	ADC_StartCalibration(ADC1);  
    950          	while(ADC_GetCalibrationStatus(ADC1));  
    951          	ADC_SoftwareStartConvCmd(ADC1, ENABLE);  
    952          }
    953          
    954          /*******************************************************************************
    955          * Function : ADC_Configuration
    956          *******************************************************************************/
    957          void I2C_Configuration(void)
    958          {
    959          	/* I2C1,2 Periph clock enable */
    960          	//RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C1, ENABLE);
    961          	//RCC_APB1PeriphClockCmd(RCC_APB1Periph_I2C2, ENABLE);	
    962          
    963          	//I2C1 Initial - TW9900 #1/#2 : PF0,1===========================================
    964          	/* Reset sEE_I2C IP */
    965          	//RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C1, ENABLE);
    966          	/* Release reset signal of sEE_I2C IP */
    967          	//RCC_APB1PeriphResetCmd(RCC_APB1Periph_I2C2, ENABLE);
    968          	/* Connect PF1 to I2C_SCL*/
    969          	//GPIO_PinAFConfig(GPIOF, GPIO_PinSource1, GPIO_AF_I2C1);
    970          	/* Connect PF0 to I2C_SDA*/
    971          	//GPIO_PinAFConfig(GPIOF, GPIO_PinSource0, GPIO_AF_I2C1);
    972          
    973          	// I2C1 Configuration	
    974          	#if(1)
    975          	I2C_InitStructure.I2C_ClockSpeed = 100000;	//100KB, 400000;
    976          	I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
    977          	I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
    978          	I2C_InitStructure.I2C_OwnAddress1 = TW9900_ADDR;
    979          	I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
    980          	I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
    981          	I2C_Cmd(I2C1, ENABLE); /* I2C Peripheral Enable enable */
    982          	I2C_Init(I2C1, &I2C_InitStructure);	/* Apply I2C configuration after enabling it */
    983          	//======================================================== I2C1 Initial END
    984          	#endif
    985          	
    986          	#if(1)
    987          	// I2C2 Configuration	
    988          	I2C_InitStructure.I2C_ClockSpeed = 100000;	//100KB, 400000;
    989          	I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
    990          	I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
    991          	I2C_InitStructure.I2C_OwnAddress1 = AT24C256_ADDR;
    992          	I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
    993          	I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
    994          	I2C_Cmd(I2C2, ENABLE); /* I2C Peripheral Enable enable */
    995          	I2C_Init(I2C2, &I2C_InitStructure);	/* Apply I2C configuration after enabling it */	
    996          	#endif	
    997          	//======================================================== I2C2 Initial END
    998          
    999          }
   1000          
   1001          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  ADC_Configuration
              8 -> ADC_Cmd
              8 -> ADC_DMACmd
              8 -> ADC_GetCalibrationStatus
              8 -> ADC_GetResetCalibrationStatus
              8 -> ADC_Init
              8 -> ADC_RegularChannelConfig
              8 -> ADC_ResetCalibration
              8 -> ADC_SoftwareStartConvCmd
              8 -> ADC_StartCalibration
              8 -> ADC_TempSensorVrefintCmd
        8  DMA_Configuration
              8 -> DMA_Cmd
              8 -> DMA_DeInit
              8 -> DMA_Init
        8  Dipswitch_Mode_Check
              8 -> GPIO_ReadInputDataBit
        8  GPIO_Configuration
              8 -> GPIO_Init
        8  I2C_Configuration
              8 -> I2C_Cmd
              8 -> I2C_Init
        8  Initial_Device
              8 -> ADC_Configuration
              8 -> DMA_Configuration
              8 -> Dipswitch_Mode_Check
              8 -> GPIO_Configuration
              8 -> I2C_Configuration
              8 -> NVIC_Configuration
              8 -> RCC_Configuration
              8 -> RCC_GetClocksFreq
              8 -> SysTick_Config
              8 -> TIMER_Init
              8 -> UART4_Init
              8 -> UART5_Init
              8 -> USART1_Init
              8 -> USART2_Init
        8  Initial_Wiper
              8 -> Delay_1ms
              8 -> Run_Wiper
        8  NVIC_Configuration
              8 -> NVIC_Init
        0  NVIC_SetPriority
        8  RCC_Configuration
              8 -> RCC_AHBPeriphClockCmd
              8 -> RCC_APB1PeriphClockCmd
              8 -> RCC_APB2PeriphClockCmd
              8 -> SystemInit
       16  Run_Wiper
             16 -> GPIO_ResetBits
             16 -> GPIO_SetBits
             16 -> TIMER1_CH4_DutyPeriod
        8  SysTick_Config
              8 -> NVIC_SetPriority
       16  TIMER1_CH4_DutyPeriod
             16 -> TIM_Cmd
             16 -> TIM_CtrlPWMOutputs
             16 -> TIM_OC4Init
        8  TIMER_Init
              8 -> TIM_Cmd
              8 -> TIM_OC1Init
              8 -> TIM_OC2Init
              8 -> TIM_OC3Init
              8 -> TIM_OC4Init
              8 -> TIM_TimeBaseInit
        8  UART4_Init
              8 -> USART_Cmd
              8 -> USART_ITConfig
              8 -> USART_Init
        8  UART5_Init
              8 -> USART_Cmd
              8 -> USART_ITConfig
              8 -> USART_Init
        8  USART1_Init
              8 -> USART_Cmd
              8 -> USART_ITConfig
              8 -> USART_Init
        8  USART2_Init
              8 -> USART_Cmd
              8 -> USART_ITConfig
              8 -> USART_Init
        8  USART3_Init
              8 -> USART_Cmd
              8 -> USART_ITConfig
              8 -> USART_Init
        8  Wiper_Active
              8 -> Delay_1ms
              8 -> Run_Wiper
        8  Wiper_Function
              8 -> Run_Wiper
              8 -> Wiper_Active


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable19
       4  ??DataTable19_1
       4  ??DataTable19_10
       4  ??DataTable19_11
       4  ??DataTable19_12
       4  ??DataTable19_13
       4  ??DataTable19_14
       4  ??DataTable19_15
       4  ??DataTable19_16
       4  ??DataTable19_17
       4  ??DataTable19_18
       4  ??DataTable19_19
       4  ??DataTable19_2
       4  ??DataTable19_20
       4  ??DataTable19_21
       4  ??DataTable19_22
       4  ??DataTable19_23
       4  ??DataTable19_24
       4  ??DataTable19_25
       4  ??DataTable19_26
       4  ??DataTable19_27
       4  ??DataTable19_28
       4  ??DataTable19_29
       4  ??DataTable19_3
       4  ??DataTable19_30
       4  ??DataTable19_31
       4  ??DataTable19_32
       4  ??DataTable19_33
       4  ??DataTable19_34
       4  ??DataTable19_35
       4  ??DataTable19_36
       4  ??DataTable19_37
       4  ??DataTable19_38
       4  ??DataTable19_4
       4  ??DataTable19_5
       4  ??DataTable19_6
       4  ??DataTable19_7
       4  ??DataTable19_8
       4  ??DataTable19_9
     136  ADC_Configuration
      20  ADC_InitStructure
      98  DMA_Configuration
      44  DMA_InitStructure
      40  Dipswitch_Mode_Check
      58  GPIO_Configuration
       4  GPIO_InitStructure
     120  I2C_Configuration
      16  I2C_InitStructure
     100  Initial_Device
     252  Initial_Wiper
     214  NVIC_Configuration
       4  NVIC_InitStructure
      38  NVIC_SetPriority
       2  PrescalerValue
     128  RCC_Configuration
     152  Run_Wiper
      56  SysTick_Config
     162  TIMER1_CH4_DutyPeriod
     188  TIMER_Init
      16  TIM_OCInitStructure
      12  TIM_TimeBaseStructure
     102  UART4_Init
     102  UART5_Init
     106  USART1_Init
     102  USART2_Init
     104  USART3_Init
      16  USART_InitStructure
     446  Wiper_Active
     190  Wiper_Function
      20  rcc_clocks

 
   154 bytes in section .bss
 3 050 bytes in section .text
 
 3 050 bytes of CODE memory
   154 bytes of DATA memory

Errors: none
Warnings: 1
