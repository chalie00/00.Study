###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     28/Jul/2022  15:47:25 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\Libraries\STM32F1 #
#                    0x_StdPeriph_Driver\src\stm32f10x_fsmc.c                 #
#    Command line =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\Libraries\STM32F1 #
#                    0x_StdPeriph_Driver\src\stm32f10x_fsmc.c -D              #
#                    USE_STDPERIPH_DRIVER -D STM32F10x_HD -D USE_FULL_ASSERT  #
#                    -lcN C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_ #
#                    M32\Debug\List\ -lb C:\Users\TTT\Desktop\zz.STDFW\00.Stu #
#                    dy\project\IAR_M32\Debug\List\ -o                        #
#                    C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_M32\D #
#                    ebug\Obj\ --no_cse --no_unroll --no_inline               #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\I #
#                    AR_M32\..\..\inc\ -I C:\Users\TTT\Desktop\zz.STDFW\00.St #
#                    udy\project\IAR_M32\..\..\Libraries\CMSIS\CM3\DeviceSupp #
#                    ort\ST\STM32F10x\ -I C:\Users\TTT\Desktop\zz.STDFW\00.St #
#                    udy\project\IAR_M32\..\..\Libraries\STM32F10x_StdPeriph_ #
#                    Driver\inc\ -I "C:\Program Files (x86)\IAR               #
#                    Systems\Embedded Workbench 6.0\arm\inc\c\" -On -I        #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_M32\D #
#                    ebug\List\stm32f10x_fsmc.lst                             #
#    Object file  =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_M32\D #
#                    ebug\Obj\stm32f10x_fsmc.o                                #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\TTT\Desktop\zz.STDFW\00.Study\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_fsmc.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f10x_fsmc.c
      4            * @author  MCD Application Team
      5            * @version V3.4.0
      6            * @date    10/15/2010
      7            * @brief   This file provides all the FSMC firmware functions.
      8            ******************************************************************************
      9            * @copy
     10            *
     11            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     12            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     13            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     14            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     15            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     16            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     17            *
     18            * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
     19            */ 
     20          
     21          /* Includes ------------------------------------------------------------------*/
     22          #include "stm32f10x_fsmc.h"
     23          #include "stm32f10x_rcc.h"
     24          
     25          /** @addtogroup STM32F10x_StdPeriph_Driver
     26            * @{
     27            */
     28          
     29          /** @defgroup FSMC 
     30            * @brief FSMC driver modules
     31            * @{
     32            */ 
     33          
     34          /** @defgroup FSMC_Private_TypesDefinitions
     35            * @{
     36            */ 
     37          /**
     38            * @}
     39            */
     40          
     41          /** @defgroup FSMC_Private_Defines
     42            * @{
     43            */
     44          
     45          /* --------------------- FSMC registers bit mask ---------------------------- */
     46          
     47          /* FSMC BCRx Mask */
     48          #define BCR_MBKEN_Set                       ((uint32_t)0x00000001)
     49          #define BCR_MBKEN_Reset                     ((uint32_t)0x000FFFFE)
     50          #define BCR_FACCEN_Set                      ((uint32_t)0x00000040)
     51          
     52          /* FSMC PCRx Mask */
     53          #define PCR_PBKEN_Set                       ((uint32_t)0x00000004)
     54          #define PCR_PBKEN_Reset                     ((uint32_t)0x000FFFFB)
     55          #define PCR_ECCEN_Set                       ((uint32_t)0x00000040)
     56          #define PCR_ECCEN_Reset                     ((uint32_t)0x000FFFBF)
     57          #define PCR_MemoryType_NAND                 ((uint32_t)0x00000008)
     58          /**
     59            * @}
     60            */
     61          
     62          /** @defgroup FSMC_Private_Macros
     63            * @{
     64            */
     65          
     66          /**
     67            * @}
     68            */
     69          
     70          /** @defgroup FSMC_Private_Variables
     71            * @{
     72            */
     73          
     74          /**
     75            * @}
     76            */
     77          
     78          /** @defgroup FSMC_Private_FunctionPrototypes
     79            * @{
     80            */
     81          
     82          /**
     83            * @}
     84            */
     85          
     86          /** @defgroup FSMC_Private_Functions
     87            * @{
     88            */
     89          
     90          /**
     91            * @brief  Deinitializes the FSMC NOR/SRAM Banks registers to their default 
     92            *   reset values.
     93            * @param  FSMC_Bank: specifies the FSMC Bank to be used
     94            *   This parameter can be one of the following values:
     95            *     @arg FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1  
     96            *     @arg FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2 
     97            *     @arg FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
     98            *     @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
     99            * @retval None
    100            */
    101          void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank)
    102          {
    103            /* Check the parameter */
    104            assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
    105            
    106            /* FSMC_Bank1_NORSRAM1 */
    107            if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
    108            {
    109              FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
    110            }
    111            /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
    112            else
    113            {   
    114              FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
    115            }
    116            FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
    117            FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
    118          }
    119          
    120          /**
    121            * @brief  Deinitializes the FSMC NAND Banks registers to their default reset values.
    122            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    123            *   This parameter can be one of the following values:
    124            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    125            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND 
    126            * @retval None
    127            */
    128          void FSMC_NANDDeInit(uint32_t FSMC_Bank)
    129          {
    130            /* Check the parameter */
    131            assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
    132            
    133            if(FSMC_Bank == FSMC_Bank2_NAND)
    134            {
    135              /* Set the FSMC_Bank2 registers to their reset values */
    136              FSMC_Bank2->PCR2 = 0x00000018;
    137              FSMC_Bank2->SR2 = 0x00000040;
    138              FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
    139              FSMC_Bank2->PATT2 = 0xFCFCFCFC;  
    140            }
    141            /* FSMC_Bank3_NAND */  
    142            else
    143            {
    144              /* Set the FSMC_Bank3 registers to their reset values */
    145              FSMC_Bank3->PCR3 = 0x00000018;
    146              FSMC_Bank3->SR3 = 0x00000040;
    147              FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
    148              FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
    149            }  
    150          }
    151          
    152          /**
    153            * @brief  Deinitializes the FSMC PCCARD Bank registers to their default reset values.
    154            * @param  None                       
    155            * @retval None
    156            */
    157          void FSMC_PCCARDDeInit(void)
    158          {
    159            /* Set the FSMC_Bank4 registers to their reset values */
    160            FSMC_Bank4->PCR4 = 0x00000018; 
    161            FSMC_Bank4->SR4 = 0x00000000;	
    162            FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
    163            FSMC_Bank4->PATT4 = 0xFCFCFCFC;
    164            FSMC_Bank4->PIO4 = 0xFCFCFCFC;
    165          }
    166          
    167          /**
    168            * @brief  Initializes the FSMC NOR/SRAM Banks according to the specified
    169            *   parameters in the FSMC_NORSRAMInitStruct.
    170            * @param  FSMC_NORSRAMInitStruct : pointer to a FSMC_NORSRAMInitTypeDef
    171            *   structure that contains the configuration information for 
    172            *   the FSMC NOR/SRAM specified Banks.                       
    173            * @retval None
    174            */
    175          void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
    176          { 
    177            /* Check the parameters */
    178            assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));
    179            assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));
    180            assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));
    181            assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));
    182            assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));
    183            assert_param(IS_FSMC_ASYNWAIT(FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait));
    184            assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));
    185            assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));
    186            assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));
    187            assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));
    188            assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));
    189            assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));
    190            assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));  
    191            assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));
    192            assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));
    193            assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));
    194            assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));
    195            assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
    196            assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
    197            assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
    198            
    199            /* Bank1 NOR/SRAM control register configuration */ 
    200            FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
    201                      (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
    202                      FSMC_NORSRAMInitStruct->FSMC_MemoryType |
    203                      FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
    204                      FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
    205                      FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |
    206                      FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
    207                      FSMC_NORSRAMInitStruct->FSMC_WrapMode |
    208                      FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
    209                      FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
    210                      FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
    211                      FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
    212                      FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
    213          
    214            if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
    215            {
    216              FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_Set;
    217            }
    218            
    219            /* Bank1 NOR/SRAM timing register configuration */
    220            FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
    221                      (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
    222                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
    223                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
    224                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
    225                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
    226                      (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
    227                       FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
    228                      
    229              
    230            /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
    231            if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
    232            {
    233              assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));
    234              assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
    235              assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
    236              assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
    237              assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
    238              assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
    239              FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
    240                        (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
    241                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
    242                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
    243                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
    244                        (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
    245                         FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
    246            }
    247            else
    248            {
    249              FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
    250            }
    251          }
    252          
    253          /**
    254            * @brief  Initializes the FSMC NAND Banks according to the specified 
    255            *   parameters in the FSMC_NANDInitStruct.
    256            * @param  FSMC_NANDInitStruct : pointer to a FSMC_NANDInitTypeDef 
    257            *   structure that contains the configuration information for the FSMC NAND specified Banks.                       
    258            * @retval None
    259            */
    260          void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
    261          {
    262            uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
    263              
    264            /* Check the parameters */
    265            assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));
    266            assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));
    267            assert_param( IS_FSMC_MEMORY_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));
    268            assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));
    269            assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));
    270            assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));
    271            assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));
    272            assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
    273            assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
    274            assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
    275            assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
    276            assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
    277            assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
    278            assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
    279            assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
    280            
    281            /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
    282            tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
    283                      PCR_MemoryType_NAND |
    284                      FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
    285                      FSMC_NANDInitStruct->FSMC_ECC |
    286                      FSMC_NANDInitStruct->FSMC_ECCPageSize |
    287                      (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
    288                      (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
    289                      
    290            /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
    291            tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
    292                      (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    293                      (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    294                      (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
    295                      
    296            /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
    297            tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
    298                      (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    299                      (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    300                      (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
    301            
    302            if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
    303            {
    304              /* FSMC_Bank2_NAND registers configuration */
    305              FSMC_Bank2->PCR2 = tmppcr;
    306              FSMC_Bank2->PMEM2 = tmppmem;
    307              FSMC_Bank2->PATT2 = tmppatt;
    308            }
    309            else
    310            {
    311              /* FSMC_Bank3_NAND registers configuration */
    312              FSMC_Bank3->PCR3 = tmppcr;
    313              FSMC_Bank3->PMEM3 = tmppmem;
    314              FSMC_Bank3->PATT3 = tmppatt;
    315            }
    316          }
    317          
    318          /**
    319            * @brief  Initializes the FSMC PCCARD Bank according to the specified 
    320            *   parameters in the FSMC_PCCARDInitStruct.
    321            * @param  FSMC_PCCARDInitStruct : pointer to a FSMC_PCCARDInitTypeDef
    322            *   structure that contains the configuration information for the FSMC PCCARD Bank.                       
    323            * @retval None
    324            */
    325          void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
    326          {
    327            /* Check the parameters */
    328            assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct->FSMC_Waitfeature));
    329            assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime));
    330            assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct->FSMC_TARSetupTime));
    331           
    332            assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
    333            assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
    334            assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
    335            assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
    336            
    337            assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
    338            assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
    339            assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
    340            assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
    341            assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime));
    342            assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
    343            assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
    344            assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
    345            
    346            /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
    347            FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
    348                               FSMC_MemoryDataWidth_16b |  
    349                               (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
    350                               (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
    351                      
    352            /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
    353            FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
    354                                (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    355                                (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    356                                (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
    357                      
    358            /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
    359            FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
    360                                (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    361                                (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    362                                (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
    363                      
    364            /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
    365            FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
    366                               (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
    367                               (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
    368                               (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);             
    369          }
    370          
    371          /**
    372            * @brief  Fills each FSMC_NORSRAMInitStruct member with its default value.
    373            * @param  FSMC_NORSRAMInitStruct: pointer to a FSMC_NORSRAMInitTypeDef 
    374            *   structure which will be initialized.
    375            * @retval None
    376            */
    377          void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
    378          {  
    379            /* Reset NOR/SRAM Init structure parameters values */
    380            FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
    381            FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
    382            FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
    383            FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
    384            FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
    385            FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
    386            FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
    387            FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
    388            FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
    389            FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
    390            FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
    391            FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
    392            FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
    393            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
    394            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
    395            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
    396            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
    397            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
    398            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
    399            FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; 
    400            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;
    401            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;
    402            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;
    403            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
    404            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;
    405            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;
    406            FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;
    407          }
    408          
    409          /**
    410            * @brief  Fills each FSMC_NANDInitStruct member with its default value.
    411            * @param  FSMC_NANDInitStruct: pointer to a FSMC_NANDInitTypeDef 
    412            *   structure which will be initialized.
    413            * @retval None
    414            */
    415          void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
    416          { 
    417            /* Reset NAND Init structure parameters values */
    418            FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
    419            FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
    420            FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
    421            FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
    422            FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
    423            FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
    424            FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
    425            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
    426            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
    427            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
    428            FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
    429            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
    430            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
    431            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
    432            FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
    433          }
    434          
    435          /**
    436            * @brief  Fills each FSMC_PCCARDInitStruct member with its default value.
    437            * @param  FSMC_PCCARDInitStruct: pointer to a FSMC_PCCARDInitTypeDef 
    438            *   structure which will be initialized.
    439            * @retval None
    440            */
    441          void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
    442          {
    443            /* Reset PCCARD Init structure parameters values */
    444            FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
    445            FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
    446            FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
    447            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
    448            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
    449            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
    450            FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
    451            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
    452            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
    453            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
    454            FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
    455            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
    456            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
    457            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
    458            FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
    459          }
    460          
    461          /**
    462            * @brief  Enables or disables the specified NOR/SRAM Memory Bank.
    463            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    464            *   This parameter can be one of the following values:
    465            *     @arg FSMC_Bank1_NORSRAM1: FSMC Bank1 NOR/SRAM1  
    466            *     @arg FSMC_Bank1_NORSRAM2: FSMC Bank1 NOR/SRAM2 
    467            *     @arg FSMC_Bank1_NORSRAM3: FSMC Bank1 NOR/SRAM3 
    468            *     @arg FSMC_Bank1_NORSRAM4: FSMC Bank1 NOR/SRAM4 
    469            * @param  NewState: new state of the FSMC_Bank. This parameter can be: ENABLE or DISABLE.
    470            * @retval None
    471            */
    472          void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
    473          {
    474            assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
    475            assert_param(IS_FUNCTIONAL_STATE(NewState));
    476            
    477            if (NewState != DISABLE)
    478            {
    479              /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
    480              FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_Set;
    481            }
    482            else
    483            {
    484              /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
    485              FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_Reset;
    486            }
    487          }
    488          
    489          /**
    490            * @brief  Enables or disables the specified NAND Memory Bank.
    491            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    492            *   This parameter can be one of the following values:
    493            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    494            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    495            * @param  NewState: new state of the FSMC_Bank. This parameter can be: ENABLE or DISABLE.
    496            * @retval None
    497            */
    498          void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
    499          {
    500            assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
    501            assert_param(IS_FUNCTIONAL_STATE(NewState));
    502            
    503            if (NewState != DISABLE)
    504            {
    505              /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
    506              if(FSMC_Bank == FSMC_Bank2_NAND)
    507              {
    508                FSMC_Bank2->PCR2 |= PCR_PBKEN_Set;
    509              }
    510              else
    511              {
    512                FSMC_Bank3->PCR3 |= PCR_PBKEN_Set;
    513              }
    514            }
    515            else
    516            {
    517              /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
    518              if(FSMC_Bank == FSMC_Bank2_NAND)
    519              {
    520                FSMC_Bank2->PCR2 &= PCR_PBKEN_Reset;
    521              }
    522              else
    523              {
    524                FSMC_Bank3->PCR3 &= PCR_PBKEN_Reset;
    525              }
    526            }
    527          }
    528          
    529          /**
    530            * @brief  Enables or disables the PCCARD Memory Bank.
    531            * @param  NewState: new state of the PCCARD Memory Bank.  
    532            *   This parameter can be: ENABLE or DISABLE.
    533            * @retval None
    534            */
    535          void FSMC_PCCARDCmd(FunctionalState NewState)
    536          {
    537            assert_param(IS_FUNCTIONAL_STATE(NewState));
    538            
    539            if (NewState != DISABLE)
    540            {
    541              /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
    542              FSMC_Bank4->PCR4 |= PCR_PBKEN_Set;
    543            }
    544            else
    545            {
    546              /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
    547              FSMC_Bank4->PCR4 &= PCR_PBKEN_Reset;
    548            }
    549          }
    550          
    551          /**
    552            * @brief  Enables or disables the FSMC NAND ECC feature.
    553            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    554            *   This parameter can be one of the following values:
    555            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    556            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    557            * @param  NewState: new state of the FSMC NAND ECC feature.  
    558            *   This parameter can be: ENABLE or DISABLE.
    559            * @retval None
    560            */
    561          void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
    562          {
    563            assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
    564            assert_param(IS_FUNCTIONAL_STATE(NewState));
    565            
    566            if (NewState != DISABLE)
    567            {
    568              /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
    569              if(FSMC_Bank == FSMC_Bank2_NAND)
    570              {
    571                FSMC_Bank2->PCR2 |= PCR_ECCEN_Set;
    572              }
    573              else
    574              {
    575                FSMC_Bank3->PCR3 |= PCR_ECCEN_Set;
    576              }
    577            }
    578            else
    579            {
    580              /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
    581              if(FSMC_Bank == FSMC_Bank2_NAND)
    582              {
    583                FSMC_Bank2->PCR2 &= PCR_ECCEN_Reset;
    584              }
    585              else
    586              {
    587                FSMC_Bank3->PCR3 &= PCR_ECCEN_Reset;
    588              }
    589            }
    590          }
    591          
    592          /**
    593            * @brief  Returns the error correction code register value.
    594            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    595            *   This parameter can be one of the following values:
    596            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    597            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    598            * @retval The Error Correction Code (ECC) value.
    599            */
    600          uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
    601          {
    602            uint32_t eccval = 0x00000000;
    603            
    604            if(FSMC_Bank == FSMC_Bank2_NAND)
    605            {
    606              /* Get the ECCR2 register value */
    607              eccval = FSMC_Bank2->ECCR2;
    608            }
    609            else
    610            {
    611              /* Get the ECCR3 register value */
    612              eccval = FSMC_Bank3->ECCR3;
    613            }
    614            /* Return the error correction code value */
    615            return(eccval);
    616          }
    617          
    618          /**
    619            * @brief  Enables or disables the specified FSMC interrupts.
    620            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    621            *   This parameter can be one of the following values:
    622            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    623            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    624            *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    625            * @param  FSMC_IT: specifies the FSMC interrupt sources to be enabled or disabled.
    626            *   This parameter can be any combination of the following values:
    627            *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
    628            *     @arg FSMC_IT_Level: Level edge detection interrupt.
    629            *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt.
    630            * @param  NewState: new state of the specified FSMC interrupts.
    631            *   This parameter can be: ENABLE or DISABLE.
    632            * @retval None
    633            */
    634          void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState)
    635          {
    636            assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
    637            assert_param(IS_FSMC_IT(FSMC_IT));	
    638            assert_param(IS_FUNCTIONAL_STATE(NewState));
    639            
    640            if (NewState != DISABLE)
    641            {
    642              /* Enable the selected FSMC_Bank2 interrupts */
    643              if(FSMC_Bank == FSMC_Bank2_NAND)
    644              {
    645                FSMC_Bank2->SR2 |= FSMC_IT;
    646              }
    647              /* Enable the selected FSMC_Bank3 interrupts */
    648              else if (FSMC_Bank == FSMC_Bank3_NAND)
    649              {
    650                FSMC_Bank3->SR3 |= FSMC_IT;
    651              }
    652              /* Enable the selected FSMC_Bank4 interrupts */
    653              else
    654              {
    655                FSMC_Bank4->SR4 |= FSMC_IT;    
    656              }
    657            }
    658            else
    659            {
    660              /* Disable the selected FSMC_Bank2 interrupts */
    661              if(FSMC_Bank == FSMC_Bank2_NAND)
    662              {
    663                
    664                FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
    665              }
    666              /* Disable the selected FSMC_Bank3 interrupts */
    667              else if (FSMC_Bank == FSMC_Bank3_NAND)
    668              {
    669                FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
    670              }
    671              /* Disable the selected FSMC_Bank4 interrupts */
    672              else
    673              {
    674                FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    
    675              }
    676            }
    677          }
    678          
    679          /**
    680            * @brief  Checks whether the specified FSMC flag is set or not.
    681            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    682            *   This parameter can be one of the following values:
    683            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    684            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    685            *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    686            * @param  FSMC_FLAG: specifies the flag to check.
    687            *   This parameter can be one of the following values:
    688            *     @arg FSMC_FLAG_RisingEdge: Rising egde detection Flag.
    689            *     @arg FSMC_FLAG_Level: Level detection Flag.
    690            *     @arg FSMC_FLAG_FallingEdge: Falling egde detection Flag.
    691            *     @arg FSMC_FLAG_FEMPT: Fifo empty Flag. 
    692            * @retval The new state of FSMC_FLAG (SET or RESET).
    693            */
    694          FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
    695          {
    696            FlagStatus bitstatus = RESET;
    697            uint32_t tmpsr = 0x00000000;
    698            
    699            /* Check the parameters */
    700            assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
    701            assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
    702            
    703            if(FSMC_Bank == FSMC_Bank2_NAND)
    704            {
    705              tmpsr = FSMC_Bank2->SR2;
    706            }  
    707            else if(FSMC_Bank == FSMC_Bank3_NAND)
    708            {
    709              tmpsr = FSMC_Bank3->SR3;
    710            }
    711            /* FSMC_Bank4_PCCARD*/
    712            else
    713            {
    714              tmpsr = FSMC_Bank4->SR4;
    715            } 
    716            
    717            /* Get the flag status */
    718            if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )
    719            {
    720              bitstatus = SET;
    721            }
    722            else
    723            {
    724              bitstatus = RESET;
    725            }
    726            /* Return the flag status */
    727            return bitstatus;
    728          }
    729          
    730          /**
    731            * @brief  Clears the FSMC’s pending flags.
    732            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    733            *   This parameter can be one of the following values:
    734            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    735            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    736            *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    737            * @param  FSMC_FLAG: specifies the flag to clear.
    738            *   This parameter can be any combination of the following values:
    739            *     @arg FSMC_FLAG_RisingEdge: Rising egde detection Flag.
    740            *     @arg FSMC_FLAG_Level: Level detection Flag.
    741            *     @arg FSMC_FLAG_FallingEdge: Falling egde detection Flag.
    742            * @retval None
    743            */
    744          void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
    745          {
    746           /* Check the parameters */
    747            assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
    748            assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
    749              
    750            if(FSMC_Bank == FSMC_Bank2_NAND)
    751            {
    752              FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
    753            }  
    754            else if(FSMC_Bank == FSMC_Bank3_NAND)
    755            {
    756              FSMC_Bank3->SR3 &= ~FSMC_FLAG;
    757            }
    758            /* FSMC_Bank4_PCCARD*/
    759            else
    760            {
    761              FSMC_Bank4->SR4 &= ~FSMC_FLAG;
    762            }
    763          }
    764          
    765          /**
    766            * @brief  Checks whether the specified FSMC interrupt has occurred or not.
    767            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    768            *   This parameter can be one of the following values:
    769            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    770            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    771            *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    772            * @param  FSMC_IT: specifies the FSMC interrupt source to check.
    773            *   This parameter can be one of the following values:
    774            *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
    775            *     @arg FSMC_IT_Level: Level edge detection interrupt.
    776            *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt. 
    777            * @retval The new state of FSMC_IT (SET or RESET).
    778            */
    779          ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT)
    780          {
    781            ITStatus bitstatus = RESET;
    782            uint32_t tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
    783            
    784            /* Check the parameters */
    785            assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
    786            assert_param(IS_FSMC_GET_IT(FSMC_IT));
    787            
    788            if(FSMC_Bank == FSMC_Bank2_NAND)
    789            {
    790              tmpsr = FSMC_Bank2->SR2;
    791            }  
    792            else if(FSMC_Bank == FSMC_Bank3_NAND)
    793            {
    794              tmpsr = FSMC_Bank3->SR3;
    795            }
    796            /* FSMC_Bank4_PCCARD*/
    797            else
    798            {
    799              tmpsr = FSMC_Bank4->SR4;
    800            } 
    801            
    802            itstatus = tmpsr & FSMC_IT;
    803            
    804            itenable = tmpsr & (FSMC_IT >> 3);
    805            if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
    806            {
    807              bitstatus = SET;
    808            }
    809            else
    810            {
    811              bitstatus = RESET;
    812            }
    813            return bitstatus; 
    814          }
    815          
    816          /**
    817            * @brief  Clears the FSMC’s interrupt pending bits.
    818            * @param  FSMC_Bank: specifies the FSMC Bank to be used
    819            *   This parameter can be one of the following values:
    820            *     @arg FSMC_Bank2_NAND: FSMC Bank2 NAND 
    821            *     @arg FSMC_Bank3_NAND: FSMC Bank3 NAND
    822            *     @arg FSMC_Bank4_PCCARD: FSMC Bank4 PCCARD
    823            * @param  FSMC_IT: specifies the interrupt pending bit to clear.
    824            *   This parameter can be any combination of the following values:
    825            *     @arg FSMC_IT_RisingEdge: Rising edge detection interrupt. 
    826            *     @arg FSMC_IT_Level: Level edge detection interrupt.
    827            *     @arg FSMC_IT_FallingEdge: Falling edge detection interrupt.
    828            * @retval None
    829            */
    830          void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT)
    831          {
    832            /* Check the parameters */
    833            assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
    834            assert_param(IS_FSMC_IT(FSMC_IT));
    835              
    836            if(FSMC_Bank == FSMC_Bank2_NAND)
    837            {
    838              FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
    839            }  
    840            else if(FSMC_Bank == FSMC_Bank3_NAND)
    841            {
    842              FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
    843            }
    844            /* FSMC_Bank4_PCCARD*/
    845            else
    846            {
    847              FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
    848            }
    849          }
    850          
    851          /**
    852            * @}
    853            */ 
    854          
    855          /**
    856            * @}
    857            */
    858          
    859          /**
    860            * @}
    861            */
    862          
    863          /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       16  FSMC_ClearFlag
             16 -> assert_failed
       16  FSMC_ClearITPendingBit
             16 -> assert_failed
        0  FSMC_GetECC
       24  FSMC_GetFlagStatus
             24 -> assert_failed
       32  FSMC_GetITStatus
             32 -> assert_failed
       16  FSMC_ITConfig
             16 -> assert_failed
       16  FSMC_NANDCmd
             16 -> assert_failed
        8  FSMC_NANDDeInit
              8 -> assert_failed
       16  FSMC_NANDECCCmd
             16 -> assert_failed
       24  FSMC_NANDInit
             24 -> assert_failed
        0  FSMC_NANDStructInit
       16  FSMC_NORSRAMCmd
             16 -> assert_failed
        8  FSMC_NORSRAMDeInit
              8 -> assert_failed
        8  FSMC_NORSRAMInit
              8 -> assert_failed
        0  FSMC_NORSRAMStructInit
        8  FSMC_PCCARDCmd
              8 -> assert_failed
        0  FSMC_PCCARDDeInit
        8  FSMC_PCCARDInit
              8 -> assert_failed
        0  FSMC_PCCARDStructInit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     100  ?<Constant "C:\\Users\\TTT\\Desktop\\...">
       4  ??DataTable12
       4  ??DataTable13
       4  ??DataTable13_1
       4  ??DataTable13_10
       4  ??DataTable13_2
       4  ??DataTable13_3
       4  ??DataTable13_4
       4  ??DataTable13_5
       4  ??DataTable13_6
       4  ??DataTable13_7
       4  ??DataTable13_8
       4  ??DataTable13_9
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable15_2
       4  ??DataTable15_3
       4  ??DataTable15_4
       4  ??DataTable15_5
       4  ??DataTable15_6
       4  ??DataTable15_7
       4  ??DataTable15_8
       4  ??DataTable15_9
     104  FSMC_ClearFlag
     110  FSMC_ClearITPendingBit
      24  FSMC_GetECC
     118  FSMC_GetFlagStatus
     146  FSMC_GetITStatus
     182  FSMC_ITConfig
     124  FSMC_NANDCmd
     106  FSMC_NANDDeInit
     122  FSMC_NANDECCCmd
     502  FSMC_NANDInit
      78  FSMC_NANDStructInit
     106  FSMC_NORSRAMCmd
      86  FSMC_NORSRAMDeInit
     864  FSMC_NORSRAMInit
     142  FSMC_NORSRAMStructInit
      62  FSMC_PCCARDCmd
      48  FSMC_PCCARDDeInit
     432  FSMC_PCCARDInit
      86  FSMC_PCCARDStructInit

 
   100 bytes in section .rodata
 3 538 bytes in section .text
 
 3 538 bytes of CODE  memory
   100 bytes of CONST memory

Errors: none
Warnings: none
