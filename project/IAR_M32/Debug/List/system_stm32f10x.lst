###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.1.53127/W32 for ARM     28/Jul/2022  15:47:26 #
# Copyright 1999-2011 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\Libraries\CMSIS\C #
#                    M3\DeviceSupport\ST\STM32F10x\system_stm32f10x.c         #
#    Command line =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\Libraries\CMSIS\C #
#                    M3\DeviceSupport\ST\STM32F10x\system_stm32f10x.c -D      #
#                    USE_STDPERIPH_DRIVER -D STM32F10x_HD -D USE_FULL_ASSERT  #
#                    -lcN C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_ #
#                    M32\Debug\List\ -lb C:\Users\TTT\Desktop\zz.STDFW\00.Stu #
#                    dy\project\IAR_M32\Debug\List\ -o                        #
#                    C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_M32\D #
#                    ebug\Obj\ --no_cse --no_unroll --no_inline               #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=Cortex-M3  #
#                    -e --fpu=None --dlib_config "C:\Program Files (x86)\IAR  #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\I #
#                    AR_M32\..\..\inc\ -I C:\Users\TTT\Desktop\zz.STDFW\00.St #
#                    udy\project\IAR_M32\..\..\Libraries\CMSIS\CM3\DeviceSupp #
#                    ort\ST\STM32F10x\ -I C:\Users\TTT\Desktop\zz.STDFW\00.St #
#                    udy\project\IAR_M32\..\..\Libraries\STM32F10x_StdPeriph_ #
#                    Driver\inc\ -I "C:\Program Files (x86)\IAR               #
#                    Systems\Embedded Workbench 6.0\arm\inc\c\" -On -I        #
#                    "C:\Program Files (x86)\IAR Systems\Embedded Workbench   #
#                    6.0\arm\CMSIS\Include\"                                  #
#    List file    =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_M32\D #
#                    ebug\List\system_stm32f10x.lst                           #
#    Object file  =  C:\Users\TTT\Desktop\zz.STDFW\00.Study\project\IAR_M32\D #
#                    ebug\Obj\system_stm32f10x.o                              #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\TTT\Desktop\zz.STDFW\00.Study\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x\system_stm32f10x.c
      1          /**
      2            ******************************************************************************
      3            * @file    system_stm32f10x.c
      4            * @author  MCD Application Team
      5            * @version V3.3.0
      6            * @date    04/16/2010
      7            * @brief   CMSIS Cortex-M3 Device Peripheral Access Layer System Source File.
      8            ******************************************************************************  
      9            *
     10            * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
     11            * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
     12            * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
     13            * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
     14            * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
     15            * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
     16            *
     17            * <h2><center>&copy; COPYRIGHT 2010 STMicroelectronics</center></h2>
     18            ******************************************************************************
     19            */
     20          
     21          /** @addtogroup CMSIS
     22            * @{
     23            */
     24          
     25          /** @addtogroup stm32f10x_system
     26            * @{
     27            */  
     28            
     29          /** @addtogroup STM32F10x_System_Private_Includes
     30            * @{
     31            */
     32          
     33          #include "stm32f10x.h"
     34          
     35          /**
     36            * @}
     37            */
     38          
     39          /** @addtogroup STM32F10x_System_Private_TypesDefinitions
     40            * @{
     41            */
     42          
     43          /**
     44            * @}
     45            */
     46          
     47          /** @addtogroup STM32F10x_System_Private_Defines
     48            * @{
     49            */
     50          
     51          /*!< Uncomment the line corresponding to the desired System clock (SYSCLK)
     52             frequency (after reset the HSI is used as SYSCLK source)
     53             
     54             IMPORTANT NOTE:
     55             ============== 
     56             1. After each device reset the HSI is used as System clock source.
     57          
     58             2. Please make sure that the selected System clock doesn't exceed your device's
     59                maximum frequency.
     60                
     61             3. If none of the define below is enabled, the HSI is used as System clock
     62              source.
     63          
     64             4. The System clock configuration functions provided within this file assume that:
     65                  - For Low and Medium density Value line devices an external 8MHz crystal 
     66                    is used to drive the System clock.
     67                  - For Low, Medium and High density devices an external 8MHz crystal is
     68                    used to drive the System clock.
     69                  - For Connectivity line devices an external 25MHz crystal is used to drive
     70                    the System clock.
     71               If you are using different crystal you have to adapt those functions accordingly.
     72              */
     73              
     74          #if defined (STM32F10X_LD_VL) || (defined STM32F10X_MD_VL) 
     75          /* #define SYSCLK_FREQ_HSE    HSE_Value */
     76           #define SYSCLK_FREQ_24MHz  24000000
     77          #else
     78          /* #define SYSCLK_FREQ_HSE    HSE_Value */
     79          /* #define SYSCLK_FREQ_24MHz  24000000 */ 
     80          /* #define SYSCLK_FREQ_36MHz  36000000 */
     81          /* #define SYSCLK_FREQ_48MHz  48000000 */
     82          /* #define SYSCLK_FREQ_56MHz  56000000 */
     83          #define SYSCLK_FREQ_72MHz  72000000
     84          #endif
     85          
     86          /*!< Uncomment the following line if you need to use external SRAM mounted
     87               on STM3210E-EVAL board (STM32 High density and XL-density devices) as data memory  */ 
     88          #if defined (STM32F10X_HD) || (defined STM32F10X_XL)
     89          /* #define DATA_IN_ExtSRAM */
     90          #endif
     91          
     92          /**
     93            * @}
     94            */
     95          
     96          /** @addtogroup STM32F10x_System_Private_Macros
     97            * @{
     98            */
     99          
    100          /**
    101            * @}
    102            */
    103          
    104          /** @addtogroup STM32F10x_System_Private_Variables
    105            * @{
    106            */
    107          
    108          /*******************************************************************************
    109          *  Clock Definitions
    110          *******************************************************************************/
    111          #ifdef SYSCLK_FREQ_HSE
    112            uint32_t SystemCoreClock         = SYSCLK_FREQ_HSE; 
    113          #elif defined SYSCLK_FREQ_24MHz
    114            uint32_t SystemCoreClock         = SYSCLK_FREQ_24MHz;        /*!< System Clock Frequency (Core Clock) */
    115          #elif defined SYSCLK_FREQ_36MHz
    116            uint32_t SystemCoreClock         = SYSCLK_FREQ_36MHz;        /*!< System Clock Frequency (Core Clock) */
    117          #elif defined SYSCLK_FREQ_48MHz
    118            uint32_t SystemCoreClock         = SYSCLK_FREQ_48MHz;        /*!< System Clock Frequency (Core Clock) */
    119          #elif defined SYSCLK_FREQ_56MHz
    120            uint32_t SystemCoreClock         = SYSCLK_FREQ_56MHz;        /*!< System Clock Frequency (Core Clock) */
    121          #elif defined SYSCLK_FREQ_72MHz
    122            uint32_t SystemCoreClock         = SYSCLK_FREQ_72MHz;        /*!< System Clock Frequency (Core Clock) */
    123          #else /*!< HSI Selected as System Clock source */
    124            uint32_t SystemCoreClock         = HSI_Value;        /*!< System Clock Frequency (Core Clock) */
    125          #endif
    126          
    127          __I uint8_t AHBPrescTable[16] = {0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 6, 7, 8, 9};
    128          /**
    129            * @}
    130            */
    131          
    132          /** @addtogroup STM32F10x_System_Private_FunctionPrototypes
    133            * @{
    134            */
    135          
    136          static void SetSysClock(void);
    137          
    138          #ifdef SYSCLK_FREQ_HSE
    139            static void SetSysClockToHSE(void);
    140          #elif defined SYSCLK_FREQ_24MHz
    141            static void SetSysClockTo24(void);
    142          #elif defined SYSCLK_FREQ_36MHz
    143            static void SetSysClockTo36(void);
    144          #elif defined SYSCLK_FREQ_48MHz
    145            static void SetSysClockTo48(void);
    146          #elif defined SYSCLK_FREQ_56MHz
    147            static void SetSysClockTo56(void);  
    148          #elif defined SYSCLK_FREQ_72MHz
    149            static void SetSysClockTo72(void);
    150          #endif
    151          
    152          #ifdef DATA_IN_ExtSRAM
    153            static void SystemInit_ExtMemCtl(void); 
    154          #endif /* DATA_IN_ExtSRAM */
    155          
    156          /**
    157            * @}
    158            */
    159          
    160          /** @addtogroup STM32F10x_System_Private_Functions
    161            * @{
    162            */
    163          
    164          /**
    165            * @brief  Setup the microcontroller system
    166            *         Initialize the Embedded Flash Interface, the PLL and update the 
    167            *         SystemCoreClock variable.
    168            * @note   This function should be used only after reset.
    169            * @param  None
    170            * @retval None
    171            */
    172          void SystemInit (void)
    173          {
    174            /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
    175            /* Set HSION bit */
    176            RCC->CR |= (uint32_t)0x00000001;
    177          
    178            /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
    179          #ifndef STM32F10X_CL
    180            RCC->CFGR &= (uint32_t)0xF8FF0000;
    181          #else
    182            RCC->CFGR &= (uint32_t)0xF0FF0000;
    183          #endif /* STM32F10X_CL */   
    184            
    185            /* Reset HSEON, CSSON and PLLON bits */
    186            RCC->CR &= (uint32_t)0xFEF6FFFF;
    187          
    188            /* Reset HSEBYP bit */
    189            RCC->CR &= (uint32_t)0xFFFBFFFF;
    190          
    191            /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
    192            RCC->CFGR &= (uint32_t)0xFF80FFFF;
    193          
    194          #ifdef STM32F10X_CL
    195            /* Reset PLL2ON and PLL3ON bits */
    196            RCC->CR &= (uint32_t)0xEBFFFFFF;
    197          
    198            /* Disable all interrupts and clear pending bits  */
    199            RCC->CIR = 0x00FF0000;
    200          
    201            /* Reset CFGR2 register */
    202            RCC->CFGR2 = 0x00000000;
    203          #elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) 
    204            /* Disable all interrupts and clear pending bits  */
    205            RCC->CIR = 0x009F0000;
    206          
    207            /* Reset CFGR2 register */
    208            RCC->CFGR2 = 0x00000000;      
    209          #else
    210            /* Disable all interrupts and clear pending bits  */
    211            RCC->CIR = 0x009F0000;
    212          #endif /* STM32F10X_CL */
    213              
    214          #if defined (STM32F10X_HD) || (defined STM32F10X_XL)
    215            #ifdef DATA_IN_ExtSRAM
    216              SystemInit_ExtMemCtl(); 
    217            #endif /* DATA_IN_ExtSRAM */
    218          #endif 
    219          
    220            /* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */
    221            /* Configure the Flash Latency cycles and enable prefetch buffer */
    222            SetSysClock();
    223          }
    224          
    225          /**
    226            * @brief  Update SystemCoreClock according to Clock Register Values
    227            * @note   None
    228            * @param  None
    229            * @retval None
    230            */
    231          void SystemCoreClockUpdate (void)
    232          {
    233            uint32_t tmp = 0, pllmull = 0, pllsource = 0;
    234          
    235          #ifdef  STM32F10X_CL
    236            uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
    237          #endif /* STM32F10X_CL */
    238          
    239          #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL)
    240            uint32_t prediv1factor = 0;
    241          #endif /* STM32F10X_LD_VL or STM32F10X_MD_VL */
    242              
    243            /* Get SYSCLK source -------------------------------------------------------*/
    244            tmp = RCC->CFGR & RCC_CFGR_SWS;
    245            
    246            switch (tmp)
    247            {
    248              case 0x00:  /* HSI used as system clock */
    249                SystemCoreClock = HSI_Value;
    250                break;
    251              case 0x04:  /* HSE used as system clock */
    252                SystemCoreClock = HSE_Value;
    253                break;
    254              case 0x08:  /* PLL used as system clock */
    255          
    256                /* Get PLL clock source and multiplication factor ----------------------*/
    257                pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
    258                pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
    259                
    260          #ifndef STM32F10X_CL      
    261                pllmull = ( pllmull >> 18) + 2;
    262                
    263                if (pllsource == 0x00)
    264                {
    265                  /* HSI oscillator clock divided by 2 selected as PLL clock entry */
    266                  SystemCoreClock = (HSI_Value >> 1) * pllmull;
    267                }
    268                else
    269                {
    270           #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL)
    271                 prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
    272                 /* HSE oscillator clock selected as PREDIV1 clock entry */
    273                 SystemCoreClock = (HSE_Value / prediv1factor) * pllmull; 
    274           #else
    275                  /* HSE selected as PLL clock entry */
    276                  if ((RCC->CFGR & RCC_CFGR_PLLXTPRE) != (uint32_t)RESET)
    277                  {/* HSE oscillator clock divided by 2 */
    278                    SystemCoreClock = (HSE_Value >> 1) * pllmull;
    279                  }
    280                  else
    281                  {
    282                    SystemCoreClock = HSE_Value * pllmull;
    283                  }
    284           #endif
    285                }
    286          #else
    287                pllmull = pllmull >> 18;
    288                
    289                if (pllmull != 0x0D)
    290                {
    291                   pllmull += 2;
    292                }
    293                else
    294                { /* PLL multiplication factor = PLL input clock * 6.5 */
    295                  pllmull = 13 / 2; 
    296                }
    297                      
    298                if (pllsource == 0x00)
    299                {
    300                  /* HSI oscillator clock divided by 2 selected as PLL clock entry */
    301                  SystemCoreClock = (HSI_Value >> 1) * pllmull;
    302                }
    303                else
    304                {/* PREDIV1 selected as PLL clock entry */
    305                  
    306                  /* Get PREDIV1 clock source and division factor */
    307                  prediv1source = RCC->CFGR2 & RCC_CFGR2_PREDIV1SRC;
    308                  prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
    309                  
    310                  if (prediv1source == 0)
    311                  { 
    312                    /* HSE oscillator clock selected as PREDIV1 clock entry */
    313                    SystemCoreClock = (HSE_Value / prediv1factor) * pllmull;          
    314                  }
    315                  else
    316                  {/* PLL2 clock selected as PREDIV1 clock entry */
    317                    
    318                    /* Get PREDIV2 division factor and PLL2 multiplication factor */
    319                    prediv2factor = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> 4) + 1;
    320                    pll2mull = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> 8 ) + 2; 
    321                    SystemCoreClock = (((HSE_Value / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
    322                  }
    323                }
    324          #endif /* STM32F10X_CL */ 
    325                break;
    326          
    327              default:
    328                SystemCoreClock = HSI_Value;
    329                break;
    330            }
    331            
    332            /* Compute HCLK clock frequency ----------------*/
    333            /* Get HCLK prescaler */
    334            tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
    335            /* HCLK clock frequency */
    336            SystemCoreClock >>= tmp;  
    337          }
    338          
    339          /**
    340            * @brief  Configures the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers.
    341            * @param  None
    342            * @retval None
    343            */
    344          static void SetSysClock(void)
    345          {
    346          #ifdef SYSCLK_FREQ_HSE
    347            SetSysClockToHSE();
    348          #elif defined SYSCLK_FREQ_24MHz
    349            SetSysClockTo24();
    350          #elif defined SYSCLK_FREQ_36MHz
    351            SetSysClockTo36();
    352          #elif defined SYSCLK_FREQ_48MHz
    353            SetSysClockTo48();
    354          #elif defined SYSCLK_FREQ_56MHz
    355            SetSysClockTo56();  
    356          #elif defined SYSCLK_FREQ_72MHz
    357            SetSysClockTo72();
    358          #endif
    359           
    360           /* If none of the define above is enabled, the HSI is used as System clock
    361              source (default after reset) */ 
    362          }
    363          
    364          /**
    365            * @brief  Setup the external memory controller. Called in startup_stm32f10x.s 
    366            *          before jump to __main
    367            * @param  None
    368            * @retval None
    369            */ 
    370          #ifdef DATA_IN_ExtSRAM
    371          /**
    372            * @brief  Setup the external memory controller. 
    373            *         Called in startup_stm32f10x_xx.s/.c before jump to main.
    374            * 	      This function configures the external SRAM mounted on STM3210E-EVAL
    375            *         board (STM32 High density devices). This SRAM will be used as program
    376            *         data memory (including heap and stack).
    377            * @param  None
    378            * @retval None
    379            */ 
    380          void SystemInit_ExtMemCtl(void) 
    381          {
    382          /*!< FSMC Bank1 NOR/SRAM3 is used for the STM3210E-EVAL, if another Bank is 
    383            required, then adjust the Register Addresses */
    384          
    385            /* Enable FSMC clock */
    386            RCC->AHBENR = 0x00000114;
    387            
    388            /* Enable GPIOD, GPIOE, GPIOF and GPIOG clocks */  
    389            RCC->APB2ENR = 0x000001E0;
    390            
    391          /* ---------------  SRAM Data lines, NOE and NWE configuration ---------------*/
    392          /*----------------  SRAM Address lines configuration -------------------------*/
    393          /*----------------  NOE and NWE configuration --------------------------------*/  
    394          /*----------------  NE3 configuration ----------------------------------------*/
    395          /*----------------  NBL0, NBL1 configuration ---------------------------------*/
    396            
    397            GPIOD->CRL = 0x44BB44BB;  
    398            GPIOD->CRH = 0xBBBBBBBB;
    399          
    400            GPIOE->CRL = 0xB44444BB;  
    401            GPIOE->CRH = 0xBBBBBBBB;
    402          
    403            GPIOF->CRL = 0x44BBBBBB;  
    404            GPIOF->CRH = 0xBBBB4444;
    405          
    406            GPIOG->CRL = 0x44BBBBBB;  
    407            GPIOG->CRH = 0x44444B44;
    408             
    409          /*----------------  FSMC Configuration ---------------------------------------*/  
    410          /*----------------  Enable FSMC Bank1_SRAM Bank ------------------------------*/
    411            
    412            FSMC_Bank1->BTCR[4] = 0x00001011;
    413            FSMC_Bank1->BTCR[5] = 0x00000200;
    414          }
    415          #endif /* DATA_IN_ExtSRAM */
    416          
    417          #ifdef SYSCLK_FREQ_HSE
    418          /**
    419            * @brief  Selects HSE as System clock source and configure HCLK, PCLK2
    420            *          and PCLK1 prescalers.
    421            * @note   This function should be used only after reset.
    422            * @param  None
    423            * @retval None
    424            */
    425          static void SetSysClockToHSE(void)
    426          {
    427            __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
    428            
    429            /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
    430            /* Enable HSE */    
    431            RCC->CR |= ((uint32_t)RCC_CR_HSEON);
    432           
    433            /* Wait till HSE is ready and if Time out is reached exit */
    434            do
    435            {
    436              HSEStatus = RCC->CR & RCC_CR_HSERDY;
    437              StartUpCounter++;  
    438            } while((HSEStatus == 0) && (StartUpCounter != HSEStartUp_TimeOut));
    439          
    440            if ((RCC->CR & RCC_CR_HSERDY) != RESET)
    441            {
    442              HSEStatus = (uint32_t)0x01;
    443            }
    444            else
    445            {
    446              HSEStatus = (uint32_t)0x00;
    447            }  
    448          
    449            if (HSEStatus == (uint32_t)0x01)
    450            {
    451          
    452          #if !defined STM32F10X_LD_VL && !defined STM32F10X_MD_VL 
    453              /* Enable Prefetch Buffer */
    454              FLASH->ACR |= FLASH_ACR_PRFTBE;
    455          
    456              /* Flash 0 wait state */
    457              FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
    458          
    459          #ifndef STM32F10X_CL
    460              FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_0;
    461          #else
    462              if (HSE_Value <= 24000000)
    463          	{
    464                FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_0;
    465          	}
    466          	else
    467          	{
    468                FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_1;
    469          	}
    470          #endif /* STM32F10X_CL */
    471          #endif
    472           
    473              /* HCLK = SYSCLK */
    474              RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
    475                
    476              /* PCLK2 = HCLK */
    477              RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
    478              
    479              /* PCLK1 = HCLK */
    480              RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV1;
    481              
    482              /* Select HSE as system clock source */
    483              RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
    484              RCC->CFGR |= (uint32_t)RCC_CFGR_SW_HSE;    
    485          
    486              /* Wait till HSE is used as system clock source */
    487              while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x04)
    488              {
    489              }
    490            }
    491            else
    492            { /* If HSE fails to start-up, the application will have wrong clock 
    493                   configuration. User can add here some code to deal with this error */
    494            }  
    495          }
    496          #elif defined SYSCLK_FREQ_24MHz
    497          /**
    498            * @brief  Sets System clock frequency to 24MHz and configure HCLK, PCLK2 
    499            *          and PCLK1 prescalers.
    500            * @note   This function should be used only after reset.
    501            * @param  None
    502            * @retval None
    503            */
    504          static void SetSysClockTo24(void)
    505          {
    506            __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
    507            
    508            /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
    509            /* Enable HSE */    
    510            RCC->CR |= ((uint32_t)RCC_CR_HSEON);
    511           
    512            /* Wait till HSE is ready and if Time out is reached exit */
    513            do
    514            {
    515              HSEStatus = RCC->CR & RCC_CR_HSERDY;
    516              StartUpCounter++;  
    517            } while((HSEStatus == 0) && (StartUpCounter != HSEStartUp_TimeOut));
    518          
    519            if ((RCC->CR & RCC_CR_HSERDY) != RESET)
    520            {
    521              HSEStatus = (uint32_t)0x01;
    522            }
    523            else
    524            {
    525              HSEStatus = (uint32_t)0x00;
    526            }  
    527          
    528            if (HSEStatus == (uint32_t)0x01)
    529            {
    530          #if !defined STM32F10X_LD_VL && !defined STM32F10X_MD_VL 
    531              /* Enable Prefetch Buffer */
    532              FLASH->ACR |= FLASH_ACR_PRFTBE;
    533          
    534              /* Flash 0 wait state */
    535              FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
    536              FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_0;    
    537          #endif
    538           
    539              /* HCLK = SYSCLK */
    540              RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
    541                
    542              /* PCLK2 = HCLK */
    543              RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
    544              
    545              /* PCLK1 = HCLK */
    546              RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV1;
    547              
    548          #ifdef STM32F10X_CL
    549              /* Configure PLLs ------------------------------------------------------*/
    550              /* PLL configuration: PLLCLK = PREDIV1 * 6 = 24 MHz */ 
    551              RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
    552              RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
    553                                      RCC_CFGR_PLLMULL6); 
    554          
    555              /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
    556              /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 10 = 4 MHz */       
    557              RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
    558                                        RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
    559              RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
    560                                       RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV10);
    561            
    562              /* Enable PLL2 */
    563              RCC->CR |= RCC_CR_PLL2ON;
    564              /* Wait till PLL2 is ready */
    565              while((RCC->CR & RCC_CR_PLL2RDY) == 0)
    566              {
    567              }   
    568          #elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL)
    569              /*  PLL configuration:  = (HSE / 2) * 6 = 24 MHz */
    570              RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));
    571              RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_PREDIV1 | RCC_CFGR_PLLXTPRE_PREDIV1_Div2 | RCC_CFGR_PLLMULL6);
    572          #else    
    573              /*  PLL configuration:  = (HSE / 2) * 6 = 24 MHz */
    574              RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));
    575              RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLXTPRE_HSE_Div2 | RCC_CFGR_PLLMULL6);
    576          #endif /* STM32F10X_CL */
    577          
    578              /* Enable PLL */
    579              RCC->CR |= RCC_CR_PLLON;
    580          
    581              /* Wait till PLL is ready */
    582              while((RCC->CR & RCC_CR_PLLRDY) == 0)
    583              {
    584              }
    585          
    586              /* Select PLL as system clock source */
    587              RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
    588              RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
    589          
    590              /* Wait till PLL is used as system clock source */
    591              while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
    592              {
    593              }
    594            }
    595            else
    596            { /* If HSE fails to start-up, the application will have wrong clock 
    597                   configuration. User can add here some code to deal with this error */
    598            } 
    599          }
    600          #elif defined SYSCLK_FREQ_36MHz
    601          /**
    602            * @brief  Sets System clock frequency to 36MHz and configure HCLK, PCLK2 
    603            *          and PCLK1 prescalers. 
    604            * @note   This function should be used only after reset.
    605            * @param  None
    606            * @retval None
    607            */
    608          static void SetSysClockTo36(void)
    609          {
    610            __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
    611            
    612            /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
    613            /* Enable HSE */    
    614            RCC->CR |= ((uint32_t)RCC_CR_HSEON);
    615           
    616            /* Wait till HSE is ready and if Time out is reached exit */
    617            do
    618            {
    619              HSEStatus = RCC->CR & RCC_CR_HSERDY;
    620              StartUpCounter++;  
    621            } while((HSEStatus == 0) && (StartUpCounter != HSEStartUp_TimeOut));
    622          
    623            if ((RCC->CR & RCC_CR_HSERDY) != RESET)
    624            {
    625              HSEStatus = (uint32_t)0x01;
    626            }
    627            else
    628            {
    629              HSEStatus = (uint32_t)0x00;
    630            }  
    631          
    632            if (HSEStatus == (uint32_t)0x01)
    633            {
    634              /* Enable Prefetch Buffer */
    635              FLASH->ACR |= FLASH_ACR_PRFTBE;
    636          
    637              /* Flash 1 wait state */
    638              FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
    639              FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_1;    
    640           
    641              /* HCLK = SYSCLK */
    642              RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
    643                
    644              /* PCLK2 = HCLK */
    645              RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
    646              
    647              /* PCLK1 = HCLK */
    648              RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV1;
    649              
    650          #ifdef STM32F10X_CL
    651              /* Configure PLLs ------------------------------------------------------*/
    652              
    653              /* PLL configuration: PLLCLK = PREDIV1 * 9 = 36 MHz */ 
    654              RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
    655              RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
    656                                      RCC_CFGR_PLLMULL9); 
    657          
    658          	/*!< PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
    659              /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 10 = 4 MHz */
    660                  
    661              RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
    662                                        RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
    663              RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
    664                                       RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV10);
    665            
    666              /* Enable PLL2 */
    667              RCC->CR |= RCC_CR_PLL2ON;
    668              /* Wait till PLL2 is ready */
    669              while((RCC->CR & RCC_CR_PLL2RDY) == 0)
    670              {
    671              }
    672              
    673          #else    
    674              /*  PLL configuration: PLLCLK = (HSE / 2) * 9 = 36 MHz */
    675              RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));
    676              RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLXTPRE_HSE_Div2 | RCC_CFGR_PLLMULL9);
    677          #endif /* STM32F10X_CL */
    678          
    679              /* Enable PLL */
    680              RCC->CR |= RCC_CR_PLLON;
    681          
    682              /* Wait till PLL is ready */
    683              while((RCC->CR & RCC_CR_PLLRDY) == 0)
    684              {
    685              }
    686          
    687              /* Select PLL as system clock source */
    688              RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
    689              RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
    690          
    691              /* Wait till PLL is used as system clock source */
    692              while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
    693              {
    694              }
    695            }
    696            else
    697            { /* If HSE fails to start-up, the application will have wrong clock 
    698                   configuration. User can add here some code to deal with this error */
    699            } 
    700          }
    701          #elif defined SYSCLK_FREQ_48MHz
    702          /**
    703            * @brief  Sets System clock frequency to 48MHz and configure HCLK, PCLK2 
    704            *          and PCLK1 prescalers. 
    705            * @note   This function should be used only after reset.
    706            * @param  None
    707            * @retval None
    708            */
    709          static void SetSysClockTo48(void)
    710          {
    711            __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
    712            
    713            /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
    714            /* Enable HSE */    
    715            RCC->CR |= ((uint32_t)RCC_CR_HSEON);
    716           
    717            /* Wait till HSE is ready and if Time out is reached exit */
    718            do
    719            {
    720              HSEStatus = RCC->CR & RCC_CR_HSERDY;
    721              StartUpCounter++;  
    722            } while((HSEStatus == 0) && (StartUpCounter != HSEStartUp_TimeOut));
    723          
    724            if ((RCC->CR & RCC_CR_HSERDY) != RESET)
    725            {
    726              HSEStatus = (uint32_t)0x01;
    727            }
    728            else
    729            {
    730              HSEStatus = (uint32_t)0x00;
    731            }  
    732          
    733            if (HSEStatus == (uint32_t)0x01)
    734            {
    735              /* Enable Prefetch Buffer */
    736              FLASH->ACR |= FLASH_ACR_PRFTBE;
    737          
    738              /* Flash 1 wait state */
    739              FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
    740              FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_1;    
    741           
    742              /* HCLK = SYSCLK */
    743              RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
    744                
    745              /* PCLK2 = HCLK */
    746              RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
    747              
    748              /* PCLK1 = HCLK */
    749              RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
    750              
    751          #ifdef STM32F10X_CL
    752              /* Configure PLLs ------------------------------------------------------*/
    753              /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
    754              /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */
    755                  
    756              RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
    757                                        RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
    758              RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
    759                                       RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);
    760            
    761              /* Enable PLL2 */
    762              RCC->CR |= RCC_CR_PLL2ON;
    763              /* Wait till PLL2 is ready */
    764              while((RCC->CR & RCC_CR_PLL2RDY) == 0)
    765              {
    766              }
    767              
    768             
    769              /* PLL configuration: PLLCLK = PREDIV1 * 6 = 48 MHz */ 
    770              RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
    771              RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
    772                                      RCC_CFGR_PLLMULL6); 
    773          #else    
    774              /*  PLL configuration: PLLCLK = HSE * 6 = 48 MHz */
    775              RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));
    776              RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL6);
    777          #endif /* STM32F10X_CL */
    778          
    779              /* Enable PLL */
    780              RCC->CR |= RCC_CR_PLLON;
    781          
    782              /* Wait till PLL is ready */
    783              while((RCC->CR & RCC_CR_PLLRDY) == 0)
    784              {
    785              }
    786          
    787              /* Select PLL as system clock source */
    788              RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
    789              RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
    790          
    791              /* Wait till PLL is used as system clock source */
    792              while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
    793              {
    794              }
    795            }
    796            else
    797            { /* If HSE fails to start-up, the application will have wrong clock 
    798                   configuration. User can add here some code to deal with this error */
    799            } 
    800          }
    801          
    802          #elif defined SYSCLK_FREQ_56MHz
    803          /**
    804            * @brief  Sets System clock frequency to 56MHz and configure HCLK, PCLK2 
    805            *          and PCLK1 prescalers. 
    806            * @note   This function should be used only after reset.
    807            * @param  None
    808            * @retval None
    809            */
    810          static void SetSysClockTo56(void)
    811          {
    812            __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
    813            
    814            /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/   
    815            /* Enable HSE */    
    816            RCC->CR |= ((uint32_t)RCC_CR_HSEON);
    817           
    818            /* Wait till HSE is ready and if Time out is reached exit */
    819            do
    820            {
    821              HSEStatus = RCC->CR & RCC_CR_HSERDY;
    822              StartUpCounter++;  
    823            } while((HSEStatus == 0) && (StartUpCounter != HSEStartUp_TimeOut));
    824          
    825            if ((RCC->CR & RCC_CR_HSERDY) != RESET)
    826            {
    827              HSEStatus = (uint32_t)0x01;
    828            }
    829            else
    830            {
    831              HSEStatus = (uint32_t)0x00;
    832            }  
    833          
    834            if (HSEStatus == (uint32_t)0x01)
    835            {
    836              /* Enable Prefetch Buffer */
    837              FLASH->ACR |= FLASH_ACR_PRFTBE;
    838          
    839              /* Flash 2 wait state */
    840              FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
    841              FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
    842           
    843              /* HCLK = SYSCLK */
    844              RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
    845                
    846              /* PCLK2 = HCLK */
    847              RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
    848              
    849              /* PCLK1 = HCLK */
    850              RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
    851          
    852          #ifdef STM32F10X_CL
    853              /* Configure PLLs ------------------------------------------------------*/
    854              /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
    855              /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */
    856                  
    857              RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
    858                                        RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
    859              RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
    860                                       RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);
    861            
    862              /* Enable PLL2 */
    863              RCC->CR |= RCC_CR_PLL2ON;
    864              /* Wait till PLL2 is ready */
    865              while((RCC->CR & RCC_CR_PLL2RDY) == 0)
    866              {
    867              }
    868              
    869             
    870              /* PLL configuration: PLLCLK = PREDIV1 * 7 = 56 MHz */ 
    871              RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
    872              RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
    873                                      RCC_CFGR_PLLMULL7); 
    874          #else     
    875              /* PLL configuration: PLLCLK = HSE * 7 = 56 MHz */
    876              RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL));
    877              RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL7);
    878          
    879          #endif /* STM32F10X_CL */
    880          
    881              /* Enable PLL */
    882              RCC->CR |= RCC_CR_PLLON;
    883          
    884              /* Wait till PLL is ready */
    885              while((RCC->CR & RCC_CR_PLLRDY) == 0)
    886              {
    887              }
    888          
    889              /* Select PLL as system clock source */
    890              RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
    891              RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
    892          
    893              /* Wait till PLL is used as system clock source */
    894              while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
    895              {
    896              }
    897            }
    898            else
    899            { /* If HSE fails to start-up, the application will have wrong clock 
    900                   configuration. User can add here some code to deal with this error */
    901            } 
    902          }
    903          
    904          #elif defined SYSCLK_FREQ_72MHz
    905          /**
    906            * @brief  Sets System clock frequency to 72MHz and configure HCLK, PCLK2 
    907            *          and PCLK1 prescalers. 
    908            * @note   This function should be used only after reset.
    909            * @param  None
    910            * @retval None
    911            */
    912          static void SetSysClockTo72(void)
    913          {
    914            __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
    915            
    916            /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
    917            /* Enable HSE */    
    918            RCC->CR |= ((uint32_t)RCC_CR_HSEON);
    919           
    920            /* Wait till HSE is ready and if Time out is reached exit */
    921            do
    922            {
    923              HSEStatus = RCC->CR & RCC_CR_HSERDY;
    924              StartUpCounter++;  
    925            } while((HSEStatus == 0) && (StartUpCounter != HSEStartUp_TimeOut));
    926          
    927            if ((RCC->CR & RCC_CR_HSERDY) != RESET)
    928            {
    929              HSEStatus = (uint32_t)0x01;
    930            }
    931            else
    932            {
    933              HSEStatus = (uint32_t)0x00;
    934            }  
    935          
    936            if (HSEStatus == (uint32_t)0x01)
    937            {
    938              /* Enable Prefetch Buffer */
    939              FLASH->ACR |= FLASH_ACR_PRFTBE;
    940          
    941              /* Flash 2 wait state */
    942              FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
    943              FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
    944          
    945           
    946              /* HCLK = SYSCLK */
    947              RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
    948                
    949              /* PCLK2 = HCLK */
    950              RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
    951              
    952              /* PCLK1 = HCLK */
    953              RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
    954          
    955          #ifdef STM32F10X_CL
    956              /* Configure PLLs ------------------------------------------------------*/
    957              /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
    958              /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */
    959                  
    960              RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
    961                                        RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
    962              RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
    963                                       RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);
    964            
    965              /* Enable PLL2 */
    966              RCC->CR |= RCC_CR_PLL2ON;
    967              /* Wait till PLL2 is ready */
    968              while((RCC->CR & RCC_CR_PLL2RDY) == 0)
    969              {
    970              }
    971              
    972             
    973              /* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */ 
    974              RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
    975              RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
    976                                      RCC_CFGR_PLLMULL9); 
    977          #else    
    978              /*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */
    979              RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |
    980                                                  RCC_CFGR_PLLMULL));
    981          #ifdef EXT_CLOCK_SOURCE_12M
    982              RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL6);
    983          #else
    984              RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);
    985          #endif
    986          #endif /* STM32F10X_CL */
    987          
    988              /* Enable PLL */
    989              RCC->CR |= RCC_CR_PLLON;
    990          
    991              /* Wait till PLL is ready */
    992              while((RCC->CR & RCC_CR_PLLRDY) == 0)
    993              {
    994              }
    995              
    996              /* Select PLL as system clock source */
    997              RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
    998              RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
    999          
   1000              /* Wait till PLL is used as system clock source */
   1001              while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
   1002              {
   1003              }
   1004            }
   1005            else
   1006            { /* If HSE fails to start-up, the application will have wrong clock 
   1007                   configuration. User can add here some code to deal with this error */
   1008            }
   1009          }
   1010          #endif
   1011          
   1012          /**
   1013            * @}
   1014            */
   1015          
   1016          /**
   1017            * @}
   1018            */
   1019            
   1020          /**
   1021            * @}
   1022            */    
   1023          /******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  SetSysClock
             8 -> SetSysClockTo72
        8  SetSysClockTo72
        4  SystemCoreClockUpdate
        8  SystemInit
             8 -> SetSysClock


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
      16  AHBPrescTable
       8  SetSysClock
     224  SetSysClockTo72
       4  SystemCoreClock
     156  SystemCoreClockUpdate
      76  SystemInit

 
  20 bytes in section .data
 508 bytes in section .text
 
 508 bytes of CODE memory
  20 bytes of DATA memory

Errors: none
Warnings: none
